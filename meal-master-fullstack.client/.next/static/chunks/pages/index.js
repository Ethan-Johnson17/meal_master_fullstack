/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/index"],{

/***/ "./node_modules/mobx-react-lite/es/ObserverComponent.js":
/*!**************************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/ObserverComponent.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Observer\": function() { return /* binding */ ObserverComponent; }\n/* harmony export */ });\n/* harmony import */ var _useObserver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useObserver */ \"./node_modules/mobx-react-lite/es/useObserver.js\");\n\nfunction ObserverComponent(_a) {\n    var children = _a.children, render = _a.render;\n    var component = children || render;\n    if (typeof component !== \"function\") {\n        return null;\n    }\n    return (0,_useObserver__WEBPACK_IMPORTED_MODULE_0__.useObserver)(component);\n}\nif (true) {\n    ObserverComponent.propTypes = {\n        children: ObserverPropsCheck,\n        render: ObserverPropsCheck\n    };\n}\nObserverComponent.displayName = \"Observer\";\n\nfunction ObserverPropsCheck(props, key, componentName, location, propFullName) {\n    var extraKey = key === \"children\" ? \"render\" : \"children\";\n    var hasProp = typeof props[key] === \"function\";\n    var hasExtraProp = typeof props[extraKey] === \"function\";\n    if (hasProp && hasExtraProp) {\n        return new Error(\"MobX Observer: Do not use children and render in the same time in`\" + componentName);\n    }\n    if (hasProp || hasExtraProp) {\n        return null;\n    }\n    return new Error(\"Invalid prop `\" +\n        propFullName +\n        \"` of type `\" +\n        typeof props[key] +\n        \"` supplied to\" +\n        \" `\" +\n        componentName +\n        \"`, expected `function`.\");\n}\n//# sourceMappingURL=ObserverComponent.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL09ic2VydmVyQ29tcG9uZW50LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcseURBQVc7QUFDdEI7QUFDQSxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tb2J4LXJlYWN0LWxpdGUvZXMvT2JzZXJ2ZXJDb21wb25lbnQuanM/MGYwMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VPYnNlcnZlciB9IGZyb20gXCIuL3VzZU9ic2VydmVyXCI7XG5mdW5jdGlvbiBPYnNlcnZlckNvbXBvbmVudChfYSkge1xuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCByZW5kZXIgPSBfYS5yZW5kZXI7XG4gICAgdmFyIGNvbXBvbmVudCA9IGNoaWxkcmVuIHx8IHJlbmRlcjtcbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdXNlT2JzZXJ2ZXIoY29tcG9uZW50KTtcbn1cbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICBPYnNlcnZlckNvbXBvbmVudC5wcm9wVHlwZXMgPSB7XG4gICAgICAgIGNoaWxkcmVuOiBPYnNlcnZlclByb3BzQ2hlY2ssXG4gICAgICAgIHJlbmRlcjogT2JzZXJ2ZXJQcm9wc0NoZWNrXG4gICAgfTtcbn1cbk9ic2VydmVyQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gXCJPYnNlcnZlclwiO1xuZXhwb3J0IHsgT2JzZXJ2ZXJDb21wb25lbnQgYXMgT2JzZXJ2ZXIgfTtcbmZ1bmN0aW9uIE9ic2VydmVyUHJvcHNDaGVjayhwcm9wcywga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIGV4dHJhS2V5ID0ga2V5ID09PSBcImNoaWxkcmVuXCIgPyBcInJlbmRlclwiIDogXCJjaGlsZHJlblwiO1xuICAgIHZhciBoYXNQcm9wID0gdHlwZW9mIHByb3BzW2tleV0gPT09IFwiZnVuY3Rpb25cIjtcbiAgICB2YXIgaGFzRXh0cmFQcm9wID0gdHlwZW9mIHByb3BzW2V4dHJhS2V5XSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIGlmIChoYXNQcm9wICYmIGhhc0V4dHJhUHJvcCkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKFwiTW9iWCBPYnNlcnZlcjogRG8gbm90IHVzZSBjaGlsZHJlbiBhbmQgcmVuZGVyIGluIHRoZSBzYW1lIHRpbWUgaW5gXCIgKyBjb21wb25lbnROYW1lKTtcbiAgICB9XG4gICAgaWYgKGhhc1Byb3AgfHwgaGFzRXh0cmFQcm9wKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKFwiSW52YWxpZCBwcm9wIGBcIiArXG4gICAgICAgIHByb3BGdWxsTmFtZSArXG4gICAgICAgIFwiYCBvZiB0eXBlIGBcIiArXG4gICAgICAgIHR5cGVvZiBwcm9wc1trZXldICtcbiAgICAgICAgXCJgIHN1cHBsaWVkIHRvXCIgK1xuICAgICAgICBcIiBgXCIgK1xuICAgICAgICBjb21wb25lbnROYW1lICtcbiAgICAgICAgXCJgLCBleHBlY3RlZCBgZnVuY3Rpb25gLlwiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmVyQ29tcG9uZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mobx-react-lite/es/ObserverComponent.js\n"));

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/index.js":
/*!**************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Observer\": function() { return /* reexport safe */ _ObserverComponent__WEBPACK_IMPORTED_MODULE_7__.Observer; },\n/* harmony export */   \"clearTimers\": function() { return /* reexport safe */ _utils_reactionCleanupTracking__WEBPACK_IMPORTED_MODULE_11__.resetCleanupScheduleForTests; },\n/* harmony export */   \"enableStaticRendering\": function() { return /* reexport safe */ _staticRendering__WEBPACK_IMPORTED_MODULE_5__.enableStaticRendering; },\n/* harmony export */   \"isObserverBatched\": function() { return /* reexport safe */ _utils_observerBatching__WEBPACK_IMPORTED_MODULE_2__.isObserverBatched; },\n/* harmony export */   \"isUsingStaticRendering\": function() { return /* reexport safe */ _staticRendering__WEBPACK_IMPORTED_MODULE_5__.isUsingStaticRendering; },\n/* harmony export */   \"observer\": function() { return /* reexport safe */ _observer__WEBPACK_IMPORTED_MODULE_6__.observer; },\n/* harmony export */   \"observerBatching\": function() { return /* reexport safe */ _utils_observerBatching__WEBPACK_IMPORTED_MODULE_2__.observerBatching; },\n/* harmony export */   \"useAsObservableSource\": function() { return /* reexport safe */ _useAsObservableSource__WEBPACK_IMPORTED_MODULE_10__.useAsObservableSource; },\n/* harmony export */   \"useLocalObservable\": function() { return /* reexport safe */ _useLocalObservable__WEBPACK_IMPORTED_MODULE_8__.useLocalObservable; },\n/* harmony export */   \"useLocalStore\": function() { return /* reexport safe */ _useLocalStore__WEBPACK_IMPORTED_MODULE_9__.useLocalStore; },\n/* harmony export */   \"useObserver\": function() { return /* binding */ useObserver; },\n/* harmony export */   \"useStaticRendering\": function() { return /* binding */ useStaticRendering; }\n/* harmony export */ });\n/* harmony import */ var _utils_assertEnvironment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/assertEnvironment */ \"./node_modules/mobx-react-lite/es/utils/assertEnvironment.js\");\n/* harmony import */ var _utils_reactBatchedUpdates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/reactBatchedUpdates */ \"./node_modules/mobx-react-lite/es/utils/reactBatchedUpdates.js\");\n/* harmony import */ var _utils_observerBatching__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/observerBatching */ \"./node_modules/mobx-react-lite/es/utils/observerBatching.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/utils */ \"./node_modules/mobx-react-lite/es/utils/utils.js\");\n/* harmony import */ var _useObserver__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./useObserver */ \"./node_modules/mobx-react-lite/es/useObserver.js\");\n/* harmony import */ var _staticRendering__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./staticRendering */ \"./node_modules/mobx-react-lite/es/staticRendering.js\");\n/* harmony import */ var _observer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./observer */ \"./node_modules/mobx-react-lite/es/observer.js\");\n/* harmony import */ var _ObserverComponent__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ObserverComponent */ \"./node_modules/mobx-react-lite/es/ObserverComponent.js\");\n/* harmony import */ var _useLocalObservable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./useLocalObservable */ \"./node_modules/mobx-react-lite/es/useLocalObservable.js\");\n/* harmony import */ var _useLocalStore__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./useLocalStore */ \"./node_modules/mobx-react-lite/es/useLocalStore.js\");\n/* harmony import */ var _useAsObservableSource__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./useAsObservableSource */ \"./node_modules/mobx-react-lite/es/useAsObservableSource.js\");\n/* harmony import */ var _utils_reactionCleanupTracking__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/reactionCleanupTracking */ \"./node_modules/mobx-react-lite/es/utils/reactionCleanupTracking.js\");\n\n\n\n\n\n\n(0,_utils_observerBatching__WEBPACK_IMPORTED_MODULE_2__.observerBatching)(_utils_reactBatchedUpdates__WEBPACK_IMPORTED_MODULE_1__.unstable_batchedUpdates);\n\n\n\n\n\n\n\nfunction useObserver(fn, baseComponentName) {\n    if (baseComponentName === void 0) { baseComponentName = \"observed\"; }\n    if (true) {\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_3__.useDeprecated)(\"[mobx-react-lite] 'useObserver(fn)' is deprecated. Use `<Observer>{fn}</Observer>` instead, or wrap the entire component in `observer`.\");\n    }\n    return (0,_useObserver__WEBPACK_IMPORTED_MODULE_4__.useObserver)(fn, baseComponentName);\n}\n\nfunction useStaticRendering(enable) {\n    if (true) {\n        console.warn(\"[mobx-react-lite] 'useStaticRendering' is deprecated, use 'enableStaticRendering' instead\");\n    }\n    (0,_staticRendering__WEBPACK_IMPORTED_MODULE_5__.enableStaticRendering)(enable);\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFtQztBQUM0QztBQUNuQjtBQUNkO0FBQ3FCO0FBQ1Q7QUFDMUQseUVBQWdCLENBQUMsK0VBQUs7QUFDNEQ7QUFDNUM7QUFDUztBQUNXO0FBQ1Y7QUFDZ0I7QUFDOEI7QUFDdkY7QUFDUCx3Q0FBd0M7QUFDeEMsUUFBUSxJQUFxQztBQUM3QyxRQUFRLDJEQUFhLHFFQUFxRSxHQUFHO0FBQzdGO0FBQ0EsV0FBVyx5REFBbUI7QUFDOUI7QUFDK0U7QUFDeEU7QUFDUCxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQSxJQUFJLHVFQUFxQjtBQUN6QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tb2J4LXJlYWN0LWxpdGUvZXMvaW5kZXguanM/NTczOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXCIuL3V0aWxzL2Fzc2VydEVudmlyb25tZW50XCI7XG5pbXBvcnQgeyB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyBhcyBiYXRjaCB9IGZyb20gXCIuL3V0aWxzL3JlYWN0QmF0Y2hlZFVwZGF0ZXNcIjtcbmltcG9ydCB7IG9ic2VydmVyQmF0Y2hpbmcgfSBmcm9tIFwiLi91dGlscy9vYnNlcnZlckJhdGNoaW5nXCI7XG5pbXBvcnQgeyB1c2VEZXByZWNhdGVkIH0gZnJvbSBcIi4vdXRpbHMvdXRpbHNcIjtcbmltcG9ydCB7IHVzZU9ic2VydmVyIGFzIHVzZU9ic2VydmVyT3JpZ2luYWwgfSBmcm9tIFwiLi91c2VPYnNlcnZlclwiO1xuaW1wb3J0IHsgZW5hYmxlU3RhdGljUmVuZGVyaW5nIH0gZnJvbSBcIi4vc3RhdGljUmVuZGVyaW5nXCI7XG5vYnNlcnZlckJhdGNoaW5nKGJhdGNoKTtcbmV4cG9ydCB7IGlzVXNpbmdTdGF0aWNSZW5kZXJpbmcsIGVuYWJsZVN0YXRpY1JlbmRlcmluZyB9IGZyb20gXCIuL3N0YXRpY1JlbmRlcmluZ1wiO1xuZXhwb3J0IHsgb2JzZXJ2ZXIgfSBmcm9tIFwiLi9vYnNlcnZlclwiO1xuZXhwb3J0IHsgT2JzZXJ2ZXIgfSBmcm9tIFwiLi9PYnNlcnZlckNvbXBvbmVudFwiO1xuZXhwb3J0IHsgdXNlTG9jYWxPYnNlcnZhYmxlIH0gZnJvbSBcIi4vdXNlTG9jYWxPYnNlcnZhYmxlXCI7XG5leHBvcnQgeyB1c2VMb2NhbFN0b3JlIH0gZnJvbSBcIi4vdXNlTG9jYWxTdG9yZVwiO1xuZXhwb3J0IHsgdXNlQXNPYnNlcnZhYmxlU291cmNlIH0gZnJvbSBcIi4vdXNlQXNPYnNlcnZhYmxlU291cmNlXCI7XG5leHBvcnQgeyByZXNldENsZWFudXBTY2hlZHVsZUZvclRlc3RzIGFzIGNsZWFyVGltZXJzIH0gZnJvbSBcIi4vdXRpbHMvcmVhY3Rpb25DbGVhbnVwVHJhY2tpbmdcIjtcbmV4cG9ydCBmdW5jdGlvbiB1c2VPYnNlcnZlcihmbiwgYmFzZUNvbXBvbmVudE5hbWUpIHtcbiAgICBpZiAoYmFzZUNvbXBvbmVudE5hbWUgPT09IHZvaWQgMCkgeyBiYXNlQ29tcG9uZW50TmFtZSA9IFwib2JzZXJ2ZWRcIjsgfVxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgdXNlRGVwcmVjYXRlZChcIlttb2J4LXJlYWN0LWxpdGVdICd1c2VPYnNlcnZlcihmbiknIGlzIGRlcHJlY2F0ZWQuIFVzZSBgPE9ic2VydmVyPntmbn08L09ic2VydmVyPmAgaW5zdGVhZCwgb3Igd3JhcCB0aGUgZW50aXJlIGNvbXBvbmVudCBpbiBgb2JzZXJ2ZXJgLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZU9ic2VydmVyT3JpZ2luYWwoZm4sIGJhc2VDb21wb25lbnROYW1lKTtcbn1cbmV4cG9ydCB7IGlzT2JzZXJ2ZXJCYXRjaGVkLCBvYnNlcnZlckJhdGNoaW5nIH0gZnJvbSBcIi4vdXRpbHMvb2JzZXJ2ZXJCYXRjaGluZ1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YXRpY1JlbmRlcmluZyhlbmFibGUpIHtcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlttb2J4LXJlYWN0LWxpdGVdICd1c2VTdGF0aWNSZW5kZXJpbmcnIGlzIGRlcHJlY2F0ZWQsIHVzZSAnZW5hYmxlU3RhdGljUmVuZGVyaW5nJyBpbnN0ZWFkXCIpO1xuICAgIH1cbiAgICBlbmFibGVTdGF0aWNSZW5kZXJpbmcoZW5hYmxlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mobx-react-lite/es/index.js\n"));

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/observer.js":
/*!*****************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/observer.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"observer\": function() { return /* binding */ observer; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _staticRendering__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./staticRendering */ \"./node_modules/mobx-react-lite/es/staticRendering.js\");\n/* harmony import */ var _useObserver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useObserver */ \"./node_modules/mobx-react-lite/es/useObserver.js\");\n\n\n\nvar warnObserverOptionsDeprecated = true;\nvar hasSymbol = typeof Symbol === \"function\" && Symbol.for;\n// Using react-is had some issues (and operates on elements, not on types), see #608 / #609\nvar ReactForwardRefSymbol = hasSymbol\n    ? Symbol.for(\"react.forward_ref\")\n    : typeof react__WEBPACK_IMPORTED_MODULE_0__.forwardRef === \"function\" && (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (props) { return null; })[\"$$typeof\"];\nvar ReactMemoSymbol = hasSymbol\n    ? Symbol.for(\"react.memo\")\n    : typeof react__WEBPACK_IMPORTED_MODULE_0__.memo === \"function\" && (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(function (props) { return null; })[\"$$typeof\"];\n// n.b. base case is not used for actual typings or exported in the typing files\nfunction observer(baseComponent, \n// TODO remove in next major\noptions) {\n    var _a;\n    if ( true && warnObserverOptionsDeprecated && options) {\n        warnObserverOptionsDeprecated = false;\n        console.warn(\"[mobx-react-lite] `observer(fn, { forwardRef: true })` is deprecated, use `observer(React.forwardRef(fn))`\");\n    }\n    if (ReactMemoSymbol && baseComponent[\"$$typeof\"] === ReactMemoSymbol) {\n        throw new Error(\"[mobx-react-lite] You are trying to use `observer` on a function component wrapped in either another `observer` or `React.memo`. The observer already applies 'React.memo' for you.\");\n    }\n    // The working of observer is explained step by step in this talk: https://www.youtube.com/watch?v=cPF4iBedoF0&feature=youtu.be&t=1307\n    if ((0,_staticRendering__WEBPACK_IMPORTED_MODULE_1__.isUsingStaticRendering)()) {\n        return baseComponent;\n    }\n    var useForwardRef = (_a = options === null || options === void 0 ? void 0 : options.forwardRef) !== null && _a !== void 0 ? _a : false;\n    var render = baseComponent;\n    var baseComponentName = baseComponent.displayName || baseComponent.name;\n    // If already wrapped with forwardRef, unwrap,\n    // so we can patch render and apply memo\n    if (ReactForwardRefSymbol && baseComponent[\"$$typeof\"] === ReactForwardRefSymbol) {\n        useForwardRef = true;\n        render = baseComponent[\"render\"];\n        if (typeof render !== \"function\") {\n            throw new Error(\"[mobx-react-lite] `render` property of ForwardRef was not a function\");\n        }\n    }\n    var observerComponent = function (props, ref) {\n        return (0,_useObserver__WEBPACK_IMPORTED_MODULE_2__.useObserver)(function () { return render(props, ref); }, baseComponentName);\n    };\n    // Don't set `displayName` for anonymous components,\n    // so the `displayName` can be customized by user, see #3192.\n    if (baseComponentName !== \"\") {\n        ;\n        observerComponent.displayName = baseComponentName;\n    }\n    // Support legacy context: `contextTypes` must be applied before `memo`\n    if (baseComponent.contextTypes) {\n        ;\n        observerComponent.contextTypes = baseComponent.contextTypes;\n    }\n    if (useForwardRef) {\n        // `forwardRef` must be applied prior `memo`\n        // `forwardRef(observer(cmp))` throws:\n        // \"forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))\"\n        observerComponent = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(observerComponent);\n    }\n    // memo; we are not interested in deep updates\n    // in props; we assume that if deep objects are changed,\n    // this is in observables, which would have been tracked anyway\n    observerComponent = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(observerComponent);\n    copyStaticProperties(baseComponent, observerComponent);\n    if (true) {\n        Object.defineProperty(observerComponent, \"contextTypes\", {\n            set: function () {\n                var _a;\n                throw new Error(\"[mobx-react-lite] `\".concat(this.displayName || ((_a = this.type) === null || _a === void 0 ? void 0 : _a.displayName) || \"Component\", \".contextTypes` must be set before applying `observer`.\"));\n            }\n        });\n    }\n    return observerComponent;\n}\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\nvar hoistBlackList = {\n    $$typeof: true,\n    render: true,\n    compare: true,\n    type: true,\n    // Don't redefine `displayName`,\n    // it's defined as getter-setter pair on `memo` (see #3192).\n    displayName: true\n};\nfunction copyStaticProperties(base, target) {\n    Object.keys(base).forEach(function (key) {\n        if (!hoistBlackList[key]) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));\n        }\n    });\n}\n//# sourceMappingURL=observer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL29ic2VydmVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXlDO0FBQ2tCO0FBQ2Y7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkNBQVUsbUJBQW1CLGlEQUFVLG9CQUFvQixjQUFjO0FBQ3RGO0FBQ0E7QUFDQSxhQUFhLHVDQUFJLG1CQUFtQiwyQ0FBSSxvQkFBb0IsY0FBYztBQUMxRTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBLHdEQUF3RCxrQkFBa0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0VBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseURBQVcsZUFBZSw0QkFBNEI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaURBQVU7QUFDdEM7QUFDQSxhQUFhO0FBQ2IsaUJBQWlCO0FBQ2pCO0FBQ0Esd0JBQXdCLDJDQUFJO0FBQzVCO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tb2J4LXJlYWN0LWxpdGUvZXMvb2JzZXJ2ZXIuanM/YjZlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmb3J3YXJkUmVmLCBtZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBpc1VzaW5nU3RhdGljUmVuZGVyaW5nIH0gZnJvbSBcIi4vc3RhdGljUmVuZGVyaW5nXCI7XG5pbXBvcnQgeyB1c2VPYnNlcnZlciB9IGZyb20gXCIuL3VzZU9ic2VydmVyXCI7XG52YXIgd2Fybk9ic2VydmVyT3B0aW9uc0RlcHJlY2F0ZWQgPSB0cnVlO1xudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuZm9yO1xuLy8gVXNpbmcgcmVhY3QtaXMgaGFkIHNvbWUgaXNzdWVzIChhbmQgb3BlcmF0ZXMgb24gZWxlbWVudHMsIG5vdCBvbiB0eXBlcyksIHNlZSAjNjA4IC8gIzYwOVxudmFyIFJlYWN0Rm9yd2FyZFJlZlN5bWJvbCA9IGhhc1N5bWJvbFxuICAgID8gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpXG4gICAgOiB0eXBlb2YgZm9yd2FyZFJlZiA9PT0gXCJmdW5jdGlvblwiICYmIGZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiBudWxsOyB9KVtcIiQkdHlwZW9mXCJdO1xudmFyIFJlYWN0TWVtb1N5bWJvbCA9IGhhc1N5bWJvbFxuICAgID8gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIilcbiAgICA6IHR5cGVvZiBtZW1vID09PSBcImZ1bmN0aW9uXCIgJiYgbWVtbyhmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIG51bGw7IH0pW1wiJCR0eXBlb2ZcIl07XG4vLyBuLmIuIGJhc2UgY2FzZSBpcyBub3QgdXNlZCBmb3IgYWN0dWFsIHR5cGluZ3Mgb3IgZXhwb3J0ZWQgaW4gdGhlIHR5cGluZyBmaWxlc1xuZXhwb3J0IGZ1bmN0aW9uIG9ic2VydmVyKGJhc2VDb21wb25lbnQsIFxuLy8gVE9ETyByZW1vdmUgaW4gbmV4dCBtYWpvclxub3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHdhcm5PYnNlcnZlck9wdGlvbnNEZXByZWNhdGVkICYmIG9wdGlvbnMpIHtcbiAgICAgICAgd2Fybk9ic2VydmVyT3B0aW9uc0RlcHJlY2F0ZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW21vYngtcmVhY3QtbGl0ZV0gYG9ic2VydmVyKGZuLCB7IGZvcndhcmRSZWY6IHRydWUgfSlgIGlzIGRlcHJlY2F0ZWQsIHVzZSBgb2JzZXJ2ZXIoUmVhY3QuZm9yd2FyZFJlZihmbikpYFwiKTtcbiAgICB9XG4gICAgaWYgKFJlYWN0TWVtb1N5bWJvbCAmJiBiYXNlQ29tcG9uZW50W1wiJCR0eXBlb2ZcIl0gPT09IFJlYWN0TWVtb1N5bWJvbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbbW9ieC1yZWFjdC1saXRlXSBZb3UgYXJlIHRyeWluZyB0byB1c2UgYG9ic2VydmVyYCBvbiBhIGZ1bmN0aW9uIGNvbXBvbmVudCB3cmFwcGVkIGluIGVpdGhlciBhbm90aGVyIGBvYnNlcnZlcmAgb3IgYFJlYWN0Lm1lbW9gLiBUaGUgb2JzZXJ2ZXIgYWxyZWFkeSBhcHBsaWVzICdSZWFjdC5tZW1vJyBmb3IgeW91LlwiKTtcbiAgICB9XG4gICAgLy8gVGhlIHdvcmtpbmcgb2Ygb2JzZXJ2ZXIgaXMgZXhwbGFpbmVkIHN0ZXAgYnkgc3RlcCBpbiB0aGlzIHRhbGs6IGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9Y1BGNGlCZWRvRjAmZmVhdHVyZT15b3V0dS5iZSZ0PTEzMDdcbiAgICBpZiAoaXNVc2luZ1N0YXRpY1JlbmRlcmluZygpKSB7XG4gICAgICAgIHJldHVybiBiYXNlQ29tcG9uZW50O1xuICAgIH1cbiAgICB2YXIgdXNlRm9yd2FyZFJlZiA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mb3J3YXJkUmVmKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcbiAgICB2YXIgcmVuZGVyID0gYmFzZUNvbXBvbmVudDtcbiAgICB2YXIgYmFzZUNvbXBvbmVudE5hbWUgPSBiYXNlQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IGJhc2VDb21wb25lbnQubmFtZTtcbiAgICAvLyBJZiBhbHJlYWR5IHdyYXBwZWQgd2l0aCBmb3J3YXJkUmVmLCB1bndyYXAsXG4gICAgLy8gc28gd2UgY2FuIHBhdGNoIHJlbmRlciBhbmQgYXBwbHkgbWVtb1xuICAgIGlmIChSZWFjdEZvcndhcmRSZWZTeW1ib2wgJiYgYmFzZUNvbXBvbmVudFtcIiQkdHlwZW9mXCJdID09PSBSZWFjdEZvcndhcmRSZWZTeW1ib2wpIHtcbiAgICAgICAgdXNlRm9yd2FyZFJlZiA9IHRydWU7XG4gICAgICAgIHJlbmRlciA9IGJhc2VDb21wb25lbnRbXCJyZW5kZXJcIl07XG4gICAgICAgIGlmICh0eXBlb2YgcmVuZGVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlttb2J4LXJlYWN0LWxpdGVdIGByZW5kZXJgIHByb3BlcnR5IG9mIEZvcndhcmRSZWYgd2FzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBvYnNlcnZlckNvbXBvbmVudCA9IGZ1bmN0aW9uIChwcm9wcywgcmVmKSB7XG4gICAgICAgIHJldHVybiB1c2VPYnNlcnZlcihmdW5jdGlvbiAoKSB7IHJldHVybiByZW5kZXIocHJvcHMsIHJlZik7IH0sIGJhc2VDb21wb25lbnROYW1lKTtcbiAgICB9O1xuICAgIC8vIERvbid0IHNldCBgZGlzcGxheU5hbWVgIGZvciBhbm9ueW1vdXMgY29tcG9uZW50cyxcbiAgICAvLyBzbyB0aGUgYGRpc3BsYXlOYW1lYCBjYW4gYmUgY3VzdG9taXplZCBieSB1c2VyLCBzZWUgIzMxOTIuXG4gICAgaWYgKGJhc2VDb21wb25lbnROYW1lICE9PSBcIlwiKSB7XG4gICAgICAgIDtcbiAgICAgICAgb2JzZXJ2ZXJDb21wb25lbnQuZGlzcGxheU5hbWUgPSBiYXNlQ29tcG9uZW50TmFtZTtcbiAgICB9XG4gICAgLy8gU3VwcG9ydCBsZWdhY3kgY29udGV4dDogYGNvbnRleHRUeXBlc2AgbXVzdCBiZSBhcHBsaWVkIGJlZm9yZSBgbWVtb2BcbiAgICBpZiAoYmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgO1xuICAgICAgICBvYnNlcnZlckNvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBiYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlcztcbiAgICB9XG4gICAgaWYgKHVzZUZvcndhcmRSZWYpIHtcbiAgICAgICAgLy8gYGZvcndhcmRSZWZgIG11c3QgYmUgYXBwbGllZCBwcmlvciBgbWVtb2BcbiAgICAgICAgLy8gYGZvcndhcmRSZWYob2JzZXJ2ZXIoY21wKSlgIHRocm93czpcbiAgICAgICAgLy8gXCJmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCByZWNlaXZlZCBhIGBtZW1vYCBjb21wb25lbnQuIEluc3RlYWQgb2YgZm9yd2FyZFJlZihtZW1vKC4uLikpLCB1c2UgbWVtbyhmb3J3YXJkUmVmKC4uLikpXCJcbiAgICAgICAgb2JzZXJ2ZXJDb21wb25lbnQgPSBmb3J3YXJkUmVmKG9ic2VydmVyQ29tcG9uZW50KTtcbiAgICB9XG4gICAgLy8gbWVtbzsgd2UgYXJlIG5vdCBpbnRlcmVzdGVkIGluIGRlZXAgdXBkYXRlc1xuICAgIC8vIGluIHByb3BzOyB3ZSBhc3N1bWUgdGhhdCBpZiBkZWVwIG9iamVjdHMgYXJlIGNoYW5nZWQsXG4gICAgLy8gdGhpcyBpcyBpbiBvYnNlcnZhYmxlcywgd2hpY2ggd291bGQgaGF2ZSBiZWVuIHRyYWNrZWQgYW55d2F5XG4gICAgb2JzZXJ2ZXJDb21wb25lbnQgPSBtZW1vKG9ic2VydmVyQ29tcG9uZW50KTtcbiAgICBjb3B5U3RhdGljUHJvcGVydGllcyhiYXNlQ29tcG9uZW50LCBvYnNlcnZlckNvbXBvbmVudCk7XG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JzZXJ2ZXJDb21wb25lbnQsIFwiY29udGV4dFR5cGVzXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbbW9ieC1yZWFjdC1saXRlXSBgXCIuY29uY2F0KHRoaXMuZGlzcGxheU5hbWUgfHwgKChfYSA9IHRoaXMudHlwZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc3BsYXlOYW1lKSB8fCBcIkNvbXBvbmVudFwiLCBcIi5jb250ZXh0VHlwZXNgIG11c3QgYmUgc2V0IGJlZm9yZSBhcHBseWluZyBgb2JzZXJ2ZXJgLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb2JzZXJ2ZXJDb21wb25lbnQ7XG59XG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbXJpZGd3YXkvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvYmxvYi9tYXN0ZXIvc3JjL2luZGV4LmpzXG52YXIgaG9pc3RCbGFja0xpc3QgPSB7XG4gICAgJCR0eXBlb2Y6IHRydWUsXG4gICAgcmVuZGVyOiB0cnVlLFxuICAgIGNvbXBhcmU6IHRydWUsXG4gICAgdHlwZTogdHJ1ZSxcbiAgICAvLyBEb24ndCByZWRlZmluZSBgZGlzcGxheU5hbWVgLFxuICAgIC8vIGl0J3MgZGVmaW5lZCBhcyBnZXR0ZXItc2V0dGVyIHBhaXIgb24gYG1lbW9gIChzZWUgIzMxOTIpLlxuICAgIGRpc3BsYXlOYW1lOiB0cnVlXG59O1xuZnVuY3Rpb24gY29weVN0YXRpY1Byb3BlcnRpZXMoYmFzZSwgdGFyZ2V0KSB7XG4gICAgT2JqZWN0LmtleXMoYmFzZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghaG9pc3RCbGFja0xpc3Rba2V5XSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIGtleSkpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYnNlcnZlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mobx-react-lite/es/observer.js\n"));

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/staticRendering.js":
/*!************************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/staticRendering.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"enableStaticRendering\": function() { return /* binding */ enableStaticRendering; },\n/* harmony export */   \"isUsingStaticRendering\": function() { return /* binding */ isUsingStaticRendering; }\n/* harmony export */ });\nvar globalIsUsingStaticRendering = false;\nfunction enableStaticRendering(enable) {\n    globalIsUsingStaticRendering = enable;\n}\nfunction isUsingStaticRendering() {\n    return globalIsUsingStaticRendering;\n}\n//# sourceMappingURL=staticRendering.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL3N0YXRpY1JlbmRlcmluZy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21vYngtcmVhY3QtbGl0ZS9lcy9zdGF0aWNSZW5kZXJpbmcuanM/ZjJhNCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZ2xvYmFsSXNVc2luZ1N0YXRpY1JlbmRlcmluZyA9IGZhbHNlO1xuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZVN0YXRpY1JlbmRlcmluZyhlbmFibGUpIHtcbiAgICBnbG9iYWxJc1VzaW5nU3RhdGljUmVuZGVyaW5nID0gZW5hYmxlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzVXNpbmdTdGF0aWNSZW5kZXJpbmcoKSB7XG4gICAgcmV0dXJuIGdsb2JhbElzVXNpbmdTdGF0aWNSZW5kZXJpbmc7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGF0aWNSZW5kZXJpbmcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mobx-react-lite/es/staticRendering.js\n"));

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/useAsObservableSource.js":
/*!******************************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/useAsObservableSource.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useAsObservableSource\": function() { return /* binding */ useAsObservableSource; }\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/utils */ \"./node_modules/mobx-react-lite/es/utils/utils.js\");\n/* harmony import */ var mobx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mobx */ \"./node_modules/mobx/dist/mobx.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\nvar __read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\n\n\n\nfunction useAsObservableSource(current) {\n    if (true)\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.useDeprecated)(\"[mobx-react-lite] 'useAsObservableSource' is deprecated, please store the values directly in an observable, for example by using 'useLocalObservable', and sync future updates using 'useEffect' when needed. See the README for examples.\");\n    var _a = __read((0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(function () { return (0,mobx__WEBPACK_IMPORTED_MODULE_2__.observable)(current, {}, { deep: false }); }), 1), res = _a[0];\n    (0,mobx__WEBPACK_IMPORTED_MODULE_2__.runInAction)(function () {\n        Object.assign(res, current);\n    });\n    return res;\n}\n//# sourceMappingURL=useAsObservableSource.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL3VzZUFzT2JzZXJ2YWJsZVNvdXJjZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLGNBQWMsU0FBSSxJQUFJLFNBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQzhDO0FBQ0M7QUFDZDtBQUMxQjtBQUNQLFFBQVEsSUFBcUM7QUFDN0MsUUFBUSwyREFBYTtBQUNyQixvQkFBb0IsK0NBQVEsZUFBZSxPQUFPLGdEQUFVLFlBQVksSUFBSSxhQUFhLElBQUk7QUFDN0YsSUFBSSxpREFBVztBQUNmO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL3VzZUFzT2JzZXJ2YWJsZVNvdXJjZS5qcz81M2M2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbmltcG9ydCB7IHVzZURlcHJlY2F0ZWQgfSBmcm9tIFwiLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgb2JzZXJ2YWJsZSwgcnVuSW5BY3Rpb24gfSBmcm9tIFwibW9ieFwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmV4cG9ydCBmdW5jdGlvbiB1c2VBc09ic2VydmFibGVTb3VyY2UoY3VycmVudCkge1xuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpXG4gICAgICAgIHVzZURlcHJlY2F0ZWQoXCJbbW9ieC1yZWFjdC1saXRlXSAndXNlQXNPYnNlcnZhYmxlU291cmNlJyBpcyBkZXByZWNhdGVkLCBwbGVhc2Ugc3RvcmUgdGhlIHZhbHVlcyBkaXJlY3RseSBpbiBhbiBvYnNlcnZhYmxlLCBmb3IgZXhhbXBsZSBieSB1c2luZyAndXNlTG9jYWxPYnNlcnZhYmxlJywgYW5kIHN5bmMgZnV0dXJlIHVwZGF0ZXMgdXNpbmcgJ3VzZUVmZmVjdCcgd2hlbiBuZWVkZWQuIFNlZSB0aGUgUkVBRE1FIGZvciBleGFtcGxlcy5cIik7XG4gICAgdmFyIF9hID0gX19yZWFkKHVzZVN0YXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9ic2VydmFibGUoY3VycmVudCwge30sIHsgZGVlcDogZmFsc2UgfSk7IH0pLCAxKSwgcmVzID0gX2FbMF07XG4gICAgcnVuSW5BY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHJlcywgY3VycmVudCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZUFzT2JzZXJ2YWJsZVNvdXJjZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mobx-react-lite/es/useAsObservableSource.js\n"));

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/useLocalObservable.js":
/*!***************************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/useLocalObservable.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useLocalObservable\": function() { return /* binding */ useLocalObservable; }\n/* harmony export */ });\n/* harmony import */ var mobx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mobx */ \"./node_modules/mobx/dist/mobx.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction useLocalObservable(initializer, annotations) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(function () { return (0,mobx__WEBPACK_IMPORTED_MODULE_1__.observable)(initializer(), annotations, { autoBind: true }); })[0];\n}\n//# sourceMappingURL=useLocalObservable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL3VzZUxvY2FsT2JzZXJ2YWJsZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWtDO0FBQ0Q7QUFDMUI7QUFDUCxXQUFXLCtDQUFRLGVBQWUsT0FBTyxnREFBVSwrQkFBK0IsZ0JBQWdCLElBQUk7QUFDdEc7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL3VzZUxvY2FsT2JzZXJ2YWJsZS5qcz82NWI4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG9ic2VydmFibGUgfSBmcm9tIFwibW9ieFwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmV4cG9ydCBmdW5jdGlvbiB1c2VMb2NhbE9ic2VydmFibGUoaW5pdGlhbGl6ZXIsIGFubm90YXRpb25zKSB7XG4gICAgcmV0dXJuIHVzZVN0YXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9ic2VydmFibGUoaW5pdGlhbGl6ZXIoKSwgYW5ub3RhdGlvbnMsIHsgYXV0b0JpbmQ6IHRydWUgfSk7IH0pWzBdO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlTG9jYWxPYnNlcnZhYmxlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mobx-react-lite/es/useLocalObservable.js\n"));

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/useLocalStore.js":
/*!**********************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/useLocalStore.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useLocalStore\": function() { return /* binding */ useLocalStore; }\n/* harmony export */ });\n/* harmony import */ var mobx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! mobx */ \"./node_modules/mobx/dist/mobx.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/utils */ \"./node_modules/mobx-react-lite/es/utils/utils.js\");\n/* harmony import */ var _useAsObservableSource__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useAsObservableSource */ \"./node_modules/mobx-react-lite/es/useAsObservableSource.js\");\n\n\n\n\nfunction useLocalStore(initializer, current) {\n    if (true)\n        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.useDeprecated)(\"[mobx-react-lite] 'useLocalStore' is deprecated, use 'useLocalObservable' instead.\");\n    var source = current && (0,_useAsObservableSource__WEBPACK_IMPORTED_MODULE_2__.useAsObservableSource)(current);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(function () { return (0,mobx__WEBPACK_IMPORTED_MODULE_3__.observable)(initializer(source), undefined, { autoBind: true }); })[0];\n}\n//# sourceMappingURL=useLocalStore.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL3VzZUxvY2FsU3RvcmUuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWtDO0FBQ0Q7QUFDYTtBQUNrQjtBQUN6RDtBQUNQLFFBQVEsSUFBcUM7QUFDN0MsUUFBUSwyREFBYTtBQUNyQiw0QkFBNEIsNkVBQXFCO0FBQ2pELFdBQVcsK0NBQVEsZUFBZSxPQUFPLGdEQUFVLG1DQUFtQyxnQkFBZ0IsSUFBSTtBQUMxRztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tb2J4LXJlYWN0LWxpdGUvZXMvdXNlTG9jYWxTdG9yZS5qcz9iNzFlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG9ic2VydmFibGUgfSBmcm9tIFwibW9ieFwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZURlcHJlY2F0ZWQgfSBmcm9tIFwiLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgdXNlQXNPYnNlcnZhYmxlU291cmNlIH0gZnJvbSBcIi4vdXNlQXNPYnNlcnZhYmxlU291cmNlXCI7XG5leHBvcnQgZnVuY3Rpb24gdXNlTG9jYWxTdG9yZShpbml0aWFsaXplciwgY3VycmVudCkge1xuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpXG4gICAgICAgIHVzZURlcHJlY2F0ZWQoXCJbbW9ieC1yZWFjdC1saXRlXSAndXNlTG9jYWxTdG9yZScgaXMgZGVwcmVjYXRlZCwgdXNlICd1c2VMb2NhbE9ic2VydmFibGUnIGluc3RlYWQuXCIpO1xuICAgIHZhciBzb3VyY2UgPSBjdXJyZW50ICYmIHVzZUFzT2JzZXJ2YWJsZVNvdXJjZShjdXJyZW50KTtcbiAgICByZXR1cm4gdXNlU3RhdGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JzZXJ2YWJsZShpbml0aWFsaXplcihzb3VyY2UpLCB1bmRlZmluZWQsIHsgYXV0b0JpbmQ6IHRydWUgfSk7IH0pWzBdO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlTG9jYWxTdG9yZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mobx-react-lite/es/useLocalStore.js\n"));

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/useObserver.js":
/*!********************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/useObserver.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useObserver\": function() { return /* binding */ useObserver; }\n/* harmony export */ });\n/* harmony import */ var mobx__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! mobx */ \"./node_modules/mobx/dist/mobx.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_printDebugValue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/printDebugValue */ \"./node_modules/mobx-react-lite/es/utils/printDebugValue.js\");\n/* harmony import */ var _utils_reactionCleanupTracking__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/reactionCleanupTracking */ \"./node_modules/mobx-react-lite/es/utils/reactionCleanupTracking.js\");\n/* harmony import */ var _staticRendering__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./staticRendering */ \"./node_modules/mobx-react-lite/es/staticRendering.js\");\nvar __read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\n\n\n\n\n\nfunction observerComponentNameFor(baseComponentName) {\n    return \"observer\".concat(baseComponentName);\n}\n/**\n * We use class to make it easier to detect in heap snapshots by name\n */\nvar ObjectToBeRetainedByReact = /** @class */ (function () {\n    function ObjectToBeRetainedByReact() {\n    }\n    return ObjectToBeRetainedByReact;\n}());\nfunction objectToBeRetainedByReactFactory() {\n    return new ObjectToBeRetainedByReact();\n}\nfunction useObserver(fn, baseComponentName) {\n    if (baseComponentName === void 0) { baseComponentName = \"observed\"; }\n    if ((0,_staticRendering__WEBPACK_IMPORTED_MODULE_3__.isUsingStaticRendering)()) {\n        return fn();\n    }\n    var _a = __read(react__WEBPACK_IMPORTED_MODULE_0___default().useState(objectToBeRetainedByReactFactory), 1), objectRetainedByReact = _a[0];\n    // Force update, see #2982\n    var _b = __read(react__WEBPACK_IMPORTED_MODULE_0___default().useState(), 2), setState = _b[1];\n    var forceUpdate = function () { return setState([]); };\n    // StrictMode/ConcurrentMode/Suspense may mean that our component is\n    // rendered and abandoned multiple times, so we need to track leaked\n    // Reactions.\n    var reactionTrackingRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null);\n    if (!reactionTrackingRef.current) {\n        // First render for this component (or first time since a previous\n        // reaction from an abandoned render was disposed).\n        var newReaction = new mobx__WEBPACK_IMPORTED_MODULE_4__.Reaction(observerComponentNameFor(baseComponentName), function () {\n            // Observable has changed, meaning we want to re-render\n            // BUT if we're a component that hasn't yet got to the useEffect()\n            // stage, we might be a component that _started_ to render, but\n            // got dropped, and we don't want to make state changes then.\n            // (It triggers warnings in StrictMode, for a start.)\n            if (trackingData_1.mounted) {\n                // We have reached useEffect(), so we're mounted, and can trigger an update\n                forceUpdate();\n            }\n            else {\n                // We haven't yet reached useEffect(), so we'll need to trigger a re-render\n                // when (and if) useEffect() arrives.\n                trackingData_1.changedBeforeMount = true;\n            }\n        });\n        var trackingData_1 = (0,_utils_reactionCleanupTracking__WEBPACK_IMPORTED_MODULE_2__.addReactionToTrack)(reactionTrackingRef, newReaction, objectRetainedByReact);\n    }\n    var reaction = reactionTrackingRef.current.reaction;\n    react__WEBPACK_IMPORTED_MODULE_0___default().useDebugValue(reaction, _utils_printDebugValue__WEBPACK_IMPORTED_MODULE_1__.printDebugValue);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function () {\n        // Called on first mount only\n        (0,_utils_reactionCleanupTracking__WEBPACK_IMPORTED_MODULE_2__.recordReactionAsCommitted)(reactionTrackingRef);\n        if (reactionTrackingRef.current) {\n            // Great. We've already got our reaction from our render;\n            // all we need to do is to record that it's now mounted,\n            // to allow future observable changes to trigger re-renders\n            reactionTrackingRef.current.mounted = true;\n            // Got a change before first mount, force an update\n            if (reactionTrackingRef.current.changedBeforeMount) {\n                reactionTrackingRef.current.changedBeforeMount = false;\n                forceUpdate();\n            }\n        }\n        else {\n            // The reaction we set up in our render has been disposed.\n            // This can be due to bad timings of renderings, e.g. our\n            // component was paused for a _very_ long time, and our\n            // reaction got cleaned up\n            // Re-create the reaction\n            reactionTrackingRef.current = {\n                reaction: new mobx__WEBPACK_IMPORTED_MODULE_4__.Reaction(observerComponentNameFor(baseComponentName), function () {\n                    // We've definitely already been mounted at this point\n                    forceUpdate();\n                }),\n                mounted: true,\n                changedBeforeMount: false,\n                cleanAt: Infinity\n            };\n            forceUpdate();\n        }\n        return function () {\n            reactionTrackingRef.current.reaction.dispose();\n            reactionTrackingRef.current = null;\n        };\n    }, []);\n    // render the original component, but have the\n    // reaction track the observables, so that rendering\n    // can be invalidated (see above) once a dependency changes\n    var rendering;\n    var exception;\n    reaction.track(function () {\n        try {\n            rendering = fn();\n        }\n        catch (e) {\n            exception = e;\n        }\n    });\n    if (exception) {\n        throw exception; // re-throw any exceptions caught during rendering\n    }\n    return rendering;\n}\n//# sourceMappingURL=useObserver.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL3VzZU9ic2VydmVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxjQUFjLFNBQUksSUFBSSxTQUFJO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNnQztBQUNOO0FBQ2dDO0FBQ3NDO0FBQ3JDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asd0NBQXdDO0FBQ3hDLFFBQVEsd0VBQXNCO0FBQzlCO0FBQ0E7QUFDQSxvQkFBb0IscURBQWM7QUFDbEM7QUFDQSxvQkFBb0IscURBQWM7QUFDbEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtREFBWTtBQUMxQztBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMENBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw2QkFBNkIsa0ZBQWtCO0FBQy9DO0FBQ0E7QUFDQSxJQUFJLDBEQUFtQixXQUFXLG1FQUFlO0FBQ2pELElBQUksc0RBQWU7QUFDbkI7QUFDQSxRQUFRLHlGQUF5QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMENBQVE7QUFDdEM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21vYngtcmVhY3QtbGl0ZS9lcy91c2VPYnNlcnZlci5qcz9jYjgzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbmltcG9ydCB7IFJlYWN0aW9uIH0gZnJvbSBcIm1vYnhcIjtcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHByaW50RGVidWdWYWx1ZSB9IGZyb20gXCIuL3V0aWxzL3ByaW50RGVidWdWYWx1ZVwiO1xuaW1wb3J0IHsgYWRkUmVhY3Rpb25Ub1RyYWNrLCByZWNvcmRSZWFjdGlvbkFzQ29tbWl0dGVkIH0gZnJvbSBcIi4vdXRpbHMvcmVhY3Rpb25DbGVhbnVwVHJhY2tpbmdcIjtcbmltcG9ydCB7IGlzVXNpbmdTdGF0aWNSZW5kZXJpbmcgfSBmcm9tIFwiLi9zdGF0aWNSZW5kZXJpbmdcIjtcbmZ1bmN0aW9uIG9ic2VydmVyQ29tcG9uZW50TmFtZUZvcihiYXNlQ29tcG9uZW50TmFtZSkge1xuICAgIHJldHVybiBcIm9ic2VydmVyXCIuY29uY2F0KGJhc2VDb21wb25lbnROYW1lKTtcbn1cbi8qKlxuICogV2UgdXNlIGNsYXNzIHRvIG1ha2UgaXQgZWFzaWVyIHRvIGRldGVjdCBpbiBoZWFwIHNuYXBzaG90cyBieSBuYW1lXG4gKi9cbnZhciBPYmplY3RUb0JlUmV0YWluZWRCeVJlYWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9iamVjdFRvQmVSZXRhaW5lZEJ5UmVhY3QoKSB7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3RUb0JlUmV0YWluZWRCeVJlYWN0O1xufSgpKTtcbmZ1bmN0aW9uIG9iamVjdFRvQmVSZXRhaW5lZEJ5UmVhY3RGYWN0b3J5KCkge1xuICAgIHJldHVybiBuZXcgT2JqZWN0VG9CZVJldGFpbmVkQnlSZWFjdCgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZU9ic2VydmVyKGZuLCBiYXNlQ29tcG9uZW50TmFtZSkge1xuICAgIGlmIChiYXNlQ29tcG9uZW50TmFtZSA9PT0gdm9pZCAwKSB7IGJhc2VDb21wb25lbnROYW1lID0gXCJvYnNlcnZlZFwiOyB9XG4gICAgaWYgKGlzVXNpbmdTdGF0aWNSZW5kZXJpbmcoKSkge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICB9XG4gICAgdmFyIF9hID0gX19yZWFkKFJlYWN0LnVzZVN0YXRlKG9iamVjdFRvQmVSZXRhaW5lZEJ5UmVhY3RGYWN0b3J5KSwgMSksIG9iamVjdFJldGFpbmVkQnlSZWFjdCA9IF9hWzBdO1xuICAgIC8vIEZvcmNlIHVwZGF0ZSwgc2VlICMyOTgyXG4gICAgdmFyIF9iID0gX19yZWFkKFJlYWN0LnVzZVN0YXRlKCksIDIpLCBzZXRTdGF0ZSA9IF9iWzFdO1xuICAgIHZhciBmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNldFN0YXRlKFtdKTsgfTtcbiAgICAvLyBTdHJpY3RNb2RlL0NvbmN1cnJlbnRNb2RlL1N1c3BlbnNlIG1heSBtZWFuIHRoYXQgb3VyIGNvbXBvbmVudCBpc1xuICAgIC8vIHJlbmRlcmVkIGFuZCBhYmFuZG9uZWQgbXVsdGlwbGUgdGltZXMsIHNvIHdlIG5lZWQgdG8gdHJhY2sgbGVha2VkXG4gICAgLy8gUmVhY3Rpb25zLlxuICAgIHZhciByZWFjdGlvblRyYWNraW5nUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIGlmICghcmVhY3Rpb25UcmFja2luZ1JlZi5jdXJyZW50KSB7XG4gICAgICAgIC8vIEZpcnN0IHJlbmRlciBmb3IgdGhpcyBjb21wb25lbnQgKG9yIGZpcnN0IHRpbWUgc2luY2UgYSBwcmV2aW91c1xuICAgICAgICAvLyByZWFjdGlvbiBmcm9tIGFuIGFiYW5kb25lZCByZW5kZXIgd2FzIGRpc3Bvc2VkKS5cbiAgICAgICAgdmFyIG5ld1JlYWN0aW9uID0gbmV3IFJlYWN0aW9uKG9ic2VydmVyQ29tcG9uZW50TmFtZUZvcihiYXNlQ29tcG9uZW50TmFtZSksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIE9ic2VydmFibGUgaGFzIGNoYW5nZWQsIG1lYW5pbmcgd2Ugd2FudCB0byByZS1yZW5kZXJcbiAgICAgICAgICAgIC8vIEJVVCBpZiB3ZSdyZSBhIGNvbXBvbmVudCB0aGF0IGhhc24ndCB5ZXQgZ290IHRvIHRoZSB1c2VFZmZlY3QoKVxuICAgICAgICAgICAgLy8gc3RhZ2UsIHdlIG1pZ2h0IGJlIGEgY29tcG9uZW50IHRoYXQgX3N0YXJ0ZWRfIHRvIHJlbmRlciwgYnV0XG4gICAgICAgICAgICAvLyBnb3QgZHJvcHBlZCwgYW5kIHdlIGRvbid0IHdhbnQgdG8gbWFrZSBzdGF0ZSBjaGFuZ2VzIHRoZW4uXG4gICAgICAgICAgICAvLyAoSXQgdHJpZ2dlcnMgd2FybmluZ3MgaW4gU3RyaWN0TW9kZSwgZm9yIGEgc3RhcnQuKVxuICAgICAgICAgICAgaWYgKHRyYWNraW5nRGF0YV8xLm1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHJlYWNoZWQgdXNlRWZmZWN0KCksIHNvIHdlJ3JlIG1vdW50ZWQsIGFuZCBjYW4gdHJpZ2dlciBhbiB1cGRhdGVcbiAgICAgICAgICAgICAgICBmb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZW4ndCB5ZXQgcmVhY2hlZCB1c2VFZmZlY3QoKSwgc28gd2UnbGwgbmVlZCB0byB0cmlnZ2VyIGEgcmUtcmVuZGVyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiAoYW5kIGlmKSB1c2VFZmZlY3QoKSBhcnJpdmVzLlxuICAgICAgICAgICAgICAgIHRyYWNraW5nRGF0YV8xLmNoYW5nZWRCZWZvcmVNb3VudCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdHJhY2tpbmdEYXRhXzEgPSBhZGRSZWFjdGlvblRvVHJhY2socmVhY3Rpb25UcmFja2luZ1JlZiwgbmV3UmVhY3Rpb24sIG9iamVjdFJldGFpbmVkQnlSZWFjdCk7XG4gICAgfVxuICAgIHZhciByZWFjdGlvbiA9IHJlYWN0aW9uVHJhY2tpbmdSZWYuY3VycmVudC5yZWFjdGlvbjtcbiAgICBSZWFjdC51c2VEZWJ1Z1ZhbHVlKHJlYWN0aW9uLCBwcmludERlYnVnVmFsdWUpO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIENhbGxlZCBvbiBmaXJzdCBtb3VudCBvbmx5XG4gICAgICAgIHJlY29yZFJlYWN0aW9uQXNDb21taXR0ZWQocmVhY3Rpb25UcmFja2luZ1JlZik7XG4gICAgICAgIGlmIChyZWFjdGlvblRyYWNraW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIC8vIEdyZWF0LiBXZSd2ZSBhbHJlYWR5IGdvdCBvdXIgcmVhY3Rpb24gZnJvbSBvdXIgcmVuZGVyO1xuICAgICAgICAgICAgLy8gYWxsIHdlIG5lZWQgdG8gZG8gaXMgdG8gcmVjb3JkIHRoYXQgaXQncyBub3cgbW91bnRlZCxcbiAgICAgICAgICAgIC8vIHRvIGFsbG93IGZ1dHVyZSBvYnNlcnZhYmxlIGNoYW5nZXMgdG8gdHJpZ2dlciByZS1yZW5kZXJzXG4gICAgICAgICAgICByZWFjdGlvblRyYWNraW5nUmVmLmN1cnJlbnQubW91bnRlZCA9IHRydWU7XG4gICAgICAgICAgICAvLyBHb3QgYSBjaGFuZ2UgYmVmb3JlIGZpcnN0IG1vdW50LCBmb3JjZSBhbiB1cGRhdGVcbiAgICAgICAgICAgIGlmIChyZWFjdGlvblRyYWNraW5nUmVmLmN1cnJlbnQuY2hhbmdlZEJlZm9yZU1vdW50KSB7XG4gICAgICAgICAgICAgICAgcmVhY3Rpb25UcmFja2luZ1JlZi5jdXJyZW50LmNoYW5nZWRCZWZvcmVNb3VudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGUgcmVhY3Rpb24gd2Ugc2V0IHVwIGluIG91ciByZW5kZXIgaGFzIGJlZW4gZGlzcG9zZWQuXG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBiZSBkdWUgdG8gYmFkIHRpbWluZ3Mgb2YgcmVuZGVyaW5ncywgZS5nLiBvdXJcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudCB3YXMgcGF1c2VkIGZvciBhIF92ZXJ5XyBsb25nIHRpbWUsIGFuZCBvdXJcbiAgICAgICAgICAgIC8vIHJlYWN0aW9uIGdvdCBjbGVhbmVkIHVwXG4gICAgICAgICAgICAvLyBSZS1jcmVhdGUgdGhlIHJlYWN0aW9uXG4gICAgICAgICAgICByZWFjdGlvblRyYWNraW5nUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgcmVhY3Rpb246IG5ldyBSZWFjdGlvbihvYnNlcnZlckNvbXBvbmVudE5hbWVGb3IoYmFzZUNvbXBvbmVudE5hbWUpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIGRlZmluaXRlbHkgYWxyZWFkeSBiZWVuIG1vdW50ZWQgYXQgdGhpcyBwb2ludFxuICAgICAgICAgICAgICAgICAgICBmb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG1vdW50ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgY2hhbmdlZEJlZm9yZU1vdW50OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjbGVhbkF0OiBJbmZpbml0eVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlYWN0aW9uVHJhY2tpbmdSZWYuY3VycmVudC5yZWFjdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgICAgICByZWFjdGlvblRyYWNraW5nUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICAvLyByZW5kZXIgdGhlIG9yaWdpbmFsIGNvbXBvbmVudCwgYnV0IGhhdmUgdGhlXG4gICAgLy8gcmVhY3Rpb24gdHJhY2sgdGhlIG9ic2VydmFibGVzLCBzbyB0aGF0IHJlbmRlcmluZ1xuICAgIC8vIGNhbiBiZSBpbnZhbGlkYXRlZCAoc2VlIGFib3ZlKSBvbmNlIGEgZGVwZW5kZW5jeSBjaGFuZ2VzXG4gICAgdmFyIHJlbmRlcmluZztcbiAgICB2YXIgZXhjZXB0aW9uO1xuICAgIHJlYWN0aW9uLnRyYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlbmRlcmluZyA9IGZuKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IGU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZXhjZXB0aW9uKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjsgLy8gcmUtdGhyb3cgYW55IGV4Y2VwdGlvbnMgY2F1Z2h0IGR1cmluZyByZW5kZXJpbmdcbiAgICB9XG4gICAgcmV0dXJuIHJlbmRlcmluZztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZU9ic2VydmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mobx-react-lite/es/useObserver.js\n"));

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/utils/FinalizationRegistryWrapper.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/utils/FinalizationRegistryWrapper.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FinalizationRegistry\": function() { return /* binding */ FinalizationRegistryLocal; }\n/* harmony export */ });\nvar FinalizationRegistryLocal = typeof FinalizationRegistry === \"undefined\" ? undefined : FinalizationRegistry;\n\n//# sourceMappingURL=FinalizationRegistryWrapper.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL3V0aWxzL0ZpbmFsaXphdGlvblJlZ2lzdHJ5V3JhcHBlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDNkQ7QUFDN0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21vYngtcmVhY3QtbGl0ZS9lcy91dGlscy9GaW5hbGl6YXRpb25SZWdpc3RyeVdyYXBwZXIuanM/NDAxMiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRmluYWxpemF0aW9uUmVnaXN0cnlMb2NhbCA9IHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gXCJ1bmRlZmluZWRcIiA/IHVuZGVmaW5lZCA6IEZpbmFsaXphdGlvblJlZ2lzdHJ5O1xuZXhwb3J0IHsgRmluYWxpemF0aW9uUmVnaXN0cnlMb2NhbCBhcyBGaW5hbGl6YXRpb25SZWdpc3RyeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmluYWxpemF0aW9uUmVnaXN0cnlXcmFwcGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mobx-react-lite/es/utils/FinalizationRegistryWrapper.js\n"));

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/utils/assertEnvironment.js":
/*!********************************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/utils/assertEnvironment.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var mobx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mobx */ \"./node_modules/mobx/dist/mobx.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nif (!react__WEBPACK_IMPORTED_MODULE_0__.useState) {\n    throw new Error(\"mobx-react-lite requires React with Hooks support\");\n}\nif (!mobx__WEBPACK_IMPORTED_MODULE_1__.makeObservable) {\n    throw new Error(\"mobx-react-lite@3 requires mobx at least version 6 to be available\");\n}\n//# sourceMappingURL=assertEnvironment.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL3V0aWxzL2Fzc2VydEVudmlyb25tZW50LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBc0M7QUFDTDtBQUNqQyxLQUFLLDJDQUFRO0FBQ2I7QUFDQTtBQUNBLEtBQUssZ0RBQWM7QUFDbkI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tb2J4LXJlYWN0LWxpdGUvZXMvdXRpbHMvYXNzZXJ0RW52aXJvbm1lbnQuanM/NzUwOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtYWtlT2JzZXJ2YWJsZSB9IGZyb20gXCJtb2J4XCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaWYgKCF1c2VTdGF0ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm1vYngtcmVhY3QtbGl0ZSByZXF1aXJlcyBSZWFjdCB3aXRoIEhvb2tzIHN1cHBvcnRcIik7XG59XG5pZiAoIW1ha2VPYnNlcnZhYmxlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibW9ieC1yZWFjdC1saXRlQDMgcmVxdWlyZXMgbW9ieCBhdCBsZWFzdCB2ZXJzaW9uIDYgdG8gYmUgYXZhaWxhYmxlXCIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzZXJ0RW52aXJvbm1lbnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mobx-react-lite/es/utils/assertEnvironment.js\n"));

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/utils/createReactionCleanupTrackingUsingFinalizationRegister.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/utils/createReactionCleanupTrackingUsingFinalizationRegister.js ***!
  \*********************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createReactionCleanupTrackingUsingFinalizationRegister\": function() { return /* binding */ createReactionCleanupTrackingUsingFinalizationRegister; }\n/* harmony export */ });\n/* harmony import */ var _reactionCleanupTrackingCommon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reactionCleanupTrackingCommon */ \"./node_modules/mobx-react-lite/es/utils/reactionCleanupTrackingCommon.js\");\n\n/**\n * FinalizationRegistry-based uncommitted reaction cleanup\n */\nfunction createReactionCleanupTrackingUsingFinalizationRegister(FinalizationRegistry) {\n    var cleanupTokenToReactionTrackingMap = new Map();\n    var globalCleanupTokensCounter = 1;\n    var registry = new FinalizationRegistry(function cleanupFunction(token) {\n        var trackedReaction = cleanupTokenToReactionTrackingMap.get(token);\n        if (trackedReaction) {\n            trackedReaction.reaction.dispose();\n            cleanupTokenToReactionTrackingMap.delete(token);\n        }\n    });\n    return {\n        addReactionToTrack: function (reactionTrackingRef, reaction, objectRetainedByReact) {\n            var token = globalCleanupTokensCounter++;\n            registry.register(objectRetainedByReact, token, reactionTrackingRef);\n            reactionTrackingRef.current = (0,_reactionCleanupTrackingCommon__WEBPACK_IMPORTED_MODULE_0__.createTrackingData)(reaction);\n            reactionTrackingRef.current.finalizationRegistryCleanupToken = token;\n            cleanupTokenToReactionTrackingMap.set(token, reactionTrackingRef.current);\n            return reactionTrackingRef.current;\n        },\n        recordReactionAsCommitted: function (reactionRef) {\n            registry.unregister(reactionRef);\n            if (reactionRef.current && reactionRef.current.finalizationRegistryCleanupToken) {\n                cleanupTokenToReactionTrackingMap.delete(reactionRef.current.finalizationRegistryCleanupToken);\n            }\n        },\n        forceCleanupTimerToRunNowForTests: function () {\n            // When FinalizationRegistry in use, this this is no-op\n        },\n        resetCleanupScheduleForTests: function () {\n            // When FinalizationRegistry in use, this this is no-op\n        }\n    };\n}\n//# sourceMappingURL=createReactionCleanupTrackingUsingFinalizationRegister.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL3V0aWxzL2NyZWF0ZVJlYWN0aW9uQ2xlYW51cFRyYWNraW5nVXNpbmdGaW5hbGl6YXRpb25SZWdpc3Rlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0ZBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tb2J4LXJlYWN0LWxpdGUvZXMvdXRpbHMvY3JlYXRlUmVhY3Rpb25DbGVhbnVwVHJhY2tpbmdVc2luZ0ZpbmFsaXphdGlvblJlZ2lzdGVyLmpzP2FmNzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlVHJhY2tpbmdEYXRhIH0gZnJvbSBcIi4vcmVhY3Rpb25DbGVhbnVwVHJhY2tpbmdDb21tb25cIjtcbi8qKlxuICogRmluYWxpemF0aW9uUmVnaXN0cnktYmFzZWQgdW5jb21taXR0ZWQgcmVhY3Rpb24gY2xlYW51cFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVhY3Rpb25DbGVhbnVwVHJhY2tpbmdVc2luZ0ZpbmFsaXphdGlvblJlZ2lzdGVyKEZpbmFsaXphdGlvblJlZ2lzdHJ5KSB7XG4gICAgdmFyIGNsZWFudXBUb2tlblRvUmVhY3Rpb25UcmFja2luZ01hcCA9IG5ldyBNYXAoKTtcbiAgICB2YXIgZ2xvYmFsQ2xlYW51cFRva2Vuc0NvdW50ZXIgPSAxO1xuICAgIHZhciByZWdpc3RyeSA9IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShmdW5jdGlvbiBjbGVhbnVwRnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgdmFyIHRyYWNrZWRSZWFjdGlvbiA9IGNsZWFudXBUb2tlblRvUmVhY3Rpb25UcmFja2luZ01hcC5nZXQodG9rZW4pO1xuICAgICAgICBpZiAodHJhY2tlZFJlYWN0aW9uKSB7XG4gICAgICAgICAgICB0cmFja2VkUmVhY3Rpb24ucmVhY3Rpb24uZGlzcG9zZSgpO1xuICAgICAgICAgICAgY2xlYW51cFRva2VuVG9SZWFjdGlvblRyYWNraW5nTWFwLmRlbGV0ZSh0b2tlbik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRSZWFjdGlvblRvVHJhY2s6IGZ1bmN0aW9uIChyZWFjdGlvblRyYWNraW5nUmVmLCByZWFjdGlvbiwgb2JqZWN0UmV0YWluZWRCeVJlYWN0KSB7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSBnbG9iYWxDbGVhbnVwVG9rZW5zQ291bnRlcisrO1xuICAgICAgICAgICAgcmVnaXN0cnkucmVnaXN0ZXIob2JqZWN0UmV0YWluZWRCeVJlYWN0LCB0b2tlbiwgcmVhY3Rpb25UcmFja2luZ1JlZik7XG4gICAgICAgICAgICByZWFjdGlvblRyYWNraW5nUmVmLmN1cnJlbnQgPSBjcmVhdGVUcmFja2luZ0RhdGEocmVhY3Rpb24pO1xuICAgICAgICAgICAgcmVhY3Rpb25UcmFja2luZ1JlZi5jdXJyZW50LmZpbmFsaXphdGlvblJlZ2lzdHJ5Q2xlYW51cFRva2VuID0gdG9rZW47XG4gICAgICAgICAgICBjbGVhbnVwVG9rZW5Ub1JlYWN0aW9uVHJhY2tpbmdNYXAuc2V0KHRva2VuLCByZWFjdGlvblRyYWNraW5nUmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlYWN0aW9uVHJhY2tpbmdSZWYuY3VycmVudDtcbiAgICAgICAgfSxcbiAgICAgICAgcmVjb3JkUmVhY3Rpb25Bc0NvbW1pdHRlZDogZnVuY3Rpb24gKHJlYWN0aW9uUmVmKSB7XG4gICAgICAgICAgICByZWdpc3RyeS51bnJlZ2lzdGVyKHJlYWN0aW9uUmVmKTtcbiAgICAgICAgICAgIGlmIChyZWFjdGlvblJlZi5jdXJyZW50ICYmIHJlYWN0aW9uUmVmLmN1cnJlbnQuZmluYWxpemF0aW9uUmVnaXN0cnlDbGVhbnVwVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjbGVhbnVwVG9rZW5Ub1JlYWN0aW9uVHJhY2tpbmdNYXAuZGVsZXRlKHJlYWN0aW9uUmVmLmN1cnJlbnQuZmluYWxpemF0aW9uUmVnaXN0cnlDbGVhbnVwVG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmb3JjZUNsZWFudXBUaW1lclRvUnVuTm93Rm9yVGVzdHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gRmluYWxpemF0aW9uUmVnaXN0cnkgaW4gdXNlLCB0aGlzIHRoaXMgaXMgbm8tb3BcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXRDbGVhbnVwU2NoZWR1bGVGb3JUZXN0czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gV2hlbiBGaW5hbGl6YXRpb25SZWdpc3RyeSBpbiB1c2UsIHRoaXMgdGhpcyBpcyBuby1vcFxuICAgICAgICB9XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZVJlYWN0aW9uQ2xlYW51cFRyYWNraW5nVXNpbmdGaW5hbGl6YXRpb25SZWdpc3Rlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mobx-react-lite/es/utils/createReactionCleanupTrackingUsingFinalizationRegister.js\n"));

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/utils/createTimerBasedReactionCleanupTracking.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/utils/createTimerBasedReactionCleanupTracking.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createTimerBasedReactionCleanupTracking\": function() { return /* binding */ createTimerBasedReactionCleanupTracking; }\n/* harmony export */ });\n/* harmony import */ var _reactionCleanupTrackingCommon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reactionCleanupTrackingCommon */ \"./node_modules/mobx-react-lite/es/utils/reactionCleanupTrackingCommon.js\");\nvar __values = (undefined && undefined.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\n/**\n * timers, gc-style, uncommitted reaction cleanup\n */\nfunction createTimerBasedReactionCleanupTracking() {\n    /**\n     * Reactions created by components that have yet to be fully mounted.\n     */\n    var uncommittedReactionRefs = new Set();\n    /**\n     * Latest 'uncommitted reactions' cleanup timer handle.\n     */\n    var reactionCleanupHandle;\n    /* istanbul ignore next */\n    /**\n     * Only to be used by test functions; do not export outside of mobx-react-lite\n     */\n    function forceCleanupTimerToRunNowForTests() {\n        // This allows us to control the execution of the cleanup timer\n        // to force it to run at awkward times in unit tests.\n        if (reactionCleanupHandle) {\n            clearTimeout(reactionCleanupHandle);\n            cleanUncommittedReactions();\n        }\n    }\n    /* istanbul ignore next */\n    function resetCleanupScheduleForTests() {\n        var e_1, _a;\n        if (uncommittedReactionRefs.size > 0) {\n            try {\n                for (var uncommittedReactionRefs_1 = __values(uncommittedReactionRefs), uncommittedReactionRefs_1_1 = uncommittedReactionRefs_1.next(); !uncommittedReactionRefs_1_1.done; uncommittedReactionRefs_1_1 = uncommittedReactionRefs_1.next()) {\n                    var ref = uncommittedReactionRefs_1_1.value;\n                    var tracking = ref.current;\n                    if (tracking) {\n                        tracking.reaction.dispose();\n                        ref.current = null;\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (uncommittedReactionRefs_1_1 && !uncommittedReactionRefs_1_1.done && (_a = uncommittedReactionRefs_1.return)) _a.call(uncommittedReactionRefs_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            uncommittedReactionRefs.clear();\n        }\n        if (reactionCleanupHandle) {\n            clearTimeout(reactionCleanupHandle);\n            reactionCleanupHandle = undefined;\n        }\n    }\n    function ensureCleanupTimerRunning() {\n        if (reactionCleanupHandle === undefined) {\n            reactionCleanupHandle = setTimeout(cleanUncommittedReactions, _reactionCleanupTrackingCommon__WEBPACK_IMPORTED_MODULE_0__.CLEANUP_TIMER_LOOP_MILLIS);\n        }\n    }\n    function scheduleCleanupOfReactionIfLeaked(ref) {\n        uncommittedReactionRefs.add(ref);\n        ensureCleanupTimerRunning();\n    }\n    function recordReactionAsCommitted(reactionRef) {\n        uncommittedReactionRefs.delete(reactionRef);\n    }\n    /**\n     * Run by the cleanup timer to dispose any outstanding reactions\n     */\n    function cleanUncommittedReactions() {\n        reactionCleanupHandle = undefined;\n        // Loop through all the candidate leaked reactions; those older\n        // than CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS get tidied.\n        var now = Date.now();\n        uncommittedReactionRefs.forEach(function (ref) {\n            var tracking = ref.current;\n            if (tracking) {\n                if (now >= tracking.cleanAt) {\n                    // It's time to tidy up this leaked reaction.\n                    tracking.reaction.dispose();\n                    ref.current = null;\n                    uncommittedReactionRefs.delete(ref);\n                }\n            }\n        });\n        if (uncommittedReactionRefs.size > 0) {\n            // We've just finished a round of cleanups but there are still\n            // some leak candidates outstanding.\n            ensureCleanupTimerRunning();\n        }\n    }\n    return {\n        addReactionToTrack: function (reactionTrackingRef, reaction, \n        /**\n         * On timer based implementation we don't really need this object,\n         * but we keep the same api\n         */\n        objectRetainedByReact) {\n            reactionTrackingRef.current = (0,_reactionCleanupTrackingCommon__WEBPACK_IMPORTED_MODULE_0__.createTrackingData)(reaction);\n            scheduleCleanupOfReactionIfLeaked(reactionTrackingRef);\n            return reactionTrackingRef.current;\n        },\n        recordReactionAsCommitted: recordReactionAsCommitted,\n        forceCleanupTimerToRunNowForTests: forceCleanupTimerToRunNowForTests,\n        resetCleanupScheduleForTests: resetCleanupScheduleForTests\n    };\n}\n//# sourceMappingURL=createTimerBasedReactionCleanupTracking.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL3V0aWxzL2NyZWF0ZVRpbWVyQmFzZWRSZWFjdGlvbkNsZWFudXBUcmFja2luZy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLGdCQUFnQixTQUFJLElBQUksU0FBSTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ2dHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdKQUF3SixtQ0FBbUM7QUFDM0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLHFGQUF5QjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrRkFBa0I7QUFDNUQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21vYngtcmVhY3QtbGl0ZS9lcy91dGlscy9jcmVhdGVUaW1lckJhc2VkUmVhY3Rpb25DbGVhbnVwVHJhY2tpbmcuanM/ZGEzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5pbXBvcnQgeyBDTEVBTlVQX1RJTUVSX0xPT1BfTUlMTElTLCBjcmVhdGVUcmFja2luZ0RhdGEgfSBmcm9tIFwiLi9yZWFjdGlvbkNsZWFudXBUcmFja2luZ0NvbW1vblwiO1xuLyoqXG4gKiB0aW1lcnMsIGdjLXN0eWxlLCB1bmNvbW1pdHRlZCByZWFjdGlvbiBjbGVhbnVwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUaW1lckJhc2VkUmVhY3Rpb25DbGVhbnVwVHJhY2tpbmcoKSB7XG4gICAgLyoqXG4gICAgICogUmVhY3Rpb25zIGNyZWF0ZWQgYnkgY29tcG9uZW50cyB0aGF0IGhhdmUgeWV0IHRvIGJlIGZ1bGx5IG1vdW50ZWQuXG4gICAgICovXG4gICAgdmFyIHVuY29tbWl0dGVkUmVhY3Rpb25SZWZzID0gbmV3IFNldCgpO1xuICAgIC8qKlxuICAgICAqIExhdGVzdCAndW5jb21taXR0ZWQgcmVhY3Rpb25zJyBjbGVhbnVwIHRpbWVyIGhhbmRsZS5cbiAgICAgKi9cbiAgICB2YXIgcmVhY3Rpb25DbGVhbnVwSGFuZGxlO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgLyoqXG4gICAgICogT25seSB0byBiZSB1c2VkIGJ5IHRlc3QgZnVuY3Rpb25zOyBkbyBub3QgZXhwb3J0IG91dHNpZGUgb2YgbW9ieC1yZWFjdC1saXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yY2VDbGVhbnVwVGltZXJUb1J1bk5vd0ZvclRlc3RzKCkge1xuICAgICAgICAvLyBUaGlzIGFsbG93cyB1cyB0byBjb250cm9sIHRoZSBleGVjdXRpb24gb2YgdGhlIGNsZWFudXAgdGltZXJcbiAgICAgICAgLy8gdG8gZm9yY2UgaXQgdG8gcnVuIGF0IGF3a3dhcmQgdGltZXMgaW4gdW5pdCB0ZXN0cy5cbiAgICAgICAgaWYgKHJlYWN0aW9uQ2xlYW51cEhhbmRsZSkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHJlYWN0aW9uQ2xlYW51cEhhbmRsZSk7XG4gICAgICAgICAgICBjbGVhblVuY29tbWl0dGVkUmVhY3Rpb25zKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBmdW5jdGlvbiByZXNldENsZWFudXBTY2hlZHVsZUZvclRlc3RzKCkge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgaWYgKHVuY29tbWl0dGVkUmVhY3Rpb25SZWZzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHVuY29tbWl0dGVkUmVhY3Rpb25SZWZzXzEgPSBfX3ZhbHVlcyh1bmNvbW1pdHRlZFJlYWN0aW9uUmVmcyksIHVuY29tbWl0dGVkUmVhY3Rpb25SZWZzXzFfMSA9IHVuY29tbWl0dGVkUmVhY3Rpb25SZWZzXzEubmV4dCgpOyAhdW5jb21taXR0ZWRSZWFjdGlvblJlZnNfMV8xLmRvbmU7IHVuY29tbWl0dGVkUmVhY3Rpb25SZWZzXzFfMSA9IHVuY29tbWl0dGVkUmVhY3Rpb25SZWZzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWYgPSB1bmNvbW1pdHRlZFJlYWN0aW9uUmVmc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFja2luZyA9IHJlZi5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2tpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNraW5nLnJlYWN0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodW5jb21taXR0ZWRSZWFjdGlvblJlZnNfMV8xICYmICF1bmNvbW1pdHRlZFJlYWN0aW9uUmVmc18xXzEuZG9uZSAmJiAoX2EgPSB1bmNvbW1pdHRlZFJlYWN0aW9uUmVmc18xLnJldHVybikpIF9hLmNhbGwodW5jb21taXR0ZWRSZWFjdGlvblJlZnNfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVuY29tbWl0dGVkUmVhY3Rpb25SZWZzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlYWN0aW9uQ2xlYW51cEhhbmRsZSkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHJlYWN0aW9uQ2xlYW51cEhhbmRsZSk7XG4gICAgICAgICAgICByZWFjdGlvbkNsZWFudXBIYW5kbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZW5zdXJlQ2xlYW51cFRpbWVyUnVubmluZygpIHtcbiAgICAgICAgaWYgKHJlYWN0aW9uQ2xlYW51cEhhbmRsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZWFjdGlvbkNsZWFudXBIYW5kbGUgPSBzZXRUaW1lb3V0KGNsZWFuVW5jb21taXR0ZWRSZWFjdGlvbnMsIENMRUFOVVBfVElNRVJfTE9PUF9NSUxMSVMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlQ2xlYW51cE9mUmVhY3Rpb25JZkxlYWtlZChyZWYpIHtcbiAgICAgICAgdW5jb21taXR0ZWRSZWFjdGlvblJlZnMuYWRkKHJlZik7XG4gICAgICAgIGVuc3VyZUNsZWFudXBUaW1lclJ1bm5pbmcoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjb3JkUmVhY3Rpb25Bc0NvbW1pdHRlZChyZWFjdGlvblJlZikge1xuICAgICAgICB1bmNvbW1pdHRlZFJlYWN0aW9uUmVmcy5kZWxldGUocmVhY3Rpb25SZWYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW4gYnkgdGhlIGNsZWFudXAgdGltZXIgdG8gZGlzcG9zZSBhbnkgb3V0c3RhbmRpbmcgcmVhY3Rpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xlYW5VbmNvbW1pdHRlZFJlYWN0aW9ucygpIHtcbiAgICAgICAgcmVhY3Rpb25DbGVhbnVwSGFuZGxlID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBjYW5kaWRhdGUgbGVha2VkIHJlYWN0aW9uczsgdGhvc2Ugb2xkZXJcbiAgICAgICAgLy8gdGhhbiBDTEVBTlVQX0xFQUtFRF9SRUFDVElPTlNfQUZURVJfTUlMTElTIGdldCB0aWRpZWQuXG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB1bmNvbW1pdHRlZFJlYWN0aW9uUmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIHZhciB0cmFja2luZyA9IHJlZi5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKHRyYWNraW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vdyA+PSB0cmFja2luZy5jbGVhbkF0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEl0J3MgdGltZSB0byB0aWR5IHVwIHRoaXMgbGVha2VkIHJlYWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICB0cmFja2luZy5yZWFjdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdW5jb21taXR0ZWRSZWFjdGlvblJlZnMuZGVsZXRlKHJlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHVuY29tbWl0dGVkUmVhY3Rpb25SZWZzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAvLyBXZSd2ZSBqdXN0IGZpbmlzaGVkIGEgcm91bmQgb2YgY2xlYW51cHMgYnV0IHRoZXJlIGFyZSBzdGlsbFxuICAgICAgICAgICAgLy8gc29tZSBsZWFrIGNhbmRpZGF0ZXMgb3V0c3RhbmRpbmcuXG4gICAgICAgICAgICBlbnN1cmVDbGVhbnVwVGltZXJSdW5uaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkUmVhY3Rpb25Ub1RyYWNrOiBmdW5jdGlvbiAocmVhY3Rpb25UcmFja2luZ1JlZiwgcmVhY3Rpb24sIFxuICAgICAgICAvKipcbiAgICAgICAgICogT24gdGltZXIgYmFzZWQgaW1wbGVtZW50YXRpb24gd2UgZG9uJ3QgcmVhbGx5IG5lZWQgdGhpcyBvYmplY3QsXG4gICAgICAgICAqIGJ1dCB3ZSBrZWVwIHRoZSBzYW1lIGFwaVxuICAgICAgICAgKi9cbiAgICAgICAgb2JqZWN0UmV0YWluZWRCeVJlYWN0KSB7XG4gICAgICAgICAgICByZWFjdGlvblRyYWNraW5nUmVmLmN1cnJlbnQgPSBjcmVhdGVUcmFja2luZ0RhdGEocmVhY3Rpb24pO1xuICAgICAgICAgICAgc2NoZWR1bGVDbGVhbnVwT2ZSZWFjdGlvbklmTGVha2VkKHJlYWN0aW9uVHJhY2tpbmdSZWYpO1xuICAgICAgICAgICAgcmV0dXJuIHJlYWN0aW9uVHJhY2tpbmdSZWYuY3VycmVudDtcbiAgICAgICAgfSxcbiAgICAgICAgcmVjb3JkUmVhY3Rpb25Bc0NvbW1pdHRlZDogcmVjb3JkUmVhY3Rpb25Bc0NvbW1pdHRlZCxcbiAgICAgICAgZm9yY2VDbGVhbnVwVGltZXJUb1J1bk5vd0ZvclRlc3RzOiBmb3JjZUNsZWFudXBUaW1lclRvUnVuTm93Rm9yVGVzdHMsXG4gICAgICAgIHJlc2V0Q2xlYW51cFNjaGVkdWxlRm9yVGVzdHM6IHJlc2V0Q2xlYW51cFNjaGVkdWxlRm9yVGVzdHNcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlVGltZXJCYXNlZFJlYWN0aW9uQ2xlYW51cFRyYWNraW5nLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mobx-react-lite/es/utils/createTimerBasedReactionCleanupTracking.js\n"));

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/utils/observerBatching.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/utils/observerBatching.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaultNoopBatch\": function() { return /* binding */ defaultNoopBatch; },\n/* harmony export */   \"isObserverBatched\": function() { return /* binding */ isObserverBatched; },\n/* harmony export */   \"observerBatching\": function() { return /* binding */ observerBatching; }\n/* harmony export */ });\n/* harmony import */ var mobx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mobx */ \"./node_modules/mobx/dist/mobx.esm.js\");\n\nfunction defaultNoopBatch(callback) {\n    callback();\n}\nfunction observerBatching(reactionScheduler) {\n    if (!reactionScheduler) {\n        reactionScheduler = defaultNoopBatch;\n        if (true) {\n            console.warn(\"[MobX] Failed to get unstable_batched updates from react-dom / react-native\");\n        }\n    }\n    (0,mobx__WEBPACK_IMPORTED_MODULE_0__.configure)({ reactionScheduler: reactionScheduler });\n}\nvar isObserverBatched = function () {\n    if (true) {\n        console.warn(\"[MobX] Deprecated\");\n    }\n    return true;\n};\n//# sourceMappingURL=observerBatching.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL3V0aWxzL29ic2VydmVyQmF0Y2hpbmcuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpQztBQUMxQjtBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxZQUFZLElBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLElBQUksK0NBQVMsR0FBRyxzQ0FBc0M7QUFDdEQ7QUFDTztBQUNQLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL3V0aWxzL29ic2VydmVyQmF0Y2hpbmcuanM/ODI1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb25maWd1cmUgfSBmcm9tIFwibW9ieFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHROb29wQmF0Y2goY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG9ic2VydmVyQmF0Y2hpbmcocmVhY3Rpb25TY2hlZHVsZXIpIHtcbiAgICBpZiAoIXJlYWN0aW9uU2NoZWR1bGVyKSB7XG4gICAgICAgIHJlYWN0aW9uU2NoZWR1bGVyID0gZGVmYXVsdE5vb3BCYXRjaDtcbiAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW01vYlhdIEZhaWxlZCB0byBnZXQgdW5zdGFibGVfYmF0Y2hlZCB1cGRhdGVzIGZyb20gcmVhY3QtZG9tIC8gcmVhY3QtbmF0aXZlXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbmZpZ3VyZSh7IHJlYWN0aW9uU2NoZWR1bGVyOiByZWFjdGlvblNjaGVkdWxlciB9KTtcbn1cbmV4cG9ydCB2YXIgaXNPYnNlcnZlckJhdGNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbTW9iWF0gRGVwcmVjYXRlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JzZXJ2ZXJCYXRjaGluZy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mobx-react-lite/es/utils/observerBatching.js\n"));

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/utils/printDebugValue.js":
/*!******************************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/utils/printDebugValue.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"printDebugValue\": function() { return /* binding */ printDebugValue; }\n/* harmony export */ });\n/* harmony import */ var mobx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mobx */ \"./node_modules/mobx/dist/mobx.esm.js\");\n\nfunction printDebugValue(v) {\n    return (0,mobx__WEBPACK_IMPORTED_MODULE_0__.getDependencyTree)(v);\n}\n//# sourceMappingURL=printDebugValue.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL3V0aWxzL3ByaW50RGVidWdWYWx1ZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF5QztBQUNsQztBQUNQLFdBQVcsdURBQWlCO0FBQzVCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21vYngtcmVhY3QtbGl0ZS9lcy91dGlscy9wcmludERlYnVnVmFsdWUuanM/OGIxMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXREZXBlbmRlbmN5VHJlZSB9IGZyb20gXCJtb2J4XCI7XG5leHBvcnQgZnVuY3Rpb24gcHJpbnREZWJ1Z1ZhbHVlKHYpIHtcbiAgICByZXR1cm4gZ2V0RGVwZW5kZW5jeVRyZWUodik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmludERlYnVnVmFsdWUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mobx-react-lite/es/utils/printDebugValue.js\n"));

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/utils/reactBatchedUpdates.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/utils/reactBatchedUpdates.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"unstable_batchedUpdates\": function() { return /* reexport safe */ react_dom__WEBPACK_IMPORTED_MODULE_0__.unstable_batchedUpdates; }\n/* harmony export */ });\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_0__);\n\n//# sourceMappingURL=reactBatchedUpdates.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL3V0aWxzL3JlYWN0QmF0Y2hlZFVwZGF0ZXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW9EO0FBQ3BEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tb2J4LXJlYWN0LWxpdGUvZXMvdXRpbHMvcmVhY3RCYXRjaGVkVXBkYXRlcy5qcz80NWVlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIH0gZnJvbSBcInJlYWN0LWRvbVwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3RCYXRjaGVkVXBkYXRlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mobx-react-lite/es/utils/reactBatchedUpdates.js\n"));

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/utils/reactionCleanupTracking.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/utils/reactionCleanupTracking.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addReactionToTrack\": function() { return /* binding */ addReactionToTrack; },\n/* harmony export */   \"forceCleanupTimerToRunNowForTests\": function() { return /* binding */ forceCleanupTimerToRunNowForTests; },\n/* harmony export */   \"recordReactionAsCommitted\": function() { return /* binding */ recordReactionAsCommitted; },\n/* harmony export */   \"resetCleanupScheduleForTests\": function() { return /* binding */ resetCleanupScheduleForTests; }\n/* harmony export */ });\n/* harmony import */ var _FinalizationRegistryWrapper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FinalizationRegistryWrapper */ \"./node_modules/mobx-react-lite/es/utils/FinalizationRegistryWrapper.js\");\n/* harmony import */ var _createReactionCleanupTrackingUsingFinalizationRegister__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createReactionCleanupTrackingUsingFinalizationRegister */ \"./node_modules/mobx-react-lite/es/utils/createReactionCleanupTrackingUsingFinalizationRegister.js\");\n/* harmony import */ var _createTimerBasedReactionCleanupTracking__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createTimerBasedReactionCleanupTracking */ \"./node_modules/mobx-react-lite/es/utils/createTimerBasedReactionCleanupTracking.js\");\n\n\n\nvar _a = _FinalizationRegistryWrapper__WEBPACK_IMPORTED_MODULE_0__.FinalizationRegistry\n    ? (0,_createReactionCleanupTrackingUsingFinalizationRegister__WEBPACK_IMPORTED_MODULE_1__.createReactionCleanupTrackingUsingFinalizationRegister)(_FinalizationRegistryWrapper__WEBPACK_IMPORTED_MODULE_0__.FinalizationRegistry)\n    : (0,_createTimerBasedReactionCleanupTracking__WEBPACK_IMPORTED_MODULE_2__.createTimerBasedReactionCleanupTracking)(), addReactionToTrack = _a.addReactionToTrack, recordReactionAsCommitted = _a.recordReactionAsCommitted, resetCleanupScheduleForTests = _a.resetCleanupScheduleForTests, forceCleanupTimerToRunNowForTests = _a.forceCleanupTimerToRunNowForTests;\n\n//# sourceMappingURL=reactionCleanupTracking.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL3V0aWxzL3JlYWN0aW9uQ2xlYW51cFRyYWNraW5nLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBMkc7QUFDdUI7QUFDOUI7QUFDcEcsU0FBUyw4RUFBa0M7QUFDM0MsTUFBTSwrSUFBc0QsQ0FBQyw4RUFBa0M7QUFDL0YsTUFBTSxpSEFBdUM7QUFDNkU7QUFDMUgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21vYngtcmVhY3QtbGl0ZS9lcy91dGlscy9yZWFjdGlvbkNsZWFudXBUcmFja2luZy5qcz8xOWU2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEZpbmFsaXphdGlvblJlZ2lzdHJ5IGFzIEZpbmFsaXphdGlvblJlZ2lzdHJ5TWF5YmVVbmRlZmluZWQgfSBmcm9tIFwiLi9GaW5hbGl6YXRpb25SZWdpc3RyeVdyYXBwZXJcIjtcbmltcG9ydCB7IGNyZWF0ZVJlYWN0aW9uQ2xlYW51cFRyYWNraW5nVXNpbmdGaW5hbGl6YXRpb25SZWdpc3RlciB9IGZyb20gXCIuL2NyZWF0ZVJlYWN0aW9uQ2xlYW51cFRyYWNraW5nVXNpbmdGaW5hbGl6YXRpb25SZWdpc3RlclwiO1xuaW1wb3J0IHsgY3JlYXRlVGltZXJCYXNlZFJlYWN0aW9uQ2xlYW51cFRyYWNraW5nIH0gZnJvbSBcIi4vY3JlYXRlVGltZXJCYXNlZFJlYWN0aW9uQ2xlYW51cFRyYWNraW5nXCI7XG52YXIgX2EgPSBGaW5hbGl6YXRpb25SZWdpc3RyeU1heWJlVW5kZWZpbmVkXG4gICAgPyBjcmVhdGVSZWFjdGlvbkNsZWFudXBUcmFja2luZ1VzaW5nRmluYWxpemF0aW9uUmVnaXN0ZXIoRmluYWxpemF0aW9uUmVnaXN0cnlNYXliZVVuZGVmaW5lZClcbiAgICA6IGNyZWF0ZVRpbWVyQmFzZWRSZWFjdGlvbkNsZWFudXBUcmFja2luZygpLCBhZGRSZWFjdGlvblRvVHJhY2sgPSBfYS5hZGRSZWFjdGlvblRvVHJhY2ssIHJlY29yZFJlYWN0aW9uQXNDb21taXR0ZWQgPSBfYS5yZWNvcmRSZWFjdGlvbkFzQ29tbWl0dGVkLCByZXNldENsZWFudXBTY2hlZHVsZUZvclRlc3RzID0gX2EucmVzZXRDbGVhbnVwU2NoZWR1bGVGb3JUZXN0cywgZm9yY2VDbGVhbnVwVGltZXJUb1J1bk5vd0ZvclRlc3RzID0gX2EuZm9yY2VDbGVhbnVwVGltZXJUb1J1bk5vd0ZvclRlc3RzO1xuZXhwb3J0IHsgYWRkUmVhY3Rpb25Ub1RyYWNrLCByZWNvcmRSZWFjdGlvbkFzQ29tbWl0dGVkLCByZXNldENsZWFudXBTY2hlZHVsZUZvclRlc3RzLCBmb3JjZUNsZWFudXBUaW1lclRvUnVuTm93Rm9yVGVzdHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0aW9uQ2xlYW51cFRyYWNraW5nLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mobx-react-lite/es/utils/reactionCleanupTracking.js\n"));

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/utils/reactionCleanupTrackingCommon.js":
/*!********************************************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/utils/reactionCleanupTrackingCommon.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS\": function() { return /* binding */ CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS; },\n/* harmony export */   \"CLEANUP_TIMER_LOOP_MILLIS\": function() { return /* binding */ CLEANUP_TIMER_LOOP_MILLIS; },\n/* harmony export */   \"createTrackingData\": function() { return /* binding */ createTrackingData; }\n/* harmony export */ });\nfunction createTrackingData(reaction) {\n    var trackingData = {\n        reaction: reaction,\n        mounted: false,\n        changedBeforeMount: false,\n        cleanAt: Date.now() + CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS\n    };\n    return trackingData;\n}\n/**\n * The minimum time before we'll clean up a Reaction created in a render\n * for a component that hasn't managed to run its effects. This needs to\n * be big enough to ensure that a component won't turn up and have its\n * effects run without being re-rendered.\n */\nvar CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS = 10000;\n/**\n * The frequency with which we'll check for leaked reactions.\n */\nvar CLEANUP_TIMER_LOOP_MILLIS = 10000;\n//# sourceMappingURL=reactionCleanupTrackingCommon.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL3V0aWxzL3JlYWN0aW9uQ2xlYW51cFRyYWNraW5nQ29tbW9uLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL3V0aWxzL3JlYWN0aW9uQ2xlYW51cFRyYWNraW5nQ29tbW9uLmpzP2JjMWMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRyYWNraW5nRGF0YShyZWFjdGlvbikge1xuICAgIHZhciB0cmFja2luZ0RhdGEgPSB7XG4gICAgICAgIHJlYWN0aW9uOiByZWFjdGlvbixcbiAgICAgICAgbW91bnRlZDogZmFsc2UsXG4gICAgICAgIGNoYW5nZWRCZWZvcmVNb3VudDogZmFsc2UsXG4gICAgICAgIGNsZWFuQXQ6IERhdGUubm93KCkgKyBDTEVBTlVQX0xFQUtFRF9SRUFDVElPTlNfQUZURVJfTUlMTElTXG4gICAgfTtcbiAgICByZXR1cm4gdHJhY2tpbmdEYXRhO1xufVxuLyoqXG4gKiBUaGUgbWluaW11bSB0aW1lIGJlZm9yZSB3ZSdsbCBjbGVhbiB1cCBhIFJlYWN0aW9uIGNyZWF0ZWQgaW4gYSByZW5kZXJcbiAqIGZvciBhIGNvbXBvbmVudCB0aGF0IGhhc24ndCBtYW5hZ2VkIHRvIHJ1biBpdHMgZWZmZWN0cy4gVGhpcyBuZWVkcyB0b1xuICogYmUgYmlnIGVub3VnaCB0byBlbnN1cmUgdGhhdCBhIGNvbXBvbmVudCB3b24ndCB0dXJuIHVwIGFuZCBoYXZlIGl0c1xuICogZWZmZWN0cyBydW4gd2l0aG91dCBiZWluZyByZS1yZW5kZXJlZC5cbiAqL1xuZXhwb3J0IHZhciBDTEVBTlVQX0xFQUtFRF9SRUFDVElPTlNfQUZURVJfTUlMTElTID0gMTAwMDA7XG4vKipcbiAqIFRoZSBmcmVxdWVuY3kgd2l0aCB3aGljaCB3ZSdsbCBjaGVjayBmb3IgbGVha2VkIHJlYWN0aW9ucy5cbiAqL1xuZXhwb3J0IHZhciBDTEVBTlVQX1RJTUVSX0xPT1BfTUlMTElTID0gMTAwMDA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdGlvbkNsZWFudXBUcmFja2luZ0NvbW1vbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mobx-react-lite/es/utils/reactionCleanupTrackingCommon.js\n"));

/***/ }),

/***/ "./node_modules/mobx-react-lite/es/utils/utils.js":
/*!********************************************************!*\
  !*** ./node_modules/mobx-react-lite/es/utils/utils.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useDeprecated\": function() { return /* binding */ useDeprecated; }\n/* harmony export */ });\nvar deprecatedMessages = [];\nfunction useDeprecated(msg) {\n    if (!deprecatedMessages.includes(msg)) {\n        deprecatedMessages.push(msg);\n        console.warn(msg);\n    }\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2VzL3V0aWxzL3V0aWxzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tb2J4LXJlYWN0LWxpdGUvZXMvdXRpbHMvdXRpbHMuanM/MzkyMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZGVwcmVjYXRlZE1lc3NhZ2VzID0gW107XG5leHBvcnQgZnVuY3Rpb24gdXNlRGVwcmVjYXRlZChtc2cpIHtcbiAgICBpZiAoIWRlcHJlY2F0ZWRNZXNzYWdlcy5pbmNsdWRlcyhtc2cpKSB7XG4gICAgICAgIGRlcHJlY2F0ZWRNZXNzYWdlcy5wdXNoKG1zZyk7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mobx-react-lite/es/utils/utils.js\n"));

/***/ }),

/***/ "./node_modules/mobx/dist/mobx.esm.js":
/*!********************************************!*\
  !*** ./node_modules/mobx/dist/mobx.esm.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$mobx\": function() { return /* binding */ $mobx; },\n/* harmony export */   \"FlowCancellationError\": function() { return /* binding */ FlowCancellationError; },\n/* harmony export */   \"ObservableMap\": function() { return /* binding */ ObservableMap; },\n/* harmony export */   \"ObservableSet\": function() { return /* binding */ ObservableSet; },\n/* harmony export */   \"Reaction\": function() { return /* binding */ Reaction; },\n/* harmony export */   \"_allowStateChanges\": function() { return /* binding */ allowStateChanges; },\n/* harmony export */   \"_allowStateChangesInsideComputed\": function() { return /* binding */ runInAction; },\n/* harmony export */   \"_allowStateReadsEnd\": function() { return /* binding */ allowStateReadsEnd; },\n/* harmony export */   \"_allowStateReadsStart\": function() { return /* binding */ allowStateReadsStart; },\n/* harmony export */   \"_autoAction\": function() { return /* binding */ autoAction; },\n/* harmony export */   \"_endAction\": function() { return /* binding */ _endAction; },\n/* harmony export */   \"_getAdministration\": function() { return /* binding */ getAdministration; },\n/* harmony export */   \"_getGlobalState\": function() { return /* binding */ getGlobalState; },\n/* harmony export */   \"_interceptReads\": function() { return /* binding */ interceptReads; },\n/* harmony export */   \"_isComputingDerivation\": function() { return /* binding */ isComputingDerivation; },\n/* harmony export */   \"_resetGlobalState\": function() { return /* binding */ resetGlobalState; },\n/* harmony export */   \"_startAction\": function() { return /* binding */ _startAction; },\n/* harmony export */   \"action\": function() { return /* binding */ action; },\n/* harmony export */   \"autorun\": function() { return /* binding */ autorun; },\n/* harmony export */   \"comparer\": function() { return /* binding */ comparer; },\n/* harmony export */   \"computed\": function() { return /* binding */ computed; },\n/* harmony export */   \"configure\": function() { return /* binding */ configure; },\n/* harmony export */   \"createAtom\": function() { return /* binding */ createAtom; },\n/* harmony export */   \"defineProperty\": function() { return /* binding */ apiDefineProperty; },\n/* harmony export */   \"entries\": function() { return /* binding */ entries; },\n/* harmony export */   \"extendObservable\": function() { return /* binding */ extendObservable; },\n/* harmony export */   \"flow\": function() { return /* binding */ flow; },\n/* harmony export */   \"flowResult\": function() { return /* binding */ flowResult; },\n/* harmony export */   \"get\": function() { return /* binding */ get; },\n/* harmony export */   \"getAtom\": function() { return /* binding */ getAtom; },\n/* harmony export */   \"getDebugName\": function() { return /* binding */ getDebugName; },\n/* harmony export */   \"getDependencyTree\": function() { return /* binding */ getDependencyTree; },\n/* harmony export */   \"getObserverTree\": function() { return /* binding */ getObserverTree; },\n/* harmony export */   \"has\": function() { return /* binding */ has; },\n/* harmony export */   \"intercept\": function() { return /* binding */ intercept; },\n/* harmony export */   \"isAction\": function() { return /* binding */ isAction; },\n/* harmony export */   \"isBoxedObservable\": function() { return /* binding */ isObservableValue; },\n/* harmony export */   \"isComputed\": function() { return /* binding */ isComputed; },\n/* harmony export */   \"isComputedProp\": function() { return /* binding */ isComputedProp; },\n/* harmony export */   \"isFlow\": function() { return /* binding */ isFlow; },\n/* harmony export */   \"isFlowCancellationError\": function() { return /* binding */ isFlowCancellationError; },\n/* harmony export */   \"isObservable\": function() { return /* binding */ isObservable; },\n/* harmony export */   \"isObservableArray\": function() { return /* binding */ isObservableArray; },\n/* harmony export */   \"isObservableMap\": function() { return /* binding */ isObservableMap; },\n/* harmony export */   \"isObservableObject\": function() { return /* binding */ isObservableObject; },\n/* harmony export */   \"isObservableProp\": function() { return /* binding */ isObservableProp; },\n/* harmony export */   \"isObservableSet\": function() { return /* binding */ isObservableSet; },\n/* harmony export */   \"keys\": function() { return /* binding */ keys; },\n/* harmony export */   \"makeAutoObservable\": function() { return /* binding */ makeAutoObservable; },\n/* harmony export */   \"makeObservable\": function() { return /* binding */ makeObservable; },\n/* harmony export */   \"observable\": function() { return /* binding */ observable; },\n/* harmony export */   \"observe\": function() { return /* binding */ observe; },\n/* harmony export */   \"onBecomeObserved\": function() { return /* binding */ onBecomeObserved; },\n/* harmony export */   \"onBecomeUnobserved\": function() { return /* binding */ onBecomeUnobserved; },\n/* harmony export */   \"onReactionError\": function() { return /* binding */ onReactionError; },\n/* harmony export */   \"override\": function() { return /* binding */ override; },\n/* harmony export */   \"ownKeys\": function() { return /* binding */ apiOwnKeys; },\n/* harmony export */   \"reaction\": function() { return /* binding */ reaction; },\n/* harmony export */   \"remove\": function() { return /* binding */ remove; },\n/* harmony export */   \"runInAction\": function() { return /* binding */ runInAction; },\n/* harmony export */   \"set\": function() { return /* binding */ set; },\n/* harmony export */   \"spy\": function() { return /* binding */ spy; },\n/* harmony export */   \"toJS\": function() { return /* binding */ toJS; },\n/* harmony export */   \"trace\": function() { return /* binding */ trace; },\n/* harmony export */   \"transaction\": function() { return /* binding */ transaction; },\n/* harmony export */   \"untracked\": function() { return /* binding */ untracked; },\n/* harmony export */   \"values\": function() { return /* binding */ values; },\n/* harmony export */   \"when\": function() { return /* binding */ when; }\n/* harmony export */ });\nvar niceErrors = {\n  0: \"Invalid value for configuration 'enforceActions', expected 'never', 'always' or 'observed'\",\n  1: function _(annotationType, key) {\n    return \"Cannot apply '\" + annotationType + \"' to '\" + key.toString() + \"': Field not found.\";\n  },\n\n  /*\r\n  2(prop) {\r\n      return `invalid decorator for '${prop.toString()}'`\r\n  },\r\n  3(prop) {\r\n      return `Cannot decorate '${prop.toString()}': action can only be used on properties with a function value.`\r\n  },\r\n  4(prop) {\r\n      return `Cannot decorate '${prop.toString()}': computed can only be used on getter properties.`\r\n  },\r\n  */\n  5: \"'keys()' can only be used on observable objects, arrays, sets and maps\",\n  6: \"'values()' can only be used on observable objects, arrays, sets and maps\",\n  7: \"'entries()' can only be used on observable objects, arrays and maps\",\n  8: \"'set()' can only be used on observable objects, arrays and maps\",\n  9: \"'remove()' can only be used on observable objects, arrays and maps\",\n  10: \"'has()' can only be used on observable objects, arrays and maps\",\n  11: \"'get()' can only be used on observable objects, arrays and maps\",\n  12: \"Invalid annotation\",\n  13: \"Dynamic observable objects cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)\",\n  14: \"Intercept handlers should return nothing or a change object\",\n  15: \"Observable arrays cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)\",\n  16: \"Modification exception: the internal structure of an observable array was changed.\",\n  17: function _(index, length) {\n    return \"[mobx.array] Index out of bounds, \" + index + \" is larger than \" + length;\n  },\n  18: \"mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js\",\n  19: function _(other) {\n    return \"Cannot initialize from classes that inherit from Map: \" + other.constructor.name;\n  },\n  20: function _(other) {\n    return \"Cannot initialize map from \" + other;\n  },\n  21: function _(dataStructure) {\n    return \"Cannot convert to map from '\" + dataStructure + \"'\";\n  },\n  22: \"mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js\",\n  23: \"It is not possible to get index atoms from arrays\",\n  24: function _(thing) {\n    return \"Cannot obtain administration from \" + thing;\n  },\n  25: function _(property, name) {\n    return \"the entry '\" + property + \"' does not exist in the observable map '\" + name + \"'\";\n  },\n  26: \"please specify a property\",\n  27: function _(property, name) {\n    return \"no observable property '\" + property.toString() + \"' found on the observable object '\" + name + \"'\";\n  },\n  28: function _(thing) {\n    return \"Cannot obtain atom from \" + thing;\n  },\n  29: \"Expecting some object\",\n  30: \"invalid action stack. did you forget to finish an action?\",\n  31: \"missing option for computed: get\",\n  32: function _(name, derivation) {\n    return \"Cycle detected in computation \" + name + \": \" + derivation;\n  },\n  33: function _(name) {\n    return \"The setter of computed value '\" + name + \"' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?\";\n  },\n  34: function _(name) {\n    return \"[ComputedValue '\" + name + \"'] It is not possible to assign a new value to a computed value.\";\n  },\n  35: \"There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`\",\n  36: \"isolateGlobalState should be called before MobX is running any reactions\",\n  37: function _(method) {\n    return \"[mobx] `observableArray.\" + method + \"()` mutates the array in-place, which is not allowed inside a derivation. Use `array.slice().\" + method + \"()` instead\";\n  },\n  38: \"'ownKeys()' can only be used on observable objects\",\n  39: \"'defineProperty()' can only be used on observable objects\"\n};\nvar errors =  true ? niceErrors : 0;\nfunction die(error) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  if (true) {\n    var e = typeof error === \"string\" ? error : errors[error];\n    if (typeof e === \"function\") e = e.apply(null, args);\n    throw new Error(\"[MobX] \" + e);\n  }\n\n  throw new Error(typeof error === \"number\" ? \"[MobX] minified error nr: \" + error + (args.length ? \" \" + args.map(String).join(\",\") : \"\") + \". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts\" : \"[MobX] \" + error);\n}\n\nvar mockGlobal = {};\nfunction getGlobal() {\n  if (typeof globalThis !== \"undefined\") {\n    return globalThis;\n  }\n\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n\n  if (typeof __webpack_require__.g !== \"undefined\") {\n    return __webpack_require__.g;\n  }\n\n  if (typeof self !== \"undefined\") {\n    return self;\n  }\n\n  return mockGlobal;\n}\n\nvar assign = Object.assign;\nvar getDescriptor = Object.getOwnPropertyDescriptor;\nvar defineProperty = Object.defineProperty;\nvar objectPrototype = Object.prototype;\nvar EMPTY_ARRAY = [];\nObject.freeze(EMPTY_ARRAY);\nvar EMPTY_OBJECT = {};\nObject.freeze(EMPTY_OBJECT);\nvar hasProxy = typeof Proxy !== \"undefined\";\nvar plainObjectString = /*#__PURE__*/Object.toString();\nfunction assertProxies() {\n  if (!hasProxy) {\n    die( true ? \"`Proxy` objects are not available in the current environment. Please configure MobX to enable a fallback implementation.`\" : 0);\n  }\n}\nfunction warnAboutProxyRequirement(msg) {\n  if ( true && globalState.verifyProxies) {\n    die(\"MobX is currently configured to be able to run in ES5 mode, but in ES5 MobX won't be able to \" + msg);\n  }\n}\nfunction getNextId() {\n  return ++globalState.mobxGuid;\n}\n/**\r\n * Makes sure that the provided function is invoked at most once.\r\n */\n\nfunction once(func) {\n  var invoked = false;\n  return function () {\n    if (invoked) {\n      return;\n    }\n\n    invoked = true;\n    return func.apply(this, arguments);\n  };\n}\nvar noop = function noop() {};\nfunction isFunction(fn) {\n  return typeof fn === \"function\";\n}\nfunction isStringish(value) {\n  var t = typeof value;\n\n  switch (t) {\n    case \"string\":\n    case \"symbol\":\n    case \"number\":\n      return true;\n  }\n\n  return false;\n}\nfunction isObject(value) {\n  return value !== null && typeof value === \"object\";\n}\nfunction isPlainObject(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n\n  var proto = Object.getPrototypeOf(value);\n\n  if (proto == null) {\n    return true;\n  }\n\n  var protoConstructor = Object.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n  return typeof protoConstructor === \"function\" && protoConstructor.toString() === plainObjectString;\n} // https://stackoverflow.com/a/37865170\n\nfunction isGenerator(obj) {\n  var constructor = obj == null ? void 0 : obj.constructor;\n\n  if (!constructor) {\n    return false;\n  }\n\n  if (\"GeneratorFunction\" === constructor.name || \"GeneratorFunction\" === constructor.displayName) {\n    return true;\n  }\n\n  return false;\n}\nfunction addHiddenProp(object, propName, value) {\n  defineProperty(object, propName, {\n    enumerable: false,\n    writable: true,\n    configurable: true,\n    value: value\n  });\n}\nfunction addHiddenFinalProp(object, propName, value) {\n  defineProperty(object, propName, {\n    enumerable: false,\n    writable: false,\n    configurable: true,\n    value: value\n  });\n}\nfunction createInstanceofPredicate(name, theClass) {\n  var propName = \"isMobX\" + name;\n  theClass.prototype[propName] = true;\n  return function (x) {\n    return isObject(x) && x[propName] === true;\n  };\n}\nfunction isES6Map(thing) {\n  return thing instanceof Map;\n}\nfunction isES6Set(thing) {\n  return thing instanceof Set;\n}\nvar hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols !== \"undefined\";\n/**\r\n * Returns the following: own enumerable keys and symbols.\r\n */\n\nfunction getPlainObjectKeys(object) {\n  var keys = Object.keys(object); // Not supported in IE, so there are not going to be symbol props anyway...\n\n  if (!hasGetOwnPropertySymbols) {\n    return keys;\n  }\n\n  var symbols = Object.getOwnPropertySymbols(object);\n\n  if (!symbols.length) {\n    return keys;\n  }\n\n  return [].concat(keys, symbols.filter(function (s) {\n    return objectPrototype.propertyIsEnumerable.call(object, s);\n  }));\n} // From Immer utils\n// Returns all own keys, including non-enumerable and symbolic\n\nvar ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function (obj) {\n  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));\n} :\n/* istanbul ignore next */\nObject.getOwnPropertyNames;\nfunction stringifyKey(key) {\n  if (typeof key === \"string\") {\n    return key;\n  }\n\n  if (typeof key === \"symbol\") {\n    return key.toString();\n  }\n\n  return new String(key).toString();\n}\nfunction toPrimitive(value) {\n  return value === null ? null : typeof value === \"object\" ? \"\" + value : value;\n}\nfunction hasProp(target, prop) {\n  return objectPrototype.hasOwnProperty.call(target, prop);\n} // From Immer utils\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(target) {\n  // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n  var res = {}; // Note: without polyfill for ownKeys, symbols won't be picked up\n\n  ownKeys(target).forEach(function (key) {\n    res[key] = getDescriptor(target, key);\n  });\n  return res;\n};\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar storedAnnotationsSymbol = /*#__PURE__*/Symbol(\"mobx-stored-annotations\");\n/**\r\n * Creates a function that acts as\r\n * - decorator\r\n * - annotation object\r\n */\n\nfunction createDecoratorAnnotation(annotation) {\n  function decorator(target, property) {\n    storeAnnotation(target, property, annotation);\n  }\n\n  return Object.assign(decorator, annotation);\n}\n/**\r\n * Stores annotation to prototype,\r\n * so it can be inspected later by `makeObservable` called from constructor\r\n */\n\nfunction storeAnnotation(prototype, key, annotation) {\n  if (!hasProp(prototype, storedAnnotationsSymbol)) {\n    addHiddenProp(prototype, storedAnnotationsSymbol, _extends({}, prototype[storedAnnotationsSymbol]));\n  } // @override must override something\n\n\n  if ( true && isOverride(annotation) && !hasProp(prototype[storedAnnotationsSymbol], key)) {\n    var fieldName = prototype.constructor.name + \".prototype.\" + key.toString();\n    die(\"'\" + fieldName + \"' is decorated with 'override', \" + \"but no such decorated member was found on prototype.\");\n  } // Cannot re-decorate\n\n\n  assertNotDecorated(prototype, annotation, key); // Ignore override\n\n  if (!isOverride(annotation)) {\n    prototype[storedAnnotationsSymbol][key] = annotation;\n  }\n}\n\nfunction assertNotDecorated(prototype, annotation, key) {\n  if ( true && !isOverride(annotation) && hasProp(prototype[storedAnnotationsSymbol], key)) {\n    var fieldName = prototype.constructor.name + \".prototype.\" + key.toString();\n    var currentAnnotationType = prototype[storedAnnotationsSymbol][key].annotationType_;\n    var requestedAnnotationType = annotation.annotationType_;\n    die(\"Cannot apply '@\" + requestedAnnotationType + \"' to '\" + fieldName + \"':\" + (\"\\nThe field is already decorated with '@\" + currentAnnotationType + \"'.\") + \"\\nRe-decorating fields is not allowed.\" + \"\\nUse '@override' decorator for methods overridden by subclass.\");\n  }\n}\n/**\r\n * Collects annotations from prototypes and stores them on target (instance)\r\n */\n\n\nfunction collectStoredAnnotations(target) {\n  if (!hasProp(target, storedAnnotationsSymbol)) {\n    if ( true && !target[storedAnnotationsSymbol]) {\n      die(\"No annotations were passed to makeObservable, but no decorated members have been found either\");\n    } // We need a copy as we will remove annotation from the list once it's applied.\n\n\n    addHiddenProp(target, storedAnnotationsSymbol, _extends({}, target[storedAnnotationsSymbol]));\n  }\n\n  return target[storedAnnotationsSymbol];\n}\n\nvar $mobx = /*#__PURE__*/Symbol(\"mobx administration\");\nvar Atom = /*#__PURE__*/function () {\n  // for effective unobserving. BaseAtom has true, for extra optimization, so its onBecomeUnobserved never gets called, because it's not needed\n\n  /**\r\n   * Create a new atom. For debugging purposes it is recommended to give it a name.\r\n   * The onBecomeObserved and onBecomeUnobserved callbacks can be used for resource management.\r\n   */\n  function Atom(name_) {\n    if (name_ === void 0) {\n      name_ =  true ? \"Atom@\" + getNextId() : 0;\n    }\n\n    this.name_ = void 0;\n    this.isPendingUnobservation_ = false;\n    this.isBeingObserved_ = false;\n    this.observers_ = new Set();\n    this.diffValue_ = 0;\n    this.lastAccessedBy_ = 0;\n    this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_;\n    this.onBOL = void 0;\n    this.onBUOL = void 0;\n    this.name_ = name_;\n  } // onBecomeObservedListeners\n\n\n  var _proto = Atom.prototype;\n\n  _proto.onBO = function onBO() {\n    if (this.onBOL) {\n      this.onBOL.forEach(function (listener) {\n        return listener();\n      });\n    }\n  };\n\n  _proto.onBUO = function onBUO() {\n    if (this.onBUOL) {\n      this.onBUOL.forEach(function (listener) {\n        return listener();\n      });\n    }\n  }\n  /**\r\n   * Invoke this method to notify mobx that your atom has been used somehow.\r\n   * Returns true if there is currently a reactive context.\r\n   */\n  ;\n\n  _proto.reportObserved = function reportObserved$1() {\n    return reportObserved(this);\n  }\n  /**\r\n   * Invoke this method _after_ this method has changed to signal mobx that all its observers should invalidate.\r\n   */\n  ;\n\n  _proto.reportChanged = function reportChanged() {\n    startBatch();\n    propagateChanged(this);\n    endBatch();\n  };\n\n  _proto.toString = function toString() {\n    return this.name_;\n  };\n\n  return Atom;\n}();\nvar isAtom = /*#__PURE__*/createInstanceofPredicate(\"Atom\", Atom);\nfunction createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {\n  if (onBecomeObservedHandler === void 0) {\n    onBecomeObservedHandler = noop;\n  }\n\n  if (onBecomeUnobservedHandler === void 0) {\n    onBecomeUnobservedHandler = noop;\n  }\n\n  var atom = new Atom(name); // default `noop` listener will not initialize the hook Set\n\n  if (onBecomeObservedHandler !== noop) {\n    onBecomeObserved(atom, onBecomeObservedHandler);\n  }\n\n  if (onBecomeUnobservedHandler !== noop) {\n    onBecomeUnobserved(atom, onBecomeUnobservedHandler);\n  }\n\n  return atom;\n}\n\nfunction identityComparer(a, b) {\n  return a === b;\n}\n\nfunction structuralComparer(a, b) {\n  return deepEqual(a, b);\n}\n\nfunction shallowComparer(a, b) {\n  return deepEqual(a, b, 1);\n}\n\nfunction defaultComparer(a, b) {\n  if (Object.is) {\n    return Object.is(a, b);\n  }\n\n  return a === b ? a !== 0 || 1 / a === 1 / b : a !== a && b !== b;\n}\n\nvar comparer = {\n  identity: identityComparer,\n  structural: structuralComparer,\n  \"default\": defaultComparer,\n  shallow: shallowComparer\n};\n\nfunction deepEnhancer(v, _, name) {\n  // it is an observable already, done\n  if (isObservable(v)) {\n    return v;\n  } // something that can be converted and mutated?\n\n\n  if (Array.isArray(v)) {\n    return observable.array(v, {\n      name: name\n    });\n  }\n\n  if (isPlainObject(v)) {\n    return observable.object(v, undefined, {\n      name: name\n    });\n  }\n\n  if (isES6Map(v)) {\n    return observable.map(v, {\n      name: name\n    });\n  }\n\n  if (isES6Set(v)) {\n    return observable.set(v, {\n      name: name\n    });\n  }\n\n  if (typeof v === \"function\" && !isAction(v) && !isFlow(v)) {\n    if (isGenerator(v)) {\n      return flow(v);\n    } else {\n      return autoAction(name, v);\n    }\n  }\n\n  return v;\n}\nfunction shallowEnhancer(v, _, name) {\n  if (v === undefined || v === null) {\n    return v;\n  }\n\n  if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v) || isObservableSet(v)) {\n    return v;\n  }\n\n  if (Array.isArray(v)) {\n    return observable.array(v, {\n      name: name,\n      deep: false\n    });\n  }\n\n  if (isPlainObject(v)) {\n    return observable.object(v, undefined, {\n      name: name,\n      deep: false\n    });\n  }\n\n  if (isES6Map(v)) {\n    return observable.map(v, {\n      name: name,\n      deep: false\n    });\n  }\n\n  if (isES6Set(v)) {\n    return observable.set(v, {\n      name: name,\n      deep: false\n    });\n  }\n\n  if (true) {\n    die(\"The shallow modifier / decorator can only used in combination with arrays, objects, maps and sets\");\n  }\n}\nfunction referenceEnhancer(newValue) {\n  // never turn into an observable\n  return newValue;\n}\nfunction refStructEnhancer(v, oldValue) {\n  if ( true && isObservable(v)) {\n    die(\"observable.struct should not be used with observable values\");\n  }\n\n  if (deepEqual(v, oldValue)) {\n    return oldValue;\n  }\n\n  return v;\n}\n\nvar OVERRIDE = \"override\";\nvar override = /*#__PURE__*/createDecoratorAnnotation({\n  annotationType_: OVERRIDE,\n  make_: make_,\n  extend_: extend_\n});\nfunction isOverride(annotation) {\n  return annotation.annotationType_ === OVERRIDE;\n}\n\nfunction make_(adm, key) {\n  // Must not be plain object\n  if ( true && adm.isPlainObject_) {\n    die(\"Cannot apply '\" + this.annotationType_ + \"' to '\" + adm.name_ + \".\" + key.toString() + \"':\" + (\"\\n'\" + this.annotationType_ + \"' cannot be used on plain objects.\"));\n  } // Must override something\n\n\n  if ( true && !hasProp(adm.appliedAnnotations_, key)) {\n    die(\"'\" + adm.name_ + \".\" + key.toString() + \"' is annotated with '\" + this.annotationType_ + \"', \" + \"but no such annotated member was found on prototype.\");\n  }\n\n  return 0\n  /* Cancel */\n  ;\n}\n\nfunction extend_(adm, key, descriptor, proxyTrap) {\n  die(\"'\" + this.annotationType_ + \"' can only be used with 'makeObservable'\");\n}\n\nfunction createActionAnnotation(name, options) {\n  return {\n    annotationType_: name,\n    options_: options,\n    make_: make_$1,\n    extend_: extend_$1\n  };\n}\n\nfunction make_$1(adm, key, descriptor, source) {\n  var _this$options_;\n\n  // bound\n  if ((_this$options_ = this.options_) != null && _this$options_.bound) {\n    return this.extend_(adm, key, descriptor, false) === null ? 0\n    /* Cancel */\n    : 1\n    /* Break */\n    ;\n  } // own\n\n\n  if (source === adm.target_) {\n    return this.extend_(adm, key, descriptor, false) === null ? 0\n    /* Cancel */\n    : 2\n    /* Continue */\n    ;\n  } // prototype\n\n\n  if (isAction(descriptor.value)) {\n    // A prototype could have been annotated already by other constructor,\n    // rest of the proto chain must be annotated already\n    return 1\n    /* Break */\n    ;\n  }\n\n  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor, false);\n  defineProperty(source, key, actionDescriptor);\n  return 2\n  /* Continue */\n  ;\n}\n\nfunction extend_$1(adm, key, descriptor, proxyTrap) {\n  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor);\n  return adm.defineProperty_(key, actionDescriptor, proxyTrap);\n}\n\nfunction assertActionDescriptor(adm, _ref, key, _ref2) {\n  var annotationType_ = _ref.annotationType_;\n  var value = _ref2.value;\n\n  if ( true && !isFunction(value)) {\n    die(\"Cannot apply '\" + annotationType_ + \"' to '\" + adm.name_ + \".\" + key.toString() + \"':\" + (\"\\n'\" + annotationType_ + \"' can only be used on properties with a function value.\"));\n  }\n}\n\nfunction createActionDescriptor(adm, annotation, key, descriptor, // provides ability to disable safeDescriptors for prototypes\nsafeDescriptors) {\n  var _annotation$options_, _annotation$options_$, _annotation$options_2, _annotation$options_$2, _annotation$options_3, _annotation$options_4, _adm$proxy_2;\n\n  if (safeDescriptors === void 0) {\n    safeDescriptors = globalState.safeDescriptors;\n  }\n\n  assertActionDescriptor(adm, annotation, key, descriptor);\n  var value = descriptor.value;\n\n  if ((_annotation$options_ = annotation.options_) != null && _annotation$options_.bound) {\n    var _adm$proxy_;\n\n    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);\n  }\n\n  return {\n    value: createAction((_annotation$options_$ = (_annotation$options_2 = annotation.options_) == null ? void 0 : _annotation$options_2.name) != null ? _annotation$options_$ : key.toString(), value, (_annotation$options_$2 = (_annotation$options_3 = annotation.options_) == null ? void 0 : _annotation$options_3.autoAction) != null ? _annotation$options_$2 : false, // https://github.com/mobxjs/mobx/discussions/3140\n    (_annotation$options_4 = annotation.options_) != null && _annotation$options_4.bound ? (_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_ : undefined),\n    // Non-configurable for classes\n    // prevents accidental field redefinition in subclass\n    configurable: safeDescriptors ? adm.isPlainObject_ : true,\n    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058\n    enumerable: false,\n    // Non-obsevable, therefore non-writable\n    // Also prevents rewriting in subclass constructor\n    writable: safeDescriptors ? false : true\n  };\n}\n\nfunction createFlowAnnotation(name, options) {\n  return {\n    annotationType_: name,\n    options_: options,\n    make_: make_$2,\n    extend_: extend_$2\n  };\n}\n\nfunction make_$2(adm, key, descriptor, source) {\n  var _this$options_;\n\n  // own\n  if (source === adm.target_) {\n    return this.extend_(adm, key, descriptor, false) === null ? 0\n    /* Cancel */\n    : 2\n    /* Continue */\n    ;\n  } // prototype\n  // bound - must annotate protos to support super.flow()\n\n\n  if ((_this$options_ = this.options_) != null && _this$options_.bound && (!hasProp(adm.target_, key) || !isFlow(adm.target_[key]))) {\n    if (this.extend_(adm, key, descriptor, false) === null) {\n      return 0\n      /* Cancel */\n      ;\n    }\n  }\n\n  if (isFlow(descriptor.value)) {\n    // A prototype could have been annotated already by other constructor,\n    // rest of the proto chain must be annotated already\n    return 1\n    /* Break */\n    ;\n  }\n\n  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, false, false);\n  defineProperty(source, key, flowDescriptor);\n  return 2\n  /* Continue */\n  ;\n}\n\nfunction extend_$2(adm, key, descriptor, proxyTrap) {\n  var _this$options_2;\n\n  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, (_this$options_2 = this.options_) == null ? void 0 : _this$options_2.bound);\n  return adm.defineProperty_(key, flowDescriptor, proxyTrap);\n}\n\nfunction assertFlowDescriptor(adm, _ref, key, _ref2) {\n  var annotationType_ = _ref.annotationType_;\n  var value = _ref2.value;\n\n  if ( true && !isFunction(value)) {\n    die(\"Cannot apply '\" + annotationType_ + \"' to '\" + adm.name_ + \".\" + key.toString() + \"':\" + (\"\\n'\" + annotationType_ + \"' can only be used on properties with a generator function value.\"));\n  }\n}\n\nfunction createFlowDescriptor(adm, annotation, key, descriptor, bound, // provides ability to disable safeDescriptors for prototypes\nsafeDescriptors) {\n  if (safeDescriptors === void 0) {\n    safeDescriptors = globalState.safeDescriptors;\n  }\n\n  assertFlowDescriptor(adm, annotation, key, descriptor);\n  var value = descriptor.value; // In case of flow.bound, the descriptor can be from already annotated prototype\n\n  if (!isFlow(value)) {\n    value = flow(value);\n  }\n\n  if (bound) {\n    var _adm$proxy_;\n\n    // We do not keep original function around, so we bind the existing flow\n    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_); // This is normally set by `flow`, but `bind` returns new function...\n\n    value.isMobXFlow = true;\n  }\n\n  return {\n    value: value,\n    // Non-configurable for classes\n    // prevents accidental field redefinition in subclass\n    configurable: safeDescriptors ? adm.isPlainObject_ : true,\n    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058\n    enumerable: false,\n    // Non-obsevable, therefore non-writable\n    // Also prevents rewriting in subclass constructor\n    writable: safeDescriptors ? false : true\n  };\n}\n\nfunction createComputedAnnotation(name, options) {\n  return {\n    annotationType_: name,\n    options_: options,\n    make_: make_$3,\n    extend_: extend_$3\n  };\n}\n\nfunction make_$3(adm, key, descriptor) {\n  return this.extend_(adm, key, descriptor, false) === null ? 0\n  /* Cancel */\n  : 1\n  /* Break */\n  ;\n}\n\nfunction extend_$3(adm, key, descriptor, proxyTrap) {\n  assertComputedDescriptor(adm, this, key, descriptor);\n  return adm.defineComputedProperty_(key, _extends({}, this.options_, {\n    get: descriptor.get,\n    set: descriptor.set\n  }), proxyTrap);\n}\n\nfunction assertComputedDescriptor(adm, _ref, key, _ref2) {\n  var annotationType_ = _ref.annotationType_;\n  var get = _ref2.get;\n\n  if ( true && !get) {\n    die(\"Cannot apply '\" + annotationType_ + \"' to '\" + adm.name_ + \".\" + key.toString() + \"':\" + (\"\\n'\" + annotationType_ + \"' can only be used on getter(+setter) properties.\"));\n  }\n}\n\nfunction createObservableAnnotation(name, options) {\n  return {\n    annotationType_: name,\n    options_: options,\n    make_: make_$4,\n    extend_: extend_$4\n  };\n}\n\nfunction make_$4(adm, key, descriptor) {\n  return this.extend_(adm, key, descriptor, false) === null ? 0\n  /* Cancel */\n  : 1\n  /* Break */\n  ;\n}\n\nfunction extend_$4(adm, key, descriptor, proxyTrap) {\n  var _this$options_$enhanc, _this$options_;\n\n  assertObservableDescriptor(adm, this, key, descriptor);\n  return adm.defineObservableProperty_(key, descriptor.value, (_this$options_$enhanc = (_this$options_ = this.options_) == null ? void 0 : _this$options_.enhancer) != null ? _this$options_$enhanc : deepEnhancer, proxyTrap);\n}\n\nfunction assertObservableDescriptor(adm, _ref, key, descriptor) {\n  var annotationType_ = _ref.annotationType_;\n\n  if ( true && !(\"value\" in descriptor)) {\n    die(\"Cannot apply '\" + annotationType_ + \"' to '\" + adm.name_ + \".\" + key.toString() + \"':\" + (\"\\n'\" + annotationType_ + \"' cannot be used on getter/setter properties\"));\n  }\n}\n\nvar AUTO = \"true\";\nvar autoAnnotation = /*#__PURE__*/createAutoAnnotation();\nfunction createAutoAnnotation(options) {\n  return {\n    annotationType_: AUTO,\n    options_: options,\n    make_: make_$5,\n    extend_: extend_$5\n  };\n}\n\nfunction make_$5(adm, key, descriptor, source) {\n  var _this$options_3, _this$options_4;\n\n  // getter -> computed\n  if (descriptor.get) {\n    return computed.make_(adm, key, descriptor, source);\n  } // lone setter -> action setter\n\n\n  if (descriptor.set) {\n    // TODO make action applicable to setter and delegate to action.make_\n    var set = createAction(key.toString(), descriptor.set); // own\n\n    if (source === adm.target_) {\n      return adm.defineProperty_(key, {\n        configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,\n        set: set\n      }) === null ? 0\n      /* Cancel */\n      : 2\n      /* Continue */\n      ;\n    } // proto\n\n\n    defineProperty(source, key, {\n      configurable: true,\n      set: set\n    });\n    return 2\n    /* Continue */\n    ;\n  } // function on proto -> autoAction/flow\n\n\n  if (source !== adm.target_ && typeof descriptor.value === \"function\") {\n    var _this$options_2;\n\n    if (isGenerator(descriptor.value)) {\n      var _this$options_;\n\n      var flowAnnotation = (_this$options_ = this.options_) != null && _this$options_.autoBind ? flow.bound : flow;\n      return flowAnnotation.make_(adm, key, descriptor, source);\n    }\n\n    var actionAnnotation = (_this$options_2 = this.options_) != null && _this$options_2.autoBind ? autoAction.bound : autoAction;\n    return actionAnnotation.make_(adm, key, descriptor, source);\n  } // other -> observable\n  // Copy props from proto as well, see test:\n  // \"decorate should work with Object.create\"\n\n\n  var observableAnnotation = ((_this$options_3 = this.options_) == null ? void 0 : _this$options_3.deep) === false ? observable.ref : observable; // if function respect autoBind option\n\n  if (typeof descriptor.value === \"function\" && (_this$options_4 = this.options_) != null && _this$options_4.autoBind) {\n    var _adm$proxy_;\n\n    descriptor.value = descriptor.value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);\n  }\n\n  return observableAnnotation.make_(adm, key, descriptor, source);\n}\n\nfunction extend_$5(adm, key, descriptor, proxyTrap) {\n  var _this$options_5, _this$options_6;\n\n  // getter -> computed\n  if (descriptor.get) {\n    return computed.extend_(adm, key, descriptor, proxyTrap);\n  } // lone setter -> action setter\n\n\n  if (descriptor.set) {\n    // TODO make action applicable to setter and delegate to action.extend_\n    return adm.defineProperty_(key, {\n      configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,\n      set: createAction(key.toString(), descriptor.set)\n    }, proxyTrap);\n  } // other -> observable\n  // if function respect autoBind option\n\n\n  if (typeof descriptor.value === \"function\" && (_this$options_5 = this.options_) != null && _this$options_5.autoBind) {\n    var _adm$proxy_2;\n\n    descriptor.value = descriptor.value.bind((_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_);\n  }\n\n  var observableAnnotation = ((_this$options_6 = this.options_) == null ? void 0 : _this$options_6.deep) === false ? observable.ref : observable;\n  return observableAnnotation.extend_(adm, key, descriptor, proxyTrap);\n}\n\nvar OBSERVABLE = \"observable\";\nvar OBSERVABLE_REF = \"observable.ref\";\nvar OBSERVABLE_SHALLOW = \"observable.shallow\";\nvar OBSERVABLE_STRUCT = \"observable.struct\"; // Predefined bags of create observable options, to avoid allocating temporarily option objects\n// in the majority of cases\n\nvar defaultCreateObservableOptions = {\n  deep: true,\n  name: undefined,\n  defaultDecorator: undefined,\n  proxy: true\n};\nObject.freeze(defaultCreateObservableOptions);\nfunction asCreateObservableOptions(thing) {\n  return thing || defaultCreateObservableOptions;\n}\nvar observableAnnotation = /*#__PURE__*/createObservableAnnotation(OBSERVABLE);\nvar observableRefAnnotation = /*#__PURE__*/createObservableAnnotation(OBSERVABLE_REF, {\n  enhancer: referenceEnhancer\n});\nvar observableShallowAnnotation = /*#__PURE__*/createObservableAnnotation(OBSERVABLE_SHALLOW, {\n  enhancer: shallowEnhancer\n});\nvar observableStructAnnotation = /*#__PURE__*/createObservableAnnotation(OBSERVABLE_STRUCT, {\n  enhancer: refStructEnhancer\n});\nvar observableDecoratorAnnotation = /*#__PURE__*/createDecoratorAnnotation(observableAnnotation);\nfunction getEnhancerFromOptions(options) {\n  return options.deep === true ? deepEnhancer : options.deep === false ? referenceEnhancer : getEnhancerFromAnnotation(options.defaultDecorator);\n}\nfunction getAnnotationFromOptions(options) {\n  var _options$defaultDecor;\n\n  return options ? (_options$defaultDecor = options.defaultDecorator) != null ? _options$defaultDecor : createAutoAnnotation(options) : undefined;\n}\nfunction getEnhancerFromAnnotation(annotation) {\n  var _annotation$options_$, _annotation$options_;\n\n  return !annotation ? deepEnhancer : (_annotation$options_$ = (_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.enhancer) != null ? _annotation$options_$ : deepEnhancer;\n}\n/**\r\n * Turns an object, array or function into a reactive structure.\r\n * @param v the value which should become observable.\r\n */\n\nfunction createObservable(v, arg2, arg3) {\n  // @observable someProp;\n  if (isStringish(arg2)) {\n    storeAnnotation(v, arg2, observableAnnotation);\n    return;\n  } // already observable - ignore\n\n\n  if (isObservable(v)) {\n    return v;\n  } // plain object\n\n\n  if (isPlainObject(v)) {\n    return observable.object(v, arg2, arg3);\n  } // Array\n\n\n  if (Array.isArray(v)) {\n    return observable.array(v, arg2);\n  } // Map\n\n\n  if (isES6Map(v)) {\n    return observable.map(v, arg2);\n  } // Set\n\n\n  if (isES6Set(v)) {\n    return observable.set(v, arg2);\n  } // other object - ignore\n\n\n  if (typeof v === \"object\" && v !== null) {\n    return v;\n  } // anything else\n\n\n  return observable.box(v, arg2);\n}\n\nObject.assign(createObservable, observableDecoratorAnnotation);\nvar observableFactories = {\n  box: function box(value, options) {\n    var o = asCreateObservableOptions(options);\n    return new ObservableValue(value, getEnhancerFromOptions(o), o.name, true, o.equals);\n  },\n  array: function array(initialValues, options) {\n    var o = asCreateObservableOptions(options);\n    return (globalState.useProxies === false || o.proxy === false ? createLegacyArray : createObservableArray)(initialValues, getEnhancerFromOptions(o), o.name);\n  },\n  map: function map(initialValues, options) {\n    var o = asCreateObservableOptions(options);\n    return new ObservableMap(initialValues, getEnhancerFromOptions(o), o.name);\n  },\n  set: function set(initialValues, options) {\n    var o = asCreateObservableOptions(options);\n    return new ObservableSet(initialValues, getEnhancerFromOptions(o), o.name);\n  },\n  object: function object(props, decorators, options) {\n    return extendObservable(globalState.useProxies === false || (options == null ? void 0 : options.proxy) === false ? asObservableObject({}, options) : asDynamicObservableObject({}, options), props, decorators);\n  },\n  ref: /*#__PURE__*/createDecoratorAnnotation(observableRefAnnotation),\n  shallow: /*#__PURE__*/createDecoratorAnnotation(observableShallowAnnotation),\n  deep: observableDecoratorAnnotation,\n  struct: /*#__PURE__*/createDecoratorAnnotation(observableStructAnnotation)\n}; // eslint-disable-next-line\n\nvar observable = /*#__PURE__*/assign(createObservable, observableFactories);\n\nvar COMPUTED = \"computed\";\nvar COMPUTED_STRUCT = \"computed.struct\";\nvar computedAnnotation = /*#__PURE__*/createComputedAnnotation(COMPUTED);\nvar computedStructAnnotation = /*#__PURE__*/createComputedAnnotation(COMPUTED_STRUCT, {\n  equals: comparer.structural\n});\n/**\r\n * Decorator for class properties: @computed get value() { return expr; }.\r\n * For legacy purposes also invokable as ES5 observable created: `computed(() => expr)`;\r\n */\n\nvar computed = function computed(arg1, arg2) {\n  if (isStringish(arg2)) {\n    // @computed\n    return storeAnnotation(arg1, arg2, computedAnnotation);\n  }\n\n  if (isPlainObject(arg1)) {\n    // @computed({ options })\n    return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, arg1));\n  } // computed(expr, options?)\n\n\n  if (true) {\n    if (!isFunction(arg1)) {\n      die(\"First argument to `computed` should be an expression.\");\n    }\n\n    if (isFunction(arg2)) {\n      die(\"A setter as second argument is no longer supported, use `{ set: fn }` option instead\");\n    }\n  }\n\n  var opts = isPlainObject(arg2) ? arg2 : {};\n  opts.get = arg1;\n  opts.name || (opts.name = arg1.name || \"\");\n  /* for generated name */\n\n  return new ComputedValue(opts);\n};\nObject.assign(computed, computedAnnotation);\ncomputed.struct = /*#__PURE__*/createDecoratorAnnotation(computedStructAnnotation);\n\nvar _getDescriptor$config, _getDescriptor;\n// mobx versions\n\nvar currentActionId = 0;\nvar nextActionId = 1;\nvar isFunctionNameConfigurable = (_getDescriptor$config = (_getDescriptor = /*#__PURE__*/getDescriptor(function () {}, \"name\")) == null ? void 0 : _getDescriptor.configurable) != null ? _getDescriptor$config : false; // we can safely recycle this object\n\nvar tmpNameDescriptor = {\n  value: \"action\",\n  configurable: true,\n  writable: false,\n  enumerable: false\n};\nfunction createAction(actionName, fn, autoAction, ref) {\n  if (autoAction === void 0) {\n    autoAction = false;\n  }\n\n  if (true) {\n    if (!isFunction(fn)) {\n      die(\"`action` can only be invoked on functions\");\n    }\n\n    if (typeof actionName !== \"string\" || !actionName) {\n      die(\"actions should have valid names, got: '\" + actionName + \"'\");\n    }\n  }\n\n  function res() {\n    return executeAction(actionName, autoAction, fn, ref || this, arguments);\n  }\n\n  res.isMobxAction = true;\n\n  if (isFunctionNameConfigurable) {\n    tmpNameDescriptor.value = actionName;\n    Object.defineProperty(res, \"name\", tmpNameDescriptor);\n  }\n\n  return res;\n}\nfunction executeAction(actionName, canRunAsDerivation, fn, scope, args) {\n  var runInfo = _startAction(actionName, canRunAsDerivation, scope, args);\n\n  try {\n    return fn.apply(scope, args);\n  } catch (err) {\n    runInfo.error_ = err;\n    throw err;\n  } finally {\n    _endAction(runInfo);\n  }\n}\nfunction _startAction(actionName, canRunAsDerivation, // true for autoAction\nscope, args) {\n  var notifySpy_ =  true && isSpyEnabled() && !!actionName;\n  var startTime_ = 0;\n\n  if ( true && notifySpy_) {\n    startTime_ = Date.now();\n    var flattenedArgs = args ? Array.from(args) : EMPTY_ARRAY;\n    spyReportStart({\n      type: ACTION,\n      name: actionName,\n      object: scope,\n      arguments: flattenedArgs\n    });\n  }\n\n  var prevDerivation_ = globalState.trackingDerivation;\n  var runAsAction = !canRunAsDerivation || !prevDerivation_;\n  startBatch();\n  var prevAllowStateChanges_ = globalState.allowStateChanges; // by default preserve previous allow\n\n  if (runAsAction) {\n    untrackedStart();\n    prevAllowStateChanges_ = allowStateChangesStart(true);\n  }\n\n  var prevAllowStateReads_ = allowStateReadsStart(true);\n  var runInfo = {\n    runAsAction_: runAsAction,\n    prevDerivation_: prevDerivation_,\n    prevAllowStateChanges_: prevAllowStateChanges_,\n    prevAllowStateReads_: prevAllowStateReads_,\n    notifySpy_: notifySpy_,\n    startTime_: startTime_,\n    actionId_: nextActionId++,\n    parentActionId_: currentActionId\n  };\n  currentActionId = runInfo.actionId_;\n  return runInfo;\n}\nfunction _endAction(runInfo) {\n  if (currentActionId !== runInfo.actionId_) {\n    die(30);\n  }\n\n  currentActionId = runInfo.parentActionId_;\n\n  if (runInfo.error_ !== undefined) {\n    globalState.suppressReactionErrors = true;\n  }\n\n  allowStateChangesEnd(runInfo.prevAllowStateChanges_);\n  allowStateReadsEnd(runInfo.prevAllowStateReads_);\n  endBatch();\n\n  if (runInfo.runAsAction_) {\n    untrackedEnd(runInfo.prevDerivation_);\n  }\n\n  if ( true && runInfo.notifySpy_) {\n    spyReportEnd({\n      time: Date.now() - runInfo.startTime_\n    });\n  }\n\n  globalState.suppressReactionErrors = false;\n}\nfunction allowStateChanges(allowStateChanges, func) {\n  var prev = allowStateChangesStart(allowStateChanges);\n\n  try {\n    return func();\n  } finally {\n    allowStateChangesEnd(prev);\n  }\n}\nfunction allowStateChangesStart(allowStateChanges) {\n  var prev = globalState.allowStateChanges;\n  globalState.allowStateChanges = allowStateChanges;\n  return prev;\n}\nfunction allowStateChangesEnd(prev) {\n  globalState.allowStateChanges = prev;\n}\n\nvar _Symbol$toPrimitive;\nvar CREATE = \"create\";\n_Symbol$toPrimitive = Symbol.toPrimitive;\nvar ObservableValue = /*#__PURE__*/function (_Atom) {\n  _inheritsLoose(ObservableValue, _Atom);\n\n  function ObservableValue(value, enhancer, name_, notifySpy, equals) {\n    var _this;\n\n    if (name_ === void 0) {\n      name_ =  true ? \"ObservableValue@\" + getNextId() : 0;\n    }\n\n    if (notifySpy === void 0) {\n      notifySpy = true;\n    }\n\n    if (equals === void 0) {\n      equals = comparer[\"default\"];\n    }\n\n    _this = _Atom.call(this, name_) || this;\n    _this.enhancer = void 0;\n    _this.name_ = void 0;\n    _this.equals = void 0;\n    _this.hasUnreportedChange_ = false;\n    _this.interceptors_ = void 0;\n    _this.changeListeners_ = void 0;\n    _this.value_ = void 0;\n    _this.dehancer = void 0;\n    _this.enhancer = enhancer;\n    _this.name_ = name_;\n    _this.equals = equals;\n    _this.value_ = enhancer(value, undefined, name_);\n\n    if ( true && notifySpy && isSpyEnabled()) {\n      // only notify spy if this is a stand-alone observable\n      spyReport({\n        type: CREATE,\n        object: _assertThisInitialized(_this),\n        observableKind: \"value\",\n        debugObjectName: _this.name_,\n        newValue: \"\" + _this.value_\n      });\n    }\n\n    return _this;\n  }\n\n  var _proto = ObservableValue.prototype;\n\n  _proto.dehanceValue = function dehanceValue(value) {\n    if (this.dehancer !== undefined) {\n      return this.dehancer(value);\n    }\n\n    return value;\n  };\n\n  _proto.set = function set(newValue) {\n    var oldValue = this.value_;\n    newValue = this.prepareNewValue_(newValue);\n\n    if (newValue !== globalState.UNCHANGED) {\n      var notifySpy = isSpyEnabled();\n\n      if ( true && notifySpy) {\n        spyReportStart({\n          type: UPDATE,\n          object: this,\n          observableKind: \"value\",\n          debugObjectName: this.name_,\n          newValue: newValue,\n          oldValue: oldValue\n        });\n      }\n\n      this.setNewValue_(newValue);\n\n      if ( true && notifySpy) {\n        spyReportEnd();\n      }\n    }\n  };\n\n  _proto.prepareNewValue_ = function prepareNewValue_(newValue) {\n    checkIfStateModificationsAreAllowed(this);\n\n    if (hasInterceptors(this)) {\n      var change = interceptChange(this, {\n        object: this,\n        type: UPDATE,\n        newValue: newValue\n      });\n\n      if (!change) {\n        return globalState.UNCHANGED;\n      }\n\n      newValue = change.newValue;\n    } // apply modifier\n\n\n    newValue = this.enhancer(newValue, this.value_, this.name_);\n    return this.equals(this.value_, newValue) ? globalState.UNCHANGED : newValue;\n  };\n\n  _proto.setNewValue_ = function setNewValue_(newValue) {\n    var oldValue = this.value_;\n    this.value_ = newValue;\n    this.reportChanged();\n\n    if (hasListeners(this)) {\n      notifyListeners(this, {\n        type: UPDATE,\n        object: this,\n        newValue: newValue,\n        oldValue: oldValue\n      });\n    }\n  };\n\n  _proto.get = function get() {\n    this.reportObserved();\n    return this.dehanceValue(this.value_);\n  };\n\n  _proto.intercept_ = function intercept_(handler) {\n    return registerInterceptor(this, handler);\n  };\n\n  _proto.observe_ = function observe_(listener, fireImmediately) {\n    if (fireImmediately) {\n      listener({\n        observableKind: \"value\",\n        debugObjectName: this.name_,\n        object: this,\n        type: UPDATE,\n        newValue: this.value_,\n        oldValue: undefined\n      });\n    }\n\n    return registerListener(this, listener);\n  };\n\n  _proto.raw = function raw() {\n    // used by MST ot get undehanced value\n    return this.value_;\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.get();\n  };\n\n  _proto.toString = function toString() {\n    return this.name_ + \"[\" + this.value_ + \"]\";\n  };\n\n  _proto.valueOf = function valueOf() {\n    return toPrimitive(this.get());\n  };\n\n  _proto[_Symbol$toPrimitive] = function () {\n    return this.valueOf();\n  };\n\n  return ObservableValue;\n}(Atom);\nvar isObservableValue = /*#__PURE__*/createInstanceofPredicate(\"ObservableValue\", ObservableValue);\n\nvar _Symbol$toPrimitive$1;\n/**\r\n * A node in the state dependency root that observes other nodes, and can be observed itself.\r\n *\r\n * ComputedValue will remember the result of the computation for the duration of the batch, or\r\n * while being observed.\r\n *\r\n * During this time it will recompute only when one of its direct dependencies changed,\r\n * but only when it is being accessed with `ComputedValue.get()`.\r\n *\r\n * Implementation description:\r\n * 1. First time it's being accessed it will compute and remember result\r\n *    give back remembered result until 2. happens\r\n * 2. First time any deep dependency change, propagate POSSIBLY_STALE to all observers, wait for 3.\r\n * 3. When it's being accessed, recompute if any shallow dependency changed.\r\n *    if result changed: propagate STALE to all observers, that were POSSIBLY_STALE from the last step.\r\n *    go to step 2. either way\r\n *\r\n * If at any point it's outside batch and it isn't observed: reset everything and go to 1.\r\n */\n\n_Symbol$toPrimitive$1 = Symbol.toPrimitive;\nvar ComputedValue = /*#__PURE__*/function () {\n  // nodes we are looking at. Our value depends on these nodes\n  // during tracking it's an array with new observed observers\n  // to check for cycles\n  // N.B: unminified as it is used by MST\n\n  /**\r\n   * Create a new computed value based on a function expression.\r\n   *\r\n   * The `name` property is for debug purposes only.\r\n   *\r\n   * The `equals` property specifies the comparer function to use to determine if a newly produced\r\n   * value differs from the previous value. Two comparers are provided in the library; `defaultComparer`\r\n   * compares based on identity comparison (===), and `structuralComparer` deeply compares the structure.\r\n   * Structural comparison can be convenient if you always produce a new aggregated object and\r\n   * don't want to notify observers if it is structurally the same.\r\n   * This is useful for working with vectors, mouse coordinates etc.\r\n   */\n  function ComputedValue(options) {\n    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;\n    this.observing_ = [];\n    this.newObserving_ = null;\n    this.isBeingObserved_ = false;\n    this.isPendingUnobservation_ = false;\n    this.observers_ = new Set();\n    this.diffValue_ = 0;\n    this.runId_ = 0;\n    this.lastAccessedBy_ = 0;\n    this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;\n    this.unboundDepsCount_ = 0;\n    this.value_ = new CaughtException(null);\n    this.name_ = void 0;\n    this.triggeredBy_ = void 0;\n    this.isComputing_ = false;\n    this.isRunningSetter_ = false;\n    this.derivation = void 0;\n    this.setter_ = void 0;\n    this.isTracing_ = TraceMode.NONE;\n    this.scope_ = void 0;\n    this.equals_ = void 0;\n    this.requiresReaction_ = void 0;\n    this.keepAlive_ = void 0;\n    this.onBOL = void 0;\n    this.onBUOL = void 0;\n\n    if (!options.get) {\n      die(31);\n    }\n\n    this.derivation = options.get;\n    this.name_ = options.name || ( true ? \"ComputedValue@\" + getNextId() : 0);\n\n    if (options.set) {\n      this.setter_ = createAction( true ? this.name_ + \"-setter\" : 0, options.set);\n    }\n\n    this.equals_ = options.equals || (options.compareStructural || options.struct ? comparer.structural : comparer[\"default\"]);\n    this.scope_ = options.context;\n    this.requiresReaction_ = options.requiresReaction;\n    this.keepAlive_ = !!options.keepAlive;\n  }\n\n  var _proto = ComputedValue.prototype;\n\n  _proto.onBecomeStale_ = function onBecomeStale_() {\n    propagateMaybeChanged(this);\n  };\n\n  _proto.onBO = function onBO() {\n    if (this.onBOL) {\n      this.onBOL.forEach(function (listener) {\n        return listener();\n      });\n    }\n  };\n\n  _proto.onBUO = function onBUO() {\n    if (this.onBUOL) {\n      this.onBUOL.forEach(function (listener) {\n        return listener();\n      });\n    }\n  }\n  /**\r\n   * Returns the current value of this computed value.\r\n   * Will evaluate its computation first if needed.\r\n   */\n  ;\n\n  _proto.get = function get() {\n    if (this.isComputing_) {\n      die(32, this.name_, this.derivation);\n    }\n\n    if (globalState.inBatch === 0 && // !globalState.trackingDerivatpion &&\n    this.observers_.size === 0 && !this.keepAlive_) {\n      if (shouldCompute(this)) {\n        this.warnAboutUntrackedRead_();\n        startBatch(); // See perf test 'computed memoization'\n\n        this.value_ = this.computeValue_(false);\n        endBatch();\n      }\n    } else {\n      reportObserved(this);\n\n      if (shouldCompute(this)) {\n        var prevTrackingContext = globalState.trackingContext;\n\n        if (this.keepAlive_ && !prevTrackingContext) {\n          globalState.trackingContext = this;\n        }\n\n        if (this.trackAndCompute()) {\n          propagateChangeConfirmed(this);\n        }\n\n        globalState.trackingContext = prevTrackingContext;\n      }\n    }\n\n    var result = this.value_;\n\n    if (isCaughtException(result)) {\n      throw result.cause;\n    }\n\n    return result;\n  };\n\n  _proto.set = function set(value) {\n    if (this.setter_) {\n      if (this.isRunningSetter_) {\n        die(33, this.name_);\n      }\n\n      this.isRunningSetter_ = true;\n\n      try {\n        this.setter_.call(this.scope_, value);\n      } finally {\n        this.isRunningSetter_ = false;\n      }\n    } else {\n      die(34, this.name_);\n    }\n  };\n\n  _proto.trackAndCompute = function trackAndCompute() {\n    // N.B: unminified as it is used by MST\n    var oldValue = this.value_;\n    var wasSuspended =\n    /* see #1208 */\n    this.dependenciesState_ === IDerivationState_.NOT_TRACKING_;\n    var newValue = this.computeValue_(true);\n    var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals_(oldValue, newValue);\n\n    if (changed) {\n      this.value_ = newValue;\n\n      if ( true && isSpyEnabled()) {\n        spyReport({\n          observableKind: \"computed\",\n          debugObjectName: this.name_,\n          object: this.scope_,\n          type: \"update\",\n          oldValue: oldValue,\n          newValue: newValue\n        });\n      }\n    }\n\n    return changed;\n  };\n\n  _proto.computeValue_ = function computeValue_(track) {\n    this.isComputing_ = true; // don't allow state changes during computation\n\n    var prev = allowStateChangesStart(false);\n    var res;\n\n    if (track) {\n      res = trackDerivedFunction(this, this.derivation, this.scope_);\n    } else {\n      if (globalState.disableErrorBoundaries === true) {\n        res = this.derivation.call(this.scope_);\n      } else {\n        try {\n          res = this.derivation.call(this.scope_);\n        } catch (e) {\n          res = new CaughtException(e);\n        }\n      }\n    }\n\n    allowStateChangesEnd(prev);\n    this.isComputing_ = false;\n    return res;\n  };\n\n  _proto.suspend_ = function suspend_() {\n    if (!this.keepAlive_) {\n      clearObserving(this);\n      this.value_ = undefined; // don't hold on to computed value!\n\n      if ( true && this.isTracing_ !== TraceMode.NONE) {\n        console.log(\"[mobx.trace] Computed value '\" + this.name_ + \"' was suspended and it will recompute on the next access.\");\n      }\n    }\n  };\n\n  _proto.observe_ = function observe_(listener, fireImmediately) {\n    var _this = this;\n\n    var firstTime = true;\n    var prevValue = undefined;\n    return autorun(function () {\n      // TODO: why is this in a different place than the spyReport() function? in all other observables it's called in the same place\n      var newValue = _this.get();\n\n      if (!firstTime || fireImmediately) {\n        var prevU = untrackedStart();\n        listener({\n          observableKind: \"computed\",\n          debugObjectName: _this.name_,\n          type: UPDATE,\n          object: _this,\n          newValue: newValue,\n          oldValue: prevValue\n        });\n        untrackedEnd(prevU);\n      }\n\n      firstTime = false;\n      prevValue = newValue;\n    });\n  };\n\n  _proto.warnAboutUntrackedRead_ = function warnAboutUntrackedRead_() {\n    if (false) {}\n\n    if (this.isTracing_ !== TraceMode.NONE) {\n      console.log(\"[mobx.trace] Computed value '\" + this.name_ + \"' is being read outside a reactive context. Doing a full recompute.\");\n    }\n\n    if (typeof this.requiresReaction_ === \"boolean\" ? this.requiresReaction_ : globalState.computedRequiresReaction) {\n      console.warn(\"[mobx] Computed value '\" + this.name_ + \"' is being read outside a reactive context. Doing a full recompute.\");\n    }\n  };\n\n  _proto.toString = function toString() {\n    return this.name_ + \"[\" + this.derivation.toString() + \"]\";\n  };\n\n  _proto.valueOf = function valueOf() {\n    return toPrimitive(this.get());\n  };\n\n  _proto[_Symbol$toPrimitive$1] = function () {\n    return this.valueOf();\n  };\n\n  return ComputedValue;\n}();\nvar isComputedValue = /*#__PURE__*/createInstanceofPredicate(\"ComputedValue\", ComputedValue);\n\nvar IDerivationState_;\n\n(function (IDerivationState_) {\n  // before being run or (outside batch and not being observed)\n  // at this point derivation is not holding any data about dependency tree\n  IDerivationState_[IDerivationState_[\"NOT_TRACKING_\"] = -1] = \"NOT_TRACKING_\"; // no shallow dependency changed since last computation\n  // won't recalculate derivation\n  // this is what makes mobx fast\n\n  IDerivationState_[IDerivationState_[\"UP_TO_DATE_\"] = 0] = \"UP_TO_DATE_\"; // some deep dependency changed, but don't know if shallow dependency changed\n  // will require to check first if UP_TO_DATE or POSSIBLY_STALE\n  // currently only ComputedValue will propagate POSSIBLY_STALE\n  //\n  // having this state is second big optimization:\n  // don't have to recompute on every dependency change, but only when it's needed\n\n  IDerivationState_[IDerivationState_[\"POSSIBLY_STALE_\"] = 1] = \"POSSIBLY_STALE_\"; // A shallow dependency has changed since last computation and the derivation\n  // will need to recompute when it's needed next.\n\n  IDerivationState_[IDerivationState_[\"STALE_\"] = 2] = \"STALE_\";\n})(IDerivationState_ || (IDerivationState_ = {}));\n\nvar TraceMode;\n\n(function (TraceMode) {\n  TraceMode[TraceMode[\"NONE\"] = 0] = \"NONE\";\n  TraceMode[TraceMode[\"LOG\"] = 1] = \"LOG\";\n  TraceMode[TraceMode[\"BREAK\"] = 2] = \"BREAK\";\n})(TraceMode || (TraceMode = {}));\n\nvar CaughtException = function CaughtException(cause) {\n  this.cause = void 0;\n  this.cause = cause; // Empty\n};\nfunction isCaughtException(e) {\n  return e instanceof CaughtException;\n}\n/**\r\n * Finds out whether any dependency of the derivation has actually changed.\r\n * If dependenciesState is 1 then it will recalculate dependencies,\r\n * if any dependency changed it will propagate it by changing dependenciesState to 2.\r\n *\r\n * By iterating over the dependencies in the same order that they were reported and\r\n * stopping on the first change, all the recalculations are only called for ComputedValues\r\n * that will be tracked by derivation. That is because we assume that if the first x\r\n * dependencies of the derivation doesn't change then the derivation should run the same way\r\n * up until accessing x-th dependency.\r\n */\n\nfunction shouldCompute(derivation) {\n  switch (derivation.dependenciesState_) {\n    case IDerivationState_.UP_TO_DATE_:\n      return false;\n\n    case IDerivationState_.NOT_TRACKING_:\n    case IDerivationState_.STALE_:\n      return true;\n\n    case IDerivationState_.POSSIBLY_STALE_:\n      {\n        // state propagation can occur outside of action/reactive context #2195\n        var prevAllowStateReads = allowStateReadsStart(true);\n        var prevUntracked = untrackedStart(); // no need for those computeds to be reported, they will be picked up in trackDerivedFunction.\n\n        var obs = derivation.observing_,\n            l = obs.length;\n\n        for (var i = 0; i < l; i++) {\n          var obj = obs[i];\n\n          if (isComputedValue(obj)) {\n            if (globalState.disableErrorBoundaries) {\n              obj.get();\n            } else {\n              try {\n                obj.get();\n              } catch (e) {\n                // we are not interested in the value *or* exception at this moment, but if there is one, notify all\n                untrackedEnd(prevUntracked);\n                allowStateReadsEnd(prevAllowStateReads);\n                return true;\n              }\n            } // if ComputedValue `obj` actually changed it will be computed and propagated to its observers.\n            // and `derivation` is an observer of `obj`\n            // invariantShouldCompute(derivation)\n\n\n            if (derivation.dependenciesState_ === IDerivationState_.STALE_) {\n              untrackedEnd(prevUntracked);\n              allowStateReadsEnd(prevAllowStateReads);\n              return true;\n            }\n          }\n        }\n\n        changeDependenciesStateTo0(derivation);\n        untrackedEnd(prevUntracked);\n        allowStateReadsEnd(prevAllowStateReads);\n        return false;\n      }\n  }\n}\nfunction isComputingDerivation() {\n  return globalState.trackingDerivation !== null; // filter out actions inside computations\n}\nfunction checkIfStateModificationsAreAllowed(atom) {\n  if (false) {}\n\n  var hasObservers = atom.observers_.size > 0; // Should not be possible to change observed state outside strict mode, except during initialization, see #563\n\n  if (!globalState.allowStateChanges && (hasObservers || globalState.enforceActions === \"always\")) {\n    console.warn(\"[MobX] \" + (globalState.enforceActions ? \"Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: \" : \"Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: \") + atom.name_);\n  }\n}\nfunction checkIfStateReadsAreAllowed(observable) {\n  if ( true && !globalState.allowStateReads && globalState.observableRequiresReaction) {\n    console.warn(\"[mobx] Observable '\" + observable.name_ + \"' being read outside a reactive context.\");\n  }\n}\n/**\r\n * Executes the provided function `f` and tracks which observables are being accessed.\r\n * The tracking information is stored on the `derivation` object and the derivation is registered\r\n * as observer of any of the accessed observables.\r\n */\n\nfunction trackDerivedFunction(derivation, f, context) {\n  var prevAllowStateReads = allowStateReadsStart(true); // pre allocate array allocation + room for variation in deps\n  // array will be trimmed by bindDependencies\n\n  changeDependenciesStateTo0(derivation);\n  derivation.newObserving_ = new Array(derivation.observing_.length + 100);\n  derivation.unboundDepsCount_ = 0;\n  derivation.runId_ = ++globalState.runId;\n  var prevTracking = globalState.trackingDerivation;\n  globalState.trackingDerivation = derivation;\n  globalState.inBatch++;\n  var result;\n\n  if (globalState.disableErrorBoundaries === true) {\n    result = f.call(context);\n  } else {\n    try {\n      result = f.call(context);\n    } catch (e) {\n      result = new CaughtException(e);\n    }\n  }\n\n  globalState.inBatch--;\n  globalState.trackingDerivation = prevTracking;\n  bindDependencies(derivation);\n  warnAboutDerivationWithoutDependencies(derivation);\n  allowStateReadsEnd(prevAllowStateReads);\n  return result;\n}\n\nfunction warnAboutDerivationWithoutDependencies(derivation) {\n  if (false) {}\n\n  if (derivation.observing_.length !== 0) {\n    return;\n  }\n\n  if (typeof derivation.requiresObservable_ === \"boolean\" ? derivation.requiresObservable_ : globalState.reactionRequiresObservable) {\n    console.warn(\"[mobx] Derivation '\" + derivation.name_ + \"' is created/updated without reading any observable value.\");\n  }\n}\n/**\r\n * diffs newObserving with observing.\r\n * update observing to be newObserving with unique observables\r\n * notify observers that become observed/unobserved\r\n */\n\n\nfunction bindDependencies(derivation) {\n  // invariant(derivation.dependenciesState !== IDerivationState.NOT_TRACKING, \"INTERNAL ERROR bindDependencies expects derivation.dependenciesState !== -1\");\n  var prevObserving = derivation.observing_;\n  var observing = derivation.observing_ = derivation.newObserving_;\n  var lowestNewObservingDerivationState = IDerivationState_.UP_TO_DATE_; // Go through all new observables and check diffValue: (this list can contain duplicates):\n  //   0: first occurrence, change to 1 and keep it\n  //   1: extra occurrence, drop it\n\n  var i0 = 0,\n      l = derivation.unboundDepsCount_;\n\n  for (var i = 0; i < l; i++) {\n    var dep = observing[i];\n\n    if (dep.diffValue_ === 0) {\n      dep.diffValue_ = 1;\n\n      if (i0 !== i) {\n        observing[i0] = dep;\n      }\n\n      i0++;\n    } // Upcast is 'safe' here, because if dep is IObservable, `dependenciesState` will be undefined,\n    // not hitting the condition\n\n\n    if (dep.dependenciesState_ > lowestNewObservingDerivationState) {\n      lowestNewObservingDerivationState = dep.dependenciesState_;\n    }\n  }\n\n  observing.length = i0;\n  derivation.newObserving_ = null; // newObserving shouldn't be needed outside tracking (statement moved down to work around FF bug, see #614)\n  // Go through all old observables and check diffValue: (it is unique after last bindDependencies)\n  //   0: it's not in new observables, unobserve it\n  //   1: it keeps being observed, don't want to notify it. change to 0\n\n  l = prevObserving.length;\n\n  while (l--) {\n    var _dep = prevObserving[l];\n\n    if (_dep.diffValue_ === 0) {\n      removeObserver(_dep, derivation);\n    }\n\n    _dep.diffValue_ = 0;\n  } // Go through all new observables and check diffValue: (now it should be unique)\n  //   0: it was set to 0 in last loop. don't need to do anything.\n  //   1: it wasn't observed, let's observe it. set back to 0\n\n\n  while (i0--) {\n    var _dep2 = observing[i0];\n\n    if (_dep2.diffValue_ === 1) {\n      _dep2.diffValue_ = 0;\n      addObserver(_dep2, derivation);\n    }\n  } // Some new observed derivations may become stale during this derivation computation\n  // so they have had no chance to propagate staleness (#916)\n\n\n  if (lowestNewObservingDerivationState !== IDerivationState_.UP_TO_DATE_) {\n    derivation.dependenciesState_ = lowestNewObservingDerivationState;\n    derivation.onBecomeStale_();\n  }\n}\n\nfunction clearObserving(derivation) {\n  // invariant(globalState.inBatch > 0, \"INTERNAL ERROR clearObserving should be called only inside batch\");\n  var obs = derivation.observing_;\n  derivation.observing_ = [];\n  var i = obs.length;\n\n  while (i--) {\n    removeObserver(obs[i], derivation);\n  }\n\n  derivation.dependenciesState_ = IDerivationState_.NOT_TRACKING_;\n}\nfunction untracked(action) {\n  var prev = untrackedStart();\n\n  try {\n    return action();\n  } finally {\n    untrackedEnd(prev);\n  }\n}\nfunction untrackedStart() {\n  var prev = globalState.trackingDerivation;\n  globalState.trackingDerivation = null;\n  return prev;\n}\nfunction untrackedEnd(prev) {\n  globalState.trackingDerivation = prev;\n}\nfunction allowStateReadsStart(allowStateReads) {\n  var prev = globalState.allowStateReads;\n  globalState.allowStateReads = allowStateReads;\n  return prev;\n}\nfunction allowStateReadsEnd(prev) {\n  globalState.allowStateReads = prev;\n}\n/**\r\n * needed to keep `lowestObserverState` correct. when changing from (2 or 1) to 0\r\n *\r\n */\n\nfunction changeDependenciesStateTo0(derivation) {\n  if (derivation.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {\n    return;\n  }\n\n  derivation.dependenciesState_ = IDerivationState_.UP_TO_DATE_;\n  var obs = derivation.observing_;\n  var i = obs.length;\n\n  while (i--) {\n    obs[i].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;\n  }\n}\n\n/**\r\n * These values will persist if global state is reset\r\n */\n\nvar persistentKeys = [\"mobxGuid\", \"spyListeners\", \"enforceActions\", \"computedRequiresReaction\", \"reactionRequiresObservable\", \"observableRequiresReaction\", \"allowStateReads\", \"disableErrorBoundaries\", \"runId\", \"UNCHANGED\", \"useProxies\"];\nvar MobXGlobals = function MobXGlobals() {\n  this.version = 6;\n  this.UNCHANGED = {};\n  this.trackingDerivation = null;\n  this.trackingContext = null;\n  this.runId = 0;\n  this.mobxGuid = 0;\n  this.inBatch = 0;\n  this.pendingUnobservations = [];\n  this.pendingReactions = [];\n  this.isRunningReactions = false;\n  this.allowStateChanges = false;\n  this.allowStateReads = true;\n  this.enforceActions = true;\n  this.spyListeners = [];\n  this.globalReactionErrorHandlers = [];\n  this.computedRequiresReaction = false;\n  this.reactionRequiresObservable = false;\n  this.observableRequiresReaction = false;\n  this.disableErrorBoundaries = false;\n  this.suppressReactionErrors = false;\n  this.useProxies = true;\n  this.verifyProxies = false;\n  this.safeDescriptors = true;\n};\nvar canMergeGlobalState = true;\nvar isolateCalled = false;\nvar globalState = /*#__PURE__*/function () {\n  var global = /*#__PURE__*/getGlobal();\n\n  if (global.__mobxInstanceCount > 0 && !global.__mobxGlobals) {\n    canMergeGlobalState = false;\n  }\n\n  if (global.__mobxGlobals && global.__mobxGlobals.version !== new MobXGlobals().version) {\n    canMergeGlobalState = false;\n  }\n\n  if (!canMergeGlobalState) {\n    // Because this is a IIFE we need to let isolateCalled a chance to change\n    // so we run it after the event loop completed at least 1 iteration\n    setTimeout(function () {\n      if (!isolateCalled) {\n        die(35);\n      }\n    }, 1);\n    return new MobXGlobals();\n  } else if (global.__mobxGlobals) {\n    global.__mobxInstanceCount += 1;\n\n    if (!global.__mobxGlobals.UNCHANGED) {\n      global.__mobxGlobals.UNCHANGED = {};\n    } // make merge backward compatible\n\n\n    return global.__mobxGlobals;\n  } else {\n    global.__mobxInstanceCount = 1;\n    return global.__mobxGlobals = /*#__PURE__*/new MobXGlobals();\n  }\n}();\nfunction isolateGlobalState() {\n  if (globalState.pendingReactions.length || globalState.inBatch || globalState.isRunningReactions) {\n    die(36);\n  }\n\n  isolateCalled = true;\n\n  if (canMergeGlobalState) {\n    var global = getGlobal();\n\n    if (--global.__mobxInstanceCount === 0) {\n      global.__mobxGlobals = undefined;\n    }\n\n    globalState = new MobXGlobals();\n  }\n}\nfunction getGlobalState() {\n  return globalState;\n}\n/**\r\n * For testing purposes only; this will break the internal state of existing observables,\r\n * but can be used to get back at a stable state after throwing errors\r\n */\n\nfunction resetGlobalState() {\n  var defaultGlobals = new MobXGlobals();\n\n  for (var key in defaultGlobals) {\n    if (persistentKeys.indexOf(key) === -1) {\n      globalState[key] = defaultGlobals[key];\n    }\n  }\n\n  globalState.allowStateChanges = !globalState.enforceActions;\n}\n\nfunction hasObservers(observable) {\n  return observable.observers_ && observable.observers_.size > 0;\n}\nfunction getObservers(observable) {\n  return observable.observers_;\n} // function invariantObservers(observable: IObservable) {\n//     const list = observable.observers\n//     const map = observable.observersIndexes\n//     const l = list.length\n//     for (let i = 0; i < l; i++) {\n//         const id = list[i].__mapid\n//         if (i) {\n//             invariant(map[id] === i, \"INTERNAL ERROR maps derivation.__mapid to index in list\") // for performance\n//         } else {\n//             invariant(!(id in map), \"INTERNAL ERROR observer on index 0 shouldn't be held in map.\") // for performance\n//         }\n//     }\n//     invariant(\n//         list.length === 0 || Object.keys(map).length === list.length - 1,\n//         \"INTERNAL ERROR there is no junk in map\"\n//     )\n// }\n\nfunction addObserver(observable, node) {\n  // invariant(node.dependenciesState !== -1, \"INTERNAL ERROR, can add only dependenciesState !== -1\");\n  // invariant(observable._observers.indexOf(node) === -1, \"INTERNAL ERROR add already added node\");\n  // invariantObservers(observable);\n  observable.observers_.add(node);\n\n  if (observable.lowestObserverState_ > node.dependenciesState_) {\n    observable.lowestObserverState_ = node.dependenciesState_;\n  } // invariantObservers(observable);\n  // invariant(observable._observers.indexOf(node) !== -1, \"INTERNAL ERROR didn't add node\");\n\n}\nfunction removeObserver(observable, node) {\n  // invariant(globalState.inBatch > 0, \"INTERNAL ERROR, remove should be called only inside batch\");\n  // invariant(observable._observers.indexOf(node) !== -1, \"INTERNAL ERROR remove already removed node\");\n  // invariantObservers(observable);\n  observable.observers_[\"delete\"](node);\n\n  if (observable.observers_.size === 0) {\n    // deleting last observer\n    queueForUnobservation(observable);\n  } // invariantObservers(observable);\n  // invariant(observable._observers.indexOf(node) === -1, \"INTERNAL ERROR remove already removed node2\");\n\n}\nfunction queueForUnobservation(observable) {\n  if (observable.isPendingUnobservation_ === false) {\n    // invariant(observable._observers.length === 0, \"INTERNAL ERROR, should only queue for unobservation unobserved observables\");\n    observable.isPendingUnobservation_ = true;\n    globalState.pendingUnobservations.push(observable);\n  }\n}\n/**\r\n * Batch starts a transaction, at least for purposes of memoizing ComputedValues when nothing else does.\r\n * During a batch `onBecomeUnobserved` will be called at most once per observable.\r\n * Avoids unnecessary recalculations.\r\n */\n\nfunction startBatch() {\n  globalState.inBatch++;\n}\nfunction endBatch() {\n  if (--globalState.inBatch === 0) {\n    runReactions(); // the batch is actually about to finish, all unobserving should happen here.\n\n    var list = globalState.pendingUnobservations;\n\n    for (var i = 0; i < list.length; i++) {\n      var observable = list[i];\n      observable.isPendingUnobservation_ = false;\n\n      if (observable.observers_.size === 0) {\n        if (observable.isBeingObserved_) {\n          // if this observable had reactive observers, trigger the hooks\n          observable.isBeingObserved_ = false;\n          observable.onBUO();\n        }\n\n        if (observable instanceof ComputedValue) {\n          // computed values are automatically teared down when the last observer leaves\n          // this process happens recursively, this computed might be the last observabe of another, etc..\n          observable.suspend_();\n        }\n      }\n    }\n\n    globalState.pendingUnobservations = [];\n  }\n}\nfunction reportObserved(observable) {\n  checkIfStateReadsAreAllowed(observable);\n  var derivation = globalState.trackingDerivation;\n\n  if (derivation !== null) {\n    /**\r\n     * Simple optimization, give each derivation run an unique id (runId)\r\n     * Check if last time this observable was accessed the same runId is used\r\n     * if this is the case, the relation is already known\r\n     */\n    if (derivation.runId_ !== observable.lastAccessedBy_) {\n      observable.lastAccessedBy_ = derivation.runId_; // Tried storing newObserving, or observing, or both as Set, but performance didn't come close...\n\n      derivation.newObserving_[derivation.unboundDepsCount_++] = observable;\n\n      if (!observable.isBeingObserved_ && globalState.trackingContext) {\n        observable.isBeingObserved_ = true;\n        observable.onBO();\n      }\n    }\n\n    return observable.isBeingObserved_;\n  } else if (observable.observers_.size === 0 && globalState.inBatch > 0) {\n    queueForUnobservation(observable);\n  }\n\n  return false;\n} // function invariantLOS(observable: IObservable, msg: string) {\n//     // it's expensive so better not run it in produciton. but temporarily helpful for testing\n//     const min = getObservers(observable).reduce((a, b) => Math.min(a, b.dependenciesState), 2)\n//     if (min >= observable.lowestObserverState) return // <- the only assumption about `lowestObserverState`\n//     throw new Error(\n//         \"lowestObserverState is wrong for \" +\n//             msg +\n//             \" because \" +\n//             min +\n//             \" < \" +\n//             observable.lowestObserverState\n//     )\n// }\n\n/**\r\n * NOTE: current propagation mechanism will in case of self reruning autoruns behave unexpectedly\r\n * It will propagate changes to observers from previous run\r\n * It's hard or maybe impossible (with reasonable perf) to get it right with current approach\r\n * Hopefully self reruning autoruns aren't a feature people should depend on\r\n * Also most basic use cases should be ok\r\n */\n// Called by Atom when its value changes\n\nfunction propagateChanged(observable) {\n  // invariantLOS(observable, \"changed start\");\n  if (observable.lowestObserverState_ === IDerivationState_.STALE_) {\n    return;\n  }\n\n  observable.lowestObserverState_ = IDerivationState_.STALE_; // Ideally we use for..of here, but the downcompiled version is really slow...\n\n  observable.observers_.forEach(function (d) {\n    if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {\n      if ( true && d.isTracing_ !== TraceMode.NONE) {\n        logTraceInfo(d, observable);\n      }\n\n      d.onBecomeStale_();\n    }\n\n    d.dependenciesState_ = IDerivationState_.STALE_;\n  }); // invariantLOS(observable, \"changed end\");\n} // Called by ComputedValue when it recalculate and its value changed\n\nfunction propagateChangeConfirmed(observable) {\n  // invariantLOS(observable, \"confirmed start\");\n  if (observable.lowestObserverState_ === IDerivationState_.STALE_) {\n    return;\n  }\n\n  observable.lowestObserverState_ = IDerivationState_.STALE_;\n  observable.observers_.forEach(function (d) {\n    if (d.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_) {\n      d.dependenciesState_ = IDerivationState_.STALE_;\n\n      if ( true && d.isTracing_ !== TraceMode.NONE) {\n        logTraceInfo(d, observable);\n      }\n    } else if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_ // this happens during computing of `d`, just keep lowestObserverState up to date.\n    ) {\n      observable.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;\n    }\n  }); // invariantLOS(observable, \"confirmed end\");\n} // Used by computed when its dependency changed, but we don't wan't to immediately recompute.\n\nfunction propagateMaybeChanged(observable) {\n  // invariantLOS(observable, \"maybe start\");\n  if (observable.lowestObserverState_ !== IDerivationState_.UP_TO_DATE_) {\n    return;\n  }\n\n  observable.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_;\n  observable.observers_.forEach(function (d) {\n    if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {\n      d.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_;\n      d.onBecomeStale_();\n    }\n  }); // invariantLOS(observable, \"maybe end\");\n}\n\nfunction logTraceInfo(derivation, observable) {\n  console.log(\"[mobx.trace] '\" + derivation.name_ + \"' is invalidated due to a change in: '\" + observable.name_ + \"'\");\n\n  if (derivation.isTracing_ === TraceMode.BREAK) {\n    var lines = [];\n    printDepTree(getDependencyTree(derivation), lines, 1); // prettier-ignore\n\n    new Function(\"debugger;\\n/*\\nTracing '\" + derivation.name_ + \"'\\n\\nYou are entering this break point because derivation '\" + derivation.name_ + \"' is being traced and '\" + observable.name_ + \"' is now forcing it to update.\\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\\n\\n\" + (derivation instanceof ComputedValue ? derivation.derivation.toString().replace(/[*]\\//g, \"/\") : \"\") + \"\\n\\nThe dependencies for this derivation are:\\n\\n\" + lines.join(\"\\n\") + \"\\n*/\\n    \")();\n  }\n}\n\nfunction printDepTree(tree, lines, depth) {\n  if (lines.length >= 1000) {\n    lines.push(\"(and many more)\");\n    return;\n  }\n\n  lines.push(\"\" + \"\\t\".repeat(depth - 1) + tree.name);\n\n  if (tree.dependencies) {\n    tree.dependencies.forEach(function (child) {\n      return printDepTree(child, lines, depth + 1);\n    });\n  }\n}\n\nvar Reaction = /*#__PURE__*/function () {\n  // nodes we are looking at. Our value depends on these nodes\n  function Reaction(name_, onInvalidate_, errorHandler_, requiresObservable_) {\n    if (name_ === void 0) {\n      name_ =  true ? \"Reaction@\" + getNextId() : 0;\n    }\n\n    this.name_ = void 0;\n    this.onInvalidate_ = void 0;\n    this.errorHandler_ = void 0;\n    this.requiresObservable_ = void 0;\n    this.observing_ = [];\n    this.newObserving_ = [];\n    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;\n    this.diffValue_ = 0;\n    this.runId_ = 0;\n    this.unboundDepsCount_ = 0;\n    this.isDisposed_ = false;\n    this.isScheduled_ = false;\n    this.isTrackPending_ = false;\n    this.isRunning_ = false;\n    this.isTracing_ = TraceMode.NONE;\n    this.name_ = name_;\n    this.onInvalidate_ = onInvalidate_;\n    this.errorHandler_ = errorHandler_;\n    this.requiresObservable_ = requiresObservable_;\n  }\n\n  var _proto = Reaction.prototype;\n\n  _proto.onBecomeStale_ = function onBecomeStale_() {\n    this.schedule_();\n  };\n\n  _proto.schedule_ = function schedule_() {\n    if (!this.isScheduled_) {\n      this.isScheduled_ = true;\n      globalState.pendingReactions.push(this);\n      runReactions();\n    }\n  };\n\n  _proto.isScheduled = function isScheduled() {\n    return this.isScheduled_;\n  }\n  /**\r\n   * internal, use schedule() if you intend to kick off a reaction\r\n   */\n  ;\n\n  _proto.runReaction_ = function runReaction_() {\n    if (!this.isDisposed_) {\n      startBatch();\n      this.isScheduled_ = false;\n      var prev = globalState.trackingContext;\n      globalState.trackingContext = this;\n\n      if (shouldCompute(this)) {\n        this.isTrackPending_ = true;\n\n        try {\n          this.onInvalidate_();\n\n          if ( true && this.isTrackPending_ && isSpyEnabled()) {\n            // onInvalidate didn't trigger track right away..\n            spyReport({\n              name: this.name_,\n              type: \"scheduled-reaction\"\n            });\n          }\n        } catch (e) {\n          this.reportExceptionInDerivation_(e);\n        }\n      }\n\n      globalState.trackingContext = prev;\n      endBatch();\n    }\n  };\n\n  _proto.track = function track(fn) {\n    if (this.isDisposed_) {\n      return; // console.warn(\"Reaction already disposed\") // Note: Not a warning / error in mobx 4 either\n    }\n\n    startBatch();\n    var notify = isSpyEnabled();\n    var startTime;\n\n    if ( true && notify) {\n      startTime = Date.now();\n      spyReportStart({\n        name: this.name_,\n        type: \"reaction\"\n      });\n    }\n\n    this.isRunning_ = true;\n    var prevReaction = globalState.trackingContext; // reactions could create reactions...\n\n    globalState.trackingContext = this;\n    var result = trackDerivedFunction(this, fn, undefined);\n    globalState.trackingContext = prevReaction;\n    this.isRunning_ = false;\n    this.isTrackPending_ = false;\n\n    if (this.isDisposed_) {\n      // disposed during last run. Clean up everything that was bound after the dispose call.\n      clearObserving(this);\n    }\n\n    if (isCaughtException(result)) {\n      this.reportExceptionInDerivation_(result.cause);\n    }\n\n    if ( true && notify) {\n      spyReportEnd({\n        time: Date.now() - startTime\n      });\n    }\n\n    endBatch();\n  };\n\n  _proto.reportExceptionInDerivation_ = function reportExceptionInDerivation_(error) {\n    var _this = this;\n\n    if (this.errorHandler_) {\n      this.errorHandler_(error, this);\n      return;\n    }\n\n    if (globalState.disableErrorBoundaries) {\n      throw error;\n    }\n\n    var message =  true ? \"[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '\" + this + \"'\" : 0;\n\n    if (!globalState.suppressReactionErrors) {\n      console.error(message, error);\n      /** If debugging brought you here, please, read the above message :-). Tnx! */\n    } else if (true) {\n      console.warn(\"[mobx] (error in reaction '\" + this.name_ + \"' suppressed, fix error of causing action below)\");\n    } // prettier-ignore\n\n\n    if ( true && isSpyEnabled()) {\n      spyReport({\n        type: \"error\",\n        name: this.name_,\n        message: message,\n        error: \"\" + error\n      });\n    }\n\n    globalState.globalReactionErrorHandlers.forEach(function (f) {\n      return f(error, _this);\n    });\n  };\n\n  _proto.dispose = function dispose() {\n    if (!this.isDisposed_) {\n      this.isDisposed_ = true;\n\n      if (!this.isRunning_) {\n        // if disposed while running, clean up later. Maybe not optimal, but rare case\n        startBatch();\n        clearObserving(this);\n        endBatch();\n      }\n    }\n  };\n\n  _proto.getDisposer_ = function getDisposer_() {\n    var r = this.dispose.bind(this);\n    r[$mobx] = this;\n    return r;\n  };\n\n  _proto.toString = function toString() {\n    return \"Reaction[\" + this.name_ + \"]\";\n  };\n\n  _proto.trace = function trace$1(enterBreakPoint) {\n    if (enterBreakPoint === void 0) {\n      enterBreakPoint = false;\n    }\n\n    trace(this, enterBreakPoint);\n  };\n\n  return Reaction;\n}();\nfunction onReactionError(handler) {\n  globalState.globalReactionErrorHandlers.push(handler);\n  return function () {\n    var idx = globalState.globalReactionErrorHandlers.indexOf(handler);\n\n    if (idx >= 0) {\n      globalState.globalReactionErrorHandlers.splice(idx, 1);\n    }\n  };\n}\n/**\r\n * Magic number alert!\r\n * Defines within how many times a reaction is allowed to re-trigger itself\r\n * until it is assumed that this is gonna be a never ending loop...\r\n */\n\nvar MAX_REACTION_ITERATIONS = 100;\n\nvar reactionScheduler = function reactionScheduler(f) {\n  return f();\n};\n\nfunction runReactions() {\n  // Trampolining, if runReactions are already running, new reactions will be picked up\n  if (globalState.inBatch > 0 || globalState.isRunningReactions) {\n    return;\n  }\n\n  reactionScheduler(runReactionsHelper);\n}\n\nfunction runReactionsHelper() {\n  globalState.isRunningReactions = true;\n  var allReactions = globalState.pendingReactions;\n  var iterations = 0; // While running reactions, new reactions might be triggered.\n  // Hence we work with two variables and check whether\n  // we converge to no remaining reactions after a while.\n\n  while (allReactions.length > 0) {\n    if (++iterations === MAX_REACTION_ITERATIONS) {\n      console.error( true ? \"Reaction doesn't converge to a stable state after \" + MAX_REACTION_ITERATIONS + \" iterations.\" + (\" Probably there is a cycle in the reactive function: \" + allReactions[0]) : 0);\n      allReactions.splice(0); // clear reactions\n    }\n\n    var remainingReactions = allReactions.splice(0);\n\n    for (var i = 0, l = remainingReactions.length; i < l; i++) {\n      remainingReactions[i].runReaction_();\n    }\n  }\n\n  globalState.isRunningReactions = false;\n}\n\nvar isReaction = /*#__PURE__*/createInstanceofPredicate(\"Reaction\", Reaction);\nfunction setReactionScheduler(fn) {\n  var baseScheduler = reactionScheduler;\n\n  reactionScheduler = function reactionScheduler(f) {\n    return fn(function () {\n      return baseScheduler(f);\n    });\n  };\n}\n\nfunction isSpyEnabled() {\n  return  true && !!globalState.spyListeners.length;\n}\nfunction spyReport(event) {\n  if (false) {} // dead code elimination can do the rest\n\n\n  if (!globalState.spyListeners.length) {\n    return;\n  }\n\n  var listeners = globalState.spyListeners;\n\n  for (var i = 0, l = listeners.length; i < l; i++) {\n    listeners[i](event);\n  }\n}\nfunction spyReportStart(event) {\n  if (false) {}\n\n  var change = _extends({}, event, {\n    spyReportStart: true\n  });\n\n  spyReport(change);\n}\nvar END_EVENT = {\n  type: \"report-end\",\n  spyReportEnd: true\n};\nfunction spyReportEnd(change) {\n  if (false) {}\n\n  if (change) {\n    spyReport(_extends({}, change, {\n      type: \"report-end\",\n      spyReportEnd: true\n    }));\n  } else {\n    spyReport(END_EVENT);\n  }\n}\nfunction spy(listener) {\n  if (false) {} else {\n    globalState.spyListeners.push(listener);\n    return once(function () {\n      globalState.spyListeners = globalState.spyListeners.filter(function (l) {\n        return l !== listener;\n      });\n    });\n  }\n}\n\nvar ACTION = \"action\";\nvar ACTION_BOUND = \"action.bound\";\nvar AUTOACTION = \"autoAction\";\nvar AUTOACTION_BOUND = \"autoAction.bound\";\nvar DEFAULT_ACTION_NAME = \"<unnamed action>\";\nvar actionAnnotation = /*#__PURE__*/createActionAnnotation(ACTION);\nvar actionBoundAnnotation = /*#__PURE__*/createActionAnnotation(ACTION_BOUND, {\n  bound: true\n});\nvar autoActionAnnotation = /*#__PURE__*/createActionAnnotation(AUTOACTION, {\n  autoAction: true\n});\nvar autoActionBoundAnnotation = /*#__PURE__*/createActionAnnotation(AUTOACTION_BOUND, {\n  autoAction: true,\n  bound: true\n});\n\nfunction createActionFactory(autoAction) {\n  var res = function action(arg1, arg2) {\n    // action(fn() {})\n    if (isFunction(arg1)) {\n      return createAction(arg1.name || DEFAULT_ACTION_NAME, arg1, autoAction);\n    } // action(\"name\", fn() {})\n\n\n    if (isFunction(arg2)) {\n      return createAction(arg1, arg2, autoAction);\n    } // @action\n\n\n    if (isStringish(arg2)) {\n      return storeAnnotation(arg1, arg2, autoAction ? autoActionAnnotation : actionAnnotation);\n    } // action(\"name\") & @action(\"name\")\n\n\n    if (isStringish(arg1)) {\n      return createDecoratorAnnotation(createActionAnnotation(autoAction ? AUTOACTION : ACTION, {\n        name: arg1,\n        autoAction: autoAction\n      }));\n    }\n\n    if (true) {\n      die(\"Invalid arguments for `action`\");\n    }\n  };\n\n  return res;\n}\n\nvar action = /*#__PURE__*/createActionFactory(false);\nObject.assign(action, actionAnnotation);\nvar autoAction = /*#__PURE__*/createActionFactory(true);\nObject.assign(autoAction, autoActionAnnotation);\naction.bound = /*#__PURE__*/createDecoratorAnnotation(actionBoundAnnotation);\nautoAction.bound = /*#__PURE__*/createDecoratorAnnotation(autoActionBoundAnnotation);\nfunction runInAction(fn) {\n  return executeAction(fn.name || DEFAULT_ACTION_NAME, false, fn, this, undefined);\n}\nfunction isAction(thing) {\n  return isFunction(thing) && thing.isMobxAction === true;\n}\n\n/**\r\n * Creates a named reactive view and keeps it alive, so that the view is always\r\n * updated if one of the dependencies changes, even when the view is not further used by something else.\r\n * @param view The reactive view\r\n * @returns disposer function, which can be used to stop the view from being updated in the future.\r\n */\n\nfunction autorun(view, opts) {\n  var _opts$name, _opts;\n\n  if (opts === void 0) {\n    opts = EMPTY_OBJECT;\n  }\n\n  if (true) {\n    if (!isFunction(view)) {\n      die(\"Autorun expects a function as first argument\");\n    }\n\n    if (isAction(view)) {\n      die(\"Autorun does not accept actions since actions are untrackable\");\n    }\n  }\n\n  var name = (_opts$name = (_opts = opts) == null ? void 0 : _opts.name) != null ? _opts$name :  true ? view.name || \"Autorun@\" + getNextId() : 0;\n  var runSync = !opts.scheduler && !opts.delay;\n  var reaction;\n\n  if (runSync) {\n    // normal autorun\n    reaction = new Reaction(name, function () {\n      this.track(reactionRunner);\n    }, opts.onError, opts.requiresObservable);\n  } else {\n    var scheduler = createSchedulerFromOptions(opts); // debounced autorun\n\n    var isScheduled = false;\n    reaction = new Reaction(name, function () {\n      if (!isScheduled) {\n        isScheduled = true;\n        scheduler(function () {\n          isScheduled = false;\n\n          if (!reaction.isDisposed_) {\n            reaction.track(reactionRunner);\n          }\n        });\n      }\n    }, opts.onError, opts.requiresObservable);\n  }\n\n  function reactionRunner() {\n    view(reaction);\n  }\n\n  reaction.schedule_();\n  return reaction.getDisposer_();\n}\n\nvar run = function run(f) {\n  return f();\n};\n\nfunction createSchedulerFromOptions(opts) {\n  return opts.scheduler ? opts.scheduler : opts.delay ? function (f) {\n    return setTimeout(f, opts.delay);\n  } : run;\n}\n\nfunction reaction(expression, effect, opts) {\n  var _opts$name2;\n\n  if (opts === void 0) {\n    opts = EMPTY_OBJECT;\n  }\n\n  if (true) {\n    if (!isFunction(expression) || !isFunction(effect)) {\n      die(\"First and second argument to reaction should be functions\");\n    }\n\n    if (!isPlainObject(opts)) {\n      die(\"Third argument of reactions should be an object\");\n    }\n  }\n\n  var name = (_opts$name2 = opts.name) != null ? _opts$name2 :  true ? \"Reaction@\" + getNextId() : 0;\n  var effectAction = action(name, opts.onError ? wrapErrorHandler(opts.onError, effect) : effect);\n  var runSync = !opts.scheduler && !opts.delay;\n  var scheduler = createSchedulerFromOptions(opts);\n  var firstTime = true;\n  var isScheduled = false;\n  var value;\n  var oldValue;\n  var equals = opts.compareStructural ? comparer.structural : opts.equals || comparer[\"default\"];\n  var r = new Reaction(name, function () {\n    if (firstTime || runSync) {\n      reactionRunner();\n    } else if (!isScheduled) {\n      isScheduled = true;\n      scheduler(reactionRunner);\n    }\n  }, opts.onError, opts.requiresObservable);\n\n  function reactionRunner() {\n    isScheduled = false;\n\n    if (r.isDisposed_) {\n      return;\n    }\n\n    var changed = false;\n    r.track(function () {\n      var nextValue = allowStateChanges(false, function () {\n        return expression(r);\n      });\n      changed = firstTime || !equals(value, nextValue);\n      oldValue = value;\n      value = nextValue;\n    });\n\n    if (firstTime && opts.fireImmediately) {\n      effectAction(value, oldValue, r);\n    } else if (!firstTime && changed) {\n      effectAction(value, oldValue, r);\n    }\n\n    firstTime = false;\n  }\n\n  r.schedule_();\n  return r.getDisposer_();\n}\n\nfunction wrapErrorHandler(errorHandler, baseFn) {\n  return function () {\n    try {\n      return baseFn.apply(this, arguments);\n    } catch (e) {\n      errorHandler.call(this, e);\n    }\n  };\n}\n\nvar ON_BECOME_OBSERVED = \"onBO\";\nvar ON_BECOME_UNOBSERVED = \"onBUO\";\nfunction onBecomeObserved(thing, arg2, arg3) {\n  return interceptHook(ON_BECOME_OBSERVED, thing, arg2, arg3);\n}\nfunction onBecomeUnobserved(thing, arg2, arg3) {\n  return interceptHook(ON_BECOME_UNOBSERVED, thing, arg2, arg3);\n}\n\nfunction interceptHook(hook, thing, arg2, arg3) {\n  var atom = typeof arg3 === \"function\" ? getAtom(thing, arg2) : getAtom(thing);\n  var cb = isFunction(arg3) ? arg3 : arg2;\n  var listenersKey = hook + \"L\";\n\n  if (atom[listenersKey]) {\n    atom[listenersKey].add(cb);\n  } else {\n    atom[listenersKey] = new Set([cb]);\n  }\n\n  return function () {\n    var hookListeners = atom[listenersKey];\n\n    if (hookListeners) {\n      hookListeners[\"delete\"](cb);\n\n      if (hookListeners.size === 0) {\n        delete atom[listenersKey];\n      }\n    }\n  };\n}\n\nvar NEVER = \"never\";\nvar ALWAYS = \"always\";\nvar OBSERVED = \"observed\"; // const IF_AVAILABLE = \"ifavailable\"\n\nfunction configure(options) {\n  if (options.isolateGlobalState === true) {\n    isolateGlobalState();\n  }\n\n  var useProxies = options.useProxies,\n      enforceActions = options.enforceActions;\n\n  if (useProxies !== undefined) {\n    globalState.useProxies = useProxies === ALWAYS ? true : useProxies === NEVER ? false : typeof Proxy !== \"undefined\";\n  }\n\n  if (useProxies === \"ifavailable\") {\n    globalState.verifyProxies = true;\n  }\n\n  if (enforceActions !== undefined) {\n    var ea = enforceActions === ALWAYS ? ALWAYS : enforceActions === OBSERVED;\n    globalState.enforceActions = ea;\n    globalState.allowStateChanges = ea === true || ea === ALWAYS ? false : true;\n  }\n  [\"computedRequiresReaction\", \"reactionRequiresObservable\", \"observableRequiresReaction\", \"disableErrorBoundaries\", \"safeDescriptors\"].forEach(function (key) {\n    if (key in options) {\n      globalState[key] = !!options[key];\n    }\n  });\n  globalState.allowStateReads = !globalState.observableRequiresReaction;\n\n  if ( true && globalState.disableErrorBoundaries === true) {\n    console.warn(\"WARNING: Debug feature only. MobX will NOT recover from errors when `disableErrorBoundaries` is enabled.\");\n  }\n\n  if (options.reactionScheduler) {\n    setReactionScheduler(options.reactionScheduler);\n  }\n}\n\nfunction extendObservable(target, properties, annotations, options) {\n  if (true) {\n    if (arguments.length > 4) {\n      die(\"'extendObservable' expected 2-4 arguments\");\n    }\n\n    if (typeof target !== \"object\") {\n      die(\"'extendObservable' expects an object as first argument\");\n    }\n\n    if (isObservableMap(target)) {\n      die(\"'extendObservable' should not be used on maps, use map.merge instead\");\n    }\n\n    if (!isPlainObject(properties)) {\n      die(\"'extendObservable' only accepts plain objects as second argument\");\n    }\n\n    if (isObservable(properties) || isObservable(annotations)) {\n      die(\"Extending an object with another observable (object) is not supported\");\n    }\n  } // Pull descriptors first, so we don't have to deal with props added by administration ($mobx)\n\n\n  var descriptors = getOwnPropertyDescriptors(properties);\n  var adm = asObservableObject(target, options)[$mobx];\n  startBatch();\n\n  try {\n    ownKeys(descriptors).forEach(function (key) {\n      adm.extend_(key, descriptors[key], // must pass \"undefined\" for { key: undefined }\n      !annotations ? true : key in annotations ? annotations[key] : true);\n    });\n  } finally {\n    endBatch();\n  }\n\n  return target;\n}\n\nfunction getDependencyTree(thing, property) {\n  return nodeToDependencyTree(getAtom(thing, property));\n}\n\nfunction nodeToDependencyTree(node) {\n  var result = {\n    name: node.name_\n  };\n\n  if (node.observing_ && node.observing_.length > 0) {\n    result.dependencies = unique(node.observing_).map(nodeToDependencyTree);\n  }\n\n  return result;\n}\n\nfunction getObserverTree(thing, property) {\n  return nodeToObserverTree(getAtom(thing, property));\n}\n\nfunction nodeToObserverTree(node) {\n  var result = {\n    name: node.name_\n  };\n\n  if (hasObservers(node)) {\n    result.observers = Array.from(getObservers(node)).map(nodeToObserverTree);\n  }\n\n  return result;\n}\n\nfunction unique(list) {\n  return Array.from(new Set(list));\n}\n\nvar generatorId = 0;\nfunction FlowCancellationError() {\n  this.message = \"FLOW_CANCELLED\";\n}\nFlowCancellationError.prototype = /*#__PURE__*/Object.create(Error.prototype);\nfunction isFlowCancellationError(error) {\n  return error instanceof FlowCancellationError;\n}\nvar flowAnnotation = /*#__PURE__*/createFlowAnnotation(\"flow\");\nvar flowBoundAnnotation = /*#__PURE__*/createFlowAnnotation(\"flow.bound\", {\n  bound: true\n});\nvar flow = /*#__PURE__*/Object.assign(function flow(arg1, arg2) {\n  // @flow\n  if (isStringish(arg2)) {\n    return storeAnnotation(arg1, arg2, flowAnnotation);\n  } // flow(fn)\n\n\n  if ( true && arguments.length !== 1) {\n    die(\"Flow expects single argument with generator function\");\n  }\n\n  var generator = arg1;\n  var name = generator.name || \"<unnamed flow>\"; // Implementation based on https://github.com/tj/co/blob/master/index.js\n\n  var res = function res() {\n    var ctx = this;\n    var args = arguments;\n    var runId = ++generatorId;\n    var gen = action(name + \" - runid: \" + runId + \" - init\", generator).apply(ctx, args);\n    var rejector;\n    var pendingPromise = undefined;\n    var promise = new Promise(function (resolve, reject) {\n      var stepId = 0;\n      rejector = reject;\n\n      function onFulfilled(res) {\n        pendingPromise = undefined;\n        var ret;\n\n        try {\n          ret = action(name + \" - runid: \" + runId + \" - yield \" + stepId++, gen.next).call(gen, res);\n        } catch (e) {\n          return reject(e);\n        }\n\n        next(ret);\n      }\n\n      function onRejected(err) {\n        pendingPromise = undefined;\n        var ret;\n\n        try {\n          ret = action(name + \" - runid: \" + runId + \" - yield \" + stepId++, gen[\"throw\"]).call(gen, err);\n        } catch (e) {\n          return reject(e);\n        }\n\n        next(ret);\n      }\n\n      function next(ret) {\n        if (isFunction(ret == null ? void 0 : ret.then)) {\n          // an async iterator\n          ret.then(next, reject);\n          return;\n        }\n\n        if (ret.done) {\n          return resolve(ret.value);\n        }\n\n        pendingPromise = Promise.resolve(ret.value);\n        return pendingPromise.then(onFulfilled, onRejected);\n      }\n\n      onFulfilled(undefined); // kick off the process\n    });\n    promise.cancel = action(name + \" - runid: \" + runId + \" - cancel\", function () {\n      try {\n        if (pendingPromise) {\n          cancelPromise(pendingPromise);\n        } // Finally block can return (or yield) stuff..\n\n\n        var _res = gen[\"return\"](undefined); // eat anything that promise would do, it's cancelled!\n\n\n        var yieldedPromise = Promise.resolve(_res.value);\n        yieldedPromise.then(noop, noop);\n        cancelPromise(yieldedPromise); // maybe it can be cancelled :)\n        // reject our original promise\n\n        rejector(new FlowCancellationError());\n      } catch (e) {\n        rejector(e); // there could be a throwing finally block\n      }\n    });\n    return promise;\n  };\n\n  res.isMobXFlow = true;\n  return res;\n}, flowAnnotation);\nflow.bound = /*#__PURE__*/createDecoratorAnnotation(flowBoundAnnotation);\n\nfunction cancelPromise(promise) {\n  if (isFunction(promise.cancel)) {\n    promise.cancel();\n  }\n}\n\nfunction flowResult(result) {\n  return result; // just tricking TypeScript :)\n}\nfunction isFlow(fn) {\n  return (fn == null ? void 0 : fn.isMobXFlow) === true;\n}\n\nfunction interceptReads(thing, propOrHandler, handler) {\n  var target;\n\n  if (isObservableMap(thing) || isObservableArray(thing) || isObservableValue(thing)) {\n    target = getAdministration(thing);\n  } else if (isObservableObject(thing)) {\n    if ( true && !isStringish(propOrHandler)) {\n      return die(\"InterceptReads can only be used with a specific property, not with an object in general\");\n    }\n\n    target = getAdministration(thing, propOrHandler);\n  } else if (true) {\n    return die(\"Expected observable map, object or array as first array\");\n  }\n\n  if ( true && target.dehancer !== undefined) {\n    return die(\"An intercept reader was already established\");\n  }\n\n  target.dehancer = typeof propOrHandler === \"function\" ? propOrHandler : handler;\n  return function () {\n    target.dehancer = undefined;\n  };\n}\n\nfunction intercept(thing, propOrHandler, handler) {\n  if (isFunction(handler)) {\n    return interceptProperty(thing, propOrHandler, handler);\n  } else {\n    return interceptInterceptable(thing, propOrHandler);\n  }\n}\n\nfunction interceptInterceptable(thing, handler) {\n  return getAdministration(thing).intercept_(handler);\n}\n\nfunction interceptProperty(thing, property, handler) {\n  return getAdministration(thing, property).intercept_(handler);\n}\n\nfunction _isComputed(value, property) {\n  if (property === undefined) {\n    return isComputedValue(value);\n  }\n\n  if (isObservableObject(value) === false) {\n    return false;\n  }\n\n  if (!value[$mobx].values_.has(property)) {\n    return false;\n  }\n\n  var atom = getAtom(value, property);\n  return isComputedValue(atom);\n}\nfunction isComputed(value) {\n  if ( true && arguments.length > 1) {\n    return die(\"isComputed expects only 1 argument. Use isComputedProp to inspect the observability of a property\");\n  }\n\n  return _isComputed(value);\n}\nfunction isComputedProp(value, propName) {\n  if ( true && !isStringish(propName)) {\n    return die(\"isComputed expected a property name as second argument\");\n  }\n\n  return _isComputed(value, propName);\n}\n\nfunction _isObservable(value, property) {\n  if (!value) {\n    return false;\n  }\n\n  if (property !== undefined) {\n    if ( true && (isObservableMap(value) || isObservableArray(value))) {\n      return die(\"isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.\");\n    }\n\n    if (isObservableObject(value)) {\n      return value[$mobx].values_.has(property);\n    }\n\n    return false;\n  } // For first check, see #701\n\n\n  return isObservableObject(value) || !!value[$mobx] || isAtom(value) || isReaction(value) || isComputedValue(value);\n}\n\nfunction isObservable(value) {\n  if ( true && arguments.length !== 1) {\n    die(\"isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property\");\n  }\n\n  return _isObservable(value);\n}\nfunction isObservableProp(value, propName) {\n  if ( true && !isStringish(propName)) {\n    return die(\"expected a property name as second argument\");\n  }\n\n  return _isObservable(value, propName);\n}\n\nfunction keys(obj) {\n  if (isObservableObject(obj)) {\n    return obj[$mobx].keys_();\n  }\n\n  if (isObservableMap(obj) || isObservableSet(obj)) {\n    return Array.from(obj.keys());\n  }\n\n  if (isObservableArray(obj)) {\n    return obj.map(function (_, index) {\n      return index;\n    });\n  }\n\n  die(5);\n}\nfunction values(obj) {\n  if (isObservableObject(obj)) {\n    return keys(obj).map(function (key) {\n      return obj[key];\n    });\n  }\n\n  if (isObservableMap(obj)) {\n    return keys(obj).map(function (key) {\n      return obj.get(key);\n    });\n  }\n\n  if (isObservableSet(obj)) {\n    return Array.from(obj.values());\n  }\n\n  if (isObservableArray(obj)) {\n    return obj.slice();\n  }\n\n  die(6);\n}\nfunction entries(obj) {\n  if (isObservableObject(obj)) {\n    return keys(obj).map(function (key) {\n      return [key, obj[key]];\n    });\n  }\n\n  if (isObservableMap(obj)) {\n    return keys(obj).map(function (key) {\n      return [key, obj.get(key)];\n    });\n  }\n\n  if (isObservableSet(obj)) {\n    return Array.from(obj.entries());\n  }\n\n  if (isObservableArray(obj)) {\n    return obj.map(function (key, index) {\n      return [index, key];\n    });\n  }\n\n  die(7);\n}\nfunction set(obj, key, value) {\n  if (arguments.length === 2 && !isObservableSet(obj)) {\n    startBatch();\n    var _values = key;\n\n    try {\n      for (var _key in _values) {\n        set(obj, _key, _values[_key]);\n      }\n    } finally {\n      endBatch();\n    }\n\n    return;\n  }\n\n  if (isObservableObject(obj)) {\n    obj[$mobx].set_(key, value);\n  } else if (isObservableMap(obj)) {\n    obj.set(key, value);\n  } else if (isObservableSet(obj)) {\n    obj.add(key);\n  } else if (isObservableArray(obj)) {\n    if (typeof key !== \"number\") {\n      key = parseInt(key, 10);\n    }\n\n    if (key < 0) {\n      die(\"Invalid index: '\" + key + \"'\");\n    }\n\n    startBatch();\n\n    if (key >= obj.length) {\n      obj.length = key + 1;\n    }\n\n    obj[key] = value;\n    endBatch();\n  } else {\n    die(8);\n  }\n}\nfunction remove(obj, key) {\n  if (isObservableObject(obj)) {\n    obj[$mobx].delete_(key);\n  } else if (isObservableMap(obj)) {\n    obj[\"delete\"](key);\n  } else if (isObservableSet(obj)) {\n    obj[\"delete\"](key);\n  } else if (isObservableArray(obj)) {\n    if (typeof key !== \"number\") {\n      key = parseInt(key, 10);\n    }\n\n    obj.splice(key, 1);\n  } else {\n    die(9);\n  }\n}\nfunction has(obj, key) {\n  if (isObservableObject(obj)) {\n    return obj[$mobx].has_(key);\n  } else if (isObservableMap(obj)) {\n    return obj.has(key);\n  } else if (isObservableSet(obj)) {\n    return obj.has(key);\n  } else if (isObservableArray(obj)) {\n    return key >= 0 && key < obj.length;\n  }\n\n  die(10);\n}\nfunction get(obj, key) {\n  if (!has(obj, key)) {\n    return undefined;\n  }\n\n  if (isObservableObject(obj)) {\n    return obj[$mobx].get_(key);\n  } else if (isObservableMap(obj)) {\n    return obj.get(key);\n  } else if (isObservableArray(obj)) {\n    return obj[key];\n  }\n\n  die(11);\n}\nfunction apiDefineProperty(obj, key, descriptor) {\n  if (isObservableObject(obj)) {\n    return obj[$mobx].defineProperty_(key, descriptor);\n  }\n\n  die(39);\n}\nfunction apiOwnKeys(obj) {\n  if (isObservableObject(obj)) {\n    return obj[$mobx].ownKeys_();\n  }\n\n  die(38);\n}\n\nfunction observe(thing, propOrCb, cbOrFire, fireImmediately) {\n  if (isFunction(cbOrFire)) {\n    return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);\n  } else {\n    return observeObservable(thing, propOrCb, cbOrFire);\n  }\n}\n\nfunction observeObservable(thing, listener, fireImmediately) {\n  return getAdministration(thing).observe_(listener, fireImmediately);\n}\n\nfunction observeObservableProperty(thing, property, listener, fireImmediately) {\n  return getAdministration(thing, property).observe_(listener, fireImmediately);\n}\n\nfunction cache(map, key, value) {\n  map.set(key, value);\n  return value;\n}\n\nfunction toJSHelper(source, __alreadySeen) {\n  if (source == null || typeof source !== \"object\" || source instanceof Date || !isObservable(source)) {\n    return source;\n  }\n\n  if (isObservableValue(source) || isComputedValue(source)) {\n    return toJSHelper(source.get(), __alreadySeen);\n  }\n\n  if (__alreadySeen.has(source)) {\n    return __alreadySeen.get(source);\n  }\n\n  if (isObservableArray(source)) {\n    var res = cache(__alreadySeen, source, new Array(source.length));\n    source.forEach(function (value, idx) {\n      res[idx] = toJSHelper(value, __alreadySeen);\n    });\n    return res;\n  }\n\n  if (isObservableSet(source)) {\n    var _res = cache(__alreadySeen, source, new Set());\n\n    source.forEach(function (value) {\n      _res.add(toJSHelper(value, __alreadySeen));\n    });\n    return _res;\n  }\n\n  if (isObservableMap(source)) {\n    var _res2 = cache(__alreadySeen, source, new Map());\n\n    source.forEach(function (value, key) {\n      _res2.set(key, toJSHelper(value, __alreadySeen));\n    });\n    return _res2;\n  } else {\n    // must be observable object\n    var _res3 = cache(__alreadySeen, source, {});\n\n    apiOwnKeys(source).forEach(function (key) {\n      if (objectPrototype.propertyIsEnumerable.call(source, key)) {\n        _res3[key] = toJSHelper(source[key], __alreadySeen);\n      }\n    });\n    return _res3;\n  }\n}\n/**\r\n * Recursively converts an observable to it's non-observable native counterpart.\r\n * It does NOT recurse into non-observables, these are left as they are, even if they contain observables.\r\n * Computed and other non-enumerable properties are completely ignored.\r\n * Complex scenarios require custom solution, eg implementing `toJSON` or using `serializr` lib.\r\n */\n\n\nfunction toJS(source, options) {\n  if ( true && options) {\n    die(\"toJS no longer supports options\");\n  }\n\n  return toJSHelper(source, new Map());\n}\n\nfunction trace() {\n  if (false) {}\n\n  var enterBreakPoint = false;\n\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  if (typeof args[args.length - 1] === \"boolean\") {\n    enterBreakPoint = args.pop();\n  }\n\n  var derivation = getAtomFromArgs(args);\n\n  if (!derivation) {\n    return die(\"'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly\");\n  }\n\n  if (derivation.isTracing_ === TraceMode.NONE) {\n    console.log(\"[mobx.trace] '\" + derivation.name_ + \"' tracing enabled\");\n  }\n\n  derivation.isTracing_ = enterBreakPoint ? TraceMode.BREAK : TraceMode.LOG;\n}\n\nfunction getAtomFromArgs(args) {\n  switch (args.length) {\n    case 0:\n      return globalState.trackingDerivation;\n\n    case 1:\n      return getAtom(args[0]);\n\n    case 2:\n      return getAtom(args[0], args[1]);\n  }\n}\n\n/**\r\n * During a transaction no views are updated until the end of the transaction.\r\n * The transaction will be run synchronously nonetheless.\r\n *\r\n * @param action a function that updates some reactive state\r\n * @returns any value that was returned by the 'action' parameter.\r\n */\n\nfunction transaction(action, thisArg) {\n  if (thisArg === void 0) {\n    thisArg = undefined;\n  }\n\n  startBatch();\n\n  try {\n    return action.apply(thisArg);\n  } finally {\n    endBatch();\n  }\n}\n\nfunction when(predicate, arg1, arg2) {\n  if (arguments.length === 1 || arg1 && typeof arg1 === \"object\") {\n    return whenPromise(predicate, arg1);\n  }\n\n  return _when(predicate, arg1, arg2 || {});\n}\n\nfunction _when(predicate, effect, opts) {\n  var timeoutHandle;\n\n  if (typeof opts.timeout === \"number\") {\n    var error = new Error(\"WHEN_TIMEOUT\");\n    timeoutHandle = setTimeout(function () {\n      if (!disposer[$mobx].isDisposed_) {\n        disposer();\n\n        if (opts.onError) {\n          opts.onError(error);\n        } else {\n          throw error;\n        }\n      }\n    }, opts.timeout);\n  }\n\n  opts.name =  true ? opts.name || \"When@\" + getNextId() : 0;\n  var effectAction = createAction( true ? opts.name + \"-effect\" : 0, effect); // eslint-disable-next-line\n\n  var disposer = autorun(function (r) {\n    // predicate should not change state\n    var cond = allowStateChanges(false, predicate);\n\n    if (cond) {\n      r.dispose();\n\n      if (timeoutHandle) {\n        clearTimeout(timeoutHandle);\n      }\n\n      effectAction();\n    }\n  }, opts);\n  return disposer;\n}\n\nfunction whenPromise(predicate, opts) {\n  var _opts$signal;\n\n  if ( true && opts && opts.onError) {\n    return die(\"the options 'onError' and 'promise' cannot be combined\");\n  }\n\n  if (opts != null && (_opts$signal = opts.signal) != null && _opts$signal.aborted) {\n    return Object.assign(Promise.reject(new Error(\"WHEN_ABORTED\")), {\n      cancel: function cancel() {\n        return null;\n      }\n    });\n  }\n\n  var cancel;\n  var abort;\n  var res = new Promise(function (resolve, reject) {\n    var _opts$signal2;\n\n    var disposer = _when(predicate, resolve, _extends({}, opts, {\n      onError: reject\n    }));\n\n    cancel = function cancel() {\n      disposer();\n      reject(new Error(\"WHEN_CANCELLED\"));\n    };\n\n    abort = function abort() {\n      disposer();\n      reject(new Error(\"WHEN_ABORTED\"));\n    };\n\n    opts == null ? void 0 : (_opts$signal2 = opts.signal) == null ? void 0 : _opts$signal2.addEventListener(\"abort\", abort);\n  })[\"finally\"](function () {\n    var _opts$signal3;\n\n    return opts == null ? void 0 : (_opts$signal3 = opts.signal) == null ? void 0 : _opts$signal3.removeEventListener(\"abort\", abort);\n  });\n  res.cancel = cancel;\n  return res;\n}\n\nfunction getAdm(target) {\n  return target[$mobx];\n} // Optimization: we don't need the intermediate objects and could have a completely custom administration for DynamicObjects,\n// and skip either the internal values map, or the base object with its property descriptors!\n\n\nvar objectProxyTraps = {\n  has: function has(target, name) {\n    if ( true && globalState.trackingDerivation) {\n      warnAboutProxyRequirement(\"detect new properties using the 'in' operator. Use 'has' from 'mobx' instead.\");\n    }\n\n    return getAdm(target).has_(name);\n  },\n  get: function get(target, name) {\n    return getAdm(target).get_(name);\n  },\n  set: function set(target, name, value) {\n    var _getAdm$set_;\n\n    if (!isStringish(name)) {\n      return false;\n    }\n\n    if ( true && !getAdm(target).values_.has(name)) {\n      warnAboutProxyRequirement(\"add a new observable property through direct assignment. Use 'set' from 'mobx' instead.\");\n    } // null (intercepted) -> true (success)\n\n\n    return (_getAdm$set_ = getAdm(target).set_(name, value, true)) != null ? _getAdm$set_ : true;\n  },\n  deleteProperty: function deleteProperty(target, name) {\n    var _getAdm$delete_;\n\n    if (true) {\n      warnAboutProxyRequirement(\"delete properties from an observable object. Use 'remove' from 'mobx' instead.\");\n    }\n\n    if (!isStringish(name)) {\n      return false;\n    } // null (intercepted) -> true (success)\n\n\n    return (_getAdm$delete_ = getAdm(target).delete_(name, true)) != null ? _getAdm$delete_ : true;\n  },\n  defineProperty: function defineProperty(target, name, descriptor) {\n    var _getAdm$definePropert;\n\n    if (true) {\n      warnAboutProxyRequirement(\"define property on an observable object. Use 'defineProperty' from 'mobx' instead.\");\n    } // null (intercepted) -> true (success)\n\n\n    return (_getAdm$definePropert = getAdm(target).defineProperty_(name, descriptor)) != null ? _getAdm$definePropert : true;\n  },\n  ownKeys: function ownKeys(target) {\n    if ( true && globalState.trackingDerivation) {\n      warnAboutProxyRequirement(\"iterate keys to detect added / removed properties. Use 'keys' from 'mobx' instead.\");\n    }\n\n    return getAdm(target).ownKeys_();\n  },\n  preventExtensions: function preventExtensions(target) {\n    die(13);\n  }\n};\nfunction asDynamicObservableObject(target, options) {\n  var _target$$mobx, _target$$mobx$proxy_;\n\n  assertProxies();\n  target = asObservableObject(target, options);\n  return (_target$$mobx$proxy_ = (_target$$mobx = target[$mobx]).proxy_) != null ? _target$$mobx$proxy_ : _target$$mobx.proxy_ = new Proxy(target, objectProxyTraps);\n}\n\nfunction hasInterceptors(interceptable) {\n  return interceptable.interceptors_ !== undefined && interceptable.interceptors_.length > 0;\n}\nfunction registerInterceptor(interceptable, handler) {\n  var interceptors = interceptable.interceptors_ || (interceptable.interceptors_ = []);\n  interceptors.push(handler);\n  return once(function () {\n    var idx = interceptors.indexOf(handler);\n\n    if (idx !== -1) {\n      interceptors.splice(idx, 1);\n    }\n  });\n}\nfunction interceptChange(interceptable, change) {\n  var prevU = untrackedStart();\n\n  try {\n    // Interceptor can modify the array, copy it to avoid concurrent modification, see #1950\n    var interceptors = [].concat(interceptable.interceptors_ || []);\n\n    for (var i = 0, l = interceptors.length; i < l; i++) {\n      change = interceptors[i](change);\n\n      if (change && !change.type) {\n        die(14);\n      }\n\n      if (!change) {\n        break;\n      }\n    }\n\n    return change;\n  } finally {\n    untrackedEnd(prevU);\n  }\n}\n\nfunction hasListeners(listenable) {\n  return listenable.changeListeners_ !== undefined && listenable.changeListeners_.length > 0;\n}\nfunction registerListener(listenable, handler) {\n  var listeners = listenable.changeListeners_ || (listenable.changeListeners_ = []);\n  listeners.push(handler);\n  return once(function () {\n    var idx = listeners.indexOf(handler);\n\n    if (idx !== -1) {\n      listeners.splice(idx, 1);\n    }\n  });\n}\nfunction notifyListeners(listenable, change) {\n  var prevU = untrackedStart();\n  var listeners = listenable.changeListeners_;\n\n  if (!listeners) {\n    return;\n  }\n\n  listeners = listeners.slice();\n\n  for (var i = 0, l = listeners.length; i < l; i++) {\n    listeners[i](change);\n  }\n\n  untrackedEnd(prevU);\n}\n\nfunction makeObservable(target, annotations, options) {\n  var adm = asObservableObject(target, options)[$mobx];\n  startBatch();\n\n  try {\n    var _annotations;\n\n    if ( true && annotations && target[storedAnnotationsSymbol]) {\n      die(\"makeObservable second arg must be nullish when using decorators. Mixing @decorator syntax with annotations is not supported.\");\n    } // Default to decorators\n\n\n    (_annotations = annotations) != null ? _annotations : annotations = collectStoredAnnotations(target); // Annotate\n\n    ownKeys(annotations).forEach(function (key) {\n      return adm.make_(key, annotations[key]);\n    });\n  } finally {\n    endBatch();\n  }\n\n  return target;\n} // proto[keysSymbol] = new Set<PropertyKey>()\n\nvar keysSymbol = /*#__PURE__*/Symbol(\"mobx-keys\");\nfunction makeAutoObservable(target, overrides, options) {\n  if (true) {\n    if (!isPlainObject(target) && !isPlainObject(Object.getPrototypeOf(target))) {\n      die(\"'makeAutoObservable' can only be used for classes that don't have a superclass\");\n    }\n\n    if (isObservableObject(target)) {\n      die(\"makeAutoObservable can only be used on objects not already made observable\");\n    }\n  } // Optimization: avoid visiting protos\n  // Assumes that annotation.make_/.extend_ works the same for plain objects\n\n\n  if (isPlainObject(target)) {\n    return extendObservable(target, target, overrides, options);\n  }\n\n  var adm = asObservableObject(target, options)[$mobx]; // Optimization: cache keys on proto\n  // Assumes makeAutoObservable can be called only once per object and can't be used in subclass\n\n  if (!target[keysSymbol]) {\n    var proto = Object.getPrototypeOf(target);\n    var keys = new Set([].concat(ownKeys(target), ownKeys(proto)));\n    keys[\"delete\"](\"constructor\");\n    keys[\"delete\"]($mobx);\n    addHiddenProp(proto, keysSymbol, keys);\n  }\n\n  startBatch();\n\n  try {\n    target[keysSymbol].forEach(function (key) {\n      return adm.make_(key, // must pass \"undefined\" for { key: undefined }\n      !overrides ? true : key in overrides ? overrides[key] : true);\n    });\n  } finally {\n    endBatch();\n  }\n\n  return target;\n}\n\nvar SPLICE = \"splice\";\nvar UPDATE = \"update\";\nvar MAX_SPLICE_SIZE = 10000; // See e.g. https://github.com/mobxjs/mobx/issues/859\n\nvar arrayTraps = {\n  get: function get(target, name) {\n    var adm = target[$mobx];\n\n    if (name === $mobx) {\n      return adm;\n    }\n\n    if (name === \"length\") {\n      return adm.getArrayLength_();\n    }\n\n    if (typeof name === \"string\" && !isNaN(name)) {\n      return adm.get_(parseInt(name));\n    }\n\n    if (hasProp(arrayExtensions, name)) {\n      return arrayExtensions[name];\n    }\n\n    return target[name];\n  },\n  set: function set(target, name, value) {\n    var adm = target[$mobx];\n\n    if (name === \"length\") {\n      adm.setArrayLength_(value);\n    }\n\n    if (typeof name === \"symbol\" || isNaN(name)) {\n      target[name] = value;\n    } else {\n      // numeric string\n      adm.set_(parseInt(name), value);\n    }\n\n    return true;\n  },\n  preventExtensions: function preventExtensions() {\n    die(15);\n  }\n};\nvar ObservableArrayAdministration = /*#__PURE__*/function () {\n  // this is the prop that gets proxied, so can't replace it!\n  function ObservableArrayAdministration(name, enhancer, owned_, legacyMode_) {\n    if (name === void 0) {\n      name =  true ? \"ObservableArray@\" + getNextId() : 0;\n    }\n\n    this.owned_ = void 0;\n    this.legacyMode_ = void 0;\n    this.atom_ = void 0;\n    this.values_ = [];\n    this.interceptors_ = void 0;\n    this.changeListeners_ = void 0;\n    this.enhancer_ = void 0;\n    this.dehancer = void 0;\n    this.proxy_ = void 0;\n    this.lastKnownLength_ = 0;\n    this.owned_ = owned_;\n    this.legacyMode_ = legacyMode_;\n    this.atom_ = new Atom(name);\n\n    this.enhancer_ = function (newV, oldV) {\n      return enhancer(newV, oldV,  true ? name + \"[..]\" : 0);\n    };\n  }\n\n  var _proto = ObservableArrayAdministration.prototype;\n\n  _proto.dehanceValue_ = function dehanceValue_(value) {\n    if (this.dehancer !== undefined) {\n      return this.dehancer(value);\n    }\n\n    return value;\n  };\n\n  _proto.dehanceValues_ = function dehanceValues_(values) {\n    if (this.dehancer !== undefined && values.length > 0) {\n      return values.map(this.dehancer);\n    }\n\n    return values;\n  };\n\n  _proto.intercept_ = function intercept_(handler) {\n    return registerInterceptor(this, handler);\n  };\n\n  _proto.observe_ = function observe_(listener, fireImmediately) {\n    if (fireImmediately === void 0) {\n      fireImmediately = false;\n    }\n\n    if (fireImmediately) {\n      listener({\n        observableKind: \"array\",\n        object: this.proxy_,\n        debugObjectName: this.atom_.name_,\n        type: \"splice\",\n        index: 0,\n        added: this.values_.slice(),\n        addedCount: this.values_.length,\n        removed: [],\n        removedCount: 0\n      });\n    }\n\n    return registerListener(this, listener);\n  };\n\n  _proto.getArrayLength_ = function getArrayLength_() {\n    this.atom_.reportObserved();\n    return this.values_.length;\n  };\n\n  _proto.setArrayLength_ = function setArrayLength_(newLength) {\n    if (typeof newLength !== \"number\" || isNaN(newLength) || newLength < 0) {\n      die(\"Out of range: \" + newLength);\n    }\n\n    var currentLength = this.values_.length;\n\n    if (newLength === currentLength) {\n      return;\n    } else if (newLength > currentLength) {\n      var newItems = new Array(newLength - currentLength);\n\n      for (var i = 0; i < newLength - currentLength; i++) {\n        newItems[i] = undefined;\n      } // No Array.fill everywhere...\n\n\n      this.spliceWithArray_(currentLength, 0, newItems);\n    } else {\n      this.spliceWithArray_(newLength, currentLength - newLength);\n    }\n  };\n\n  _proto.updateArrayLength_ = function updateArrayLength_(oldLength, delta) {\n    if (oldLength !== this.lastKnownLength_) {\n      die(16);\n    }\n\n    this.lastKnownLength_ += delta;\n\n    if (this.legacyMode_ && delta > 0) {\n      reserveArrayBuffer(oldLength + delta + 1);\n    }\n  };\n\n  _proto.spliceWithArray_ = function spliceWithArray_(index, deleteCount, newItems) {\n    var _this = this;\n\n    checkIfStateModificationsAreAllowed(this.atom_);\n    var length = this.values_.length;\n\n    if (index === undefined) {\n      index = 0;\n    } else if (index > length) {\n      index = length;\n    } else if (index < 0) {\n      index = Math.max(0, length + index);\n    }\n\n    if (arguments.length === 1) {\n      deleteCount = length - index;\n    } else if (deleteCount === undefined || deleteCount === null) {\n      deleteCount = 0;\n    } else {\n      deleteCount = Math.max(0, Math.min(deleteCount, length - index));\n    }\n\n    if (newItems === undefined) {\n      newItems = EMPTY_ARRAY;\n    }\n\n    if (hasInterceptors(this)) {\n      var change = interceptChange(this, {\n        object: this.proxy_,\n        type: SPLICE,\n        index: index,\n        removedCount: deleteCount,\n        added: newItems\n      });\n\n      if (!change) {\n        return EMPTY_ARRAY;\n      }\n\n      deleteCount = change.removedCount;\n      newItems = change.added;\n    }\n\n    newItems = newItems.length === 0 ? newItems : newItems.map(function (v) {\n      return _this.enhancer_(v, undefined);\n    });\n\n    if (this.legacyMode_ || \"development\" !== \"production\") {\n      var lengthDelta = newItems.length - deleteCount;\n      this.updateArrayLength_(length, lengthDelta); // checks if internal array wasn't modified\n    }\n\n    var res = this.spliceItemsIntoValues_(index, deleteCount, newItems);\n\n    if (deleteCount !== 0 || newItems.length !== 0) {\n      this.notifyArraySplice_(index, newItems, res);\n    }\n\n    return this.dehanceValues_(res);\n  };\n\n  _proto.spliceItemsIntoValues_ = function spliceItemsIntoValues_(index, deleteCount, newItems) {\n    if (newItems.length < MAX_SPLICE_SIZE) {\n      var _this$values_;\n\n      return (_this$values_ = this.values_).splice.apply(_this$values_, [index, deleteCount].concat(newItems));\n    } else {\n      // The items removed by the splice\n      var res = this.values_.slice(index, index + deleteCount); // The items that that should remain at the end of the array\n\n      var oldItems = this.values_.slice(index + deleteCount); // New length is the previous length + addition count - deletion count\n\n      this.values_.length += newItems.length - deleteCount;\n\n      for (var i = 0; i < newItems.length; i++) {\n        this.values_[index + i] = newItems[i];\n      }\n\n      for (var _i = 0; _i < oldItems.length; _i++) {\n        this.values_[index + newItems.length + _i] = oldItems[_i];\n      }\n\n      return res;\n    }\n  };\n\n  _proto.notifyArrayChildUpdate_ = function notifyArrayChildUpdate_(index, newValue, oldValue) {\n    var notifySpy = !this.owned_ && isSpyEnabled();\n    var notify = hasListeners(this);\n    var change = notify || notifySpy ? {\n      observableKind: \"array\",\n      object: this.proxy_,\n      type: UPDATE,\n      debugObjectName: this.atom_.name_,\n      index: index,\n      newValue: newValue,\n      oldValue: oldValue\n    } : null; // The reason why this is on right hand side here (and not above), is this way the uglifier will drop it, but it won't\n    // cause any runtime overhead in development mode without NODE_ENV set, unless spying is enabled\n\n    if ( true && notifySpy) {\n      spyReportStart(change);\n    }\n\n    this.atom_.reportChanged();\n\n    if (notify) {\n      notifyListeners(this, change);\n    }\n\n    if ( true && notifySpy) {\n      spyReportEnd();\n    }\n  };\n\n  _proto.notifyArraySplice_ = function notifyArraySplice_(index, added, removed) {\n    var notifySpy = !this.owned_ && isSpyEnabled();\n    var notify = hasListeners(this);\n    var change = notify || notifySpy ? {\n      observableKind: \"array\",\n      object: this.proxy_,\n      debugObjectName: this.atom_.name_,\n      type: SPLICE,\n      index: index,\n      removed: removed,\n      added: added,\n      removedCount: removed.length,\n      addedCount: added.length\n    } : null;\n\n    if ( true && notifySpy) {\n      spyReportStart(change);\n    }\n\n    this.atom_.reportChanged(); // conform: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe\n\n    if (notify) {\n      notifyListeners(this, change);\n    }\n\n    if ( true && notifySpy) {\n      spyReportEnd();\n    }\n  };\n\n  _proto.get_ = function get_(index) {\n    if (this.legacyMode_ && index >= this.values_.length) {\n      console.warn( true ? \"[mobx.array] Attempt to read an array index (\" + index + \") that is out of bounds (\" + this.values_.length + \"). Please check length first. Out of bound indices will not be tracked by MobX\" : 0);\n      return undefined;\n    }\n\n    this.atom_.reportObserved();\n    return this.dehanceValue_(this.values_[index]);\n  };\n\n  _proto.set_ = function set_(index, newValue) {\n    var values = this.values_;\n\n    if (this.legacyMode_ && index > values.length) {\n      // out of bounds\n      die(17, index, values.length);\n    }\n\n    if (index < values.length) {\n      // update at index in range\n      checkIfStateModificationsAreAllowed(this.atom_);\n      var oldValue = values[index];\n\n      if (hasInterceptors(this)) {\n        var change = interceptChange(this, {\n          type: UPDATE,\n          object: this.proxy_,\n          index: index,\n          newValue: newValue\n        });\n\n        if (!change) {\n          return;\n        }\n\n        newValue = change.newValue;\n      }\n\n      newValue = this.enhancer_(newValue, oldValue);\n      var changed = newValue !== oldValue;\n\n      if (changed) {\n        values[index] = newValue;\n        this.notifyArrayChildUpdate_(index, newValue, oldValue);\n      }\n    } else {\n      // For out of bound index, we don't create an actual sparse array,\n      // but rather fill the holes with undefined (same as setArrayLength_).\n      // This could be considered a bug.\n      var newItems = new Array(index + 1 - values.length);\n\n      for (var i = 0; i < newItems.length - 1; i++) {\n        newItems[i] = undefined;\n      } // No Array.fill everywhere...\n\n\n      newItems[newItems.length - 1] = newValue;\n      this.spliceWithArray_(values.length, 0, newItems);\n    }\n  };\n\n  return ObservableArrayAdministration;\n}();\nfunction createObservableArray(initialValues, enhancer, name, owned) {\n  if (name === void 0) {\n    name =  true ? \"ObservableArray@\" + getNextId() : 0;\n  }\n\n  if (owned === void 0) {\n    owned = false;\n  }\n\n  assertProxies();\n  var adm = new ObservableArrayAdministration(name, enhancer, owned, false);\n  addHiddenFinalProp(adm.values_, $mobx, adm);\n  var proxy = new Proxy(adm.values_, arrayTraps);\n  adm.proxy_ = proxy;\n\n  if (initialValues && initialValues.length) {\n    var prev = allowStateChangesStart(true);\n    adm.spliceWithArray_(0, 0, initialValues);\n    allowStateChangesEnd(prev);\n  }\n\n  return proxy;\n} // eslint-disable-next-line\n\nvar arrayExtensions = {\n  clear: function clear() {\n    return this.splice(0);\n  },\n  replace: function replace(newItems) {\n    var adm = this[$mobx];\n    return adm.spliceWithArray_(0, adm.values_.length, newItems);\n  },\n  // Used by JSON.stringify\n  toJSON: function toJSON() {\n    return this.slice();\n  },\n\n  /*\r\n   * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)\r\n   * since these functions alter the inner structure of the array, the have side effects.\r\n   * Because the have side effects, they should not be used in computed function,\r\n   * and for that reason the do not call dependencyState.notifyObserved\r\n   */\n  splice: function splice(index, deleteCount) {\n    for (var _len = arguments.length, newItems = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      newItems[_key - 2] = arguments[_key];\n    }\n\n    var adm = this[$mobx];\n\n    switch (arguments.length) {\n      case 0:\n        return [];\n\n      case 1:\n        return adm.spliceWithArray_(index);\n\n      case 2:\n        return adm.spliceWithArray_(index, deleteCount);\n    }\n\n    return adm.spliceWithArray_(index, deleteCount, newItems);\n  },\n  spliceWithArray: function spliceWithArray(index, deleteCount, newItems) {\n    return this[$mobx].spliceWithArray_(index, deleteCount, newItems);\n  },\n  push: function push() {\n    var adm = this[$mobx];\n\n    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      items[_key2] = arguments[_key2];\n    }\n\n    adm.spliceWithArray_(adm.values_.length, 0, items);\n    return adm.values_.length;\n  },\n  pop: function pop() {\n    return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];\n  },\n  shift: function shift() {\n    return this.splice(0, 1)[0];\n  },\n  unshift: function unshift() {\n    var adm = this[$mobx];\n\n    for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      items[_key3] = arguments[_key3];\n    }\n\n    adm.spliceWithArray_(0, 0, items);\n    return adm.values_.length;\n  },\n  reverse: function reverse() {\n    // reverse by default mutates in place before returning the result\n    // which makes it both a 'derivation' and a 'mutation'.\n    if (globalState.trackingDerivation) {\n      die(37, \"reverse\");\n    }\n\n    this.replace(this.slice().reverse());\n    return this;\n  },\n  sort: function sort() {\n    // sort by default mutates in place before returning the result\n    // which goes against all good practices. Let's not change the array in place!\n    if (globalState.trackingDerivation) {\n      die(37, \"sort\");\n    }\n\n    var copy = this.slice();\n    copy.sort.apply(copy, arguments);\n    this.replace(copy);\n    return this;\n  },\n  remove: function remove(value) {\n    var adm = this[$mobx];\n    var idx = adm.dehanceValues_(adm.values_).indexOf(value);\n\n    if (idx > -1) {\n      this.splice(idx, 1);\n      return true;\n    }\n\n    return false;\n  }\n};\n/**\r\n * Wrap function from prototype\r\n * Without this, everything works as well, but this works\r\n * faster as everything works on unproxied values\r\n */\n\naddArrayExtension(\"concat\", simpleFunc);\naddArrayExtension(\"flat\", simpleFunc);\naddArrayExtension(\"includes\", simpleFunc);\naddArrayExtension(\"indexOf\", simpleFunc);\naddArrayExtension(\"join\", simpleFunc);\naddArrayExtension(\"lastIndexOf\", simpleFunc);\naddArrayExtension(\"slice\", simpleFunc);\naddArrayExtension(\"toString\", simpleFunc);\naddArrayExtension(\"toLocaleString\", simpleFunc); // map\n\naddArrayExtension(\"every\", mapLikeFunc);\naddArrayExtension(\"filter\", mapLikeFunc);\naddArrayExtension(\"find\", mapLikeFunc);\naddArrayExtension(\"findIndex\", mapLikeFunc);\naddArrayExtension(\"flatMap\", mapLikeFunc);\naddArrayExtension(\"forEach\", mapLikeFunc);\naddArrayExtension(\"map\", mapLikeFunc);\naddArrayExtension(\"some\", mapLikeFunc); // reduce\n\naddArrayExtension(\"reduce\", reduceLikeFunc);\naddArrayExtension(\"reduceRight\", reduceLikeFunc);\n\nfunction addArrayExtension(funcName, funcFactory) {\n  if (typeof Array.prototype[funcName] === \"function\") {\n    arrayExtensions[funcName] = funcFactory(funcName);\n  }\n} // Report and delegate to dehanced array\n\n\nfunction simpleFunc(funcName) {\n  return function () {\n    var adm = this[$mobx];\n    adm.atom_.reportObserved();\n    var dehancedValues = adm.dehanceValues_(adm.values_);\n    return dehancedValues[funcName].apply(dehancedValues, arguments);\n  };\n} // Make sure callbacks recieve correct array arg #2326\n\n\nfunction mapLikeFunc(funcName) {\n  return function (callback, thisArg) {\n    var _this2 = this;\n\n    var adm = this[$mobx];\n    adm.atom_.reportObserved();\n    var dehancedValues = adm.dehanceValues_(adm.values_);\n    return dehancedValues[funcName](function (element, index) {\n      return callback.call(thisArg, element, index, _this2);\n    });\n  };\n} // Make sure callbacks recieve correct array arg #2326\n\n\nfunction reduceLikeFunc(funcName) {\n  return function () {\n    var _this3 = this;\n\n    var adm = this[$mobx];\n    adm.atom_.reportObserved();\n    var dehancedValues = adm.dehanceValues_(adm.values_); // #2432 - reduce behavior depends on arguments.length\n\n    var callback = arguments[0];\n\n    arguments[0] = function (accumulator, currentValue, index) {\n      return callback(accumulator, currentValue, index, _this3);\n    };\n\n    return dehancedValues[funcName].apply(dehancedValues, arguments);\n  };\n}\n\nvar isObservableArrayAdministration = /*#__PURE__*/createInstanceofPredicate(\"ObservableArrayAdministration\", ObservableArrayAdministration);\nfunction isObservableArray(thing) {\n  return isObject(thing) && isObservableArrayAdministration(thing[$mobx]);\n}\n\nvar _Symbol$iterator, _Symbol$toStringTag;\nvar ObservableMapMarker = {};\nvar ADD = \"add\";\nvar DELETE = \"delete\"; // just extend Map? See also https://gist.github.com/nestharus/13b4d74f2ef4a2f4357dbd3fc23c1e54\n// But: https://github.com/mobxjs/mobx/issues/1556\n\n_Symbol$iterator = Symbol.iterator;\n_Symbol$toStringTag = Symbol.toStringTag;\nvar ObservableMap = /*#__PURE__*/function () {\n  // hasMap, not hashMap >-).\n  function ObservableMap(initialData, enhancer_, name_) {\n    var _this = this;\n\n    if (enhancer_ === void 0) {\n      enhancer_ = deepEnhancer;\n    }\n\n    if (name_ === void 0) {\n      name_ =  true ? \"ObservableMap@\" + getNextId() : 0;\n    }\n\n    this.enhancer_ = void 0;\n    this.name_ = void 0;\n    this[$mobx] = ObservableMapMarker;\n    this.data_ = void 0;\n    this.hasMap_ = void 0;\n    this.keysAtom_ = void 0;\n    this.interceptors_ = void 0;\n    this.changeListeners_ = void 0;\n    this.dehancer = void 0;\n    this.enhancer_ = enhancer_;\n    this.name_ = name_;\n\n    if (!isFunction(Map)) {\n      die(18);\n    }\n\n    this.keysAtom_ = createAtom( true ? this.name_ + \".keys()\" : 0);\n    this.data_ = new Map();\n    this.hasMap_ = new Map();\n    allowStateChanges(true, function () {\n      _this.merge(initialData);\n    });\n  }\n\n  var _proto = ObservableMap.prototype;\n\n  _proto.has_ = function has_(key) {\n    return this.data_.has(key);\n  };\n\n  _proto.has = function has(key) {\n    var _this2 = this;\n\n    if (!globalState.trackingDerivation) {\n      return this.has_(key);\n    }\n\n    var entry = this.hasMap_.get(key);\n\n    if (!entry) {\n      var newEntry = entry = new ObservableValue(this.has_(key), referenceEnhancer,  true ? this.name_ + \".\" + stringifyKey(key) + \"?\" : 0, false);\n      this.hasMap_.set(key, newEntry);\n      onBecomeUnobserved(newEntry, function () {\n        return _this2.hasMap_[\"delete\"](key);\n      });\n    }\n\n    return entry.get();\n  };\n\n  _proto.set = function set(key, value) {\n    var hasKey = this.has_(key);\n\n    if (hasInterceptors(this)) {\n      var change = interceptChange(this, {\n        type: hasKey ? UPDATE : ADD,\n        object: this,\n        newValue: value,\n        name: key\n      });\n\n      if (!change) {\n        return this;\n      }\n\n      value = change.newValue;\n    }\n\n    if (hasKey) {\n      this.updateValue_(key, value);\n    } else {\n      this.addValue_(key, value);\n    }\n\n    return this;\n  };\n\n  _proto[\"delete\"] = function _delete(key) {\n    var _this3 = this;\n\n    checkIfStateModificationsAreAllowed(this.keysAtom_);\n\n    if (hasInterceptors(this)) {\n      var change = interceptChange(this, {\n        type: DELETE,\n        object: this,\n        name: key\n      });\n\n      if (!change) {\n        return false;\n      }\n    }\n\n    if (this.has_(key)) {\n      var notifySpy = isSpyEnabled();\n      var notify = hasListeners(this);\n\n      var _change = notify || notifySpy ? {\n        observableKind: \"map\",\n        debugObjectName: this.name_,\n        type: DELETE,\n        object: this,\n        oldValue: this.data_.get(key).value_,\n        name: key\n      } : null;\n\n      if ( true && notifySpy) {\n        spyReportStart(_change);\n      } // TODO fix type\n\n\n      transaction(function () {\n        var _this3$hasMap_$get;\n\n        _this3.keysAtom_.reportChanged();\n\n        (_this3$hasMap_$get = _this3.hasMap_.get(key)) == null ? void 0 : _this3$hasMap_$get.setNewValue_(false);\n\n        var observable = _this3.data_.get(key);\n\n        observable.setNewValue_(undefined);\n\n        _this3.data_[\"delete\"](key);\n      });\n\n      if (notify) {\n        notifyListeners(this, _change);\n      }\n\n      if ( true && notifySpy) {\n        spyReportEnd();\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto.updateValue_ = function updateValue_(key, newValue) {\n    var observable = this.data_.get(key);\n    newValue = observable.prepareNewValue_(newValue);\n\n    if (newValue !== globalState.UNCHANGED) {\n      var notifySpy = isSpyEnabled();\n      var notify = hasListeners(this);\n      var change = notify || notifySpy ? {\n        observableKind: \"map\",\n        debugObjectName: this.name_,\n        type: UPDATE,\n        object: this,\n        oldValue: observable.value_,\n        name: key,\n        newValue: newValue\n      } : null;\n\n      if ( true && notifySpy) {\n        spyReportStart(change);\n      } // TODO fix type\n\n\n      observable.setNewValue_(newValue);\n\n      if (notify) {\n        notifyListeners(this, change);\n      }\n\n      if ( true && notifySpy) {\n        spyReportEnd();\n      }\n    }\n  };\n\n  _proto.addValue_ = function addValue_(key, newValue) {\n    var _this4 = this;\n\n    checkIfStateModificationsAreAllowed(this.keysAtom_);\n    transaction(function () {\n      var _this4$hasMap_$get;\n\n      var observable = new ObservableValue(newValue, _this4.enhancer_,  true ? _this4.name_ + \".\" + stringifyKey(key) : 0, false);\n\n      _this4.data_.set(key, observable);\n\n      newValue = observable.value_; // value might have been changed\n\n      (_this4$hasMap_$get = _this4.hasMap_.get(key)) == null ? void 0 : _this4$hasMap_$get.setNewValue_(true);\n\n      _this4.keysAtom_.reportChanged();\n    });\n    var notifySpy = isSpyEnabled();\n    var notify = hasListeners(this);\n    var change = notify || notifySpy ? {\n      observableKind: \"map\",\n      debugObjectName: this.name_,\n      type: ADD,\n      object: this,\n      name: key,\n      newValue: newValue\n    } : null;\n\n    if ( true && notifySpy) {\n      spyReportStart(change);\n    } // TODO fix type\n\n\n    if (notify) {\n      notifyListeners(this, change);\n    }\n\n    if ( true && notifySpy) {\n      spyReportEnd();\n    }\n  };\n\n  _proto.get = function get(key) {\n    if (this.has(key)) {\n      return this.dehanceValue_(this.data_.get(key).get());\n    }\n\n    return this.dehanceValue_(undefined);\n  };\n\n  _proto.dehanceValue_ = function dehanceValue_(value) {\n    if (this.dehancer !== undefined) {\n      return this.dehancer(value);\n    }\n\n    return value;\n  };\n\n  _proto.keys = function keys() {\n    this.keysAtom_.reportObserved();\n    return this.data_.keys();\n  };\n\n  _proto.values = function values() {\n    var self = this;\n    var keys = this.keys();\n    return makeIterable({\n      next: function next() {\n        var _keys$next = keys.next(),\n            done = _keys$next.done,\n            value = _keys$next.value;\n\n        return {\n          done: done,\n          value: done ? undefined : self.get(value)\n        };\n      }\n    });\n  };\n\n  _proto.entries = function entries() {\n    var self = this;\n    var keys = this.keys();\n    return makeIterable({\n      next: function next() {\n        var _keys$next2 = keys.next(),\n            done = _keys$next2.done,\n            value = _keys$next2.value;\n\n        return {\n          done: done,\n          value: done ? undefined : [value, self.get(value)]\n        };\n      }\n    });\n  };\n\n  _proto[_Symbol$iterator] = function () {\n    return this.entries();\n  };\n\n  _proto.forEach = function forEach(callback, thisArg) {\n    for (var _iterator = _createForOfIteratorHelperLoose(this), _step; !(_step = _iterator()).done;) {\n      var _step$value = _step.value,\n          key = _step$value[0],\n          value = _step$value[1];\n      callback.call(thisArg, value, key, this);\n    }\n  }\n  /** Merge another object into this object, returns this. */\n  ;\n\n  _proto.merge = function merge(other) {\n    var _this5 = this;\n\n    if (isObservableMap(other)) {\n      other = new Map(other);\n    }\n\n    transaction(function () {\n      if (isPlainObject(other)) {\n        getPlainObjectKeys(other).forEach(function (key) {\n          return _this5.set(key, other[key]);\n        });\n      } else if (Array.isArray(other)) {\n        other.forEach(function (_ref) {\n          var key = _ref[0],\n              value = _ref[1];\n          return _this5.set(key, value);\n        });\n      } else if (isES6Map(other)) {\n        if (other.constructor !== Map) {\n          die(19, other);\n        }\n\n        other.forEach(function (value, key) {\n          return _this5.set(key, value);\n        });\n      } else if (other !== null && other !== undefined) {\n        die(20, other);\n      }\n    });\n    return this;\n  };\n\n  _proto.clear = function clear() {\n    var _this6 = this;\n\n    transaction(function () {\n      untracked(function () {\n        for (var _iterator2 = _createForOfIteratorHelperLoose(_this6.keys()), _step2; !(_step2 = _iterator2()).done;) {\n          var key = _step2.value;\n\n          _this6[\"delete\"](key);\n        }\n      });\n    });\n  };\n\n  _proto.replace = function replace(values) {\n    var _this7 = this;\n\n    // Implementation requirements:\n    // - respect ordering of replacement map\n    // - allow interceptors to run and potentially prevent individual operations\n    // - don't recreate observables that already exist in original map (so we don't destroy existing subscriptions)\n    // - don't _keysAtom.reportChanged if the keys of resulting map are indentical (order matters!)\n    // - note that result map may differ from replacement map due to the interceptors\n    transaction(function () {\n      // Convert to map so we can do quick key lookups\n      var replacementMap = convertToMap(values);\n      var orderedData = new Map(); // Used for optimization\n\n      var keysReportChangedCalled = false; // Delete keys that don't exist in replacement map\n      // if the key deletion is prevented by interceptor\n      // add entry at the beginning of the result map\n\n      for (var _iterator3 = _createForOfIteratorHelperLoose(_this7.data_.keys()), _step3; !(_step3 = _iterator3()).done;) {\n        var key = _step3.value;\n\n        // Concurrently iterating/deleting keys\n        // iterator should handle this correctly\n        if (!replacementMap.has(key)) {\n          var deleted = _this7[\"delete\"](key); // Was the key removed?\n\n\n          if (deleted) {\n            // _keysAtom.reportChanged() was already called\n            keysReportChangedCalled = true;\n          } else {\n            // Delete prevented by interceptor\n            var value = _this7.data_.get(key);\n\n            orderedData.set(key, value);\n          }\n        }\n      } // Merge entries\n\n\n      for (var _iterator4 = _createForOfIteratorHelperLoose(replacementMap.entries()), _step4; !(_step4 = _iterator4()).done;) {\n        var _step4$value = _step4.value,\n            _key = _step4$value[0],\n            _value = _step4$value[1];\n\n        // We will want to know whether a new key is added\n        var keyExisted = _this7.data_.has(_key); // Add or update value\n\n\n        _this7.set(_key, _value); // The addition could have been prevent by interceptor\n\n\n        if (_this7.data_.has(_key)) {\n          // The update could have been prevented by interceptor\n          // and also we want to preserve existing values\n          // so use value from _data map (instead of replacement map)\n          var _value2 = _this7.data_.get(_key);\n\n          orderedData.set(_key, _value2); // Was a new key added?\n\n          if (!keyExisted) {\n            // _keysAtom.reportChanged() was already called\n            keysReportChangedCalled = true;\n          }\n        }\n      } // Check for possible key order change\n\n\n      if (!keysReportChangedCalled) {\n        if (_this7.data_.size !== orderedData.size) {\n          // If size differs, keys are definitely modified\n          _this7.keysAtom_.reportChanged();\n        } else {\n          var iter1 = _this7.data_.keys();\n\n          var iter2 = orderedData.keys();\n          var next1 = iter1.next();\n          var next2 = iter2.next();\n\n          while (!next1.done) {\n            if (next1.value !== next2.value) {\n              _this7.keysAtom_.reportChanged();\n\n              break;\n            }\n\n            next1 = iter1.next();\n            next2 = iter2.next();\n          }\n        }\n      } // Use correctly ordered map\n\n\n      _this7.data_ = orderedData;\n    });\n    return this;\n  };\n\n  _proto.toString = function toString() {\n    return \"[object ObservableMap]\";\n  };\n\n  _proto.toJSON = function toJSON() {\n    return Array.from(this);\n  };\n\n  /**\r\n   * Observes this object. Triggers for the events 'add', 'update' and 'delete'.\r\n   * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe\r\n   * for callback details\r\n   */\n  _proto.observe_ = function observe_(listener, fireImmediately) {\n    if ( true && fireImmediately === true) {\n      die(\"`observe` doesn't support fireImmediately=true in combination with maps.\");\n    }\n\n    return registerListener(this, listener);\n  };\n\n  _proto.intercept_ = function intercept_(handler) {\n    return registerInterceptor(this, handler);\n  };\n\n  _createClass(ObservableMap, [{\n    key: \"size\",\n    get: function get() {\n      this.keysAtom_.reportObserved();\n      return this.data_.size;\n    }\n  }, {\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return \"Map\";\n    }\n  }]);\n\n  return ObservableMap;\n}(); // eslint-disable-next-line\n\nvar isObservableMap = /*#__PURE__*/createInstanceofPredicate(\"ObservableMap\", ObservableMap);\n\nfunction convertToMap(dataStructure) {\n  if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {\n    return dataStructure;\n  } else if (Array.isArray(dataStructure)) {\n    return new Map(dataStructure);\n  } else if (isPlainObject(dataStructure)) {\n    var map = new Map();\n\n    for (var key in dataStructure) {\n      map.set(key, dataStructure[key]);\n    }\n\n    return map;\n  } else {\n    return die(21, dataStructure);\n  }\n}\n\nvar _Symbol$iterator$1, _Symbol$toStringTag$1;\nvar ObservableSetMarker = {};\n_Symbol$iterator$1 = Symbol.iterator;\n_Symbol$toStringTag$1 = Symbol.toStringTag;\nvar ObservableSet = /*#__PURE__*/function () {\n  function ObservableSet(initialData, enhancer, name_) {\n    if (enhancer === void 0) {\n      enhancer = deepEnhancer;\n    }\n\n    if (name_ === void 0) {\n      name_ =  true ? \"ObservableSet@\" + getNextId() : 0;\n    }\n\n    this.name_ = void 0;\n    this[$mobx] = ObservableSetMarker;\n    this.data_ = new Set();\n    this.atom_ = void 0;\n    this.changeListeners_ = void 0;\n    this.interceptors_ = void 0;\n    this.dehancer = void 0;\n    this.enhancer_ = void 0;\n    this.name_ = name_;\n\n    if (!isFunction(Set)) {\n      die(22);\n    }\n\n    this.atom_ = createAtom(this.name_);\n\n    this.enhancer_ = function (newV, oldV) {\n      return enhancer(newV, oldV, name_);\n    };\n\n    if (initialData) {\n      this.replace(initialData);\n    }\n  }\n\n  var _proto = ObservableSet.prototype;\n\n  _proto.dehanceValue_ = function dehanceValue_(value) {\n    if (this.dehancer !== undefined) {\n      return this.dehancer(value);\n    }\n\n    return value;\n  };\n\n  _proto.clear = function clear() {\n    var _this = this;\n\n    transaction(function () {\n      untracked(function () {\n        for (var _iterator = _createForOfIteratorHelperLoose(_this.data_.values()), _step; !(_step = _iterator()).done;) {\n          var value = _step.value;\n\n          _this[\"delete\"](value);\n        }\n      });\n    });\n  };\n\n  _proto.forEach = function forEach(callbackFn, thisArg) {\n    for (var _iterator2 = _createForOfIteratorHelperLoose(this), _step2; !(_step2 = _iterator2()).done;) {\n      var value = _step2.value;\n      callbackFn.call(thisArg, value, value, this);\n    }\n  };\n\n  _proto.add = function add(value) {\n    var _this2 = this;\n\n    checkIfStateModificationsAreAllowed(this.atom_);\n\n    if (hasInterceptors(this)) {\n      var change = interceptChange(this, {\n        type: ADD,\n        object: this,\n        newValue: value\n      });\n\n      if (!change) {\n        return this;\n      } // ideally, value = change.value would be done here, so that values can be\n      // changed by interceptor. Same applies for other Set and Map api's.\n\n    }\n\n    if (!this.has(value)) {\n      transaction(function () {\n        _this2.data_.add(_this2.enhancer_(value, undefined));\n\n        _this2.atom_.reportChanged();\n      });\n      var notifySpy =  true && isSpyEnabled();\n      var notify = hasListeners(this);\n\n      var _change = notify || notifySpy ? {\n        observableKind: \"set\",\n        debugObjectName: this.name_,\n        type: ADD,\n        object: this,\n        newValue: value\n      } : null;\n\n      if (notifySpy && \"development\" !== \"production\") {\n        spyReportStart(_change);\n      }\n\n      if (notify) {\n        notifyListeners(this, _change);\n      }\n\n      if (notifySpy && \"development\" !== \"production\") {\n        spyReportEnd();\n      }\n    }\n\n    return this;\n  };\n\n  _proto[\"delete\"] = function _delete(value) {\n    var _this3 = this;\n\n    if (hasInterceptors(this)) {\n      var change = interceptChange(this, {\n        type: DELETE,\n        object: this,\n        oldValue: value\n      });\n\n      if (!change) {\n        return false;\n      }\n    }\n\n    if (this.has(value)) {\n      var notifySpy =  true && isSpyEnabled();\n      var notify = hasListeners(this);\n\n      var _change2 = notify || notifySpy ? {\n        observableKind: \"set\",\n        debugObjectName: this.name_,\n        type: DELETE,\n        object: this,\n        oldValue: value\n      } : null;\n\n      if (notifySpy && \"development\" !== \"production\") {\n        spyReportStart(_change2);\n      }\n\n      transaction(function () {\n        _this3.atom_.reportChanged();\n\n        _this3.data_[\"delete\"](value);\n      });\n\n      if (notify) {\n        notifyListeners(this, _change2);\n      }\n\n      if (notifySpy && \"development\" !== \"production\") {\n        spyReportEnd();\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto.has = function has(value) {\n    this.atom_.reportObserved();\n    return this.data_.has(this.dehanceValue_(value));\n  };\n\n  _proto.entries = function entries() {\n    var nextIndex = 0;\n    var keys = Array.from(this.keys());\n    var values = Array.from(this.values());\n    return makeIterable({\n      next: function next() {\n        var index = nextIndex;\n        nextIndex += 1;\n        return index < values.length ? {\n          value: [keys[index], values[index]],\n          done: false\n        } : {\n          done: true\n        };\n      }\n    });\n  };\n\n  _proto.keys = function keys() {\n    return this.values();\n  };\n\n  _proto.values = function values() {\n    this.atom_.reportObserved();\n    var self = this;\n    var nextIndex = 0;\n    var observableValues = Array.from(this.data_.values());\n    return makeIterable({\n      next: function next() {\n        return nextIndex < observableValues.length ? {\n          value: self.dehanceValue_(observableValues[nextIndex++]),\n          done: false\n        } : {\n          done: true\n        };\n      }\n    });\n  };\n\n  _proto.replace = function replace(other) {\n    var _this4 = this;\n\n    if (isObservableSet(other)) {\n      other = new Set(other);\n    }\n\n    transaction(function () {\n      if (Array.isArray(other)) {\n        _this4.clear();\n\n        other.forEach(function (value) {\n          return _this4.add(value);\n        });\n      } else if (isES6Set(other)) {\n        _this4.clear();\n\n        other.forEach(function (value) {\n          return _this4.add(value);\n        });\n      } else if (other !== null && other !== undefined) {\n        die(\"Cannot initialize set from \" + other);\n      }\n    });\n    return this;\n  };\n\n  _proto.observe_ = function observe_(listener, fireImmediately) {\n    // ... 'fireImmediately' could also be true?\n    if ( true && fireImmediately === true) {\n      die(\"`observe` doesn't support fireImmediately=true in combination with sets.\");\n    }\n\n    return registerListener(this, listener);\n  };\n\n  _proto.intercept_ = function intercept_(handler) {\n    return registerInterceptor(this, handler);\n  };\n\n  _proto.toJSON = function toJSON() {\n    return Array.from(this);\n  };\n\n  _proto.toString = function toString() {\n    return \"[object ObservableSet]\";\n  };\n\n  _proto[_Symbol$iterator$1] = function () {\n    return this.values();\n  };\n\n  _createClass(ObservableSet, [{\n    key: \"size\",\n    get: function get() {\n      this.atom_.reportObserved();\n      return this.data_.size;\n    }\n  }, {\n    key: _Symbol$toStringTag$1,\n    get: function get() {\n      return \"Set\";\n    }\n  }]);\n\n  return ObservableSet;\n}(); // eslint-disable-next-line\n\nvar isObservableSet = /*#__PURE__*/createInstanceofPredicate(\"ObservableSet\", ObservableSet);\n\nvar descriptorCache = /*#__PURE__*/Object.create(null);\nvar REMOVE = \"remove\";\nvar ObservableObjectAdministration = /*#__PURE__*/function () {\n  function ObservableObjectAdministration(target_, values_, name_, // Used anytime annotation is not explicitely provided\n  defaultAnnotation_) {\n    if (values_ === void 0) {\n      values_ = new Map();\n    }\n\n    if (defaultAnnotation_ === void 0) {\n      defaultAnnotation_ = autoAnnotation;\n    }\n\n    this.target_ = void 0;\n    this.values_ = void 0;\n    this.name_ = void 0;\n    this.defaultAnnotation_ = void 0;\n    this.keysAtom_ = void 0;\n    this.changeListeners_ = void 0;\n    this.interceptors_ = void 0;\n    this.proxy_ = void 0;\n    this.isPlainObject_ = void 0;\n    this.appliedAnnotations_ = void 0;\n    this.pendingKeys_ = void 0;\n    this.target_ = target_;\n    this.values_ = values_;\n    this.name_ = name_;\n    this.defaultAnnotation_ = defaultAnnotation_;\n    this.keysAtom_ = new Atom( true ? this.name_ + \".keys\" : 0); // Optimization: we use this frequently\n\n    this.isPlainObject_ = isPlainObject(this.target_);\n\n    if ( true && !isAnnotation(this.defaultAnnotation_)) {\n      die(\"defaultAnnotation must be valid annotation\");\n    }\n\n    if (true) {\n      // Prepare structure for tracking which fields were already annotated\n      this.appliedAnnotations_ = {};\n    }\n  }\n\n  var _proto = ObservableObjectAdministration.prototype;\n\n  _proto.getObservablePropValue_ = function getObservablePropValue_(key) {\n    return this.values_.get(key).get();\n  };\n\n  _proto.setObservablePropValue_ = function setObservablePropValue_(key, newValue) {\n    var observable = this.values_.get(key);\n\n    if (observable instanceof ComputedValue) {\n      observable.set(newValue);\n      return true;\n    } // intercept\n\n\n    if (hasInterceptors(this)) {\n      var change = interceptChange(this, {\n        type: UPDATE,\n        object: this.proxy_ || this.target_,\n        name: key,\n        newValue: newValue\n      });\n\n      if (!change) {\n        return null;\n      }\n\n      newValue = change.newValue;\n    }\n\n    newValue = observable.prepareNewValue_(newValue); // notify spy & observers\n\n    if (newValue !== globalState.UNCHANGED) {\n      var notify = hasListeners(this);\n      var notifySpy =  true && isSpyEnabled();\n\n      var _change = notify || notifySpy ? {\n        type: UPDATE,\n        observableKind: \"object\",\n        debugObjectName: this.name_,\n        object: this.proxy_ || this.target_,\n        oldValue: observable.value_,\n        name: key,\n        newValue: newValue\n      } : null;\n\n      if ( true && notifySpy) {\n        spyReportStart(_change);\n      }\n      observable.setNewValue_(newValue);\n\n      if (notify) {\n        notifyListeners(this, _change);\n      }\n\n      if ( true && notifySpy) {\n        spyReportEnd();\n      }\n    }\n\n    return true;\n  };\n\n  _proto.get_ = function get_(key) {\n    if (globalState.trackingDerivation && !hasProp(this.target_, key)) {\n      // Key doesn't exist yet, subscribe for it in case it's added later\n      this.has_(key);\n    }\n\n    return this.target_[key];\n  }\n  /**\r\n   * @param {PropertyKey} key\r\n   * @param {any} value\r\n   * @param {Annotation|boolean} annotation true - use default annotation, false - copy as is\r\n   * @param {boolean} proxyTrap whether it's called from proxy trap\r\n   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor\r\n   */\n  ;\n\n  _proto.set_ = function set_(key, value, proxyTrap) {\n    if (proxyTrap === void 0) {\n      proxyTrap = false;\n    }\n\n    // Don't use .has(key) - we care about own\n    if (hasProp(this.target_, key)) {\n      // Existing prop\n      if (this.values_.has(key)) {\n        // Observable (can be intercepted)\n        return this.setObservablePropValue_(key, value);\n      } else if (proxyTrap) {\n        // Non-observable - proxy\n        return Reflect.set(this.target_, key, value);\n      } else {\n        // Non-observable\n        this.target_[key] = value;\n        return true;\n      }\n    } else {\n      // New prop\n      return this.extend_(key, {\n        value: value,\n        enumerable: true,\n        writable: true,\n        configurable: true\n      }, this.defaultAnnotation_, proxyTrap);\n    }\n  } // Trap for \"in\"\n  ;\n\n  _proto.has_ = function has_(key) {\n    if (!globalState.trackingDerivation) {\n      // Skip key subscription outside derivation\n      return key in this.target_;\n    }\n\n    this.pendingKeys_ || (this.pendingKeys_ = new Map());\n    var entry = this.pendingKeys_.get(key);\n\n    if (!entry) {\n      entry = new ObservableValue(key in this.target_, referenceEnhancer,  true ? this.name_ + \".\" + stringifyKey(key) + \"?\" : 0, false);\n      this.pendingKeys_.set(key, entry);\n    }\n\n    return entry.get();\n  }\n  /**\r\n   * @param {PropertyKey} key\r\n   * @param {Annotation|boolean} annotation true - use default annotation, false - ignore prop\r\n   */\n  ;\n\n  _proto.make_ = function make_(key, annotation) {\n    if (annotation === true) {\n      annotation = this.defaultAnnotation_;\n    }\n\n    if (annotation === false) {\n      return;\n    }\n\n    assertAnnotable(this, annotation, key);\n\n    if (!(key in this.target_)) {\n      var _this$target_$storedA;\n\n      // Throw on missing key, except for decorators:\n      // Decorator annotations are collected from whole prototype chain.\n      // When called from super() some props may not exist yet.\n      // However we don't have to worry about missing prop,\n      // because the decorator must have been applied to something.\n      if ((_this$target_$storedA = this.target_[storedAnnotationsSymbol]) != null && _this$target_$storedA[key]) {\n        return; // will be annotated by subclass constructor\n      } else {\n        die(1, annotation.annotationType_, this.name_ + \".\" + key.toString());\n      }\n    }\n\n    var source = this.target_;\n\n    while (source && source !== objectPrototype) {\n      var descriptor = getDescriptor(source, key);\n\n      if (descriptor) {\n        var outcome = annotation.make_(this, key, descriptor, source);\n\n        if (outcome === 0\n        /* Cancel */\n        ) {\n          return;\n        }\n\n        if (outcome === 1\n        /* Break */\n        ) {\n          break;\n        }\n      }\n\n      source = Object.getPrototypeOf(source);\n    }\n\n    recordAnnotationApplied(this, annotation, key);\n  }\n  /**\r\n   * @param {PropertyKey} key\r\n   * @param {PropertyDescriptor} descriptor\r\n   * @param {Annotation|boolean} annotation true - use default annotation, false - copy as is\r\n   * @param {boolean} proxyTrap whether it's called from proxy trap\r\n   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor\r\n   */\n  ;\n\n  _proto.extend_ = function extend_(key, descriptor, annotation, proxyTrap) {\n    if (proxyTrap === void 0) {\n      proxyTrap = false;\n    }\n\n    if (annotation === true) {\n      annotation = this.defaultAnnotation_;\n    }\n\n    if (annotation === false) {\n      return this.defineProperty_(key, descriptor, proxyTrap);\n    }\n\n    assertAnnotable(this, annotation, key);\n    var outcome = annotation.extend_(this, key, descriptor, proxyTrap);\n\n    if (outcome) {\n      recordAnnotationApplied(this, annotation, key);\n    }\n\n    return outcome;\n  }\n  /**\r\n   * @param {PropertyKey} key\r\n   * @param {PropertyDescriptor} descriptor\r\n   * @param {boolean} proxyTrap whether it's called from proxy trap\r\n   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor\r\n   */\n  ;\n\n  _proto.defineProperty_ = function defineProperty_(key, descriptor, proxyTrap) {\n    if (proxyTrap === void 0) {\n      proxyTrap = false;\n    }\n\n    try {\n      startBatch(); // Delete\n\n      var deleteOutcome = this.delete_(key);\n\n      if (!deleteOutcome) {\n        // Failure or intercepted\n        return deleteOutcome;\n      } // ADD interceptor\n\n\n      if (hasInterceptors(this)) {\n        var change = interceptChange(this, {\n          object: this.proxy_ || this.target_,\n          name: key,\n          type: ADD,\n          newValue: descriptor.value\n        });\n\n        if (!change) {\n          return null;\n        }\n\n        var newValue = change.newValue;\n\n        if (descriptor.value !== newValue) {\n          descriptor = _extends({}, descriptor, {\n            value: newValue\n          });\n        }\n      } // Define\n\n\n      if (proxyTrap) {\n        if (!Reflect.defineProperty(this.target_, key, descriptor)) {\n          return false;\n        }\n      } else {\n        defineProperty(this.target_, key, descriptor);\n      } // Notify\n\n\n      this.notifyPropertyAddition_(key, descriptor.value);\n    } finally {\n      endBatch();\n    }\n\n    return true;\n  } // If original descriptor becomes relevant, move this to annotation directly\n  ;\n\n  _proto.defineObservableProperty_ = function defineObservableProperty_(key, value, enhancer, proxyTrap) {\n    if (proxyTrap === void 0) {\n      proxyTrap = false;\n    }\n\n    try {\n      startBatch(); // Delete\n\n      var deleteOutcome = this.delete_(key);\n\n      if (!deleteOutcome) {\n        // Failure or intercepted\n        return deleteOutcome;\n      } // ADD interceptor\n\n\n      if (hasInterceptors(this)) {\n        var change = interceptChange(this, {\n          object: this.proxy_ || this.target_,\n          name: key,\n          type: ADD,\n          newValue: value\n        });\n\n        if (!change) {\n          return null;\n        }\n\n        value = change.newValue;\n      }\n\n      var cachedDescriptor = getCachedObservablePropDescriptor(key);\n      var descriptor = {\n        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,\n        enumerable: true,\n        get: cachedDescriptor.get,\n        set: cachedDescriptor.set\n      }; // Define\n\n      if (proxyTrap) {\n        if (!Reflect.defineProperty(this.target_, key, descriptor)) {\n          return false;\n        }\n      } else {\n        defineProperty(this.target_, key, descriptor);\n      }\n\n      var observable = new ObservableValue(value, enhancer,  true ? this.name_ + \".\" + key.toString() : 0, false);\n      this.values_.set(key, observable); // Notify (value possibly changed by ObservableValue)\n\n      this.notifyPropertyAddition_(key, observable.value_);\n    } finally {\n      endBatch();\n    }\n\n    return true;\n  } // If original descriptor becomes relevant, move this to annotation directly\n  ;\n\n  _proto.defineComputedProperty_ = function defineComputedProperty_(key, options, proxyTrap) {\n    if (proxyTrap === void 0) {\n      proxyTrap = false;\n    }\n\n    try {\n      startBatch(); // Delete\n\n      var deleteOutcome = this.delete_(key);\n\n      if (!deleteOutcome) {\n        // Failure or intercepted\n        return deleteOutcome;\n      } // ADD interceptor\n\n\n      if (hasInterceptors(this)) {\n        var change = interceptChange(this, {\n          object: this.proxy_ || this.target_,\n          name: key,\n          type: ADD,\n          newValue: undefined\n        });\n\n        if (!change) {\n          return null;\n        }\n      }\n\n      options.name || (options.name =  true ? this.name_ + \".\" + key.toString() : 0);\n      options.context = this.proxy_ || this.target_;\n      var cachedDescriptor = getCachedObservablePropDescriptor(key);\n      var descriptor = {\n        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,\n        enumerable: false,\n        get: cachedDescriptor.get,\n        set: cachedDescriptor.set\n      }; // Define\n\n      if (proxyTrap) {\n        if (!Reflect.defineProperty(this.target_, key, descriptor)) {\n          return false;\n        }\n      } else {\n        defineProperty(this.target_, key, descriptor);\n      }\n\n      this.values_.set(key, new ComputedValue(options)); // Notify\n\n      this.notifyPropertyAddition_(key, undefined);\n    } finally {\n      endBatch();\n    }\n\n    return true;\n  }\n  /**\r\n   * @param {PropertyKey} key\r\n   * @param {PropertyDescriptor} descriptor\r\n   * @param {boolean} proxyTrap whether it's called from proxy trap\r\n   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor\r\n   */\n  ;\n\n  _proto.delete_ = function delete_(key, proxyTrap) {\n    if (proxyTrap === void 0) {\n      proxyTrap = false;\n    }\n\n    // No such prop\n    if (!hasProp(this.target_, key)) {\n      return true;\n    } // Intercept\n\n\n    if (hasInterceptors(this)) {\n      var change = interceptChange(this, {\n        object: this.proxy_ || this.target_,\n        name: key,\n        type: REMOVE\n      }); // Cancelled\n\n      if (!change) {\n        return null;\n      }\n    } // Delete\n\n\n    try {\n      var _this$pendingKeys_, _this$pendingKeys_$ge;\n\n      startBatch();\n      var notify = hasListeners(this);\n      var notifySpy =  true && isSpyEnabled();\n      var observable = this.values_.get(key); // Value needed for spies/listeners\n\n      var value = undefined; // Optimization: don't pull the value unless we will need it\n\n      if (!observable && (notify || notifySpy)) {\n        var _getDescriptor;\n\n        value = (_getDescriptor = getDescriptor(this.target_, key)) == null ? void 0 : _getDescriptor.value;\n      } // delete prop (do first, may fail)\n\n\n      if (proxyTrap) {\n        if (!Reflect.deleteProperty(this.target_, key)) {\n          return false;\n        }\n      } else {\n        delete this.target_[key];\n      } // Allow re-annotating this field\n\n\n      if (true) {\n        delete this.appliedAnnotations_[key];\n      } // Clear observable\n\n\n      if (observable) {\n        this.values_[\"delete\"](key); // for computed, value is undefined\n\n        if (observable instanceof ObservableValue) {\n          value = observable.value_;\n        } // Notify: autorun(() => obj[key]), see #1796\n\n\n        propagateChanged(observable);\n      } // Notify \"keys/entries/values\" observers\n\n\n      this.keysAtom_.reportChanged(); // Notify \"has\" observers\n      // \"in\" as it may still exist in proto\n\n      (_this$pendingKeys_ = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_$ge = _this$pendingKeys_.get(key)) == null ? void 0 : _this$pendingKeys_$ge.set(key in this.target_); // Notify spies/listeners\n\n      if (notify || notifySpy) {\n        var _change2 = {\n          type: REMOVE,\n          observableKind: \"object\",\n          object: this.proxy_ || this.target_,\n          debugObjectName: this.name_,\n          oldValue: value,\n          name: key\n        };\n\n        if ( true && notifySpy) {\n          spyReportStart(_change2);\n        }\n\n        if (notify) {\n          notifyListeners(this, _change2);\n        }\n\n        if ( true && notifySpy) {\n          spyReportEnd();\n        }\n      }\n    } finally {\n      endBatch();\n    }\n\n    return true;\n  }\n  /**\r\n   * Observes this object. Triggers for the events 'add', 'update' and 'delete'.\r\n   * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe\r\n   * for callback details\r\n   */\n  ;\n\n  _proto.observe_ = function observe_(callback, fireImmediately) {\n    if ( true && fireImmediately === true) {\n      die(\"`observe` doesn't support the fire immediately property for observable objects.\");\n    }\n\n    return registerListener(this, callback);\n  };\n\n  _proto.intercept_ = function intercept_(handler) {\n    return registerInterceptor(this, handler);\n  };\n\n  _proto.notifyPropertyAddition_ = function notifyPropertyAddition_(key, value) {\n    var _this$pendingKeys_2, _this$pendingKeys_2$g;\n\n    var notify = hasListeners(this);\n    var notifySpy =  true && isSpyEnabled();\n\n    if (notify || notifySpy) {\n      var change = notify || notifySpy ? {\n        type: ADD,\n        observableKind: \"object\",\n        debugObjectName: this.name_,\n        object: this.proxy_ || this.target_,\n        name: key,\n        newValue: value\n      } : null;\n\n      if ( true && notifySpy) {\n        spyReportStart(change);\n      }\n\n      if (notify) {\n        notifyListeners(this, change);\n      }\n\n      if ( true && notifySpy) {\n        spyReportEnd();\n      }\n    }\n\n    (_this$pendingKeys_2 = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_2$g = _this$pendingKeys_2.get(key)) == null ? void 0 : _this$pendingKeys_2$g.set(true); // Notify \"keys/entries/values\" observers\n\n    this.keysAtom_.reportChanged();\n  };\n\n  _proto.ownKeys_ = function ownKeys_() {\n    this.keysAtom_.reportObserved();\n    return ownKeys(this.target_);\n  };\n\n  _proto.keys_ = function keys_() {\n    // Returns enumerable && own, but unfortunately keysAtom will report on ANY key change.\n    // There is no way to distinguish between Object.keys(object) and Reflect.ownKeys(object) - both are handled by ownKeys trap.\n    // We can either over-report in Object.keys(object) or under-report in Reflect.ownKeys(object)\n    // We choose to over-report in Object.keys(object), because:\n    // - typically it's used with simple data objects\n    // - when symbolic/non-enumerable keys are relevant Reflect.ownKeys works as expected\n    this.keysAtom_.reportObserved();\n    return Object.keys(this.target_);\n  };\n\n  return ObservableObjectAdministration;\n}();\nfunction asObservableObject(target, options) {\n  var _options$name;\n\n  if ( true && options && isObservableObject(target)) {\n    die(\"Options can't be provided for already observable objects.\");\n  }\n\n  if (hasProp(target, $mobx)) {\n    if ( true && !(getAdministration(target) instanceof ObservableObjectAdministration)) {\n      die(\"Cannot convert '\" + getDebugName(target) + \"' into observable object:\" + \"\\nThe target is already observable of different type.\" + \"\\nExtending builtins is not supported.\");\n    }\n\n    return target;\n  }\n\n  if ( true && !Object.isExtensible(target)) {\n    die(\"Cannot make the designated object observable; it is not extensible\");\n  }\n\n  var name = (_options$name = options == null ? void 0 : options.name) != null ? _options$name :  true ? (isPlainObject(target) ? \"ObservableObject\" : target.constructor.name) + \"@\" + getNextId() : 0;\n  var adm = new ObservableObjectAdministration(target, new Map(), String(name), getAnnotationFromOptions(options));\n  addHiddenProp(target, $mobx, adm);\n  return target;\n}\nvar isObservableObjectAdministration = /*#__PURE__*/createInstanceofPredicate(\"ObservableObjectAdministration\", ObservableObjectAdministration);\n\nfunction getCachedObservablePropDescriptor(key) {\n  return descriptorCache[key] || (descriptorCache[key] = {\n    get: function get() {\n      return this[$mobx].getObservablePropValue_(key);\n    },\n    set: function set(value) {\n      return this[$mobx].setObservablePropValue_(key, value);\n    }\n  });\n}\n\nfunction isObservableObject(thing) {\n  if (isObject(thing)) {\n    return isObservableObjectAdministration(thing[$mobx]);\n  }\n\n  return false;\n}\nfunction recordAnnotationApplied(adm, annotation, key) {\n  var _adm$target_$storedAn;\n\n  if (true) {\n    adm.appliedAnnotations_[key] = annotation;\n  } // Remove applied decorator annotation so we don't try to apply it again in subclass constructor\n\n\n  (_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null ? true : delete _adm$target_$storedAn[key];\n}\n\nfunction assertAnnotable(adm, annotation, key) {\n  // Valid annotation\n  if ( true && !isAnnotation(annotation)) {\n    die(\"Cannot annotate '\" + adm.name_ + \".\" + key.toString() + \"': Invalid annotation.\");\n  }\n  /*\r\n  // Configurable, not sealed, not frozen\r\n  // Possibly not needed, just a little better error then the one thrown by engine.\r\n  // Cases where this would be useful the most (subclass field initializer) are not interceptable by this.\r\n  if (__DEV__) {\r\n      const configurable = getDescriptor(adm.target_, key)?.configurable\r\n      const frozen = Object.isFrozen(adm.target_)\r\n      const sealed = Object.isSealed(adm.target_)\r\n      if (!configurable || frozen || sealed) {\r\n          const fieldName = `${adm.name_}.${key.toString()}`\r\n          const requestedAnnotationType = annotation.annotationType_\r\n          let error = `Cannot apply '${requestedAnnotationType}' to '${fieldName}':`\r\n          if (frozen) {\r\n              error += `\\nObject is frozen.`\r\n          }\r\n          if (sealed) {\r\n              error += `\\nObject is sealed.`\r\n          }\r\n          if (!configurable) {\r\n              error += `\\nproperty is not configurable.`\r\n              // Mention only if caused by us to avoid confusion\r\n              if (hasProp(adm.appliedAnnotations!, key)) {\r\n                  error += `\\nTo prevent accidental re-definition of a field by a subclass, `\r\n                  error += `all annotated fields of non-plain objects (classes) are not configurable.`\r\n              }\r\n          }\r\n          die(error)\r\n      }\r\n  }\r\n  */\n  // Not annotated\n\n\n  if ( true && !isOverride(annotation) && hasProp(adm.appliedAnnotations_, key)) {\n    var fieldName = adm.name_ + \".\" + key.toString();\n    var currentAnnotationType = adm.appliedAnnotations_[key].annotationType_;\n    var requestedAnnotationType = annotation.annotationType_;\n    die(\"Cannot apply '\" + requestedAnnotationType + \"' to '\" + fieldName + \"':\" + (\"\\nThe field is already annotated with '\" + currentAnnotationType + \"'.\") + \"\\nRe-annotating fields is not allowed.\" + \"\\nUse 'override' annotation for methods overridden by subclass.\");\n  }\n}\n\nvar ENTRY_0 = /*#__PURE__*/createArrayEntryDescriptor(0);\n/**\r\n * This array buffer contains two lists of properties, so that all arrays\r\n * can recycle their property definitions, which significantly improves performance of creating\r\n * properties on the fly.\r\n */\n\n\nvar OBSERVABLE_ARRAY_BUFFER_SIZE = 0; // Typescript workaround to make sure ObservableArray extends Array\n\nvar StubArray = function StubArray() {};\n\nfunction inherit(ctor, proto) {\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(ctor.prototype, proto);\n  } else if (ctor.prototype.__proto__ !== undefined) {\n    ctor.prototype.__proto__ = proto;\n  } else {\n    ctor.prototype = proto;\n  }\n}\n\ninherit(StubArray, Array.prototype); // Weex proto freeze protection was here,\n// but it is unclear why the hack is need as MobX never changed the prototype\n// anyway, so removed it in V6\n\nvar LegacyObservableArray = /*#__PURE__*/function (_StubArray, _Symbol$toStringTag, _Symbol$iterator) {\n  _inheritsLoose(LegacyObservableArray, _StubArray);\n\n  function LegacyObservableArray(initialValues, enhancer, name, owned) {\n    var _this;\n\n    if (name === void 0) {\n      name =  true ? \"ObservableArray@\" + getNextId() : 0;\n    }\n\n    if (owned === void 0) {\n      owned = false;\n    }\n\n    _this = _StubArray.call(this) || this;\n    var adm = new ObservableArrayAdministration(name, enhancer, owned, true);\n    adm.proxy_ = _assertThisInitialized(_this);\n    addHiddenFinalProp(_assertThisInitialized(_this), $mobx, adm);\n\n    if (initialValues && initialValues.length) {\n      var prev = allowStateChangesStart(true); // @ts-ignore\n\n      _this.spliceWithArray(0, 0, initialValues);\n\n      allowStateChangesEnd(prev);\n    }\n\n    {\n      // Seems that Safari won't use numeric prototype setter untill any * numeric property is\n      // defined on the instance. After that it works fine, even if this property is deleted.\n      Object.defineProperty(_assertThisInitialized(_this), \"0\", ENTRY_0);\n    }\n\n    return _this;\n  }\n\n  var _proto = LegacyObservableArray.prototype;\n\n  _proto.concat = function concat() {\n    this[$mobx].atom_.reportObserved();\n\n    for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n      arrays[_key] = arguments[_key];\n    }\n\n    return Array.prototype.concat.apply(this.slice(), //@ts-ignore\n    arrays.map(function (a) {\n      return isObservableArray(a) ? a.slice() : a;\n    }));\n  };\n\n  _proto[_Symbol$iterator] = function () {\n    var self = this;\n    var nextIndex = 0;\n    return makeIterable({\n      next: function next() {\n        return nextIndex < self.length ? {\n          value: self[nextIndex++],\n          done: false\n        } : {\n          done: true,\n          value: undefined\n        };\n      }\n    });\n  };\n\n  _createClass(LegacyObservableArray, [{\n    key: \"length\",\n    get: function get() {\n      return this[$mobx].getArrayLength_();\n    },\n    set: function set(newLength) {\n      this[$mobx].setArrayLength_(newLength);\n    }\n  }, {\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return \"Array\";\n    }\n  }]);\n\n  return LegacyObservableArray;\n}(StubArray, Symbol.toStringTag, Symbol.iterator);\n\nObject.entries(arrayExtensions).forEach(function (_ref) {\n  var prop = _ref[0],\n      fn = _ref[1];\n\n  if (prop !== \"concat\") {\n    addHiddenProp(LegacyObservableArray.prototype, prop, fn);\n  }\n});\n\nfunction createArrayEntryDescriptor(index) {\n  return {\n    enumerable: false,\n    configurable: true,\n    get: function get() {\n      return this[$mobx].get_(index);\n    },\n    set: function set(value) {\n      this[$mobx].set_(index, value);\n    }\n  };\n}\n\nfunction createArrayBufferItem(index) {\n  defineProperty(LegacyObservableArray.prototype, \"\" + index, createArrayEntryDescriptor(index));\n}\n\nfunction reserveArrayBuffer(max) {\n  if (max > OBSERVABLE_ARRAY_BUFFER_SIZE) {\n    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max + 100; index++) {\n      createArrayBufferItem(index);\n    }\n\n    OBSERVABLE_ARRAY_BUFFER_SIZE = max;\n  }\n}\nreserveArrayBuffer(1000);\nfunction createLegacyArray(initialValues, enhancer, name) {\n  return new LegacyObservableArray(initialValues, enhancer, name);\n}\n\nfunction getAtom(thing, property) {\n  if (typeof thing === \"object\" && thing !== null) {\n    if (isObservableArray(thing)) {\n      if (property !== undefined) {\n        die(23);\n      }\n\n      return thing[$mobx].atom_;\n    }\n\n    if (isObservableSet(thing)) {\n      return thing[$mobx];\n    }\n\n    if (isObservableMap(thing)) {\n      if (property === undefined) {\n        return thing.keysAtom_;\n      }\n\n      var observable = thing.data_.get(property) || thing.hasMap_.get(property);\n\n      if (!observable) {\n        die(25, property, getDebugName(thing));\n      }\n\n      return observable;\n    }\n\n\n    if (isObservableObject(thing)) {\n      if (!property) {\n        return die(26);\n      }\n\n      var _observable = thing[$mobx].values_.get(property);\n\n      if (!_observable) {\n        die(27, property, getDebugName(thing));\n      }\n\n      return _observable;\n    }\n\n    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {\n      return thing;\n    }\n  } else if (isFunction(thing)) {\n    if (isReaction(thing[$mobx])) {\n      // disposer function\n      return thing[$mobx];\n    }\n  }\n\n  die(28);\n}\nfunction getAdministration(thing, property) {\n  if (!thing) {\n    die(29);\n  }\n\n  if (property !== undefined) {\n    return getAdministration(getAtom(thing, property));\n  }\n\n  if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {\n    return thing;\n  }\n\n  if (isObservableMap(thing) || isObservableSet(thing)) {\n    return thing;\n  }\n\n  if (thing[$mobx]) {\n    return thing[$mobx];\n  }\n\n  die(24, thing);\n}\nfunction getDebugName(thing, property) {\n  var named;\n\n  if (property !== undefined) {\n    named = getAtom(thing, property);\n  } else if (isAction(thing)) {\n    return thing.name;\n  } else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing)) {\n    named = getAdministration(thing);\n  } else {\n    // valid for arrays as well\n    named = getAtom(thing);\n  }\n\n  return named.name_;\n}\n\nvar toString = objectPrototype.toString;\nfunction deepEqual(a, b, depth) {\n  if (depth === void 0) {\n    depth = -1;\n  }\n\n  return eq(a, b, depth);\n} // Copied from https://github.com/jashkenas/underscore/blob/5c237a7c682fb68fd5378203f0bf22dce1624854/underscore.js#L1186-L1289\n// Internal recursive comparison function for `isEqual`.\n\nfunction eq(a, b, depth, aStack, bStack) {\n  // Identical objects are equal. `0 === -0`, but they aren't identical.\n  // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n  if (a === b) {\n    return a !== 0 || 1 / a === 1 / b;\n  } // `null` or `undefined` only equal to itself (strict comparison).\n\n\n  if (a == null || b == null) {\n    return false;\n  } // `NaN`s are equivalent, but non-reflexive.\n\n\n  if (a !== a) {\n    return b !== b;\n  } // Exhaust primitive checks\n\n\n  var type = typeof a;\n\n  if (type !== \"function\" && type !== \"object\" && typeof b != \"object\") {\n    return false;\n  } // Compare `[[Class]]` names.\n\n\n  var className = toString.call(a);\n\n  if (className !== toString.call(b)) {\n    return false;\n  }\n\n  switch (className) {\n    // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n    case \"[object RegExp]\": // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n\n    case \"[object String]\":\n      // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n      // equivalent to `new String(\"5\")`.\n      return \"\" + a === \"\" + b;\n\n    case \"[object Number]\":\n      // `NaN`s are equivalent, but non-reflexive.\n      // Object(NaN) is equivalent to NaN.\n      if (+a !== +a) {\n        return +b !== +b;\n      } // An `egal` comparison is performed for other numeric values.\n\n\n      return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n\n    case \"[object Date]\":\n    case \"[object Boolean]\":\n      // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n      // millisecond representations. Note that invalid dates with millisecond representations\n      // of `NaN` are not equivalent.\n      return +a === +b;\n\n    case \"[object Symbol]\":\n      return typeof Symbol !== \"undefined\" && Symbol.valueOf.call(a) === Symbol.valueOf.call(b);\n\n    case \"[object Map]\":\n    case \"[object Set]\":\n      // Maps and Sets are unwrapped to arrays of entry-pairs, adding an incidental level.\n      // Hide this extra level by increasing the depth.\n      if (depth >= 0) {\n        depth++;\n      }\n\n      break;\n  } // Unwrap any wrapped objects.\n\n\n  a = unwrap(a);\n  b = unwrap(b);\n  var areArrays = className === \"[object Array]\";\n\n  if (!areArrays) {\n    if (typeof a != \"object\" || typeof b != \"object\") {\n      return false;\n    } // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n    // from different frames are.\n\n\n    var aCtor = a.constructor,\n        bCtor = b.constructor;\n\n    if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor && isFunction(bCtor) && bCtor instanceof bCtor) && \"constructor\" in a && \"constructor\" in b) {\n      return false;\n    }\n  }\n\n  if (depth === 0) {\n    return false;\n  } else if (depth < 0) {\n    depth = -1;\n  } // Assume equality for cyclic structures. The algorithm for detecting cyclic\n  // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n  // Initializing stack of traversed objects.\n  // It's done here since we only need them for objects and arrays comparison.\n\n\n  aStack = aStack || [];\n  bStack = bStack || [];\n  var length = aStack.length;\n\n  while (length--) {\n    // Linear search. Performance is inversely proportional to the number of\n    // unique nested structures.\n    if (aStack[length] === a) {\n      return bStack[length] === b;\n    }\n  } // Add the first object to the stack of traversed objects.\n\n\n  aStack.push(a);\n  bStack.push(b); // Recursively compare objects and arrays.\n\n  if (areArrays) {\n    // Compare array lengths to determine if a deep comparison is necessary.\n    length = a.length;\n\n    if (length !== b.length) {\n      return false;\n    } // Deep compare the contents, ignoring non-numeric properties.\n\n\n    while (length--) {\n      if (!eq(a[length], b[length], depth - 1, aStack, bStack)) {\n        return false;\n      }\n    }\n  } else {\n    // Deep compare objects.\n    var keys = Object.keys(a);\n    var key;\n    length = keys.length; // Ensure that both objects contain the same number of properties before comparing deep equality.\n\n    if (Object.keys(b).length !== length) {\n      return false;\n    }\n\n    while (length--) {\n      // Deep compare each member\n      key = keys[length];\n\n      if (!(hasProp(b, key) && eq(a[key], b[key], depth - 1, aStack, bStack))) {\n        return false;\n      }\n    }\n  } // Remove the first object from the stack of traversed objects.\n\n\n  aStack.pop();\n  bStack.pop();\n  return true;\n}\n\nfunction unwrap(a) {\n  if (isObservableArray(a)) {\n    return a.slice();\n  }\n\n  if (isES6Map(a) || isObservableMap(a)) {\n    return Array.from(a.entries());\n  }\n\n  if (isES6Set(a) || isObservableSet(a)) {\n    return Array.from(a.entries());\n  }\n\n  return a;\n}\n\nfunction makeIterable(iterator) {\n  iterator[Symbol.iterator] = getSelf;\n  return iterator;\n}\n\nfunction getSelf() {\n  return this;\n}\n\nfunction isAnnotation(thing) {\n  return (// Can be function\n    thing instanceof Object && typeof thing.annotationType_ === \"string\" && isFunction(thing.make_) && isFunction(thing.extend_)\n  );\n}\n\n/**\r\n * (c) Michel Weststrate 2015 - 2020\r\n * MIT Licensed\r\n *\r\n * Welcome to the mobx sources! To get a global overview of how MobX internally works,\r\n * this is a good place to start:\r\n * https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.xvbh6qd74\r\n *\r\n * Source folders:\r\n * ===============\r\n *\r\n * - api/     Most of the public static methods exposed by the module can be found here.\r\n * - core/    Implementation of the MobX algorithm; atoms, derivations, reactions, dependency trees, optimizations. Cool stuff can be found here.\r\n * - types/   All the magic that is need to have observable objects, arrays and values is in this folder. Including the modifiers like `asFlat`.\r\n * - utils/   Utility stuff.\r\n *\r\n */\n[\"Symbol\", \"Map\", \"Set\"].forEach(function (m) {\n  var g = getGlobal();\n\n  if (typeof g[m] === \"undefined\") {\n    die(\"MobX requires global '\" + m + \"' to be available or polyfilled\");\n  }\n});\n\nif (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === \"object\") {\n  // See: https://github.com/andykog/mobx-devtools/\n  __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({\n    spy: spy,\n    extras: {\n      getDebugName: getDebugName\n    },\n    $mobx: $mobx\n  });\n}\n\n\n//# sourceMappingURL=mobx.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9ieC9kaXN0L21vYnguZXNtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZELEdBQUc7QUFDSDtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQsR0FBRztBQUNIO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxxSEFBcUgsMEJBQTBCO0FBQy9JO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQXFDLGdCQUFnQixDQUFFO0FBQ3BFO0FBQ0EseUZBQXlGLGFBQWE7QUFDdEc7QUFDQTs7QUFFQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxxQkFBTTtBQUNuQixXQUFXLHFCQUFNO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBcUMsaUlBQWlJLENBQXFCO0FBQ25NO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUzs7QUFFbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakUsSUFBSTs7O0FBR0osTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0EsSUFBSTs7O0FBR0osa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBLE1BQU07OztBQUdOLDhEQUE4RDtBQUM5RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQXFDLDJCQUEyQixDQUFNO0FBQ3BGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0EsSUFBSTs7O0FBR0osTUFBTSxLQUFxQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FB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Q1A7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFVBQVUsS0FBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUEsVUFBVSxLQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsS0FBcUMsb0NBQW9DLENBQWU7O0FBRTFIO0FBQ0Esa0NBQWtDLEtBQXFDLDRCQUE0QixDQUFzQjtBQUN6SDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFVBQVUsS0FBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0IsVUFBVSxLQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFFBQVEsS0FBd0MsRUFBRSxFQUU3Qzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7O0FBRUEsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUZBQW1GO0FBQ25GOztBQUVBO0FBQ0EsQ0FBQyw4Q0FBOEM7O0FBRS9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7O0FBRS9CO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQTs7QUFFQSx3QkFBd0IsT0FBTztBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLE1BQU0sS0FBd0MsRUFBRSxFQUU3Qzs7QUFFSCwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0Q7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxLQUF3QyxFQUFFLEVBRTdDOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsT0FBTztBQUN6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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STtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1YsNkNBQTZDOzs7QUFHN0M7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBLFFBQVE7QUFDUixxQkFBcUI7QUFDckI7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLFFBQVEsS0FBcUM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBLElBQUksU0FBUyxJQUFxQztBQUNsRDtBQUNBOztBQUVBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0o7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU0sS0FBd0MsRUFBRSxFQUU3Qzs7QUFFSDs7QUFFQSxzRUFBc0UsYUFBYTtBQUNuRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLGNBQWMsS0FBcUMsd0NBQXdDLENBQU07QUFDakcsa0NBQWtDLEtBQXFDLDJCQUEyQixDQUFhLFdBQVc7O0FBRTFIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3REFBd0Q7QUFDeEQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxLQUFxQztBQUM3QztBQUNBLE1BQU07OztBQUdOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsUUFBUSxJQUFxQztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQSxNQUFNOzs7QUFHTjtBQUNBLEdBQUc7QUFDSDtBQUNBLFFBQVEsS0FBcUM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsT0FBTztBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7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RUE7QUFDQSwrQ0FBK0M7O0FBRS9DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMEVBQTBFLGFBQWE7QUFDdkY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1EQUFtRCxtQkFBbUI7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7O0FBRXlxQztBQUN6cUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21vYngvZGlzdC9tb2J4LmVzbS5qcz83ZWFjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBuaWNlRXJyb3JzID0ge1xuICAwOiBcIkludmFsaWQgdmFsdWUgZm9yIGNvbmZpZ3VyYXRpb24gJ2VuZm9yY2VBY3Rpb25zJywgZXhwZWN0ZWQgJ25ldmVyJywgJ2Fsd2F5cycgb3IgJ29ic2VydmVkJ1wiLFxuICAxOiBmdW5jdGlvbiBfKGFubm90YXRpb25UeXBlLCBrZXkpIHtcbiAgICByZXR1cm4gXCJDYW5ub3QgYXBwbHkgJ1wiICsgYW5ub3RhdGlvblR5cGUgKyBcIicgdG8gJ1wiICsga2V5LnRvU3RyaW5nKCkgKyBcIic6IEZpZWxkIG5vdCBmb3VuZC5cIjtcbiAgfSxcblxuICAvKlxyXG4gIDIocHJvcCkge1xyXG4gICAgICByZXR1cm4gYGludmFsaWQgZGVjb3JhdG9yIGZvciAnJHtwcm9wLnRvU3RyaW5nKCl9J2BcclxuICB9LFxyXG4gIDMocHJvcCkge1xyXG4gICAgICByZXR1cm4gYENhbm5vdCBkZWNvcmF0ZSAnJHtwcm9wLnRvU3RyaW5nKCl9JzogYWN0aW9uIGNhbiBvbmx5IGJlIHVzZWQgb24gcHJvcGVydGllcyB3aXRoIGEgZnVuY3Rpb24gdmFsdWUuYFxyXG4gIH0sXHJcbiAgNChwcm9wKSB7XHJcbiAgICAgIHJldHVybiBgQ2Fubm90IGRlY29yYXRlICcke3Byb3AudG9TdHJpbmcoKX0nOiBjb21wdXRlZCBjYW4gb25seSBiZSB1c2VkIG9uIGdldHRlciBwcm9wZXJ0aWVzLmBcclxuICB9LFxyXG4gICovXG4gIDU6IFwiJ2tleXMoKScgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYnNlcnZhYmxlIG9iamVjdHMsIGFycmF5cywgc2V0cyBhbmQgbWFwc1wiLFxuICA2OiBcIid2YWx1ZXMoKScgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYnNlcnZhYmxlIG9iamVjdHMsIGFycmF5cywgc2V0cyBhbmQgbWFwc1wiLFxuICA3OiBcIidlbnRyaWVzKCknIGNhbiBvbmx5IGJlIHVzZWQgb24gb2JzZXJ2YWJsZSBvYmplY3RzLCBhcnJheXMgYW5kIG1hcHNcIixcbiAgODogXCInc2V0KCknIGNhbiBvbmx5IGJlIHVzZWQgb24gb2JzZXJ2YWJsZSBvYmplY3RzLCBhcnJheXMgYW5kIG1hcHNcIixcbiAgOTogXCIncmVtb3ZlKCknIGNhbiBvbmx5IGJlIHVzZWQgb24gb2JzZXJ2YWJsZSBvYmplY3RzLCBhcnJheXMgYW5kIG1hcHNcIixcbiAgMTA6IFwiJ2hhcygpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0cywgYXJyYXlzIGFuZCBtYXBzXCIsXG4gIDExOiBcIidnZXQoKScgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYnNlcnZhYmxlIG9iamVjdHMsIGFycmF5cyBhbmQgbWFwc1wiLFxuICAxMjogXCJJbnZhbGlkIGFubm90YXRpb25cIixcbiAgMTM6IFwiRHluYW1pYyBvYnNlcnZhYmxlIG9iamVjdHMgY2Fubm90IGJlIGZyb3plbi4gSWYgeW91J3JlIHBhc3Npbmcgb2JzZXJ2YWJsZXMgdG8gM3JkIHBhcnR5IGNvbXBvbmVudC9mdW5jdGlvbiB0aGF0IGNhbGxzIE9iamVjdC5mcmVlemUsIHBhc3MgY29weSBpbnN0ZWFkOiB0b0pTKG9ic2VydmFibGUpXCIsXG4gIDE0OiBcIkludGVyY2VwdCBoYW5kbGVycyBzaG91bGQgcmV0dXJuIG5vdGhpbmcgb3IgYSBjaGFuZ2Ugb2JqZWN0XCIsXG4gIDE1OiBcIk9ic2VydmFibGUgYXJyYXlzIGNhbm5vdCBiZSBmcm96ZW4uIElmIHlvdSdyZSBwYXNzaW5nIG9ic2VydmFibGVzIHRvIDNyZCBwYXJ0eSBjb21wb25lbnQvZnVuY3Rpb24gdGhhdCBjYWxscyBPYmplY3QuZnJlZXplLCBwYXNzIGNvcHkgaW5zdGVhZDogdG9KUyhvYnNlcnZhYmxlKVwiLFxuICAxNjogXCJNb2RpZmljYXRpb24gZXhjZXB0aW9uOiB0aGUgaW50ZXJuYWwgc3RydWN0dXJlIG9mIGFuIG9ic2VydmFibGUgYXJyYXkgd2FzIGNoYW5nZWQuXCIsXG4gIDE3OiBmdW5jdGlvbiBfKGluZGV4LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gXCJbbW9ieC5hcnJheV0gSW5kZXggb3V0IG9mIGJvdW5kcywgXCIgKyBpbmRleCArIFwiIGlzIGxhcmdlciB0aGFuIFwiICsgbGVuZ3RoO1xuICB9LFxuICAxODogXCJtb2J4Lm1hcCByZXF1aXJlcyBNYXAgcG9seWZpbGwgZm9yIHRoZSBjdXJyZW50IGJyb3dzZXIuIENoZWNrIGJhYmVsLXBvbHlmaWxsIG9yIGNvcmUtanMvZXM2L21hcC5qc1wiLFxuICAxOTogZnVuY3Rpb24gXyhvdGhlcikge1xuICAgIHJldHVybiBcIkNhbm5vdCBpbml0aWFsaXplIGZyb20gY2xhc3NlcyB0aGF0IGluaGVyaXQgZnJvbSBNYXA6IFwiICsgb3RoZXIuY29uc3RydWN0b3IubmFtZTtcbiAgfSxcbiAgMjA6IGZ1bmN0aW9uIF8ob3RoZXIpIHtcbiAgICByZXR1cm4gXCJDYW5ub3QgaW5pdGlhbGl6ZSBtYXAgZnJvbSBcIiArIG90aGVyO1xuICB9LFxuICAyMTogZnVuY3Rpb24gXyhkYXRhU3RydWN0dXJlKSB7XG4gICAgcmV0dXJuIFwiQ2Fubm90IGNvbnZlcnQgdG8gbWFwIGZyb20gJ1wiICsgZGF0YVN0cnVjdHVyZSArIFwiJ1wiO1xuICB9LFxuICAyMjogXCJtb2J4LnNldCByZXF1aXJlcyBTZXQgcG9seWZpbGwgZm9yIHRoZSBjdXJyZW50IGJyb3dzZXIuIENoZWNrIGJhYmVsLXBvbHlmaWxsIG9yIGNvcmUtanMvZXM2L3NldC5qc1wiLFxuICAyMzogXCJJdCBpcyBub3QgcG9zc2libGUgdG8gZ2V0IGluZGV4IGF0b21zIGZyb20gYXJyYXlzXCIsXG4gIDI0OiBmdW5jdGlvbiBfKHRoaW5nKSB7XG4gICAgcmV0dXJuIFwiQ2Fubm90IG9idGFpbiBhZG1pbmlzdHJhdGlvbiBmcm9tIFwiICsgdGhpbmc7XG4gIH0sXG4gIDI1OiBmdW5jdGlvbiBfKHByb3BlcnR5LCBuYW1lKSB7XG4gICAgcmV0dXJuIFwidGhlIGVudHJ5ICdcIiArIHByb3BlcnR5ICsgXCInIGRvZXMgbm90IGV4aXN0IGluIHRoZSBvYnNlcnZhYmxlIG1hcCAnXCIgKyBuYW1lICsgXCInXCI7XG4gIH0sXG4gIDI2OiBcInBsZWFzZSBzcGVjaWZ5IGEgcHJvcGVydHlcIixcbiAgMjc6IGZ1bmN0aW9uIF8ocHJvcGVydHksIG5hbWUpIHtcbiAgICByZXR1cm4gXCJubyBvYnNlcnZhYmxlIHByb3BlcnR5ICdcIiArIHByb3BlcnR5LnRvU3RyaW5nKCkgKyBcIicgZm91bmQgb24gdGhlIG9ic2VydmFibGUgb2JqZWN0ICdcIiArIG5hbWUgKyBcIidcIjtcbiAgfSxcbiAgMjg6IGZ1bmN0aW9uIF8odGhpbmcpIHtcbiAgICByZXR1cm4gXCJDYW5ub3Qgb2J0YWluIGF0b20gZnJvbSBcIiArIHRoaW5nO1xuICB9LFxuICAyOTogXCJFeHBlY3Rpbmcgc29tZSBvYmplY3RcIixcbiAgMzA6IFwiaW52YWxpZCBhY3Rpb24gc3RhY2suIGRpZCB5b3UgZm9yZ2V0IHRvIGZpbmlzaCBhbiBhY3Rpb24/XCIsXG4gIDMxOiBcIm1pc3Npbmcgb3B0aW9uIGZvciBjb21wdXRlZDogZ2V0XCIsXG4gIDMyOiBmdW5jdGlvbiBfKG5hbWUsIGRlcml2YXRpb24pIHtcbiAgICByZXR1cm4gXCJDeWNsZSBkZXRlY3RlZCBpbiBjb21wdXRhdGlvbiBcIiArIG5hbWUgKyBcIjogXCIgKyBkZXJpdmF0aW9uO1xuICB9LFxuICAzMzogZnVuY3Rpb24gXyhuYW1lKSB7XG4gICAgcmV0dXJuIFwiVGhlIHNldHRlciBvZiBjb21wdXRlZCB2YWx1ZSAnXCIgKyBuYW1lICsgXCInIGlzIHRyeWluZyB0byB1cGRhdGUgaXRzZWxmLiBEaWQgeW91IGludGVuZCB0byB1cGRhdGUgYW4gX29ic2VydmFibGVfIHZhbHVlLCBpbnN0ZWFkIG9mIHRoZSBjb21wdXRlZCBwcm9wZXJ0eT9cIjtcbiAgfSxcbiAgMzQ6IGZ1bmN0aW9uIF8obmFtZSkge1xuICAgIHJldHVybiBcIltDb21wdXRlZFZhbHVlICdcIiArIG5hbWUgKyBcIiddIEl0IGlzIG5vdCBwb3NzaWJsZSB0byBhc3NpZ24gYSBuZXcgdmFsdWUgdG8gYSBjb21wdXRlZCB2YWx1ZS5cIjtcbiAgfSxcbiAgMzU6IFwiVGhlcmUgYXJlIG11bHRpcGxlLCBkaWZmZXJlbnQgdmVyc2lvbnMgb2YgTW9iWCBhY3RpdmUuIE1ha2Ugc3VyZSBNb2JYIGlzIGxvYWRlZCBvbmx5IG9uY2Ugb3IgdXNlIGBjb25maWd1cmUoeyBpc29sYXRlR2xvYmFsU3RhdGU6IHRydWUgfSlgXCIsXG4gIDM2OiBcImlzb2xhdGVHbG9iYWxTdGF0ZSBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZSBNb2JYIGlzIHJ1bm5pbmcgYW55IHJlYWN0aW9uc1wiLFxuICAzNzogZnVuY3Rpb24gXyhtZXRob2QpIHtcbiAgICByZXR1cm4gXCJbbW9ieF0gYG9ic2VydmFibGVBcnJheS5cIiArIG1ldGhvZCArIFwiKClgIG11dGF0ZXMgdGhlIGFycmF5IGluLXBsYWNlLCB3aGljaCBpcyBub3QgYWxsb3dlZCBpbnNpZGUgYSBkZXJpdmF0aW9uLiBVc2UgYGFycmF5LnNsaWNlKCkuXCIgKyBtZXRob2QgKyBcIigpYCBpbnN0ZWFkXCI7XG4gIH0sXG4gIDM4OiBcIidvd25LZXlzKCknIGNhbiBvbmx5IGJlIHVzZWQgb24gb2JzZXJ2YWJsZSBvYmplY3RzXCIsXG4gIDM5OiBcIidkZWZpbmVQcm9wZXJ0eSgpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0c1wiXG59O1xudmFyIGVycm9ycyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IG5pY2VFcnJvcnMgOiB7fTtcbmZ1bmN0aW9uIGRpZShlcnJvcikge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFyIGUgPSB0eXBlb2YgZXJyb3IgPT09IFwic3RyaW5nXCIgPyBlcnJvciA6IGVycm9yc1tlcnJvcl07XG4gICAgaWYgKHR5cGVvZiBlID09PSBcImZ1bmN0aW9uXCIpIGUgPSBlLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIHRocm93IG5ldyBFcnJvcihcIltNb2JYXSBcIiArIGUpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKHR5cGVvZiBlcnJvciA9PT0gXCJudW1iZXJcIiA/IFwiW01vYlhdIG1pbmlmaWVkIGVycm9yIG5yOiBcIiArIGVycm9yICsgKGFyZ3MubGVuZ3RoID8gXCIgXCIgKyBhcmdzLm1hcChTdHJpbmcpLmpvaW4oXCIsXCIpIDogXCJcIikgKyBcIi4gRmluZCB0aGUgZnVsbCBlcnJvciBhdDogaHR0cHM6Ly9naXRodWIuY29tL21vYnhqcy9tb2J4L2Jsb2IvbWFpbi9wYWNrYWdlcy9tb2J4L3NyYy9lcnJvcnMudHNcIiA6IFwiW01vYlhdIFwiICsgZXJyb3IpO1xufVxuXG52YXIgbW9ja0dsb2JhbCA9IHt9O1xuZnVuY3Rpb24gZ2V0R2xvYmFsKCkge1xuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgfVxuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGdsb2JhbDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgcmV0dXJuIG1vY2tHbG9iYWw7XG59XG5cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xudmFyIGdldERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIG9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgRU1QVFlfQVJSQVkgPSBbXTtcbk9iamVjdC5mcmVlemUoRU1QVFlfQVJSQVkpO1xudmFyIEVNUFRZX09CSkVDVCA9IHt9O1xuT2JqZWN0LmZyZWV6ZShFTVBUWV9PQkpFQ1QpO1xudmFyIGhhc1Byb3h5ID0gdHlwZW9mIFByb3h5ICE9PSBcInVuZGVmaW5lZFwiO1xudmFyIHBsYWluT2JqZWN0U3RyaW5nID0gLyojX19QVVJFX18qL09iamVjdC50b1N0cmluZygpO1xuZnVuY3Rpb24gYXNzZXJ0UHJveGllcygpIHtcbiAgaWYgKCFoYXNQcm94eSkge1xuICAgIGRpZShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcImBQcm94eWAgb2JqZWN0cyBhcmUgbm90IGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4gUGxlYXNlIGNvbmZpZ3VyZSBNb2JYIHRvIGVuYWJsZSBhIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uLmBcIiA6IFwiUHJveHkgbm90IGF2YWlsYWJsZVwiKTtcbiAgfVxufVxuZnVuY3Rpb24gd2FybkFib3V0UHJveHlSZXF1aXJlbWVudChtc2cpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBnbG9iYWxTdGF0ZS52ZXJpZnlQcm94aWVzKSB7XG4gICAgZGllKFwiTW9iWCBpcyBjdXJyZW50bHkgY29uZmlndXJlZCB0byBiZSBhYmxlIHRvIHJ1biBpbiBFUzUgbW9kZSwgYnV0IGluIEVTNSBNb2JYIHdvbid0IGJlIGFibGUgdG8gXCIgKyBtc2cpO1xuICB9XG59XG5mdW5jdGlvbiBnZXROZXh0SWQoKSB7XG4gIHJldHVybiArK2dsb2JhbFN0YXRlLm1vYnhHdWlkO1xufVxuLyoqXHJcbiAqIE1ha2VzIHN1cmUgdGhhdCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gaXMgaW52b2tlZCBhdCBtb3N0IG9uY2UuXHJcbiAqL1xuXG5mdW5jdGlvbiBvbmNlKGZ1bmMpIHtcbiAgdmFyIGludm9rZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaW52b2tlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludm9rZWQgPSB0cnVlO1xuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcbmZ1bmN0aW9uIGlzRnVuY3Rpb24oZm4pIHtcbiAgcmV0dXJuIHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gaXNTdHJpbmdpc2godmFsdWUpIHtcbiAgdmFyIHQgPSB0eXBlb2YgdmFsdWU7XG5cbiAgc3dpdGNoICh0KSB7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG59XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcblxuICBpZiAocHJvdG8gPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIHByb3RvQ29uc3RydWN0b3IgPSBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgXCJjb25zdHJ1Y3RvclwiKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBwcm90b0NvbnN0cnVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgcHJvdG9Db25zdHJ1Y3Rvci50b1N0cmluZygpID09PSBwbGFpbk9iamVjdFN0cmluZztcbn0gLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM3ODY1MTcwXG5cbmZ1bmN0aW9uIGlzR2VuZXJhdG9yKG9iaikge1xuICB2YXIgY29uc3RydWN0b3IgPSBvYmogPT0gbnVsbCA/IHZvaWQgMCA6IG9iai5jb25zdHJ1Y3RvcjtcblxuICBpZiAoIWNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA9PT0gY29uc3RydWN0b3IubmFtZSB8fCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBhZGRIaWRkZW5Qcm9wKG9iamVjdCwgcHJvcE5hbWUsIHZhbHVlKSB7XG4gIGRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcE5hbWUsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IHZhbHVlXG4gIH0pO1xufVxuZnVuY3Rpb24gYWRkSGlkZGVuRmluYWxQcm9wKG9iamVjdCwgcHJvcE5hbWUsIHZhbHVlKSB7XG4gIGRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcE5hbWUsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUobmFtZSwgdGhlQ2xhc3MpIHtcbiAgdmFyIHByb3BOYW1lID0gXCJpc01vYlhcIiArIG5hbWU7XG4gIHRoZUNsYXNzLnByb3RvdHlwZVtwcm9wTmFtZV0gPSB0cnVlO1xuICByZXR1cm4gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gaXNPYmplY3QoeCkgJiYgeFtwcm9wTmFtZV0gPT09IHRydWU7XG4gIH07XG59XG5mdW5jdGlvbiBpc0VTNk1hcCh0aGluZykge1xuICByZXR1cm4gdGhpbmcgaW5zdGFuY2VvZiBNYXA7XG59XG5mdW5jdGlvbiBpc0VTNlNldCh0aGluZykge1xuICByZXR1cm4gdGhpbmcgaW5zdGFuY2VvZiBTZXQ7XG59XG52YXIgaGFzR2V0T3duUHJvcGVydHlTeW1ib2xzID0gdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09IFwidW5kZWZpbmVkXCI7XG4vKipcclxuICogUmV0dXJucyB0aGUgZm9sbG93aW5nOiBvd24gZW51bWVyYWJsZSBrZXlzIGFuZCBzeW1ib2xzLlxyXG4gKi9cblxuZnVuY3Rpb24gZ2V0UGxhaW5PYmplY3RLZXlzKG9iamVjdCkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IC8vIE5vdCBzdXBwb3J0ZWQgaW4gSUUsIHNvIHRoZXJlIGFyZSBub3QgZ29pbmcgdG8gYmUgc3ltYm9sIHByb3BzIGFueXdheS4uLlxuXG4gIGlmICghaGFzR2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgcmV0dXJuIGtleXM7XG4gIH1cblxuICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcblxuICBpZiAoIXN5bWJvbHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGtleXM7XG4gIH1cblxuICByZXR1cm4gW10uY29uY2F0KGtleXMsIHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIG9iamVjdFByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgcyk7XG4gIH0pKTtcbn0gLy8gRnJvbSBJbW1lciB1dGlsc1xuLy8gUmV0dXJucyBhbGwgb3duIGtleXMsIGluY2x1ZGluZyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9saWNcblxudmFyIG93bktleXMgPSB0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0Lm93bktleXMgPyBSZWZsZWN0Lm93bktleXMgOiBoYXNHZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaikpO1xufSA6XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG5mdW5jdGlvbiBzdHJpbmdpZnlLZXkoa2V5KSB7XG4gIGlmICh0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGtleTtcbiAgfVxuXG4gIGlmICh0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiKSB7XG4gICAgcmV0dXJuIGtleS50b1N0cmluZygpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBTdHJpbmcoa2V5KS50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gdG9QcmltaXRpdmUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gbnVsbCA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiA/IFwiXCIgKyB2YWx1ZSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gaGFzUHJvcCh0YXJnZXQsIHByb3ApIHtcbiAgcmV0dXJuIG9iamVjdFByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwgcHJvcCk7XG59IC8vIEZyb20gSW1tZXIgdXRpbHNcblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHRhcmdldCkge1xuICAvLyBQb2x5ZmlsbCBuZWVkZWQgZm9yIEhlcm1lcyBhbmQgSUUsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svaGVybWVzL2lzc3Vlcy8yNzRcbiAgdmFyIHJlcyA9IHt9OyAvLyBOb3RlOiB3aXRob3V0IHBvbHlmaWxsIGZvciBvd25LZXlzLCBzeW1ib2xzIHdvbid0IGJlIHBpY2tlZCB1cFxuXG4gIG93bktleXModGFyZ2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXNba2V5XSA9IGdldERlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICB9KTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG5cbiAgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKG8sIGFsbG93QXJyYXlMaWtlKSB7XG4gIHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdO1xuICBpZiAoaXQpIHJldHVybiAoaXQgPSBpdC5jYWxsKG8pKS5uZXh0LmJpbmQoaXQpO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICBpZiAoaXQpIG8gPSBpdDtcbiAgICB2YXIgaSA9IDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4ge1xuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBvW2krK11cbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxudmFyIHN0b3JlZEFubm90YXRpb25zU3ltYm9sID0gLyojX19QVVJFX18qL1N5bWJvbChcIm1vYngtc3RvcmVkLWFubm90YXRpb25zXCIpO1xuLyoqXHJcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFjdHMgYXNcclxuICogLSBkZWNvcmF0b3JcclxuICogLSBhbm5vdGF0aW9uIG9iamVjdFxyXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihhbm5vdGF0aW9uKSB7XG4gIGZ1bmN0aW9uIGRlY29yYXRvcih0YXJnZXQsIHByb3BlcnR5KSB7XG4gICAgc3RvcmVBbm5vdGF0aW9uKHRhcmdldCwgcHJvcGVydHksIGFubm90YXRpb24pO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZGVjb3JhdG9yLCBhbm5vdGF0aW9uKTtcbn1cbi8qKlxyXG4gKiBTdG9yZXMgYW5ub3RhdGlvbiB0byBwcm90b3R5cGUsXHJcbiAqIHNvIGl0IGNhbiBiZSBpbnNwZWN0ZWQgbGF0ZXIgYnkgYG1ha2VPYnNlcnZhYmxlYCBjYWxsZWQgZnJvbSBjb25zdHJ1Y3RvclxyXG4gKi9cblxuZnVuY3Rpb24gc3RvcmVBbm5vdGF0aW9uKHByb3RvdHlwZSwga2V5LCBhbm5vdGF0aW9uKSB7XG4gIGlmICghaGFzUHJvcChwcm90b3R5cGUsIHN0b3JlZEFubm90YXRpb25zU3ltYm9sKSkge1xuICAgIGFkZEhpZGRlblByb3AocHJvdG90eXBlLCBzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbCwgX2V4dGVuZHMoe30sIHByb3RvdHlwZVtzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF0pKTtcbiAgfSAvLyBAb3ZlcnJpZGUgbXVzdCBvdmVycmlkZSBzb21ldGhpbmdcblxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNPdmVycmlkZShhbm5vdGF0aW9uKSAmJiAhaGFzUHJvcChwcm90b3R5cGVbc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdLCBrZXkpKSB7XG4gICAgdmFyIGZpZWxkTmFtZSA9IHByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lICsgXCIucHJvdG90eXBlLlwiICsga2V5LnRvU3RyaW5nKCk7XG4gICAgZGllKFwiJ1wiICsgZmllbGROYW1lICsgXCInIGlzIGRlY29yYXRlZCB3aXRoICdvdmVycmlkZScsIFwiICsgXCJidXQgbm8gc3VjaCBkZWNvcmF0ZWQgbWVtYmVyIHdhcyBmb3VuZCBvbiBwcm90b3R5cGUuXCIpO1xuICB9IC8vIENhbm5vdCByZS1kZWNvcmF0ZVxuXG5cbiAgYXNzZXJ0Tm90RGVjb3JhdGVkKHByb3RvdHlwZSwgYW5ub3RhdGlvbiwga2V5KTsgLy8gSWdub3JlIG92ZXJyaWRlXG5cbiAgaWYgKCFpc092ZXJyaWRlKGFubm90YXRpb24pKSB7XG4gICAgcHJvdG90eXBlW3N0b3JlZEFubm90YXRpb25zU3ltYm9sXVtrZXldID0gYW5ub3RhdGlvbjtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnROb3REZWNvcmF0ZWQocHJvdG90eXBlLCBhbm5vdGF0aW9uLCBrZXkpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhaXNPdmVycmlkZShhbm5vdGF0aW9uKSAmJiBoYXNQcm9wKHByb3RvdHlwZVtzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF0sIGtleSkpIHtcbiAgICB2YXIgZmllbGROYW1lID0gcHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWUgKyBcIi5wcm90b3R5cGUuXCIgKyBrZXkudG9TdHJpbmcoKTtcbiAgICB2YXIgY3VycmVudEFubm90YXRpb25UeXBlID0gcHJvdG90eXBlW3N0b3JlZEFubm90YXRpb25zU3ltYm9sXVtrZXldLmFubm90YXRpb25UeXBlXztcbiAgICB2YXIgcmVxdWVzdGVkQW5ub3RhdGlvblR5cGUgPSBhbm5vdGF0aW9uLmFubm90YXRpb25UeXBlXztcbiAgICBkaWUoXCJDYW5ub3QgYXBwbHkgJ0BcIiArIHJlcXVlc3RlZEFubm90YXRpb25UeXBlICsgXCInIHRvICdcIiArIGZpZWxkTmFtZSArIFwiJzpcIiArIChcIlxcblRoZSBmaWVsZCBpcyBhbHJlYWR5IGRlY29yYXRlZCB3aXRoICdAXCIgKyBjdXJyZW50QW5ub3RhdGlvblR5cGUgKyBcIicuXCIpICsgXCJcXG5SZS1kZWNvcmF0aW5nIGZpZWxkcyBpcyBub3QgYWxsb3dlZC5cIiArIFwiXFxuVXNlICdAb3ZlcnJpZGUnIGRlY29yYXRvciBmb3IgbWV0aG9kcyBvdmVycmlkZGVuIGJ5IHN1YmNsYXNzLlwiKTtcbiAgfVxufVxuLyoqXHJcbiAqIENvbGxlY3RzIGFubm90YXRpb25zIGZyb20gcHJvdG90eXBlcyBhbmQgc3RvcmVzIHRoZW0gb24gdGFyZ2V0IChpbnN0YW5jZSlcclxuICovXG5cblxuZnVuY3Rpb24gY29sbGVjdFN0b3JlZEFubm90YXRpb25zKHRhcmdldCkge1xuICBpZiAoIWhhc1Byb3AodGFyZ2V0LCBzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbCkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICF0YXJnZXRbc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdKSB7XG4gICAgICBkaWUoXCJObyBhbm5vdGF0aW9ucyB3ZXJlIHBhc3NlZCB0byBtYWtlT2JzZXJ2YWJsZSwgYnV0IG5vIGRlY29yYXRlZCBtZW1iZXJzIGhhdmUgYmVlbiBmb3VuZCBlaXRoZXJcIik7XG4gICAgfSAvLyBXZSBuZWVkIGEgY29weSBhcyB3ZSB3aWxsIHJlbW92ZSBhbm5vdGF0aW9uIGZyb20gdGhlIGxpc3Qgb25jZSBpdCdzIGFwcGxpZWQuXG5cblxuICAgIGFkZEhpZGRlblByb3AodGFyZ2V0LCBzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbCwgX2V4dGVuZHMoe30sIHRhcmdldFtzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF0pKTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXRbc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdO1xufVxuXG52YXIgJG1vYnggPSAvKiNfX1BVUkVfXyovU3ltYm9sKFwibW9ieCBhZG1pbmlzdHJhdGlvblwiKTtcbnZhciBBdG9tID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gZm9yIGVmZmVjdGl2ZSB1bm9ic2VydmluZy4gQmFzZUF0b20gaGFzIHRydWUsIGZvciBleHRyYSBvcHRpbWl6YXRpb24sIHNvIGl0cyBvbkJlY29tZVVub2JzZXJ2ZWQgbmV2ZXIgZ2V0cyBjYWxsZWQsIGJlY2F1c2UgaXQncyBub3QgbmVlZGVkXG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGF0b20uIEZvciBkZWJ1Z2dpbmcgcHVycG9zZXMgaXQgaXMgcmVjb21tZW5kZWQgdG8gZ2l2ZSBpdCBhIG5hbWUuXHJcbiAgICogVGhlIG9uQmVjb21lT2JzZXJ2ZWQgYW5kIG9uQmVjb21lVW5vYnNlcnZlZCBjYWxsYmFja3MgY2FuIGJlIHVzZWQgZm9yIHJlc291cmNlIG1hbmFnZW1lbnQuXHJcbiAgICovXG4gIGZ1bmN0aW9uIEF0b20obmFtZV8pIHtcbiAgICBpZiAobmFtZV8gPT09IHZvaWQgMCkge1xuICAgICAgbmFtZV8gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIkF0b21AXCIgKyBnZXROZXh0SWQoKSA6IFwiQXRvbVwiO1xuICAgIH1cblxuICAgIHRoaXMubmFtZV8gPSB2b2lkIDA7XG4gICAgdGhpcy5pc1BlbmRpbmdVbm9ic2VydmF0aW9uXyA9IGZhbHNlO1xuICAgIHRoaXMuaXNCZWluZ09ic2VydmVkXyA9IGZhbHNlO1xuICAgIHRoaXMub2JzZXJ2ZXJzXyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmRpZmZWYWx1ZV8gPSAwO1xuICAgIHRoaXMubGFzdEFjY2Vzc2VkQnlfID0gMDtcbiAgICB0aGlzLmxvd2VzdE9ic2VydmVyU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uTk9UX1RSQUNLSU5HXztcbiAgICB0aGlzLm9uQk9MID0gdm9pZCAwO1xuICAgIHRoaXMub25CVU9MID0gdm9pZCAwO1xuICAgIHRoaXMubmFtZV8gPSBuYW1lXztcbiAgfSAvLyBvbkJlY29tZU9ic2VydmVkTGlzdGVuZXJzXG5cblxuICB2YXIgX3Byb3RvID0gQXRvbS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLm9uQk8gPSBmdW5jdGlvbiBvbkJPKCkge1xuICAgIGlmICh0aGlzLm9uQk9MKSB7XG4gICAgICB0aGlzLm9uQk9MLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkJVTyA9IGZ1bmN0aW9uIG9uQlVPKCkge1xuICAgIGlmICh0aGlzLm9uQlVPTCkge1xuICAgICAgdGhpcy5vbkJVT0wuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogSW52b2tlIHRoaXMgbWV0aG9kIHRvIG5vdGlmeSBtb2J4IHRoYXQgeW91ciBhdG9tIGhhcyBiZWVuIHVzZWQgc29tZWhvdy5cclxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgY3VycmVudGx5IGEgcmVhY3RpdmUgY29udGV4dC5cclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZXBvcnRPYnNlcnZlZCA9IGZ1bmN0aW9uIHJlcG9ydE9ic2VydmVkJDEoKSB7XG4gICAgcmV0dXJuIHJlcG9ydE9ic2VydmVkKHRoaXMpO1xuICB9XG4gIC8qKlxyXG4gICAqIEludm9rZSB0aGlzIG1ldGhvZCBfYWZ0ZXJfIHRoaXMgbWV0aG9kIGhhcyBjaGFuZ2VkIHRvIHNpZ25hbCBtb2J4IHRoYXQgYWxsIGl0cyBvYnNlcnZlcnMgc2hvdWxkIGludmFsaWRhdGUuXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVwb3J0Q2hhbmdlZCA9IGZ1bmN0aW9uIHJlcG9ydENoYW5nZWQoKSB7XG4gICAgc3RhcnRCYXRjaCgpO1xuICAgIHByb3BhZ2F0ZUNoYW5nZWQodGhpcyk7XG4gICAgZW5kQmF0Y2goKTtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lXztcbiAgfTtcblxuICByZXR1cm4gQXRvbTtcbn0oKTtcbnZhciBpc0F0b20gPSAvKiNfX1BVUkVfXyovY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIkF0b21cIiwgQXRvbSk7XG5mdW5jdGlvbiBjcmVhdGVBdG9tKG5hbWUsIG9uQmVjb21lT2JzZXJ2ZWRIYW5kbGVyLCBvbkJlY29tZVVub2JzZXJ2ZWRIYW5kbGVyKSB7XG4gIGlmIChvbkJlY29tZU9ic2VydmVkSGFuZGxlciA9PT0gdm9pZCAwKSB7XG4gICAgb25CZWNvbWVPYnNlcnZlZEhhbmRsZXIgPSBub29wO1xuICB9XG5cbiAgaWYgKG9uQmVjb21lVW5vYnNlcnZlZEhhbmRsZXIgPT09IHZvaWQgMCkge1xuICAgIG9uQmVjb21lVW5vYnNlcnZlZEhhbmRsZXIgPSBub29wO1xuICB9XG5cbiAgdmFyIGF0b20gPSBuZXcgQXRvbShuYW1lKTsgLy8gZGVmYXVsdCBgbm9vcGAgbGlzdGVuZXIgd2lsbCBub3QgaW5pdGlhbGl6ZSB0aGUgaG9vayBTZXRcblxuICBpZiAob25CZWNvbWVPYnNlcnZlZEhhbmRsZXIgIT09IG5vb3ApIHtcbiAgICBvbkJlY29tZU9ic2VydmVkKGF0b20sIG9uQmVjb21lT2JzZXJ2ZWRIYW5kbGVyKTtcbiAgfVxuXG4gIGlmIChvbkJlY29tZVVub2JzZXJ2ZWRIYW5kbGVyICE9PSBub29wKSB7XG4gICAgb25CZWNvbWVVbm9ic2VydmVkKGF0b20sIG9uQmVjb21lVW5vYnNlcnZlZEhhbmRsZXIpO1xuICB9XG5cbiAgcmV0dXJuIGF0b207XG59XG5cbmZ1bmN0aW9uIGlkZW50aXR5Q29tcGFyZXIoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYjtcbn1cblxuZnVuY3Rpb24gc3RydWN0dXJhbENvbXBhcmVyKGEsIGIpIHtcbiAgcmV0dXJuIGRlZXBFcXVhbChhLCBiKTtcbn1cblxuZnVuY3Rpb24gc2hhbGxvd0NvbXBhcmVyKGEsIGIpIHtcbiAgcmV0dXJuIGRlZXBFcXVhbChhLCBiLCAxKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENvbXBhcmVyKGEsIGIpIHtcbiAgaWYgKE9iamVjdC5pcykge1xuICAgIHJldHVybiBPYmplY3QuaXMoYSwgYik7XG4gIH1cblxuICByZXR1cm4gYSA9PT0gYiA/IGEgIT09IDAgfHwgMSAvIGEgPT09IDEgLyBiIDogYSAhPT0gYSAmJiBiICE9PSBiO1xufVxuXG52YXIgY29tcGFyZXIgPSB7XG4gIGlkZW50aXR5OiBpZGVudGl0eUNvbXBhcmVyLFxuICBzdHJ1Y3R1cmFsOiBzdHJ1Y3R1cmFsQ29tcGFyZXIsXG4gIFwiZGVmYXVsdFwiOiBkZWZhdWx0Q29tcGFyZXIsXG4gIHNoYWxsb3c6IHNoYWxsb3dDb21wYXJlclxufTtcblxuZnVuY3Rpb24gZGVlcEVuaGFuY2VyKHYsIF8sIG5hbWUpIHtcbiAgLy8gaXQgaXMgYW4gb2JzZXJ2YWJsZSBhbHJlYWR5LCBkb25lXG4gIGlmIChpc09ic2VydmFibGUodikpIHtcbiAgICByZXR1cm4gdjtcbiAgfSAvLyBzb21ldGhpbmcgdGhhdCBjYW4gYmUgY29udmVydGVkIGFuZCBtdXRhdGVkP1xuXG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZS5hcnJheSh2LCB7XG4gICAgICBuYW1lOiBuYW1lXG4gICAgfSk7XG4gIH1cblxuICBpZiAoaXNQbGFpbk9iamVjdCh2KSkge1xuICAgIHJldHVybiBvYnNlcnZhYmxlLm9iamVjdCh2LCB1bmRlZmluZWQsIHtcbiAgICAgIG5hbWU6IG5hbWVcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChpc0VTNk1hcCh2KSkge1xuICAgIHJldHVybiBvYnNlcnZhYmxlLm1hcCh2LCB7XG4gICAgICBuYW1lOiBuYW1lXG4gICAgfSk7XG4gIH1cblxuICBpZiAoaXNFUzZTZXQodikpIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZS5zZXQodiwge1xuICAgICAgbmFtZTogbmFtZVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2ID09PSBcImZ1bmN0aW9uXCIgJiYgIWlzQWN0aW9uKHYpICYmICFpc0Zsb3codikpIHtcbiAgICBpZiAoaXNHZW5lcmF0b3IodikpIHtcbiAgICAgIHJldHVybiBmbG93KHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXV0b0FjdGlvbihuYW1lLCB2KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dFbmhhbmNlcih2LCBfLCBuYW1lKSB7XG4gIGlmICh2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbCkge1xuICAgIHJldHVybiB2O1xuICB9XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdCh2KSB8fCBpc09ic2VydmFibGVBcnJheSh2KSB8fCBpc09ic2VydmFibGVNYXAodikgfHwgaXNPYnNlcnZhYmxlU2V0KHYpKSB7XG4gICAgcmV0dXJuIHY7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgIHJldHVybiBvYnNlcnZhYmxlLmFycmF5KHYsIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBkZWVwOiBmYWxzZVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGlzUGxhaW5PYmplY3QodikpIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZS5vYmplY3QodiwgdW5kZWZpbmVkLCB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgZGVlcDogZmFsc2VcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChpc0VTNk1hcCh2KSkge1xuICAgIHJldHVybiBvYnNlcnZhYmxlLm1hcCh2LCB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgZGVlcDogZmFsc2VcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChpc0VTNlNldCh2KSkge1xuICAgIHJldHVybiBvYnNlcnZhYmxlLnNldCh2LCB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgZGVlcDogZmFsc2VcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBkaWUoXCJUaGUgc2hhbGxvdyBtb2RpZmllciAvIGRlY29yYXRvciBjYW4gb25seSB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggYXJyYXlzLCBvYmplY3RzLCBtYXBzIGFuZCBzZXRzXCIpO1xuICB9XG59XG5mdW5jdGlvbiByZWZlcmVuY2VFbmhhbmNlcihuZXdWYWx1ZSkge1xuICAvLyBuZXZlciB0dXJuIGludG8gYW4gb2JzZXJ2YWJsZVxuICByZXR1cm4gbmV3VmFsdWU7XG59XG5mdW5jdGlvbiByZWZTdHJ1Y3RFbmhhbmNlcih2LCBvbGRWYWx1ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGlzT2JzZXJ2YWJsZSh2KSkge1xuICAgIGRpZShcIm9ic2VydmFibGUuc3RydWN0IHNob3VsZCBub3QgYmUgdXNlZCB3aXRoIG9ic2VydmFibGUgdmFsdWVzXCIpO1xuICB9XG5cbiAgaWYgKGRlZXBFcXVhbCh2LCBvbGRWYWx1ZSkpIHtcbiAgICByZXR1cm4gb2xkVmFsdWU7XG4gIH1cblxuICByZXR1cm4gdjtcbn1cblxudmFyIE9WRVJSSURFID0gXCJvdmVycmlkZVwiO1xudmFyIG92ZXJyaWRlID0gLyojX19QVVJFX18qL2NyZWF0ZURlY29yYXRvckFubm90YXRpb24oe1xuICBhbm5vdGF0aW9uVHlwZV86IE9WRVJSSURFLFxuICBtYWtlXzogbWFrZV8sXG4gIGV4dGVuZF86IGV4dGVuZF9cbn0pO1xuZnVuY3Rpb24gaXNPdmVycmlkZShhbm5vdGF0aW9uKSB7XG4gIHJldHVybiBhbm5vdGF0aW9uLmFubm90YXRpb25UeXBlXyA9PT0gT1ZFUlJJREU7XG59XG5cbmZ1bmN0aW9uIG1ha2VfKGFkbSwga2V5KSB7XG4gIC8vIE11c3Qgbm90IGJlIHBsYWluIG9iamVjdFxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGFkbS5pc1BsYWluT2JqZWN0Xykge1xuICAgIGRpZShcIkNhbm5vdCBhcHBseSAnXCIgKyB0aGlzLmFubm90YXRpb25UeXBlXyArIFwiJyB0byAnXCIgKyBhZG0ubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpICsgXCInOlwiICsgKFwiXFxuJ1wiICsgdGhpcy5hbm5vdGF0aW9uVHlwZV8gKyBcIicgY2Fubm90IGJlIHVzZWQgb24gcGxhaW4gb2JqZWN0cy5cIikpO1xuICB9IC8vIE11c3Qgb3ZlcnJpZGUgc29tZXRoaW5nXG5cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFoYXNQcm9wKGFkbS5hcHBsaWVkQW5ub3RhdGlvbnNfLCBrZXkpKSB7XG4gICAgZGllKFwiJ1wiICsgYWRtLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKSArIFwiJyBpcyBhbm5vdGF0ZWQgd2l0aCAnXCIgKyB0aGlzLmFubm90YXRpb25UeXBlXyArIFwiJywgXCIgKyBcImJ1dCBubyBzdWNoIGFubm90YXRlZCBtZW1iZXIgd2FzIGZvdW5kIG9uIHByb3RvdHlwZS5cIik7XG4gIH1cblxuICByZXR1cm4gMFxuICAvKiBDYW5jZWwgKi9cbiAgO1xufVxuXG5mdW5jdGlvbiBleHRlbmRfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApIHtcbiAgZGllKFwiJ1wiICsgdGhpcy5hbm5vdGF0aW9uVHlwZV8gKyBcIicgY2FuIG9ubHkgYmUgdXNlZCB3aXRoICdtYWtlT2JzZXJ2YWJsZSdcIik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbkFubm90YXRpb24obmFtZSwgb3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGFubm90YXRpb25UeXBlXzogbmFtZSxcbiAgICBvcHRpb25zXzogb3B0aW9ucyxcbiAgICBtYWtlXzogbWFrZV8kMSxcbiAgICBleHRlbmRfOiBleHRlbmRfJDFcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFrZV8kMShhZG0sIGtleSwgZGVzY3JpcHRvciwgc291cmNlKSB7XG4gIHZhciBfdGhpcyRvcHRpb25zXztcblxuICAvLyBib3VuZFxuICBpZiAoKF90aGlzJG9wdGlvbnNfID0gdGhpcy5vcHRpb25zXykgIT0gbnVsbCAmJiBfdGhpcyRvcHRpb25zXy5ib3VuZCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZF8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIGZhbHNlKSA9PT0gbnVsbCA/IDBcbiAgICAvKiBDYW5jZWwgKi9cbiAgICA6IDFcbiAgICAvKiBCcmVhayAqL1xuICAgIDtcbiAgfSAvLyBvd25cblxuXG4gIGlmIChzb3VyY2UgPT09IGFkbS50YXJnZXRfKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgZmFsc2UpID09PSBudWxsID8gMFxuICAgIC8qIENhbmNlbCAqL1xuICAgIDogMlxuICAgIC8qIENvbnRpbnVlICovXG4gICAgO1xuICB9IC8vIHByb3RvdHlwZVxuXG5cbiAgaWYgKGlzQWN0aW9uKGRlc2NyaXB0b3IudmFsdWUpKSB7XG4gICAgLy8gQSBwcm90b3R5cGUgY291bGQgaGF2ZSBiZWVuIGFubm90YXRlZCBhbHJlYWR5IGJ5IG90aGVyIGNvbnN0cnVjdG9yLFxuICAgIC8vIHJlc3Qgb2YgdGhlIHByb3RvIGNoYWluIG11c3QgYmUgYW5ub3RhdGVkIGFscmVhZHlcbiAgICByZXR1cm4gMVxuICAgIC8qIEJyZWFrICovXG4gICAgO1xuICB9XG5cbiAgdmFyIGFjdGlvbkRlc2NyaXB0b3IgPSBjcmVhdGVBY3Rpb25EZXNjcmlwdG9yKGFkbSwgdGhpcywga2V5LCBkZXNjcmlwdG9yLCBmYWxzZSk7XG4gIGRlZmluZVByb3BlcnR5KHNvdXJjZSwga2V5LCBhY3Rpb25EZXNjcmlwdG9yKTtcbiAgcmV0dXJuIDJcbiAgLyogQ29udGludWUgKi9cbiAgO1xufVxuXG5mdW5jdGlvbiBleHRlbmRfJDEoYWRtLCBrZXksIGRlc2NyaXB0b3IsIHByb3h5VHJhcCkge1xuICB2YXIgYWN0aW9uRGVzY3JpcHRvciA9IGNyZWF0ZUFjdGlvbkRlc2NyaXB0b3IoYWRtLCB0aGlzLCBrZXksIGRlc2NyaXB0b3IpO1xuICByZXR1cm4gYWRtLmRlZmluZVByb3BlcnR5XyhrZXksIGFjdGlvbkRlc2NyaXB0b3IsIHByb3h5VHJhcCk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEFjdGlvbkRlc2NyaXB0b3IoYWRtLCBfcmVmLCBrZXksIF9yZWYyKSB7XG4gIHZhciBhbm5vdGF0aW9uVHlwZV8gPSBfcmVmLmFubm90YXRpb25UeXBlXztcbiAgdmFyIHZhbHVlID0gX3JlZjIudmFsdWU7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBkaWUoXCJDYW5ub3QgYXBwbHkgJ1wiICsgYW5ub3RhdGlvblR5cGVfICsgXCInIHRvICdcIiArIGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgKyBcIic6XCIgKyAoXCJcXG4nXCIgKyBhbm5vdGF0aW9uVHlwZV8gKyBcIicgY2FuIG9ubHkgYmUgdXNlZCBvbiBwcm9wZXJ0aWVzIHdpdGggYSBmdW5jdGlvbiB2YWx1ZS5cIikpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbkRlc2NyaXB0b3IoYWRtLCBhbm5vdGF0aW9uLCBrZXksIGRlc2NyaXB0b3IsIC8vIHByb3ZpZGVzIGFiaWxpdHkgdG8gZGlzYWJsZSBzYWZlRGVzY3JpcHRvcnMgZm9yIHByb3RvdHlwZXNcbnNhZmVEZXNjcmlwdG9ycykge1xuICB2YXIgX2Fubm90YXRpb24kb3B0aW9uc18sIF9hbm5vdGF0aW9uJG9wdGlvbnNfJCwgX2Fubm90YXRpb24kb3B0aW9uc18yLCBfYW5ub3RhdGlvbiRvcHRpb25zXyQyLCBfYW5ub3RhdGlvbiRvcHRpb25zXzMsIF9hbm5vdGF0aW9uJG9wdGlvbnNfNCwgX2FkbSRwcm94eV8yO1xuXG4gIGlmIChzYWZlRGVzY3JpcHRvcnMgPT09IHZvaWQgMCkge1xuICAgIHNhZmVEZXNjcmlwdG9ycyA9IGdsb2JhbFN0YXRlLnNhZmVEZXNjcmlwdG9ycztcbiAgfVxuXG4gIGFzc2VydEFjdGlvbkRlc2NyaXB0b3IoYWRtLCBhbm5vdGF0aW9uLCBrZXksIGRlc2NyaXB0b3IpO1xuICB2YXIgdmFsdWUgPSBkZXNjcmlwdG9yLnZhbHVlO1xuXG4gIGlmICgoX2Fubm90YXRpb24kb3B0aW9uc18gPSBhbm5vdGF0aW9uLm9wdGlvbnNfKSAhPSBudWxsICYmIF9hbm5vdGF0aW9uJG9wdGlvbnNfLmJvdW5kKSB7XG4gICAgdmFyIF9hZG0kcHJveHlfO1xuXG4gICAgdmFsdWUgPSB2YWx1ZS5iaW5kKChfYWRtJHByb3h5XyA9IGFkbS5wcm94eV8pICE9IG51bGwgPyBfYWRtJHByb3h5XyA6IGFkbS50YXJnZXRfKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmFsdWU6IGNyZWF0ZUFjdGlvbigoX2Fubm90YXRpb24kb3B0aW9uc18kID0gKF9hbm5vdGF0aW9uJG9wdGlvbnNfMiA9IGFubm90YXRpb24ub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfYW5ub3RhdGlvbiRvcHRpb25zXzIubmFtZSkgIT0gbnVsbCA/IF9hbm5vdGF0aW9uJG9wdGlvbnNfJCA6IGtleS50b1N0cmluZygpLCB2YWx1ZSwgKF9hbm5vdGF0aW9uJG9wdGlvbnNfJDIgPSAoX2Fubm90YXRpb24kb3B0aW9uc18zID0gYW5ub3RhdGlvbi5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hbm5vdGF0aW9uJG9wdGlvbnNfMy5hdXRvQWN0aW9uKSAhPSBudWxsID8gX2Fubm90YXRpb24kb3B0aW9uc18kMiA6IGZhbHNlLCAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9ieGpzL21vYngvZGlzY3Vzc2lvbnMvMzE0MFxuICAgIChfYW5ub3RhdGlvbiRvcHRpb25zXzQgPSBhbm5vdGF0aW9uLm9wdGlvbnNfKSAhPSBudWxsICYmIF9hbm5vdGF0aW9uJG9wdGlvbnNfNC5ib3VuZCA/IChfYWRtJHByb3h5XzIgPSBhZG0ucHJveHlfKSAhPSBudWxsID8gX2FkbSRwcm94eV8yIDogYWRtLnRhcmdldF8gOiB1bmRlZmluZWQpLFxuICAgIC8vIE5vbi1jb25maWd1cmFibGUgZm9yIGNsYXNzZXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsIGZpZWxkIHJlZGVmaW5pdGlvbiBpbiBzdWJjbGFzc1xuICAgIGNvbmZpZ3VyYWJsZTogc2FmZURlc2NyaXB0b3JzID8gYWRtLmlzUGxhaW5PYmplY3RfIDogdHJ1ZSxcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9ieGpzL21vYngvcHVsbC8yNjQxI2lzc3VlY29tbWVudC03MzcyOTIwNThcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAvLyBOb24tb2JzZXZhYmxlLCB0aGVyZWZvcmUgbm9uLXdyaXRhYmxlXG4gICAgLy8gQWxzbyBwcmV2ZW50cyByZXdyaXRpbmcgaW4gc3ViY2xhc3MgY29uc3RydWN0b3JcbiAgICB3cml0YWJsZTogc2FmZURlc2NyaXB0b3JzID8gZmFsc2UgOiB0cnVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZsb3dBbm5vdGF0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBhbm5vdGF0aW9uVHlwZV86IG5hbWUsXG4gICAgb3B0aW9uc186IG9wdGlvbnMsXG4gICAgbWFrZV86IG1ha2VfJDIsXG4gICAgZXh0ZW5kXzogZXh0ZW5kXyQyXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VfJDIoYWRtLCBrZXksIGRlc2NyaXB0b3IsIHNvdXJjZSkge1xuICB2YXIgX3RoaXMkb3B0aW9uc187XG5cbiAgLy8gb3duXG4gIGlmIChzb3VyY2UgPT09IGFkbS50YXJnZXRfKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgZmFsc2UpID09PSBudWxsID8gMFxuICAgIC8qIENhbmNlbCAqL1xuICAgIDogMlxuICAgIC8qIENvbnRpbnVlICovXG4gICAgO1xuICB9IC8vIHByb3RvdHlwZVxuICAvLyBib3VuZCAtIG11c3QgYW5ub3RhdGUgcHJvdG9zIHRvIHN1cHBvcnQgc3VwZXIuZmxvdygpXG5cblxuICBpZiAoKF90aGlzJG9wdGlvbnNfID0gdGhpcy5vcHRpb25zXykgIT0gbnVsbCAmJiBfdGhpcyRvcHRpb25zXy5ib3VuZCAmJiAoIWhhc1Byb3AoYWRtLnRhcmdldF8sIGtleSkgfHwgIWlzRmxvdyhhZG0udGFyZ2V0X1trZXldKSkpIHtcbiAgICBpZiAodGhpcy5leHRlbmRfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBmYWxzZSkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAwXG4gICAgICAvKiBDYW5jZWwgKi9cbiAgICAgIDtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNGbG93KGRlc2NyaXB0b3IudmFsdWUpKSB7XG4gICAgLy8gQSBwcm90b3R5cGUgY291bGQgaGF2ZSBiZWVuIGFubm90YXRlZCBhbHJlYWR5IGJ5IG90aGVyIGNvbnN0cnVjdG9yLFxuICAgIC8vIHJlc3Qgb2YgdGhlIHByb3RvIGNoYWluIG11c3QgYmUgYW5ub3RhdGVkIGFscmVhZHlcbiAgICByZXR1cm4gMVxuICAgIC8qIEJyZWFrICovXG4gICAgO1xuICB9XG5cbiAgdmFyIGZsb3dEZXNjcmlwdG9yID0gY3JlYXRlRmxvd0Rlc2NyaXB0b3IoYWRtLCB0aGlzLCBrZXksIGRlc2NyaXB0b3IsIGZhbHNlLCBmYWxzZSk7XG4gIGRlZmluZVByb3BlcnR5KHNvdXJjZSwga2V5LCBmbG93RGVzY3JpcHRvcik7XG4gIHJldHVybiAyXG4gIC8qIENvbnRpbnVlICovXG4gIDtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kXyQyKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApIHtcbiAgdmFyIF90aGlzJG9wdGlvbnNfMjtcblxuICB2YXIgZmxvd0Rlc2NyaXB0b3IgPSBjcmVhdGVGbG93RGVzY3JpcHRvcihhZG0sIHRoaXMsIGtleSwgZGVzY3JpcHRvciwgKF90aGlzJG9wdGlvbnNfMiA9IHRoaXMub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zXzIuYm91bmQpO1xuICByZXR1cm4gYWRtLmRlZmluZVByb3BlcnR5XyhrZXksIGZsb3dEZXNjcmlwdG9yLCBwcm94eVRyYXApO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRGbG93RGVzY3JpcHRvcihhZG0sIF9yZWYsIGtleSwgX3JlZjIpIHtcbiAgdmFyIGFubm90YXRpb25UeXBlXyA9IF9yZWYuYW5ub3RhdGlvblR5cGVfO1xuICB2YXIgdmFsdWUgPSBfcmVmMi52YWx1ZTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIGRpZShcIkNhbm5vdCBhcHBseSAnXCIgKyBhbm5vdGF0aW9uVHlwZV8gKyBcIicgdG8gJ1wiICsgYWRtLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKSArIFwiJzpcIiArIChcIlxcbidcIiArIGFubm90YXRpb25UeXBlXyArIFwiJyBjYW4gb25seSBiZSB1c2VkIG9uIHByb3BlcnRpZXMgd2l0aCBhIGdlbmVyYXRvciBmdW5jdGlvbiB2YWx1ZS5cIikpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZsb3dEZXNjcmlwdG9yKGFkbSwgYW5ub3RhdGlvbiwga2V5LCBkZXNjcmlwdG9yLCBib3VuZCwgLy8gcHJvdmlkZXMgYWJpbGl0eSB0byBkaXNhYmxlIHNhZmVEZXNjcmlwdG9ycyBmb3IgcHJvdG90eXBlc1xuc2FmZURlc2NyaXB0b3JzKSB7XG4gIGlmIChzYWZlRGVzY3JpcHRvcnMgPT09IHZvaWQgMCkge1xuICAgIHNhZmVEZXNjcmlwdG9ycyA9IGdsb2JhbFN0YXRlLnNhZmVEZXNjcmlwdG9ycztcbiAgfVxuXG4gIGFzc2VydEZsb3dEZXNjcmlwdG9yKGFkbSwgYW5ub3RhdGlvbiwga2V5LCBkZXNjcmlwdG9yKTtcbiAgdmFyIHZhbHVlID0gZGVzY3JpcHRvci52YWx1ZTsgLy8gSW4gY2FzZSBvZiBmbG93LmJvdW5kLCB0aGUgZGVzY3JpcHRvciBjYW4gYmUgZnJvbSBhbHJlYWR5IGFubm90YXRlZCBwcm90b3R5cGVcblxuICBpZiAoIWlzRmxvdyh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IGZsb3codmFsdWUpO1xuICB9XG5cbiAgaWYgKGJvdW5kKSB7XG4gICAgdmFyIF9hZG0kcHJveHlfO1xuXG4gICAgLy8gV2UgZG8gbm90IGtlZXAgb3JpZ2luYWwgZnVuY3Rpb24gYXJvdW5kLCBzbyB3ZSBiaW5kIHRoZSBleGlzdGluZyBmbG93XG4gICAgdmFsdWUgPSB2YWx1ZS5iaW5kKChfYWRtJHByb3h5XyA9IGFkbS5wcm94eV8pICE9IG51bGwgPyBfYWRtJHByb3h5XyA6IGFkbS50YXJnZXRfKTsgLy8gVGhpcyBpcyBub3JtYWxseSBzZXQgYnkgYGZsb3dgLCBidXQgYGJpbmRgIHJldHVybnMgbmV3IGZ1bmN0aW9uLi4uXG5cbiAgICB2YWx1ZS5pc01vYlhGbG93ID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIC8vIE5vbi1jb25maWd1cmFibGUgZm9yIGNsYXNzZXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsIGZpZWxkIHJlZGVmaW5pdGlvbiBpbiBzdWJjbGFzc1xuICAgIGNvbmZpZ3VyYWJsZTogc2FmZURlc2NyaXB0b3JzID8gYWRtLmlzUGxhaW5PYmplY3RfIDogdHJ1ZSxcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9ieGpzL21vYngvcHVsbC8yNjQxI2lzc3VlY29tbWVudC03MzcyOTIwNThcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAvLyBOb24tb2JzZXZhYmxlLCB0aGVyZWZvcmUgbm9uLXdyaXRhYmxlXG4gICAgLy8gQWxzbyBwcmV2ZW50cyByZXdyaXRpbmcgaW4gc3ViY2xhc3MgY29uc3RydWN0b3JcbiAgICB3cml0YWJsZTogc2FmZURlc2NyaXB0b3JzID8gZmFsc2UgOiB0cnVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkQW5ub3RhdGlvbihuYW1lLCBvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgYW5ub3RhdGlvblR5cGVfOiBuYW1lLFxuICAgIG9wdGlvbnNfOiBvcHRpb25zLFxuICAgIG1ha2VfOiBtYWtlXyQzLFxuICAgIGV4dGVuZF86IGV4dGVuZF8kM1xuICB9O1xufVxuXG5mdW5jdGlvbiBtYWtlXyQzKGFkbSwga2V5LCBkZXNjcmlwdG9yKSB7XG4gIHJldHVybiB0aGlzLmV4dGVuZF8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIGZhbHNlKSA9PT0gbnVsbCA/IDBcbiAgLyogQ2FuY2VsICovXG4gIDogMVxuICAvKiBCcmVhayAqL1xuICA7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZF8kMyhhZG0sIGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKSB7XG4gIGFzc2VydENvbXB1dGVkRGVzY3JpcHRvcihhZG0sIHRoaXMsIGtleSwgZGVzY3JpcHRvcik7XG4gIHJldHVybiBhZG0uZGVmaW5lQ29tcHV0ZWRQcm9wZXJ0eV8oa2V5LCBfZXh0ZW5kcyh7fSwgdGhpcy5vcHRpb25zXywge1xuICAgIGdldDogZGVzY3JpcHRvci5nZXQsXG4gICAgc2V0OiBkZXNjcmlwdG9yLnNldFxuICB9KSwgcHJveHlUcmFwKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Q29tcHV0ZWREZXNjcmlwdG9yKGFkbSwgX3JlZiwga2V5LCBfcmVmMikge1xuICB2YXIgYW5ub3RhdGlvblR5cGVfID0gX3JlZi5hbm5vdGF0aW9uVHlwZV87XG4gIHZhciBnZXQgPSBfcmVmMi5nZXQ7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhZ2V0KSB7XG4gICAgZGllKFwiQ2Fubm90IGFwcGx5ICdcIiArIGFubm90YXRpb25UeXBlXyArIFwiJyB0byAnXCIgKyBhZG0ubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpICsgXCInOlwiICsgKFwiXFxuJ1wiICsgYW5ub3RhdGlvblR5cGVfICsgXCInIGNhbiBvbmx5IGJlIHVzZWQgb24gZ2V0dGVyKCtzZXR0ZXIpIHByb3BlcnRpZXMuXCIpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZhYmxlQW5ub3RhdGlvbihuYW1lLCBvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgYW5ub3RhdGlvblR5cGVfOiBuYW1lLFxuICAgIG9wdGlvbnNfOiBvcHRpb25zLFxuICAgIG1ha2VfOiBtYWtlXyQ0LFxuICAgIGV4dGVuZF86IGV4dGVuZF8kNFxuICB9O1xufVxuXG5mdW5jdGlvbiBtYWtlXyQ0KGFkbSwga2V5LCBkZXNjcmlwdG9yKSB7XG4gIHJldHVybiB0aGlzLmV4dGVuZF8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIGZhbHNlKSA9PT0gbnVsbCA/IDBcbiAgLyogQ2FuY2VsICovXG4gIDogMVxuICAvKiBCcmVhayAqL1xuICA7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZF8kNChhZG0sIGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKSB7XG4gIHZhciBfdGhpcyRvcHRpb25zXyRlbmhhbmMsIF90aGlzJG9wdGlvbnNfO1xuXG4gIGFzc2VydE9ic2VydmFibGVEZXNjcmlwdG9yKGFkbSwgdGhpcywga2V5LCBkZXNjcmlwdG9yKTtcbiAgcmV0dXJuIGFkbS5kZWZpbmVPYnNlcnZhYmxlUHJvcGVydHlfKGtleSwgZGVzY3JpcHRvci52YWx1ZSwgKF90aGlzJG9wdGlvbnNfJGVuaGFuYyA9IChfdGhpcyRvcHRpb25zXyA9IHRoaXMub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zXy5lbmhhbmNlcikgIT0gbnVsbCA/IF90aGlzJG9wdGlvbnNfJGVuaGFuYyA6IGRlZXBFbmhhbmNlciwgcHJveHlUcmFwKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JzZXJ2YWJsZURlc2NyaXB0b3IoYWRtLCBfcmVmLCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgdmFyIGFubm90YXRpb25UeXBlXyA9IF9yZWYuYW5ub3RhdGlvblR5cGVfO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIShcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikpIHtcbiAgICBkaWUoXCJDYW5ub3QgYXBwbHkgJ1wiICsgYW5ub3RhdGlvblR5cGVfICsgXCInIHRvICdcIiArIGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgKyBcIic6XCIgKyAoXCJcXG4nXCIgKyBhbm5vdGF0aW9uVHlwZV8gKyBcIicgY2Fubm90IGJlIHVzZWQgb24gZ2V0dGVyL3NldHRlciBwcm9wZXJ0aWVzXCIpKTtcbiAgfVxufVxuXG52YXIgQVVUTyA9IFwidHJ1ZVwiO1xudmFyIGF1dG9Bbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUF1dG9Bbm5vdGF0aW9uKCk7XG5mdW5jdGlvbiBjcmVhdGVBdXRvQW5ub3RhdGlvbihvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgYW5ub3RhdGlvblR5cGVfOiBBVVRPLFxuICAgIG9wdGlvbnNfOiBvcHRpb25zLFxuICAgIG1ha2VfOiBtYWtlXyQ1LFxuICAgIGV4dGVuZF86IGV4dGVuZF8kNVxuICB9O1xufVxuXG5mdW5jdGlvbiBtYWtlXyQ1KGFkbSwga2V5LCBkZXNjcmlwdG9yLCBzb3VyY2UpIHtcbiAgdmFyIF90aGlzJG9wdGlvbnNfMywgX3RoaXMkb3B0aW9uc180O1xuXG4gIC8vIGdldHRlciAtPiBjb21wdXRlZFxuICBpZiAoZGVzY3JpcHRvci5nZXQpIHtcbiAgICByZXR1cm4gY29tcHV0ZWQubWFrZV8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIHNvdXJjZSk7XG4gIH0gLy8gbG9uZSBzZXR0ZXIgLT4gYWN0aW9uIHNldHRlclxuXG5cbiAgaWYgKGRlc2NyaXB0b3Iuc2V0KSB7XG4gICAgLy8gVE9ETyBtYWtlIGFjdGlvbiBhcHBsaWNhYmxlIHRvIHNldHRlciBhbmQgZGVsZWdhdGUgdG8gYWN0aW9uLm1ha2VfXG4gICAgdmFyIHNldCA9IGNyZWF0ZUFjdGlvbihrZXkudG9TdHJpbmcoKSwgZGVzY3JpcHRvci5zZXQpOyAvLyBvd25cblxuICAgIGlmIChzb3VyY2UgPT09IGFkbS50YXJnZXRfKSB7XG4gICAgICByZXR1cm4gYWRtLmRlZmluZVByb3BlcnR5XyhrZXksIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBnbG9iYWxTdGF0ZS5zYWZlRGVzY3JpcHRvcnMgPyBhZG0uaXNQbGFpbk9iamVjdF8gOiB0cnVlLFxuICAgICAgICBzZXQ6IHNldFxuICAgICAgfSkgPT09IG51bGwgPyAwXG4gICAgICAvKiBDYW5jZWwgKi9cbiAgICAgIDogMlxuICAgICAgLyogQ29udGludWUgKi9cbiAgICAgIDtcbiAgICB9IC8vIHByb3RvXG5cblxuICAgIGRlZmluZVByb3BlcnR5KHNvdXJjZSwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBzZXQ6IHNldFxuICAgIH0pO1xuICAgIHJldHVybiAyXG4gICAgLyogQ29udGludWUgKi9cbiAgICA7XG4gIH0gLy8gZnVuY3Rpb24gb24gcHJvdG8gLT4gYXV0b0FjdGlvbi9mbG93XG5cblxuICBpZiAoc291cmNlICE9PSBhZG0udGFyZ2V0XyAmJiB0eXBlb2YgZGVzY3JpcHRvci52YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIF90aGlzJG9wdGlvbnNfMjtcblxuICAgIGlmIChpc0dlbmVyYXRvcihkZXNjcmlwdG9yLnZhbHVlKSkge1xuICAgICAgdmFyIF90aGlzJG9wdGlvbnNfO1xuXG4gICAgICB2YXIgZmxvd0Fubm90YXRpb24gPSAoX3RoaXMkb3B0aW9uc18gPSB0aGlzLm9wdGlvbnNfKSAhPSBudWxsICYmIF90aGlzJG9wdGlvbnNfLmF1dG9CaW5kID8gZmxvdy5ib3VuZCA6IGZsb3c7XG4gICAgICByZXR1cm4gZmxvd0Fubm90YXRpb24ubWFrZV8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIHNvdXJjZSk7XG4gICAgfVxuXG4gICAgdmFyIGFjdGlvbkFubm90YXRpb24gPSAoX3RoaXMkb3B0aW9uc18yID0gdGhpcy5vcHRpb25zXykgIT0gbnVsbCAmJiBfdGhpcyRvcHRpb25zXzIuYXV0b0JpbmQgPyBhdXRvQWN0aW9uLmJvdW5kIDogYXV0b0FjdGlvbjtcbiAgICByZXR1cm4gYWN0aW9uQW5ub3RhdGlvbi5tYWtlXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgc291cmNlKTtcbiAgfSAvLyBvdGhlciAtPiBvYnNlcnZhYmxlXG4gIC8vIENvcHkgcHJvcHMgZnJvbSBwcm90byBhcyB3ZWxsLCBzZWUgdGVzdDpcbiAgLy8gXCJkZWNvcmF0ZSBzaG91bGQgd29yayB3aXRoIE9iamVjdC5jcmVhdGVcIlxuXG5cbiAgdmFyIG9ic2VydmFibGVBbm5vdGF0aW9uID0gKChfdGhpcyRvcHRpb25zXzMgPSB0aGlzLm9wdGlvbnNfKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb3B0aW9uc18zLmRlZXApID09PSBmYWxzZSA/IG9ic2VydmFibGUucmVmIDogb2JzZXJ2YWJsZTsgLy8gaWYgZnVuY3Rpb24gcmVzcGVjdCBhdXRvQmluZCBvcHRpb25cblxuICBpZiAodHlwZW9mIGRlc2NyaXB0b3IudmFsdWUgPT09IFwiZnVuY3Rpb25cIiAmJiAoX3RoaXMkb3B0aW9uc180ID0gdGhpcy5vcHRpb25zXykgIT0gbnVsbCAmJiBfdGhpcyRvcHRpb25zXzQuYXV0b0JpbmQpIHtcbiAgICB2YXIgX2FkbSRwcm94eV87XG5cbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gZGVzY3JpcHRvci52YWx1ZS5iaW5kKChfYWRtJHByb3h5XyA9IGFkbS5wcm94eV8pICE9IG51bGwgPyBfYWRtJHByb3h5XyA6IGFkbS50YXJnZXRfKTtcbiAgfVxuXG4gIHJldHVybiBvYnNlcnZhYmxlQW5ub3RhdGlvbi5tYWtlXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgc291cmNlKTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kXyQ1KGFkbSwga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApIHtcbiAgdmFyIF90aGlzJG9wdGlvbnNfNSwgX3RoaXMkb3B0aW9uc182O1xuXG4gIC8vIGdldHRlciAtPiBjb21wdXRlZFxuICBpZiAoZGVzY3JpcHRvci5nZXQpIHtcbiAgICByZXR1cm4gY29tcHV0ZWQuZXh0ZW5kXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKTtcbiAgfSAvLyBsb25lIHNldHRlciAtPiBhY3Rpb24gc2V0dGVyXG5cblxuICBpZiAoZGVzY3JpcHRvci5zZXQpIHtcbiAgICAvLyBUT0RPIG1ha2UgYWN0aW9uIGFwcGxpY2FibGUgdG8gc2V0dGVyIGFuZCBkZWxlZ2F0ZSB0byBhY3Rpb24uZXh0ZW5kX1xuICAgIHJldHVybiBhZG0uZGVmaW5lUHJvcGVydHlfKGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiBnbG9iYWxTdGF0ZS5zYWZlRGVzY3JpcHRvcnMgPyBhZG0uaXNQbGFpbk9iamVjdF8gOiB0cnVlLFxuICAgICAgc2V0OiBjcmVhdGVBY3Rpb24oa2V5LnRvU3RyaW5nKCksIGRlc2NyaXB0b3Iuc2V0KVxuICAgIH0sIHByb3h5VHJhcCk7XG4gIH0gLy8gb3RoZXIgLT4gb2JzZXJ2YWJsZVxuICAvLyBpZiBmdW5jdGlvbiByZXNwZWN0IGF1dG9CaW5kIG9wdGlvblxuXG5cbiAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yLnZhbHVlID09PSBcImZ1bmN0aW9uXCIgJiYgKF90aGlzJG9wdGlvbnNfNSA9IHRoaXMub3B0aW9uc18pICE9IG51bGwgJiYgX3RoaXMkb3B0aW9uc181LmF1dG9CaW5kKSB7XG4gICAgdmFyIF9hZG0kcHJveHlfMjtcblxuICAgIGRlc2NyaXB0b3IudmFsdWUgPSBkZXNjcmlwdG9yLnZhbHVlLmJpbmQoKF9hZG0kcHJveHlfMiA9IGFkbS5wcm94eV8pICE9IG51bGwgPyBfYWRtJHByb3h5XzIgOiBhZG0udGFyZ2V0Xyk7XG4gIH1cblxuICB2YXIgb2JzZXJ2YWJsZUFubm90YXRpb24gPSAoKF90aGlzJG9wdGlvbnNfNiA9IHRoaXMub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zXzYuZGVlcCkgPT09IGZhbHNlID8gb2JzZXJ2YWJsZS5yZWYgOiBvYnNlcnZhYmxlO1xuICByZXR1cm4gb2JzZXJ2YWJsZUFubm90YXRpb24uZXh0ZW5kXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKTtcbn1cblxudmFyIE9CU0VSVkFCTEUgPSBcIm9ic2VydmFibGVcIjtcbnZhciBPQlNFUlZBQkxFX1JFRiA9IFwib2JzZXJ2YWJsZS5yZWZcIjtcbnZhciBPQlNFUlZBQkxFX1NIQUxMT1cgPSBcIm9ic2VydmFibGUuc2hhbGxvd1wiO1xudmFyIE9CU0VSVkFCTEVfU1RSVUNUID0gXCJvYnNlcnZhYmxlLnN0cnVjdFwiOyAvLyBQcmVkZWZpbmVkIGJhZ3Mgb2YgY3JlYXRlIG9ic2VydmFibGUgb3B0aW9ucywgdG8gYXZvaWQgYWxsb2NhdGluZyB0ZW1wb3JhcmlseSBvcHRpb24gb2JqZWN0c1xuLy8gaW4gdGhlIG1ham9yaXR5IG9mIGNhc2VzXG5cbnZhciBkZWZhdWx0Q3JlYXRlT2JzZXJ2YWJsZU9wdGlvbnMgPSB7XG4gIGRlZXA6IHRydWUsXG4gIG5hbWU6IHVuZGVmaW5lZCxcbiAgZGVmYXVsdERlY29yYXRvcjogdW5kZWZpbmVkLFxuICBwcm94eTogdHJ1ZVxufTtcbk9iamVjdC5mcmVlemUoZGVmYXVsdENyZWF0ZU9ic2VydmFibGVPcHRpb25zKTtcbmZ1bmN0aW9uIGFzQ3JlYXRlT2JzZXJ2YWJsZU9wdGlvbnModGhpbmcpIHtcbiAgcmV0dXJuIHRoaW5nIHx8IGRlZmF1bHRDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucztcbn1cbnZhciBvYnNlcnZhYmxlQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVPYnNlcnZhYmxlQW5ub3RhdGlvbihPQlNFUlZBQkxFKTtcbnZhciBvYnNlcnZhYmxlUmVmQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVPYnNlcnZhYmxlQW5ub3RhdGlvbihPQlNFUlZBQkxFX1JFRiwge1xuICBlbmhhbmNlcjogcmVmZXJlbmNlRW5oYW5jZXJcbn0pO1xudmFyIG9ic2VydmFibGVTaGFsbG93QW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVPYnNlcnZhYmxlQW5ub3RhdGlvbihPQlNFUlZBQkxFX1NIQUxMT1csIHtcbiAgZW5oYW5jZXI6IHNoYWxsb3dFbmhhbmNlclxufSk7XG52YXIgb2JzZXJ2YWJsZVN0cnVjdEFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlT2JzZXJ2YWJsZUFubm90YXRpb24oT0JTRVJWQUJMRV9TVFJVQ1QsIHtcbiAgZW5oYW5jZXI6IHJlZlN0cnVjdEVuaGFuY2VyXG59KTtcbnZhciBvYnNlcnZhYmxlRGVjb3JhdG9yQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVEZWNvcmF0b3JBbm5vdGF0aW9uKG9ic2VydmFibGVBbm5vdGF0aW9uKTtcbmZ1bmN0aW9uIGdldEVuaGFuY2VyRnJvbU9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5kZWVwID09PSB0cnVlID8gZGVlcEVuaGFuY2VyIDogb3B0aW9ucy5kZWVwID09PSBmYWxzZSA/IHJlZmVyZW5jZUVuaGFuY2VyIDogZ2V0RW5oYW5jZXJGcm9tQW5ub3RhdGlvbihvcHRpb25zLmRlZmF1bHREZWNvcmF0b3IpO1xufVxuZnVuY3Rpb24gZ2V0QW5ub3RhdGlvbkZyb21PcHRpb25zKG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zJGRlZmF1bHREZWNvcjtcblxuICByZXR1cm4gb3B0aW9ucyA/IChfb3B0aW9ucyRkZWZhdWx0RGVjb3IgPSBvcHRpb25zLmRlZmF1bHREZWNvcmF0b3IpICE9IG51bGwgPyBfb3B0aW9ucyRkZWZhdWx0RGVjb3IgOiBjcmVhdGVBdXRvQW5ub3RhdGlvbihvcHRpb25zKSA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldEVuaGFuY2VyRnJvbUFubm90YXRpb24oYW5ub3RhdGlvbikge1xuICB2YXIgX2Fubm90YXRpb24kb3B0aW9uc18kLCBfYW5ub3RhdGlvbiRvcHRpb25zXztcblxuICByZXR1cm4gIWFubm90YXRpb24gPyBkZWVwRW5oYW5jZXIgOiAoX2Fubm90YXRpb24kb3B0aW9uc18kID0gKF9hbm5vdGF0aW9uJG9wdGlvbnNfID0gYW5ub3RhdGlvbi5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hbm5vdGF0aW9uJG9wdGlvbnNfLmVuaGFuY2VyKSAhPSBudWxsID8gX2Fubm90YXRpb24kb3B0aW9uc18kIDogZGVlcEVuaGFuY2VyO1xufVxuLyoqXHJcbiAqIFR1cm5zIGFuIG9iamVjdCwgYXJyYXkgb3IgZnVuY3Rpb24gaW50byBhIHJlYWN0aXZlIHN0cnVjdHVyZS5cclxuICogQHBhcmFtIHYgdGhlIHZhbHVlIHdoaWNoIHNob3VsZCBiZWNvbWUgb2JzZXJ2YWJsZS5cclxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmFibGUodiwgYXJnMiwgYXJnMykge1xuICAvLyBAb2JzZXJ2YWJsZSBzb21lUHJvcDtcbiAgaWYgKGlzU3RyaW5naXNoKGFyZzIpKSB7XG4gICAgc3RvcmVBbm5vdGF0aW9uKHYsIGFyZzIsIG9ic2VydmFibGVBbm5vdGF0aW9uKTtcbiAgICByZXR1cm47XG4gIH0gLy8gYWxyZWFkeSBvYnNlcnZhYmxlIC0gaWdub3JlXG5cblxuICBpZiAoaXNPYnNlcnZhYmxlKHYpKSB7XG4gICAgcmV0dXJuIHY7XG4gIH0gLy8gcGxhaW4gb2JqZWN0XG5cblxuICBpZiAoaXNQbGFpbk9iamVjdCh2KSkge1xuICAgIHJldHVybiBvYnNlcnZhYmxlLm9iamVjdCh2LCBhcmcyLCBhcmczKTtcbiAgfSAvLyBBcnJheVxuXG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZS5hcnJheSh2LCBhcmcyKTtcbiAgfSAvLyBNYXBcblxuXG4gIGlmIChpc0VTNk1hcCh2KSkge1xuICAgIHJldHVybiBvYnNlcnZhYmxlLm1hcCh2LCBhcmcyKTtcbiAgfSAvLyBTZXRcblxuXG4gIGlmIChpc0VTNlNldCh2KSkge1xuICAgIHJldHVybiBvYnNlcnZhYmxlLnNldCh2LCBhcmcyKTtcbiAgfSAvLyBvdGhlciBvYmplY3QgLSBpZ25vcmVcblxuXG4gIGlmICh0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHY7XG4gIH0gLy8gYW55dGhpbmcgZWxzZVxuXG5cbiAgcmV0dXJuIG9ic2VydmFibGUuYm94KHYsIGFyZzIpO1xufVxuXG5PYmplY3QuYXNzaWduKGNyZWF0ZU9ic2VydmFibGUsIG9ic2VydmFibGVEZWNvcmF0b3JBbm5vdGF0aW9uKTtcbnZhciBvYnNlcnZhYmxlRmFjdG9yaWVzID0ge1xuICBib3g6IGZ1bmN0aW9uIGJveCh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHZhciBvID0gYXNDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyhvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVWYWx1ZSh2YWx1ZSwgZ2V0RW5oYW5jZXJGcm9tT3B0aW9ucyhvKSwgby5uYW1lLCB0cnVlLCBvLmVxdWFscyk7XG4gIH0sXG4gIGFycmF5OiBmdW5jdGlvbiBhcnJheShpbml0aWFsVmFsdWVzLCBvcHRpb25zKSB7XG4gICAgdmFyIG8gPSBhc0NyZWF0ZU9ic2VydmFibGVPcHRpb25zKG9wdGlvbnMpO1xuICAgIHJldHVybiAoZ2xvYmFsU3RhdGUudXNlUHJveGllcyA9PT0gZmFsc2UgfHwgby5wcm94eSA9PT0gZmFsc2UgPyBjcmVhdGVMZWdhY3lBcnJheSA6IGNyZWF0ZU9ic2VydmFibGVBcnJheSkoaW5pdGlhbFZhbHVlcywgZ2V0RW5oYW5jZXJGcm9tT3B0aW9ucyhvKSwgby5uYW1lKTtcbiAgfSxcbiAgbWFwOiBmdW5jdGlvbiBtYXAoaW5pdGlhbFZhbHVlcywgb3B0aW9ucykge1xuICAgIHZhciBvID0gYXNDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyhvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVNYXAoaW5pdGlhbFZhbHVlcywgZ2V0RW5oYW5jZXJGcm9tT3B0aW9ucyhvKSwgby5uYW1lKTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQoaW5pdGlhbFZhbHVlcywgb3B0aW9ucykge1xuICAgIHZhciBvID0gYXNDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyhvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVTZXQoaW5pdGlhbFZhbHVlcywgZ2V0RW5oYW5jZXJGcm9tT3B0aW9ucyhvKSwgby5uYW1lKTtcbiAgfSxcbiAgb2JqZWN0OiBmdW5jdGlvbiBvYmplY3QocHJvcHMsIGRlY29yYXRvcnMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZXh0ZW5kT2JzZXJ2YWJsZShnbG9iYWxTdGF0ZS51c2VQcm94aWVzID09PSBmYWxzZSB8fCAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5wcm94eSkgPT09IGZhbHNlID8gYXNPYnNlcnZhYmxlT2JqZWN0KHt9LCBvcHRpb25zKSA6IGFzRHluYW1pY09ic2VydmFibGVPYmplY3Qoe30sIG9wdGlvbnMpLCBwcm9wcywgZGVjb3JhdG9ycyk7XG4gIH0sXG4gIHJlZjogLyojX19QVVJFX18qL2NyZWF0ZURlY29yYXRvckFubm90YXRpb24ob2JzZXJ2YWJsZVJlZkFubm90YXRpb24pLFxuICBzaGFsbG93OiAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihvYnNlcnZhYmxlU2hhbGxvd0Fubm90YXRpb24pLFxuICBkZWVwOiBvYnNlcnZhYmxlRGVjb3JhdG9yQW5ub3RhdGlvbixcbiAgc3RydWN0OiAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihvYnNlcnZhYmxlU3RydWN0QW5ub3RhdGlvbilcbn07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuXG52YXIgb2JzZXJ2YWJsZSA9IC8qI19fUFVSRV9fKi9hc3NpZ24oY3JlYXRlT2JzZXJ2YWJsZSwgb2JzZXJ2YWJsZUZhY3Rvcmllcyk7XG5cbnZhciBDT01QVVRFRCA9IFwiY29tcHV0ZWRcIjtcbnZhciBDT01QVVRFRF9TVFJVQ1QgPSBcImNvbXB1dGVkLnN0cnVjdFwiO1xudmFyIGNvbXB1dGVkQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb21wdXRlZEFubm90YXRpb24oQ09NUFVURUQpO1xudmFyIGNvbXB1dGVkU3RydWN0QW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb21wdXRlZEFubm90YXRpb24oQ09NUFVURURfU1RSVUNULCB7XG4gIGVxdWFsczogY29tcGFyZXIuc3RydWN0dXJhbFxufSk7XG4vKipcclxuICogRGVjb3JhdG9yIGZvciBjbGFzcyBwcm9wZXJ0aWVzOiBAY29tcHV0ZWQgZ2V0IHZhbHVlKCkgeyByZXR1cm4gZXhwcjsgfS5cclxuICogRm9yIGxlZ2FjeSBwdXJwb3NlcyBhbHNvIGludm9rYWJsZSBhcyBFUzUgb2JzZXJ2YWJsZSBjcmVhdGVkOiBgY29tcHV0ZWQoKCkgPT4gZXhwcilgO1xyXG4gKi9cblxudmFyIGNvbXB1dGVkID0gZnVuY3Rpb24gY29tcHV0ZWQoYXJnMSwgYXJnMikge1xuICBpZiAoaXNTdHJpbmdpc2goYXJnMikpIHtcbiAgICAvLyBAY29tcHV0ZWRcbiAgICByZXR1cm4gc3RvcmVBbm5vdGF0aW9uKGFyZzEsIGFyZzIsIGNvbXB1dGVkQW5ub3RhdGlvbik7XG4gIH1cblxuICBpZiAoaXNQbGFpbk9iamVjdChhcmcxKSkge1xuICAgIC8vIEBjb21wdXRlZCh7IG9wdGlvbnMgfSlcbiAgICByZXR1cm4gY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihjcmVhdGVDb21wdXRlZEFubm90YXRpb24oQ09NUFVURUQsIGFyZzEpKTtcbiAgfSAvLyBjb21wdXRlZChleHByLCBvcHRpb25zPylcblxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24oYXJnMSkpIHtcbiAgICAgIGRpZShcIkZpcnN0IGFyZ3VtZW50IHRvIGBjb21wdXRlZGAgc2hvdWxkIGJlIGFuIGV4cHJlc3Npb24uXCIpO1xuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKGFyZzIpKSB7XG4gICAgICBkaWUoXCJBIHNldHRlciBhcyBzZWNvbmQgYXJndW1lbnQgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCwgdXNlIGB7IHNldDogZm4gfWAgb3B0aW9uIGluc3RlYWRcIik7XG4gICAgfVxuICB9XG5cbiAgdmFyIG9wdHMgPSBpc1BsYWluT2JqZWN0KGFyZzIpID8gYXJnMiA6IHt9O1xuICBvcHRzLmdldCA9IGFyZzE7XG4gIG9wdHMubmFtZSB8fCAob3B0cy5uYW1lID0gYXJnMS5uYW1lIHx8IFwiXCIpO1xuICAvKiBmb3IgZ2VuZXJhdGVkIG5hbWUgKi9cblxuICByZXR1cm4gbmV3IENvbXB1dGVkVmFsdWUob3B0cyk7XG59O1xuT2JqZWN0LmFzc2lnbihjb21wdXRlZCwgY29tcHV0ZWRBbm5vdGF0aW9uKTtcbmNvbXB1dGVkLnN0cnVjdCA9IC8qI19fUFVSRV9fKi9jcmVhdGVEZWNvcmF0b3JBbm5vdGF0aW9uKGNvbXB1dGVkU3RydWN0QW5ub3RhdGlvbik7XG5cbnZhciBfZ2V0RGVzY3JpcHRvciRjb25maWcsIF9nZXREZXNjcmlwdG9yO1xuLy8gbW9ieCB2ZXJzaW9uc1xuXG52YXIgY3VycmVudEFjdGlvbklkID0gMDtcbnZhciBuZXh0QWN0aW9uSWQgPSAxO1xudmFyIGlzRnVuY3Rpb25OYW1lQ29uZmlndXJhYmxlID0gKF9nZXREZXNjcmlwdG9yJGNvbmZpZyA9IChfZ2V0RGVzY3JpcHRvciA9IC8qI19fUFVSRV9fKi9nZXREZXNjcmlwdG9yKGZ1bmN0aW9uICgpIHt9LCBcIm5hbWVcIikpID09IG51bGwgPyB2b2lkIDAgOiBfZ2V0RGVzY3JpcHRvci5jb25maWd1cmFibGUpICE9IG51bGwgPyBfZ2V0RGVzY3JpcHRvciRjb25maWcgOiBmYWxzZTsgLy8gd2UgY2FuIHNhZmVseSByZWN5Y2xlIHRoaXMgb2JqZWN0XG5cbnZhciB0bXBOYW1lRGVzY3JpcHRvciA9IHtcbiAgdmFsdWU6IFwiYWN0aW9uXCIsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiBmYWxzZVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbihhY3Rpb25OYW1lLCBmbiwgYXV0b0FjdGlvbiwgcmVmKSB7XG4gIGlmIChhdXRvQWN0aW9uID09PSB2b2lkIDApIHtcbiAgICBhdXRvQWN0aW9uID0gZmFsc2U7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKGZuKSkge1xuICAgICAgZGllKFwiYGFjdGlvbmAgY2FuIG9ubHkgYmUgaW52b2tlZCBvbiBmdW5jdGlvbnNcIik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBhY3Rpb25OYW1lICE9PSBcInN0cmluZ1wiIHx8ICFhY3Rpb25OYW1lKSB7XG4gICAgICBkaWUoXCJhY3Rpb25zIHNob3VsZCBoYXZlIHZhbGlkIG5hbWVzLCBnb3Q6ICdcIiArIGFjdGlvbk5hbWUgKyBcIidcIik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzKCkge1xuICAgIHJldHVybiBleGVjdXRlQWN0aW9uKGFjdGlvbk5hbWUsIGF1dG9BY3Rpb24sIGZuLCByZWYgfHwgdGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJlcy5pc01vYnhBY3Rpb24gPSB0cnVlO1xuXG4gIGlmIChpc0Z1bmN0aW9uTmFtZUNvbmZpZ3VyYWJsZSkge1xuICAgIHRtcE5hbWVEZXNjcmlwdG9yLnZhbHVlID0gYWN0aW9uTmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzLCBcIm5hbWVcIiwgdG1wTmFtZURlc2NyaXB0b3IpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGV4ZWN1dGVBY3Rpb24oYWN0aW9uTmFtZSwgY2FuUnVuQXNEZXJpdmF0aW9uLCBmbiwgc2NvcGUsIGFyZ3MpIHtcbiAgdmFyIHJ1bkluZm8gPSBfc3RhcnRBY3Rpb24oYWN0aW9uTmFtZSwgY2FuUnVuQXNEZXJpdmF0aW9uLCBzY29wZSwgYXJncyk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZm4uYXBwbHkoc2NvcGUsIGFyZ3MpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBydW5JbmZvLmVycm9yXyA9IGVycjtcbiAgICB0aHJvdyBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgX2VuZEFjdGlvbihydW5JbmZvKTtcbiAgfVxufVxuZnVuY3Rpb24gX3N0YXJ0QWN0aW9uKGFjdGlvbk5hbWUsIGNhblJ1bkFzRGVyaXZhdGlvbiwgLy8gdHJ1ZSBmb3IgYXV0b0FjdGlvblxuc2NvcGUsIGFyZ3MpIHtcbiAgdmFyIG5vdGlmeVNweV8gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNTcHlFbmFibGVkKCkgJiYgISFhY3Rpb25OYW1lO1xuICB2YXIgc3RhcnRUaW1lXyA9IDA7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHlfKSB7XG4gICAgc3RhcnRUaW1lXyA9IERhdGUubm93KCk7XG4gICAgdmFyIGZsYXR0ZW5lZEFyZ3MgPSBhcmdzID8gQXJyYXkuZnJvbShhcmdzKSA6IEVNUFRZX0FSUkFZO1xuICAgIHNweVJlcG9ydFN0YXJ0KHtcbiAgICAgIHR5cGU6IEFDVElPTixcbiAgICAgIG5hbWU6IGFjdGlvbk5hbWUsXG4gICAgICBvYmplY3Q6IHNjb3BlLFxuICAgICAgYXJndW1lbnRzOiBmbGF0dGVuZWRBcmdzXG4gICAgfSk7XG4gIH1cblxuICB2YXIgcHJldkRlcml2YXRpb25fID0gZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uO1xuICB2YXIgcnVuQXNBY3Rpb24gPSAhY2FuUnVuQXNEZXJpdmF0aW9uIHx8ICFwcmV2RGVyaXZhdGlvbl87XG4gIHN0YXJ0QmF0Y2goKTtcbiAgdmFyIHByZXZBbGxvd1N0YXRlQ2hhbmdlc18gPSBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlQ2hhbmdlczsgLy8gYnkgZGVmYXVsdCBwcmVzZXJ2ZSBwcmV2aW91cyBhbGxvd1xuXG4gIGlmIChydW5Bc0FjdGlvbikge1xuICAgIHVudHJhY2tlZFN0YXJ0KCk7XG4gICAgcHJldkFsbG93U3RhdGVDaGFuZ2VzXyA9IGFsbG93U3RhdGVDaGFuZ2VzU3RhcnQodHJ1ZSk7XG4gIH1cblxuICB2YXIgcHJldkFsbG93U3RhdGVSZWFkc18gPSBhbGxvd1N0YXRlUmVhZHNTdGFydCh0cnVlKTtcbiAgdmFyIHJ1bkluZm8gPSB7XG4gICAgcnVuQXNBY3Rpb25fOiBydW5Bc0FjdGlvbixcbiAgICBwcmV2RGVyaXZhdGlvbl86IHByZXZEZXJpdmF0aW9uXyxcbiAgICBwcmV2QWxsb3dTdGF0ZUNoYW5nZXNfOiBwcmV2QWxsb3dTdGF0ZUNoYW5nZXNfLFxuICAgIHByZXZBbGxvd1N0YXRlUmVhZHNfOiBwcmV2QWxsb3dTdGF0ZVJlYWRzXyxcbiAgICBub3RpZnlTcHlfOiBub3RpZnlTcHlfLFxuICAgIHN0YXJ0VGltZV86IHN0YXJ0VGltZV8sXG4gICAgYWN0aW9uSWRfOiBuZXh0QWN0aW9uSWQrKyxcbiAgICBwYXJlbnRBY3Rpb25JZF86IGN1cnJlbnRBY3Rpb25JZFxuICB9O1xuICBjdXJyZW50QWN0aW9uSWQgPSBydW5JbmZvLmFjdGlvbklkXztcbiAgcmV0dXJuIHJ1bkluZm87XG59XG5mdW5jdGlvbiBfZW5kQWN0aW9uKHJ1bkluZm8pIHtcbiAgaWYgKGN1cnJlbnRBY3Rpb25JZCAhPT0gcnVuSW5mby5hY3Rpb25JZF8pIHtcbiAgICBkaWUoMzApO1xuICB9XG5cbiAgY3VycmVudEFjdGlvbklkID0gcnVuSW5mby5wYXJlbnRBY3Rpb25JZF87XG5cbiAgaWYgKHJ1bkluZm8uZXJyb3JfICE9PSB1bmRlZmluZWQpIHtcbiAgICBnbG9iYWxTdGF0ZS5zdXBwcmVzc1JlYWN0aW9uRXJyb3JzID0gdHJ1ZTtcbiAgfVxuXG4gIGFsbG93U3RhdGVDaGFuZ2VzRW5kKHJ1bkluZm8ucHJldkFsbG93U3RhdGVDaGFuZ2VzXyk7XG4gIGFsbG93U3RhdGVSZWFkc0VuZChydW5JbmZvLnByZXZBbGxvd1N0YXRlUmVhZHNfKTtcbiAgZW5kQmF0Y2goKTtcblxuICBpZiAocnVuSW5mby5ydW5Bc0FjdGlvbl8pIHtcbiAgICB1bnRyYWNrZWRFbmQocnVuSW5mby5wcmV2RGVyaXZhdGlvbl8pO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBydW5JbmZvLm5vdGlmeVNweV8pIHtcbiAgICBzcHlSZXBvcnRFbmQoe1xuICAgICAgdGltZTogRGF0ZS5ub3coKSAtIHJ1bkluZm8uc3RhcnRUaW1lX1xuICAgIH0pO1xuICB9XG5cbiAgZ2xvYmFsU3RhdGUuc3VwcHJlc3NSZWFjdGlvbkVycm9ycyA9IGZhbHNlO1xufVxuZnVuY3Rpb24gYWxsb3dTdGF0ZUNoYW5nZXMoYWxsb3dTdGF0ZUNoYW5nZXMsIGZ1bmMpIHtcbiAgdmFyIHByZXYgPSBhbGxvd1N0YXRlQ2hhbmdlc1N0YXJ0KGFsbG93U3RhdGVDaGFuZ2VzKTtcblxuICB0cnkge1xuICAgIHJldHVybiBmdW5jKCk7XG4gIH0gZmluYWxseSB7XG4gICAgYWxsb3dTdGF0ZUNoYW5nZXNFbmQocHJldik7XG4gIH1cbn1cbmZ1bmN0aW9uIGFsbG93U3RhdGVDaGFuZ2VzU3RhcnQoYWxsb3dTdGF0ZUNoYW5nZXMpIHtcbiAgdmFyIHByZXYgPSBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlQ2hhbmdlcztcbiAgZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZUNoYW5nZXMgPSBhbGxvd1N0YXRlQ2hhbmdlcztcbiAgcmV0dXJuIHByZXY7XG59XG5mdW5jdGlvbiBhbGxvd1N0YXRlQ2hhbmdlc0VuZChwcmV2KSB7XG4gIGdsb2JhbFN0YXRlLmFsbG93U3RhdGVDaGFuZ2VzID0gcHJldjtcbn1cblxudmFyIF9TeW1ib2wkdG9QcmltaXRpdmU7XG52YXIgQ1JFQVRFID0gXCJjcmVhdGVcIjtcbl9TeW1ib2wkdG9QcmltaXRpdmUgPSBTeW1ib2wudG9QcmltaXRpdmU7XG52YXIgT2JzZXJ2YWJsZVZhbHVlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQXRvbSkge1xuICBfaW5oZXJpdHNMb29zZShPYnNlcnZhYmxlVmFsdWUsIF9BdG9tKTtcblxuICBmdW5jdGlvbiBPYnNlcnZhYmxlVmFsdWUodmFsdWUsIGVuaGFuY2VyLCBuYW1lXywgbm90aWZ5U3B5LCBlcXVhbHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBpZiAobmFtZV8gPT09IHZvaWQgMCkge1xuICAgICAgbmFtZV8gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIk9ic2VydmFibGVWYWx1ZUBcIiArIGdldE5leHRJZCgpIDogXCJPYnNlcnZhYmxlVmFsdWVcIjtcbiAgICB9XG5cbiAgICBpZiAobm90aWZ5U3B5ID09PSB2b2lkIDApIHtcbiAgICAgIG5vdGlmeVNweSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGVxdWFscyA9PT0gdm9pZCAwKSB7XG4gICAgICBlcXVhbHMgPSBjb21wYXJlcltcImRlZmF1bHRcIl07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfQXRvbS5jYWxsKHRoaXMsIG5hbWVfKSB8fCB0aGlzO1xuICAgIF90aGlzLmVuaGFuY2VyID0gdm9pZCAwO1xuICAgIF90aGlzLm5hbWVfID0gdm9pZCAwO1xuICAgIF90aGlzLmVxdWFscyA9IHZvaWQgMDtcbiAgICBfdGhpcy5oYXNVbnJlcG9ydGVkQ2hhbmdlXyA9IGZhbHNlO1xuICAgIF90aGlzLmludGVyY2VwdG9yc18gPSB2b2lkIDA7XG4gICAgX3RoaXMuY2hhbmdlTGlzdGVuZXJzXyA9IHZvaWQgMDtcbiAgICBfdGhpcy52YWx1ZV8gPSB2b2lkIDA7XG4gICAgX3RoaXMuZGVoYW5jZXIgPSB2b2lkIDA7XG4gICAgX3RoaXMuZW5oYW5jZXIgPSBlbmhhbmNlcjtcbiAgICBfdGhpcy5uYW1lXyA9IG5hbWVfO1xuICAgIF90aGlzLmVxdWFscyA9IGVxdWFscztcbiAgICBfdGhpcy52YWx1ZV8gPSBlbmhhbmNlcih2YWx1ZSwgdW5kZWZpbmVkLCBuYW1lXyk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSAmJiBpc1NweUVuYWJsZWQoKSkge1xuICAgICAgLy8gb25seSBub3RpZnkgc3B5IGlmIHRoaXMgaXMgYSBzdGFuZC1hbG9uZSBvYnNlcnZhYmxlXG4gICAgICBzcHlSZXBvcnQoe1xuICAgICAgICB0eXBlOiBDUkVBVEUsXG4gICAgICAgIG9iamVjdDogX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksXG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcInZhbHVlXCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogX3RoaXMubmFtZV8sXG4gICAgICAgIG5ld1ZhbHVlOiBcIlwiICsgX3RoaXMudmFsdWVfXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gT2JzZXJ2YWJsZVZhbHVlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVoYW5jZVZhbHVlID0gZnVuY3Rpb24gZGVoYW5jZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZGVoYW5jZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVoYW5jZXIodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KG5ld1ZhbHVlKSB7XG4gICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZV87XG4gICAgbmV3VmFsdWUgPSB0aGlzLnByZXBhcmVOZXdWYWx1ZV8obmV3VmFsdWUpO1xuXG4gICAgaWYgKG5ld1ZhbHVlICE9PSBnbG9iYWxTdGF0ZS5VTkNIQU5HRUQpIHtcbiAgICAgIHZhciBub3RpZnlTcHkgPSBpc1NweUVuYWJsZWQoKTtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHtcbiAgICAgICAgc3B5UmVwb3J0U3RhcnQoe1xuICAgICAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwidmFsdWVcIixcbiAgICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXROZXdWYWx1ZV8obmV3VmFsdWUpO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSkge1xuICAgICAgICBzcHlSZXBvcnRFbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnByZXBhcmVOZXdWYWx1ZV8gPSBmdW5jdGlvbiBwcmVwYXJlTmV3VmFsdWVfKG5ld1ZhbHVlKSB7XG4gICAgY2hlY2tJZlN0YXRlTW9kaWZpY2F0aW9uc0FyZUFsbG93ZWQodGhpcyk7XG5cbiAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICB0eXBlOiBVUERBVEUsXG4gICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghY2hhbmdlKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxTdGF0ZS5VTkNIQU5HRUQ7XG4gICAgICB9XG5cbiAgICAgIG5ld1ZhbHVlID0gY2hhbmdlLm5ld1ZhbHVlO1xuICAgIH0gLy8gYXBwbHkgbW9kaWZpZXJcblxuXG4gICAgbmV3VmFsdWUgPSB0aGlzLmVuaGFuY2VyKG5ld1ZhbHVlLCB0aGlzLnZhbHVlXywgdGhpcy5uYW1lXyk7XG4gICAgcmV0dXJuIHRoaXMuZXF1YWxzKHRoaXMudmFsdWVfLCBuZXdWYWx1ZSkgPyBnbG9iYWxTdGF0ZS5VTkNIQU5HRUQgOiBuZXdWYWx1ZTtcbiAgfTtcblxuICBfcHJvdG8uc2V0TmV3VmFsdWVfID0gZnVuY3Rpb24gc2V0TmV3VmFsdWVfKG5ld1ZhbHVlKSB7XG4gICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZV87XG4gICAgdGhpcy52YWx1ZV8gPSBuZXdWYWx1ZTtcbiAgICB0aGlzLnJlcG9ydENoYW5nZWQoKTtcblxuICAgIGlmIChoYXNMaXN0ZW5lcnModGhpcykpIHtcbiAgICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCB7XG4gICAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWUsXG4gICAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoKSB7XG4gICAgdGhpcy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHJldHVybiB0aGlzLmRlaGFuY2VWYWx1ZSh0aGlzLnZhbHVlXyk7XG4gIH07XG5cbiAgX3Byb3RvLmludGVyY2VwdF8gPSBmdW5jdGlvbiBpbnRlcmNlcHRfKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gcmVnaXN0ZXJJbnRlcmNlcHRvcih0aGlzLCBoYW5kbGVyKTtcbiAgfTtcblxuICBfcHJvdG8ub2JzZXJ2ZV8gPSBmdW5jdGlvbiBvYnNlcnZlXyhsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KSB7XG4gICAgaWYgKGZpcmVJbW1lZGlhdGVseSkge1xuICAgICAgbGlzdGVuZXIoe1xuICAgICAgICBvYnNlcnZhYmxlS2luZDogXCJ2YWx1ZVwiLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgICBuZXdWYWx1ZTogdGhpcy52YWx1ZV8sXG4gICAgICAgIG9sZFZhbHVlOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZWdpc3Rlckxpc3RlbmVyKHRoaXMsIGxpc3RlbmVyKTtcbiAgfTtcblxuICBfcHJvdG8ucmF3ID0gZnVuY3Rpb24gcmF3KCkge1xuICAgIC8vIHVzZWQgYnkgTVNUIG90IGdldCB1bmRlaGFuY2VkIHZhbHVlXG4gICAgcmV0dXJuIHRoaXMudmFsdWVfO1xuICB9O1xuXG4gIF9wcm90by50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCk7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZV8gKyBcIltcIiArIHRoaXMudmFsdWVfICsgXCJdXCI7XG4gIH07XG5cbiAgX3Byb3RvLnZhbHVlT2YgPSBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgIHJldHVybiB0b1ByaW1pdGl2ZSh0aGlzLmdldCgpKTtcbiAgfTtcblxuICBfcHJvdG9bX1N5bWJvbCR0b1ByaW1pdGl2ZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVPZigpO1xuICB9O1xuXG4gIHJldHVybiBPYnNlcnZhYmxlVmFsdWU7XG59KEF0b20pO1xudmFyIGlzT2JzZXJ2YWJsZVZhbHVlID0gLyojX19QVVJFX18qL2NyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUoXCJPYnNlcnZhYmxlVmFsdWVcIiwgT2JzZXJ2YWJsZVZhbHVlKTtcblxudmFyIF9TeW1ib2wkdG9QcmltaXRpdmUkMTtcbi8qKlxyXG4gKiBBIG5vZGUgaW4gdGhlIHN0YXRlIGRlcGVuZGVuY3kgcm9vdCB0aGF0IG9ic2VydmVzIG90aGVyIG5vZGVzLCBhbmQgY2FuIGJlIG9ic2VydmVkIGl0c2VsZi5cclxuICpcclxuICogQ29tcHV0ZWRWYWx1ZSB3aWxsIHJlbWVtYmVyIHRoZSByZXN1bHQgb2YgdGhlIGNvbXB1dGF0aW9uIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGJhdGNoLCBvclxyXG4gKiB3aGlsZSBiZWluZyBvYnNlcnZlZC5cclxuICpcclxuICogRHVyaW5nIHRoaXMgdGltZSBpdCB3aWxsIHJlY29tcHV0ZSBvbmx5IHdoZW4gb25lIG9mIGl0cyBkaXJlY3QgZGVwZW5kZW5jaWVzIGNoYW5nZWQsXHJcbiAqIGJ1dCBvbmx5IHdoZW4gaXQgaXMgYmVpbmcgYWNjZXNzZWQgd2l0aCBgQ29tcHV0ZWRWYWx1ZS5nZXQoKWAuXHJcbiAqXHJcbiAqIEltcGxlbWVudGF0aW9uIGRlc2NyaXB0aW9uOlxyXG4gKiAxLiBGaXJzdCB0aW1lIGl0J3MgYmVpbmcgYWNjZXNzZWQgaXQgd2lsbCBjb21wdXRlIGFuZCByZW1lbWJlciByZXN1bHRcclxuICogICAgZ2l2ZSBiYWNrIHJlbWVtYmVyZWQgcmVzdWx0IHVudGlsIDIuIGhhcHBlbnNcclxuICogMi4gRmlyc3QgdGltZSBhbnkgZGVlcCBkZXBlbmRlbmN5IGNoYW5nZSwgcHJvcGFnYXRlIFBPU1NJQkxZX1NUQUxFIHRvIGFsbCBvYnNlcnZlcnMsIHdhaXQgZm9yIDMuXHJcbiAqIDMuIFdoZW4gaXQncyBiZWluZyBhY2Nlc3NlZCwgcmVjb21wdXRlIGlmIGFueSBzaGFsbG93IGRlcGVuZGVuY3kgY2hhbmdlZC5cclxuICogICAgaWYgcmVzdWx0IGNoYW5nZWQ6IHByb3BhZ2F0ZSBTVEFMRSB0byBhbGwgb2JzZXJ2ZXJzLCB0aGF0IHdlcmUgUE9TU0lCTFlfU1RBTEUgZnJvbSB0aGUgbGFzdCBzdGVwLlxyXG4gKiAgICBnbyB0byBzdGVwIDIuIGVpdGhlciB3YXlcclxuICpcclxuICogSWYgYXQgYW55IHBvaW50IGl0J3Mgb3V0c2lkZSBiYXRjaCBhbmQgaXQgaXNuJ3Qgb2JzZXJ2ZWQ6IHJlc2V0IGV2ZXJ5dGhpbmcgYW5kIGdvIHRvIDEuXHJcbiAqL1xuXG5fU3ltYm9sJHRvUHJpbWl0aXZlJDEgPSBTeW1ib2wudG9QcmltaXRpdmU7XG52YXIgQ29tcHV0ZWRWYWx1ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIG5vZGVzIHdlIGFyZSBsb29raW5nIGF0LiBPdXIgdmFsdWUgZGVwZW5kcyBvbiB0aGVzZSBub2Rlc1xuICAvLyBkdXJpbmcgdHJhY2tpbmcgaXQncyBhbiBhcnJheSB3aXRoIG5ldyBvYnNlcnZlZCBvYnNlcnZlcnNcbiAgLy8gdG8gY2hlY2sgZm9yIGN5Y2xlc1xuICAvLyBOLkI6IHVubWluaWZpZWQgYXMgaXQgaXMgdXNlZCBieSBNU1RcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgY29tcHV0ZWQgdmFsdWUgYmFzZWQgb24gYSBmdW5jdGlvbiBleHByZXNzaW9uLlxyXG4gICAqXHJcbiAgICogVGhlIGBuYW1lYCBwcm9wZXJ0eSBpcyBmb3IgZGVidWcgcHVycG9zZXMgb25seS5cclxuICAgKlxyXG4gICAqIFRoZSBgZXF1YWxzYCBwcm9wZXJ0eSBzcGVjaWZpZXMgdGhlIGNvbXBhcmVyIGZ1bmN0aW9uIHRvIHVzZSB0byBkZXRlcm1pbmUgaWYgYSBuZXdseSBwcm9kdWNlZFxyXG4gICAqIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgcHJldmlvdXMgdmFsdWUuIFR3byBjb21wYXJlcnMgYXJlIHByb3ZpZGVkIGluIHRoZSBsaWJyYXJ5OyBgZGVmYXVsdENvbXBhcmVyYFxyXG4gICAqIGNvbXBhcmVzIGJhc2VkIG9uIGlkZW50aXR5IGNvbXBhcmlzb24gKD09PSksIGFuZCBgc3RydWN0dXJhbENvbXBhcmVyYCBkZWVwbHkgY29tcGFyZXMgdGhlIHN0cnVjdHVyZS5cclxuICAgKiBTdHJ1Y3R1cmFsIGNvbXBhcmlzb24gY2FuIGJlIGNvbnZlbmllbnQgaWYgeW91IGFsd2F5cyBwcm9kdWNlIGEgbmV3IGFnZ3JlZ2F0ZWQgb2JqZWN0IGFuZFxyXG4gICAqIGRvbid0IHdhbnQgdG8gbm90aWZ5IG9ic2VydmVycyBpZiBpdCBpcyBzdHJ1Y3R1cmFsbHkgdGhlIHNhbWUuXHJcbiAgICogVGhpcyBpcyB1c2VmdWwgZm9yIHdvcmtpbmcgd2l0aCB2ZWN0b3JzLCBtb3VzZSBjb29yZGluYXRlcyBldGMuXHJcbiAgICovXG4gIGZ1bmN0aW9uIENvbXB1dGVkVmFsdWUob3B0aW9ucykge1xuICAgIHRoaXMuZGVwZW5kZW5jaWVzU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uTk9UX1RSQUNLSU5HXztcbiAgICB0aGlzLm9ic2VydmluZ18gPSBbXTtcbiAgICB0aGlzLm5ld09ic2VydmluZ18gPSBudWxsO1xuICAgIHRoaXMuaXNCZWluZ09ic2VydmVkXyA9IGZhbHNlO1xuICAgIHRoaXMuaXNQZW5kaW5nVW5vYnNlcnZhdGlvbl8gPSBmYWxzZTtcbiAgICB0aGlzLm9ic2VydmVyc18gPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5kaWZmVmFsdWVfID0gMDtcbiAgICB0aGlzLnJ1bklkXyA9IDA7XG4gICAgdGhpcy5sYXN0QWNjZXNzZWRCeV8gPSAwO1xuICAgIHRoaXMubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXztcbiAgICB0aGlzLnVuYm91bmREZXBzQ291bnRfID0gMDtcbiAgICB0aGlzLnZhbHVlXyA9IG5ldyBDYXVnaHRFeGNlcHRpb24obnVsbCk7XG4gICAgdGhpcy5uYW1lXyA9IHZvaWQgMDtcbiAgICB0aGlzLnRyaWdnZXJlZEJ5XyA9IHZvaWQgMDtcbiAgICB0aGlzLmlzQ29tcHV0aW5nXyA9IGZhbHNlO1xuICAgIHRoaXMuaXNSdW5uaW5nU2V0dGVyXyA9IGZhbHNlO1xuICAgIHRoaXMuZGVyaXZhdGlvbiA9IHZvaWQgMDtcbiAgICB0aGlzLnNldHRlcl8gPSB2b2lkIDA7XG4gICAgdGhpcy5pc1RyYWNpbmdfID0gVHJhY2VNb2RlLk5PTkU7XG4gICAgdGhpcy5zY29wZV8gPSB2b2lkIDA7XG4gICAgdGhpcy5lcXVhbHNfID0gdm9pZCAwO1xuICAgIHRoaXMucmVxdWlyZXNSZWFjdGlvbl8gPSB2b2lkIDA7XG4gICAgdGhpcy5rZWVwQWxpdmVfID0gdm9pZCAwO1xuICAgIHRoaXMub25CT0wgPSB2b2lkIDA7XG4gICAgdGhpcy5vbkJVT0wgPSB2b2lkIDA7XG5cbiAgICBpZiAoIW9wdGlvbnMuZ2V0KSB7XG4gICAgICBkaWUoMzEpO1xuICAgIH1cblxuICAgIHRoaXMuZGVyaXZhdGlvbiA9IG9wdGlvbnMuZ2V0O1xuICAgIHRoaXMubmFtZV8gPSBvcHRpb25zLm5hbWUgfHwgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiQ29tcHV0ZWRWYWx1ZUBcIiArIGdldE5leHRJZCgpIDogXCJDb21wdXRlZFZhbHVlXCIpO1xuXG4gICAgaWYgKG9wdGlvbnMuc2V0KSB7XG4gICAgICB0aGlzLnNldHRlcl8gPSBjcmVhdGVBY3Rpb24ocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gdGhpcy5uYW1lXyArIFwiLXNldHRlclwiIDogXCJDb21wdXRlZFZhbHVlLXNldHRlclwiLCBvcHRpb25zLnNldCk7XG4gICAgfVxuXG4gICAgdGhpcy5lcXVhbHNfID0gb3B0aW9ucy5lcXVhbHMgfHwgKG9wdGlvbnMuY29tcGFyZVN0cnVjdHVyYWwgfHwgb3B0aW9ucy5zdHJ1Y3QgPyBjb21wYXJlci5zdHJ1Y3R1cmFsIDogY29tcGFyZXJbXCJkZWZhdWx0XCJdKTtcbiAgICB0aGlzLnNjb3BlXyA9IG9wdGlvbnMuY29udGV4dDtcbiAgICB0aGlzLnJlcXVpcmVzUmVhY3Rpb25fID0gb3B0aW9ucy5yZXF1aXJlc1JlYWN0aW9uO1xuICAgIHRoaXMua2VlcEFsaXZlXyA9ICEhb3B0aW9ucy5rZWVwQWxpdmU7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQ29tcHV0ZWRWYWx1ZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLm9uQmVjb21lU3RhbGVfID0gZnVuY3Rpb24gb25CZWNvbWVTdGFsZV8oKSB7XG4gICAgcHJvcGFnYXRlTWF5YmVDaGFuZ2VkKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5vbkJPID0gZnVuY3Rpb24gb25CTygpIHtcbiAgICBpZiAodGhpcy5vbkJPTCkge1xuICAgICAgdGhpcy5vbkJPTC5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gbGlzdGVuZXIoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25CVU8gPSBmdW5jdGlvbiBvbkJVTygpIHtcbiAgICBpZiAodGhpcy5vbkJVT0wpIHtcbiAgICAgIHRoaXMub25CVU9MLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhpcyBjb21wdXRlZCB2YWx1ZS5cclxuICAgKiBXaWxsIGV2YWx1YXRlIGl0cyBjb21wdXRhdGlvbiBmaXJzdCBpZiBuZWVkZWQuXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLmlzQ29tcHV0aW5nXykge1xuICAgICAgZGllKDMyLCB0aGlzLm5hbWVfLCB0aGlzLmRlcml2YXRpb24pO1xuICAgIH1cblxuICAgIGlmIChnbG9iYWxTdGF0ZS5pbkJhdGNoID09PSAwICYmIC8vICFnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRwaW9uICYmXG4gICAgdGhpcy5vYnNlcnZlcnNfLnNpemUgPT09IDAgJiYgIXRoaXMua2VlcEFsaXZlXykge1xuICAgICAgaWYgKHNob3VsZENvbXB1dGUodGhpcykpIHtcbiAgICAgICAgdGhpcy53YXJuQWJvdXRVbnRyYWNrZWRSZWFkXygpO1xuICAgICAgICBzdGFydEJhdGNoKCk7IC8vIFNlZSBwZXJmIHRlc3QgJ2NvbXB1dGVkIG1lbW9pemF0aW9uJ1xuXG4gICAgICAgIHRoaXMudmFsdWVfID0gdGhpcy5jb21wdXRlVmFsdWVfKGZhbHNlKTtcbiAgICAgICAgZW5kQmF0Y2goKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVwb3J0T2JzZXJ2ZWQodGhpcyk7XG5cbiAgICAgIGlmIChzaG91bGRDb21wdXRlKHRoaXMpKSB7XG4gICAgICAgIHZhciBwcmV2VHJhY2tpbmdDb250ZXh0ID0gZ2xvYmFsU3RhdGUudHJhY2tpbmdDb250ZXh0O1xuXG4gICAgICAgIGlmICh0aGlzLmtlZXBBbGl2ZV8gJiYgIXByZXZUcmFja2luZ0NvbnRleHQpIHtcbiAgICAgICAgICBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQgPSB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudHJhY2tBbmRDb21wdXRlKCkpIHtcbiAgICAgICAgICBwcm9wYWdhdGVDaGFuZ2VDb25maXJtZWQodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQgPSBwcmV2VHJhY2tpbmdDb250ZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB0aGlzLnZhbHVlXztcblxuICAgIGlmIChpc0NhdWdodEV4Y2VwdGlvbihyZXN1bHQpKSB7XG4gICAgICB0aHJvdyByZXN1bHQuY2F1c2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuc2V0dGVyXykge1xuICAgICAgaWYgKHRoaXMuaXNSdW5uaW5nU2V0dGVyXykge1xuICAgICAgICBkaWUoMzMsIHRoaXMubmFtZV8pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlzUnVubmluZ1NldHRlcl8gPSB0cnVlO1xuXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnNldHRlcl8uY2FsbCh0aGlzLnNjb3BlXywgdmFsdWUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5pc1J1bm5pbmdTZXR0ZXJfID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpZSgzNCwgdGhpcy5uYW1lXyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by50cmFja0FuZENvbXB1dGUgPSBmdW5jdGlvbiB0cmFja0FuZENvbXB1dGUoKSB7XG4gICAgLy8gTi5COiB1bm1pbmlmaWVkIGFzIGl0IGlzIHVzZWQgYnkgTVNUXG4gICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZV87XG4gICAgdmFyIHdhc1N1c3BlbmRlZCA9XG4gICAgLyogc2VlICMxMjA4ICovXG4gICAgdGhpcy5kZXBlbmRlbmNpZXNTdGF0ZV8gPT09IElEZXJpdmF0aW9uU3RhdGVfLk5PVF9UUkFDS0lOR187XG4gICAgdmFyIG5ld1ZhbHVlID0gdGhpcy5jb21wdXRlVmFsdWVfKHRydWUpO1xuICAgIHZhciBjaGFuZ2VkID0gd2FzU3VzcGVuZGVkIHx8IGlzQ2F1Z2h0RXhjZXB0aW9uKG9sZFZhbHVlKSB8fCBpc0NhdWdodEV4Y2VwdGlvbihuZXdWYWx1ZSkgfHwgIXRoaXMuZXF1YWxzXyhvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuXG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMudmFsdWVfID0gbmV3VmFsdWU7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNTcHlFbmFibGVkKCkpIHtcbiAgICAgICAgc3B5UmVwb3J0KHtcbiAgICAgICAgICBvYnNlcnZhYmxlS2luZDogXCJjb21wdXRlZFwiLFxuICAgICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgICBvYmplY3Q6IHRoaXMuc2NvcGVfLFxuICAgICAgICAgIHR5cGU6IFwidXBkYXRlXCIsXG4gICAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlLFxuICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfTtcblxuICBfcHJvdG8uY29tcHV0ZVZhbHVlXyA9IGZ1bmN0aW9uIGNvbXB1dGVWYWx1ZV8odHJhY2spIHtcbiAgICB0aGlzLmlzQ29tcHV0aW5nXyA9IHRydWU7IC8vIGRvbid0IGFsbG93IHN0YXRlIGNoYW5nZXMgZHVyaW5nIGNvbXB1dGF0aW9uXG5cbiAgICB2YXIgcHJldiA9IGFsbG93U3RhdGVDaGFuZ2VzU3RhcnQoZmFsc2UpO1xuICAgIHZhciByZXM7XG5cbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHJlcyA9IHRyYWNrRGVyaXZlZEZ1bmN0aW9uKHRoaXMsIHRoaXMuZGVyaXZhdGlvbiwgdGhpcy5zY29wZV8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZ2xvYmFsU3RhdGUuZGlzYWJsZUVycm9yQm91bmRhcmllcyA9PT0gdHJ1ZSkge1xuICAgICAgICByZXMgPSB0aGlzLmRlcml2YXRpb24uY2FsbCh0aGlzLnNjb3BlXyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlcyA9IHRoaXMuZGVyaXZhdGlvbi5jYWxsKHRoaXMuc2NvcGVfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlcyA9IG5ldyBDYXVnaHRFeGNlcHRpb24oZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBhbGxvd1N0YXRlQ2hhbmdlc0VuZChwcmV2KTtcbiAgICB0aGlzLmlzQ29tcHV0aW5nXyA9IGZhbHNlO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgX3Byb3RvLnN1c3BlbmRfID0gZnVuY3Rpb24gc3VzcGVuZF8oKSB7XG4gICAgaWYgKCF0aGlzLmtlZXBBbGl2ZV8pIHtcbiAgICAgIGNsZWFyT2JzZXJ2aW5nKHRoaXMpO1xuICAgICAgdGhpcy52YWx1ZV8gPSB1bmRlZmluZWQ7IC8vIGRvbid0IGhvbGQgb24gdG8gY29tcHV0ZWQgdmFsdWUhXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdGhpcy5pc1RyYWNpbmdfICE9PSBUcmFjZU1vZGUuTk9ORSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlttb2J4LnRyYWNlXSBDb21wdXRlZCB2YWx1ZSAnXCIgKyB0aGlzLm5hbWVfICsgXCInIHdhcyBzdXNwZW5kZWQgYW5kIGl0IHdpbGwgcmVjb21wdXRlIG9uIHRoZSBuZXh0IGFjY2Vzcy5cIik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vYnNlcnZlXyA9IGZ1bmN0aW9uIG9ic2VydmVfKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG4gICAgdmFyIHByZXZWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gYXV0b3J1bihmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBUT0RPOiB3aHkgaXMgdGhpcyBpbiBhIGRpZmZlcmVudCBwbGFjZSB0aGFuIHRoZSBzcHlSZXBvcnQoKSBmdW5jdGlvbj8gaW4gYWxsIG90aGVyIG9ic2VydmFibGVzIGl0J3MgY2FsbGVkIGluIHRoZSBzYW1lIHBsYWNlXG4gICAgICB2YXIgbmV3VmFsdWUgPSBfdGhpcy5nZXQoKTtcblxuICAgICAgaWYgKCFmaXJzdFRpbWUgfHwgZmlyZUltbWVkaWF0ZWx5KSB7XG4gICAgICAgIHZhciBwcmV2VSA9IHVudHJhY2tlZFN0YXJ0KCk7XG4gICAgICAgIGxpc3RlbmVyKHtcbiAgICAgICAgICBvYnNlcnZhYmxlS2luZDogXCJjb21wdXRlZFwiLFxuICAgICAgICAgIGRlYnVnT2JqZWN0TmFtZTogX3RoaXMubmFtZV8sXG4gICAgICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgICAgIG9iamVjdDogX3RoaXMsXG4gICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgIG9sZFZhbHVlOiBwcmV2VmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIHVudHJhY2tlZEVuZChwcmV2VSk7XG4gICAgICB9XG5cbiAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgICAgcHJldlZhbHVlID0gbmV3VmFsdWU7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLndhcm5BYm91dFVudHJhY2tlZFJlYWRfID0gZnVuY3Rpb24gd2FybkFib3V0VW50cmFja2VkUmVhZF8oKSB7XG4gICAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzVHJhY2luZ18gIT09IFRyYWNlTW9kZS5OT05FKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlttb2J4LnRyYWNlXSBDb21wdXRlZCB2YWx1ZSAnXCIgKyB0aGlzLm5hbWVfICsgXCInIGlzIGJlaW5nIHJlYWQgb3V0c2lkZSBhIHJlYWN0aXZlIGNvbnRleHQuIERvaW5nIGEgZnVsbCByZWNvbXB1dGUuXCIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5yZXF1aXJlc1JlYWN0aW9uXyA9PT0gXCJib29sZWFuXCIgPyB0aGlzLnJlcXVpcmVzUmVhY3Rpb25fIDogZ2xvYmFsU3RhdGUuY29tcHV0ZWRSZXF1aXJlc1JlYWN0aW9uKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbbW9ieF0gQ29tcHV0ZWQgdmFsdWUgJ1wiICsgdGhpcy5uYW1lXyArIFwiJyBpcyBiZWluZyByZWFkIG91dHNpZGUgYSByZWFjdGl2ZSBjb250ZXh0LiBEb2luZyBhIGZ1bGwgcmVjb21wdXRlLlwiKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZV8gKyBcIltcIiArIHRoaXMuZGVyaXZhdGlvbi50b1N0cmluZygpICsgXCJdXCI7XG4gIH07XG5cbiAgX3Byb3RvLnZhbHVlT2YgPSBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgIHJldHVybiB0b1ByaW1pdGl2ZSh0aGlzLmdldCgpKTtcbiAgfTtcblxuICBfcHJvdG9bX1N5bWJvbCR0b1ByaW1pdGl2ZSQxXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCk7XG4gIH07XG5cbiAgcmV0dXJuIENvbXB1dGVkVmFsdWU7XG59KCk7XG52YXIgaXNDb21wdXRlZFZhbHVlID0gLyojX19QVVJFX18qL2NyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUoXCJDb21wdXRlZFZhbHVlXCIsIENvbXB1dGVkVmFsdWUpO1xuXG52YXIgSURlcml2YXRpb25TdGF0ZV87XG5cbihmdW5jdGlvbiAoSURlcml2YXRpb25TdGF0ZV8pIHtcbiAgLy8gYmVmb3JlIGJlaW5nIHJ1biBvciAob3V0c2lkZSBiYXRjaCBhbmQgbm90IGJlaW5nIG9ic2VydmVkKVxuICAvLyBhdCB0aGlzIHBvaW50IGRlcml2YXRpb24gaXMgbm90IGhvbGRpbmcgYW55IGRhdGEgYWJvdXQgZGVwZW5kZW5jeSB0cmVlXG4gIElEZXJpdmF0aW9uU3RhdGVfW0lEZXJpdmF0aW9uU3RhdGVfW1wiTk9UX1RSQUNLSU5HX1wiXSA9IC0xXSA9IFwiTk9UX1RSQUNLSU5HX1wiOyAvLyBubyBzaGFsbG93IGRlcGVuZGVuY3kgY2hhbmdlZCBzaW5jZSBsYXN0IGNvbXB1dGF0aW9uXG4gIC8vIHdvbid0IHJlY2FsY3VsYXRlIGRlcml2YXRpb25cbiAgLy8gdGhpcyBpcyB3aGF0IG1ha2VzIG1vYnggZmFzdFxuXG4gIElEZXJpdmF0aW9uU3RhdGVfW0lEZXJpdmF0aW9uU3RhdGVfW1wiVVBfVE9fREFURV9cIl0gPSAwXSA9IFwiVVBfVE9fREFURV9cIjsgLy8gc29tZSBkZWVwIGRlcGVuZGVuY3kgY2hhbmdlZCwgYnV0IGRvbid0IGtub3cgaWYgc2hhbGxvdyBkZXBlbmRlbmN5IGNoYW5nZWRcbiAgLy8gd2lsbCByZXF1aXJlIHRvIGNoZWNrIGZpcnN0IGlmIFVQX1RPX0RBVEUgb3IgUE9TU0lCTFlfU1RBTEVcbiAgLy8gY3VycmVudGx5IG9ubHkgQ29tcHV0ZWRWYWx1ZSB3aWxsIHByb3BhZ2F0ZSBQT1NTSUJMWV9TVEFMRVxuICAvL1xuICAvLyBoYXZpbmcgdGhpcyBzdGF0ZSBpcyBzZWNvbmQgYmlnIG9wdGltaXphdGlvbjpcbiAgLy8gZG9uJ3QgaGF2ZSB0byByZWNvbXB1dGUgb24gZXZlcnkgZGVwZW5kZW5jeSBjaGFuZ2UsIGJ1dCBvbmx5IHdoZW4gaXQncyBuZWVkZWRcblxuICBJRGVyaXZhdGlvblN0YXRlX1tJRGVyaXZhdGlvblN0YXRlX1tcIlBPU1NJQkxZX1NUQUxFX1wiXSA9IDFdID0gXCJQT1NTSUJMWV9TVEFMRV9cIjsgLy8gQSBzaGFsbG93IGRlcGVuZGVuY3kgaGFzIGNoYW5nZWQgc2luY2UgbGFzdCBjb21wdXRhdGlvbiBhbmQgdGhlIGRlcml2YXRpb25cbiAgLy8gd2lsbCBuZWVkIHRvIHJlY29tcHV0ZSB3aGVuIGl0J3MgbmVlZGVkIG5leHQuXG5cbiAgSURlcml2YXRpb25TdGF0ZV9bSURlcml2YXRpb25TdGF0ZV9bXCJTVEFMRV9cIl0gPSAyXSA9IFwiU1RBTEVfXCI7XG59KShJRGVyaXZhdGlvblN0YXRlXyB8fCAoSURlcml2YXRpb25TdGF0ZV8gPSB7fSkpO1xuXG52YXIgVHJhY2VNb2RlO1xuXG4oZnVuY3Rpb24gKFRyYWNlTW9kZSkge1xuICBUcmFjZU1vZGVbVHJhY2VNb2RlW1wiTk9ORVwiXSA9IDBdID0gXCJOT05FXCI7XG4gIFRyYWNlTW9kZVtUcmFjZU1vZGVbXCJMT0dcIl0gPSAxXSA9IFwiTE9HXCI7XG4gIFRyYWNlTW9kZVtUcmFjZU1vZGVbXCJCUkVBS1wiXSA9IDJdID0gXCJCUkVBS1wiO1xufSkoVHJhY2VNb2RlIHx8IChUcmFjZU1vZGUgPSB7fSkpO1xuXG52YXIgQ2F1Z2h0RXhjZXB0aW9uID0gZnVuY3Rpb24gQ2F1Z2h0RXhjZXB0aW9uKGNhdXNlKSB7XG4gIHRoaXMuY2F1c2UgPSB2b2lkIDA7XG4gIHRoaXMuY2F1c2UgPSBjYXVzZTsgLy8gRW1wdHlcbn07XG5mdW5jdGlvbiBpc0NhdWdodEV4Y2VwdGlvbihlKSB7XG4gIHJldHVybiBlIGluc3RhbmNlb2YgQ2F1Z2h0RXhjZXB0aW9uO1xufVxuLyoqXHJcbiAqIEZpbmRzIG91dCB3aGV0aGVyIGFueSBkZXBlbmRlbmN5IG9mIHRoZSBkZXJpdmF0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxyXG4gKiBJZiBkZXBlbmRlbmNpZXNTdGF0ZSBpcyAxIHRoZW4gaXQgd2lsbCByZWNhbGN1bGF0ZSBkZXBlbmRlbmNpZXMsXHJcbiAqIGlmIGFueSBkZXBlbmRlbmN5IGNoYW5nZWQgaXQgd2lsbCBwcm9wYWdhdGUgaXQgYnkgY2hhbmdpbmcgZGVwZW5kZW5jaWVzU3RhdGUgdG8gMi5cclxuICpcclxuICogQnkgaXRlcmF0aW5nIG92ZXIgdGhlIGRlcGVuZGVuY2llcyBpbiB0aGUgc2FtZSBvcmRlciB0aGF0IHRoZXkgd2VyZSByZXBvcnRlZCBhbmRcclxuICogc3RvcHBpbmcgb24gdGhlIGZpcnN0IGNoYW5nZSwgYWxsIHRoZSByZWNhbGN1bGF0aW9ucyBhcmUgb25seSBjYWxsZWQgZm9yIENvbXB1dGVkVmFsdWVzXHJcbiAqIHRoYXQgd2lsbCBiZSB0cmFja2VkIGJ5IGRlcml2YXRpb24uIFRoYXQgaXMgYmVjYXVzZSB3ZSBhc3N1bWUgdGhhdCBpZiB0aGUgZmlyc3QgeFxyXG4gKiBkZXBlbmRlbmNpZXMgb2YgdGhlIGRlcml2YXRpb24gZG9lc24ndCBjaGFuZ2UgdGhlbiB0aGUgZGVyaXZhdGlvbiBzaG91bGQgcnVuIHRoZSBzYW1lIHdheVxyXG4gKiB1cCB1bnRpbCBhY2Nlc3NpbmcgeC10aCBkZXBlbmRlbmN5LlxyXG4gKi9cblxuZnVuY3Rpb24gc2hvdWxkQ29tcHV0ZShkZXJpdmF0aW9uKSB7XG4gIHN3aXRjaCAoZGVyaXZhdGlvbi5kZXBlbmRlbmNpZXNTdGF0ZV8pIHtcbiAgICBjYXNlIElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgY2FzZSBJRGVyaXZhdGlvblN0YXRlXy5OT1RfVFJBQ0tJTkdfOlxuICAgIGNhc2UgSURlcml2YXRpb25TdGF0ZV8uU1RBTEVfOlxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIElEZXJpdmF0aW9uU3RhdGVfLlBPU1NJQkxZX1NUQUxFXzpcbiAgICAgIHtcbiAgICAgICAgLy8gc3RhdGUgcHJvcGFnYXRpb24gY2FuIG9jY3VyIG91dHNpZGUgb2YgYWN0aW9uL3JlYWN0aXZlIGNvbnRleHQgIzIxOTVcbiAgICAgICAgdmFyIHByZXZBbGxvd1N0YXRlUmVhZHMgPSBhbGxvd1N0YXRlUmVhZHNTdGFydCh0cnVlKTtcbiAgICAgICAgdmFyIHByZXZVbnRyYWNrZWQgPSB1bnRyYWNrZWRTdGFydCgpOyAvLyBubyBuZWVkIGZvciB0aG9zZSBjb21wdXRlZHMgdG8gYmUgcmVwb3J0ZWQsIHRoZXkgd2lsbCBiZSBwaWNrZWQgdXAgaW4gdHJhY2tEZXJpdmVkRnVuY3Rpb24uXG5cbiAgICAgICAgdmFyIG9icyA9IGRlcml2YXRpb24ub2JzZXJ2aW5nXyxcbiAgICAgICAgICAgIGwgPSBvYnMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG9iaiA9IG9ic1tpXTtcblxuICAgICAgICAgIGlmIChpc0NvbXB1dGVkVmFsdWUob2JqKSkge1xuICAgICAgICAgICAgaWYgKGdsb2JhbFN0YXRlLmRpc2FibGVFcnJvckJvdW5kYXJpZXMpIHtcbiAgICAgICAgICAgICAgb2JqLmdldCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvYmouZ2V0KCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBhcmUgbm90IGludGVyZXN0ZWQgaW4gdGhlIHZhbHVlICpvciogZXhjZXB0aW9uIGF0IHRoaXMgbW9tZW50LCBidXQgaWYgdGhlcmUgaXMgb25lLCBub3RpZnkgYWxsXG4gICAgICAgICAgICAgICAgdW50cmFja2VkRW5kKHByZXZVbnRyYWNrZWQpO1xuICAgICAgICAgICAgICAgIGFsbG93U3RhdGVSZWFkc0VuZChwcmV2QWxsb3dTdGF0ZVJlYWRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBpZiBDb21wdXRlZFZhbHVlIGBvYmpgIGFjdHVhbGx5IGNoYW5nZWQgaXQgd2lsbCBiZSBjb21wdXRlZCBhbmQgcHJvcGFnYXRlZCB0byBpdHMgb2JzZXJ2ZXJzLlxuICAgICAgICAgICAgLy8gYW5kIGBkZXJpdmF0aW9uYCBpcyBhbiBvYnNlcnZlciBvZiBgb2JqYFxuICAgICAgICAgICAgLy8gaW52YXJpYW50U2hvdWxkQ29tcHV0ZShkZXJpdmF0aW9uKVxuXG5cbiAgICAgICAgICAgIGlmIChkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uU1RBTEVfKSB7XG4gICAgICAgICAgICAgIHVudHJhY2tlZEVuZChwcmV2VW50cmFja2VkKTtcbiAgICAgICAgICAgICAgYWxsb3dTdGF0ZVJlYWRzRW5kKHByZXZBbGxvd1N0YXRlUmVhZHMpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjaGFuZ2VEZXBlbmRlbmNpZXNTdGF0ZVRvMChkZXJpdmF0aW9uKTtcbiAgICAgICAgdW50cmFja2VkRW5kKHByZXZVbnRyYWNrZWQpO1xuICAgICAgICBhbGxvd1N0YXRlUmVhZHNFbmQocHJldkFsbG93U3RhdGVSZWFkcyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaXNDb21wdXRpbmdEZXJpdmF0aW9uKCkge1xuICByZXR1cm4gZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uICE9PSBudWxsOyAvLyBmaWx0ZXIgb3V0IGFjdGlvbnMgaW5zaWRlIGNvbXB1dGF0aW9uc1xufVxuZnVuY3Rpb24gY2hlY2tJZlN0YXRlTW9kaWZpY2F0aW9uc0FyZUFsbG93ZWQoYXRvbSkge1xuICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGhhc09ic2VydmVycyA9IGF0b20ub2JzZXJ2ZXJzXy5zaXplID4gMDsgLy8gU2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBjaGFuZ2Ugb2JzZXJ2ZWQgc3RhdGUgb3V0c2lkZSBzdHJpY3QgbW9kZSwgZXhjZXB0IGR1cmluZyBpbml0aWFsaXphdGlvbiwgc2VlICM1NjNcblxuICBpZiAoIWdsb2JhbFN0YXRlLmFsbG93U3RhdGVDaGFuZ2VzICYmIChoYXNPYnNlcnZlcnMgfHwgZ2xvYmFsU3RhdGUuZW5mb3JjZUFjdGlvbnMgPT09IFwiYWx3YXlzXCIpKSB7XG4gICAgY29uc29sZS53YXJuKFwiW01vYlhdIFwiICsgKGdsb2JhbFN0YXRlLmVuZm9yY2VBY3Rpb25zID8gXCJTaW5jZSBzdHJpY3QtbW9kZSBpcyBlbmFibGVkLCBjaGFuZ2luZyAob2JzZXJ2ZWQpIG9ic2VydmFibGUgdmFsdWVzIHdpdGhvdXQgdXNpbmcgYW4gYWN0aW9uIGlzIG5vdCBhbGxvd2VkLiBUcmllZCB0byBtb2RpZnk6IFwiIDogXCJTaWRlIGVmZmVjdHMgbGlrZSBjaGFuZ2luZyBzdGF0ZSBhcmUgbm90IGFsbG93ZWQgYXQgdGhpcyBwb2ludC4gQXJlIHlvdSB0cnlpbmcgdG8gbW9kaWZ5IHN0YXRlIGZyb20sIGZvciBleGFtcGxlLCBhIGNvbXB1dGVkIHZhbHVlIG9yIHRoZSByZW5kZXIgZnVuY3Rpb24gb2YgYSBSZWFjdCBjb21wb25lbnQ/IFlvdSBjYW4gd3JhcCBzaWRlIGVmZmVjdHMgaW4gJ3J1bkluQWN0aW9uJyAob3IgZGVjb3JhdGUgZnVuY3Rpb25zIHdpdGggJ2FjdGlvbicpIGlmIG5lZWRlZC4gVHJpZWQgdG8gbW9kaWZ5OiBcIikgKyBhdG9tLm5hbWVfKTtcbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tJZlN0YXRlUmVhZHNBcmVBbGxvd2VkKG9ic2VydmFibGUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZVJlYWRzICYmIGdsb2JhbFN0YXRlLm9ic2VydmFibGVSZXF1aXJlc1JlYWN0aW9uKSB7XG4gICAgY29uc29sZS53YXJuKFwiW21vYnhdIE9ic2VydmFibGUgJ1wiICsgb2JzZXJ2YWJsZS5uYW1lXyArIFwiJyBiZWluZyByZWFkIG91dHNpZGUgYSByZWFjdGl2ZSBjb250ZXh0LlwiKTtcbiAgfVxufVxuLyoqXHJcbiAqIEV4ZWN1dGVzIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBgZmAgYW5kIHRyYWNrcyB3aGljaCBvYnNlcnZhYmxlcyBhcmUgYmVpbmcgYWNjZXNzZWQuXHJcbiAqIFRoZSB0cmFja2luZyBpbmZvcm1hdGlvbiBpcyBzdG9yZWQgb24gdGhlIGBkZXJpdmF0aW9uYCBvYmplY3QgYW5kIHRoZSBkZXJpdmF0aW9uIGlzIHJlZ2lzdGVyZWRcclxuICogYXMgb2JzZXJ2ZXIgb2YgYW55IG9mIHRoZSBhY2Nlc3NlZCBvYnNlcnZhYmxlcy5cclxuICovXG5cbmZ1bmN0aW9uIHRyYWNrRGVyaXZlZEZ1bmN0aW9uKGRlcml2YXRpb24sIGYsIGNvbnRleHQpIHtcbiAgdmFyIHByZXZBbGxvd1N0YXRlUmVhZHMgPSBhbGxvd1N0YXRlUmVhZHNTdGFydCh0cnVlKTsgLy8gcHJlIGFsbG9jYXRlIGFycmF5IGFsbG9jYXRpb24gKyByb29tIGZvciB2YXJpYXRpb24gaW4gZGVwc1xuICAvLyBhcnJheSB3aWxsIGJlIHRyaW1tZWQgYnkgYmluZERlcGVuZGVuY2llc1xuXG4gIGNoYW5nZURlcGVuZGVuY2llc1N0YXRlVG8wKGRlcml2YXRpb24pO1xuICBkZXJpdmF0aW9uLm5ld09ic2VydmluZ18gPSBuZXcgQXJyYXkoZGVyaXZhdGlvbi5vYnNlcnZpbmdfLmxlbmd0aCArIDEwMCk7XG4gIGRlcml2YXRpb24udW5ib3VuZERlcHNDb3VudF8gPSAwO1xuICBkZXJpdmF0aW9uLnJ1bklkXyA9ICsrZ2xvYmFsU3RhdGUucnVuSWQ7XG4gIHZhciBwcmV2VHJhY2tpbmcgPSBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb247XG4gIGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbiA9IGRlcml2YXRpb247XG4gIGdsb2JhbFN0YXRlLmluQmF0Y2grKztcbiAgdmFyIHJlc3VsdDtcblxuICBpZiAoZ2xvYmFsU3RhdGUuZGlzYWJsZUVycm9yQm91bmRhcmllcyA9PT0gdHJ1ZSkge1xuICAgIHJlc3VsdCA9IGYuY2FsbChjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gZi5jYWxsKGNvbnRleHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlc3VsdCA9IG5ldyBDYXVnaHRFeGNlcHRpb24oZSk7XG4gICAgfVxuICB9XG5cbiAgZ2xvYmFsU3RhdGUuaW5CYXRjaC0tO1xuICBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24gPSBwcmV2VHJhY2tpbmc7XG4gIGJpbmREZXBlbmRlbmNpZXMoZGVyaXZhdGlvbik7XG4gIHdhcm5BYm91dERlcml2YXRpb25XaXRob3V0RGVwZW5kZW5jaWVzKGRlcml2YXRpb24pO1xuICBhbGxvd1N0YXRlUmVhZHNFbmQocHJldkFsbG93U3RhdGVSZWFkcyk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5BYm91dERlcml2YXRpb25XaXRob3V0RGVwZW5kZW5jaWVzKGRlcml2YXRpb24pIHtcbiAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChkZXJpdmF0aW9uLm9ic2VydmluZ18ubGVuZ3RoICE9PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBkZXJpdmF0aW9uLnJlcXVpcmVzT2JzZXJ2YWJsZV8gPT09IFwiYm9vbGVhblwiID8gZGVyaXZhdGlvbi5yZXF1aXJlc09ic2VydmFibGVfIDogZ2xvYmFsU3RhdGUucmVhY3Rpb25SZXF1aXJlc09ic2VydmFibGUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJbbW9ieF0gRGVyaXZhdGlvbiAnXCIgKyBkZXJpdmF0aW9uLm5hbWVfICsgXCInIGlzIGNyZWF0ZWQvdXBkYXRlZCB3aXRob3V0IHJlYWRpbmcgYW55IG9ic2VydmFibGUgdmFsdWUuXCIpO1xuICB9XG59XG4vKipcclxuICogZGlmZnMgbmV3T2JzZXJ2aW5nIHdpdGggb2JzZXJ2aW5nLlxyXG4gKiB1cGRhdGUgb2JzZXJ2aW5nIHRvIGJlIG5ld09ic2VydmluZyB3aXRoIHVuaXF1ZSBvYnNlcnZhYmxlc1xyXG4gKiBub3RpZnkgb2JzZXJ2ZXJzIHRoYXQgYmVjb21lIG9ic2VydmVkL3Vub2JzZXJ2ZWRcclxuICovXG5cblxuZnVuY3Rpb24gYmluZERlcGVuZGVuY2llcyhkZXJpdmF0aW9uKSB7XG4gIC8vIGludmFyaWFudChkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlICE9PSBJRGVyaXZhdGlvblN0YXRlLk5PVF9UUkFDS0lORywgXCJJTlRFUk5BTCBFUlJPUiBiaW5kRGVwZW5kZW5jaWVzIGV4cGVjdHMgZGVyaXZhdGlvbi5kZXBlbmRlbmNpZXNTdGF0ZSAhPT0gLTFcIik7XG4gIHZhciBwcmV2T2JzZXJ2aW5nID0gZGVyaXZhdGlvbi5vYnNlcnZpbmdfO1xuICB2YXIgb2JzZXJ2aW5nID0gZGVyaXZhdGlvbi5vYnNlcnZpbmdfID0gZGVyaXZhdGlvbi5uZXdPYnNlcnZpbmdfO1xuICB2YXIgbG93ZXN0TmV3T2JzZXJ2aW5nRGVyaXZhdGlvblN0YXRlID0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV87IC8vIEdvIHRocm91Z2ggYWxsIG5ldyBvYnNlcnZhYmxlcyBhbmQgY2hlY2sgZGlmZlZhbHVlOiAodGhpcyBsaXN0IGNhbiBjb250YWluIGR1cGxpY2F0ZXMpOlxuICAvLyAgIDA6IGZpcnN0IG9jY3VycmVuY2UsIGNoYW5nZSB0byAxIGFuZCBrZWVwIGl0XG4gIC8vICAgMTogZXh0cmEgb2NjdXJyZW5jZSwgZHJvcCBpdFxuXG4gIHZhciBpMCA9IDAsXG4gICAgICBsID0gZGVyaXZhdGlvbi51bmJvdW5kRGVwc0NvdW50XztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBkZXAgPSBvYnNlcnZpbmdbaV07XG5cbiAgICBpZiAoZGVwLmRpZmZWYWx1ZV8gPT09IDApIHtcbiAgICAgIGRlcC5kaWZmVmFsdWVfID0gMTtcblxuICAgICAgaWYgKGkwICE9PSBpKSB7XG4gICAgICAgIG9ic2VydmluZ1tpMF0gPSBkZXA7XG4gICAgICB9XG5cbiAgICAgIGkwKys7XG4gICAgfSAvLyBVcGNhc3QgaXMgJ3NhZmUnIGhlcmUsIGJlY2F1c2UgaWYgZGVwIGlzIElPYnNlcnZhYmxlLCBgZGVwZW5kZW5jaWVzU3RhdGVgIHdpbGwgYmUgdW5kZWZpbmVkLFxuICAgIC8vIG5vdCBoaXR0aW5nIHRoZSBjb25kaXRpb25cblxuXG4gICAgaWYgKGRlcC5kZXBlbmRlbmNpZXNTdGF0ZV8gPiBsb3dlc3ROZXdPYnNlcnZpbmdEZXJpdmF0aW9uU3RhdGUpIHtcbiAgICAgIGxvd2VzdE5ld09ic2VydmluZ0Rlcml2YXRpb25TdGF0ZSA9IGRlcC5kZXBlbmRlbmNpZXNTdGF0ZV87XG4gICAgfVxuICB9XG5cbiAgb2JzZXJ2aW5nLmxlbmd0aCA9IGkwO1xuICBkZXJpdmF0aW9uLm5ld09ic2VydmluZ18gPSBudWxsOyAvLyBuZXdPYnNlcnZpbmcgc2hvdWxkbid0IGJlIG5lZWRlZCBvdXRzaWRlIHRyYWNraW5nIChzdGF0ZW1lbnQgbW92ZWQgZG93biB0byB3b3JrIGFyb3VuZCBGRiBidWcsIHNlZSAjNjE0KVxuICAvLyBHbyB0aHJvdWdoIGFsbCBvbGQgb2JzZXJ2YWJsZXMgYW5kIGNoZWNrIGRpZmZWYWx1ZTogKGl0IGlzIHVuaXF1ZSBhZnRlciBsYXN0IGJpbmREZXBlbmRlbmNpZXMpXG4gIC8vICAgMDogaXQncyBub3QgaW4gbmV3IG9ic2VydmFibGVzLCB1bm9ic2VydmUgaXRcbiAgLy8gICAxOiBpdCBrZWVwcyBiZWluZyBvYnNlcnZlZCwgZG9uJ3Qgd2FudCB0byBub3RpZnkgaXQuIGNoYW5nZSB0byAwXG5cbiAgbCA9IHByZXZPYnNlcnZpbmcubGVuZ3RoO1xuXG4gIHdoaWxlIChsLS0pIHtcbiAgICB2YXIgX2RlcCA9IHByZXZPYnNlcnZpbmdbbF07XG5cbiAgICBpZiAoX2RlcC5kaWZmVmFsdWVfID09PSAwKSB7XG4gICAgICByZW1vdmVPYnNlcnZlcihfZGVwLCBkZXJpdmF0aW9uKTtcbiAgICB9XG5cbiAgICBfZGVwLmRpZmZWYWx1ZV8gPSAwO1xuICB9IC8vIEdvIHRocm91Z2ggYWxsIG5ldyBvYnNlcnZhYmxlcyBhbmQgY2hlY2sgZGlmZlZhbHVlOiAobm93IGl0IHNob3VsZCBiZSB1bmlxdWUpXG4gIC8vICAgMDogaXQgd2FzIHNldCB0byAwIGluIGxhc3QgbG9vcC4gZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZy5cbiAgLy8gICAxOiBpdCB3YXNuJ3Qgb2JzZXJ2ZWQsIGxldCdzIG9ic2VydmUgaXQuIHNldCBiYWNrIHRvIDBcblxuXG4gIHdoaWxlIChpMC0tKSB7XG4gICAgdmFyIF9kZXAyID0gb2JzZXJ2aW5nW2kwXTtcblxuICAgIGlmIChfZGVwMi5kaWZmVmFsdWVfID09PSAxKSB7XG4gICAgICBfZGVwMi5kaWZmVmFsdWVfID0gMDtcbiAgICAgIGFkZE9ic2VydmVyKF9kZXAyLCBkZXJpdmF0aW9uKTtcbiAgICB9XG4gIH0gLy8gU29tZSBuZXcgb2JzZXJ2ZWQgZGVyaXZhdGlvbnMgbWF5IGJlY29tZSBzdGFsZSBkdXJpbmcgdGhpcyBkZXJpdmF0aW9uIGNvbXB1dGF0aW9uXG4gIC8vIHNvIHRoZXkgaGF2ZSBoYWQgbm8gY2hhbmNlIHRvIHByb3BhZ2F0ZSBzdGFsZW5lc3MgKCM5MTYpXG5cblxuICBpZiAobG93ZXN0TmV3T2JzZXJ2aW5nRGVyaXZhdGlvblN0YXRlICE9PSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXykge1xuICAgIGRlcml2YXRpb24uZGVwZW5kZW5jaWVzU3RhdGVfID0gbG93ZXN0TmV3T2JzZXJ2aW5nRGVyaXZhdGlvblN0YXRlO1xuICAgIGRlcml2YXRpb24ub25CZWNvbWVTdGFsZV8oKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhck9ic2VydmluZyhkZXJpdmF0aW9uKSB7XG4gIC8vIGludmFyaWFudChnbG9iYWxTdGF0ZS5pbkJhdGNoID4gMCwgXCJJTlRFUk5BTCBFUlJPUiBjbGVhck9ic2VydmluZyBzaG91bGQgYmUgY2FsbGVkIG9ubHkgaW5zaWRlIGJhdGNoXCIpO1xuICB2YXIgb2JzID0gZGVyaXZhdGlvbi5vYnNlcnZpbmdfO1xuICBkZXJpdmF0aW9uLm9ic2VydmluZ18gPSBbXTtcbiAgdmFyIGkgPSBvYnMubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICByZW1vdmVPYnNlcnZlcihvYnNbaV0sIGRlcml2YXRpb24pO1xuICB9XG5cbiAgZGVyaXZhdGlvbi5kZXBlbmRlbmNpZXNTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5OT1RfVFJBQ0tJTkdfO1xufVxuZnVuY3Rpb24gdW50cmFja2VkKGFjdGlvbikge1xuICB2YXIgcHJldiA9IHVudHJhY2tlZFN0YXJ0KCk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gYWN0aW9uKCk7XG4gIH0gZmluYWxseSB7XG4gICAgdW50cmFja2VkRW5kKHByZXYpO1xuICB9XG59XG5mdW5jdGlvbiB1bnRyYWNrZWRTdGFydCgpIHtcbiAgdmFyIHByZXYgPSBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb247XG4gIGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbiA9IG51bGw7XG4gIHJldHVybiBwcmV2O1xufVxuZnVuY3Rpb24gdW50cmFja2VkRW5kKHByZXYpIHtcbiAgZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uID0gcHJldjtcbn1cbmZ1bmN0aW9uIGFsbG93U3RhdGVSZWFkc1N0YXJ0KGFsbG93U3RhdGVSZWFkcykge1xuICB2YXIgcHJldiA9IGdsb2JhbFN0YXRlLmFsbG93U3RhdGVSZWFkcztcbiAgZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZVJlYWRzID0gYWxsb3dTdGF0ZVJlYWRzO1xuICByZXR1cm4gcHJldjtcbn1cbmZ1bmN0aW9uIGFsbG93U3RhdGVSZWFkc0VuZChwcmV2KSB7XG4gIGdsb2JhbFN0YXRlLmFsbG93U3RhdGVSZWFkcyA9IHByZXY7XG59XG4vKipcclxuICogbmVlZGVkIHRvIGtlZXAgYGxvd2VzdE9ic2VydmVyU3RhdGVgIGNvcnJlY3QuIHdoZW4gY2hhbmdpbmcgZnJvbSAoMiBvciAxKSB0byAwXHJcbiAqXHJcbiAqL1xuXG5mdW5jdGlvbiBjaGFuZ2VEZXBlbmRlbmNpZXNTdGF0ZVRvMChkZXJpdmF0aW9uKSB7XG4gIGlmIChkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV8pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfO1xuICB2YXIgb2JzID0gZGVyaXZhdGlvbi5vYnNlcnZpbmdfO1xuICB2YXIgaSA9IG9icy5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIG9ic1tpXS5sb3dlc3RPYnNlcnZlclN0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfO1xuICB9XG59XG5cbi8qKlxyXG4gKiBUaGVzZSB2YWx1ZXMgd2lsbCBwZXJzaXN0IGlmIGdsb2JhbCBzdGF0ZSBpcyByZXNldFxyXG4gKi9cblxudmFyIHBlcnNpc3RlbnRLZXlzID0gW1wibW9ieEd1aWRcIiwgXCJzcHlMaXN0ZW5lcnNcIiwgXCJlbmZvcmNlQWN0aW9uc1wiLCBcImNvbXB1dGVkUmVxdWlyZXNSZWFjdGlvblwiLCBcInJlYWN0aW9uUmVxdWlyZXNPYnNlcnZhYmxlXCIsIFwib2JzZXJ2YWJsZVJlcXVpcmVzUmVhY3Rpb25cIiwgXCJhbGxvd1N0YXRlUmVhZHNcIiwgXCJkaXNhYmxlRXJyb3JCb3VuZGFyaWVzXCIsIFwicnVuSWRcIiwgXCJVTkNIQU5HRURcIiwgXCJ1c2VQcm94aWVzXCJdO1xudmFyIE1vYlhHbG9iYWxzID0gZnVuY3Rpb24gTW9iWEdsb2JhbHMoKSB7XG4gIHRoaXMudmVyc2lvbiA9IDY7XG4gIHRoaXMuVU5DSEFOR0VEID0ge307XG4gIHRoaXMudHJhY2tpbmdEZXJpdmF0aW9uID0gbnVsbDtcbiAgdGhpcy50cmFja2luZ0NvbnRleHQgPSBudWxsO1xuICB0aGlzLnJ1bklkID0gMDtcbiAgdGhpcy5tb2J4R3VpZCA9IDA7XG4gIHRoaXMuaW5CYXRjaCA9IDA7XG4gIHRoaXMucGVuZGluZ1Vub2JzZXJ2YXRpb25zID0gW107XG4gIHRoaXMucGVuZGluZ1JlYWN0aW9ucyA9IFtdO1xuICB0aGlzLmlzUnVubmluZ1JlYWN0aW9ucyA9IGZhbHNlO1xuICB0aGlzLmFsbG93U3RhdGVDaGFuZ2VzID0gZmFsc2U7XG4gIHRoaXMuYWxsb3dTdGF0ZVJlYWRzID0gdHJ1ZTtcbiAgdGhpcy5lbmZvcmNlQWN0aW9ucyA9IHRydWU7XG4gIHRoaXMuc3B5TGlzdGVuZXJzID0gW107XG4gIHRoaXMuZ2xvYmFsUmVhY3Rpb25FcnJvckhhbmRsZXJzID0gW107XG4gIHRoaXMuY29tcHV0ZWRSZXF1aXJlc1JlYWN0aW9uID0gZmFsc2U7XG4gIHRoaXMucmVhY3Rpb25SZXF1aXJlc09ic2VydmFibGUgPSBmYWxzZTtcbiAgdGhpcy5vYnNlcnZhYmxlUmVxdWlyZXNSZWFjdGlvbiA9IGZhbHNlO1xuICB0aGlzLmRpc2FibGVFcnJvckJvdW5kYXJpZXMgPSBmYWxzZTtcbiAgdGhpcy5zdXBwcmVzc1JlYWN0aW9uRXJyb3JzID0gZmFsc2U7XG4gIHRoaXMudXNlUHJveGllcyA9IHRydWU7XG4gIHRoaXMudmVyaWZ5UHJveGllcyA9IGZhbHNlO1xuICB0aGlzLnNhZmVEZXNjcmlwdG9ycyA9IHRydWU7XG59O1xudmFyIGNhbk1lcmdlR2xvYmFsU3RhdGUgPSB0cnVlO1xudmFyIGlzb2xhdGVDYWxsZWQgPSBmYWxzZTtcbnZhciBnbG9iYWxTdGF0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHZhciBnbG9iYWwgPSAvKiNfX1BVUkVfXyovZ2V0R2xvYmFsKCk7XG5cbiAgaWYgKGdsb2JhbC5fX21vYnhJbnN0YW5jZUNvdW50ID4gMCAmJiAhZ2xvYmFsLl9fbW9ieEdsb2JhbHMpIHtcbiAgICBjYW5NZXJnZUdsb2JhbFN0YXRlID0gZmFsc2U7XG4gIH1cblxuICBpZiAoZ2xvYmFsLl9fbW9ieEdsb2JhbHMgJiYgZ2xvYmFsLl9fbW9ieEdsb2JhbHMudmVyc2lvbiAhPT0gbmV3IE1vYlhHbG9iYWxzKCkudmVyc2lvbikge1xuICAgIGNhbk1lcmdlR2xvYmFsU3RhdGUgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICghY2FuTWVyZ2VHbG9iYWxTdGF0ZSkge1xuICAgIC8vIEJlY2F1c2UgdGhpcyBpcyBhIElJRkUgd2UgbmVlZCB0byBsZXQgaXNvbGF0ZUNhbGxlZCBhIGNoYW5jZSB0byBjaGFuZ2VcbiAgICAvLyBzbyB3ZSBydW4gaXQgYWZ0ZXIgdGhlIGV2ZW50IGxvb3AgY29tcGxldGVkIGF0IGxlYXN0IDEgaXRlcmF0aW9uXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWlzb2xhdGVDYWxsZWQpIHtcbiAgICAgICAgZGllKDM1KTtcbiAgICAgIH1cbiAgICB9LCAxKTtcbiAgICByZXR1cm4gbmV3IE1vYlhHbG9iYWxzKCk7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsLl9fbW9ieEdsb2JhbHMpIHtcbiAgICBnbG9iYWwuX19tb2J4SW5zdGFuY2VDb3VudCArPSAxO1xuXG4gICAgaWYgKCFnbG9iYWwuX19tb2J4R2xvYmFscy5VTkNIQU5HRUQpIHtcbiAgICAgIGdsb2JhbC5fX21vYnhHbG9iYWxzLlVOQ0hBTkdFRCA9IHt9O1xuICAgIH0gLy8gbWFrZSBtZXJnZSBiYWNrd2FyZCBjb21wYXRpYmxlXG5cblxuICAgIHJldHVybiBnbG9iYWwuX19tb2J4R2xvYmFscztcbiAgfSBlbHNlIHtcbiAgICBnbG9iYWwuX19tb2J4SW5zdGFuY2VDb3VudCA9IDE7XG4gICAgcmV0dXJuIGdsb2JhbC5fX21vYnhHbG9iYWxzID0gLyojX19QVVJFX18qL25ldyBNb2JYR2xvYmFscygpO1xuICB9XG59KCk7XG5mdW5jdGlvbiBpc29sYXRlR2xvYmFsU3RhdGUoKSB7XG4gIGlmIChnbG9iYWxTdGF0ZS5wZW5kaW5nUmVhY3Rpb25zLmxlbmd0aCB8fCBnbG9iYWxTdGF0ZS5pbkJhdGNoIHx8IGdsb2JhbFN0YXRlLmlzUnVubmluZ1JlYWN0aW9ucykge1xuICAgIGRpZSgzNik7XG4gIH1cblxuICBpc29sYXRlQ2FsbGVkID0gdHJ1ZTtcblxuICBpZiAoY2FuTWVyZ2VHbG9iYWxTdGF0ZSkge1xuICAgIHZhciBnbG9iYWwgPSBnZXRHbG9iYWwoKTtcblxuICAgIGlmICgtLWdsb2JhbC5fX21vYnhJbnN0YW5jZUNvdW50ID09PSAwKSB7XG4gICAgICBnbG9iYWwuX19tb2J4R2xvYmFscyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBnbG9iYWxTdGF0ZSA9IG5ldyBNb2JYR2xvYmFscygpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRHbG9iYWxTdGF0ZSgpIHtcbiAgcmV0dXJuIGdsb2JhbFN0YXRlO1xufVxuLyoqXHJcbiAqIEZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHk7IHRoaXMgd2lsbCBicmVhayB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgZXhpc3Rpbmcgb2JzZXJ2YWJsZXMsXHJcbiAqIGJ1dCBjYW4gYmUgdXNlZCB0byBnZXQgYmFjayBhdCBhIHN0YWJsZSBzdGF0ZSBhZnRlciB0aHJvd2luZyBlcnJvcnNcclxuICovXG5cbmZ1bmN0aW9uIHJlc2V0R2xvYmFsU3RhdGUoKSB7XG4gIHZhciBkZWZhdWx0R2xvYmFscyA9IG5ldyBNb2JYR2xvYmFscygpO1xuXG4gIGZvciAodmFyIGtleSBpbiBkZWZhdWx0R2xvYmFscykge1xuICAgIGlmIChwZXJzaXN0ZW50S2V5cy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICBnbG9iYWxTdGF0ZVtrZXldID0gZGVmYXVsdEdsb2JhbHNba2V5XTtcbiAgICB9XG4gIH1cblxuICBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlQ2hhbmdlcyA9ICFnbG9iYWxTdGF0ZS5lbmZvcmNlQWN0aW9ucztcbn1cblxuZnVuY3Rpb24gaGFzT2JzZXJ2ZXJzKG9ic2VydmFibGUpIHtcbiAgcmV0dXJuIG9ic2VydmFibGUub2JzZXJ2ZXJzXyAmJiBvYnNlcnZhYmxlLm9ic2VydmVyc18uc2l6ZSA+IDA7XG59XG5mdW5jdGlvbiBnZXRPYnNlcnZlcnMob2JzZXJ2YWJsZSkge1xuICByZXR1cm4gb2JzZXJ2YWJsZS5vYnNlcnZlcnNfO1xufSAvLyBmdW5jdGlvbiBpbnZhcmlhbnRPYnNlcnZlcnMob2JzZXJ2YWJsZTogSU9ic2VydmFibGUpIHtcbi8vICAgICBjb25zdCBsaXN0ID0gb2JzZXJ2YWJsZS5vYnNlcnZlcnNcbi8vICAgICBjb25zdCBtYXAgPSBvYnNlcnZhYmxlLm9ic2VydmVyc0luZGV4ZXNcbi8vICAgICBjb25zdCBsID0gbGlzdC5sZW5ndGhcbi8vICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuLy8gICAgICAgICBjb25zdCBpZCA9IGxpc3RbaV0uX19tYXBpZFxuLy8gICAgICAgICBpZiAoaSkge1xuLy8gICAgICAgICAgICAgaW52YXJpYW50KG1hcFtpZF0gPT09IGksIFwiSU5URVJOQUwgRVJST1IgbWFwcyBkZXJpdmF0aW9uLl9fbWFwaWQgdG8gaW5kZXggaW4gbGlzdFwiKSAvLyBmb3IgcGVyZm9ybWFuY2Vcbi8vICAgICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgICAgIGludmFyaWFudCghKGlkIGluIG1hcCksIFwiSU5URVJOQUwgRVJST1Igb2JzZXJ2ZXIgb24gaW5kZXggMCBzaG91bGRuJ3QgYmUgaGVsZCBpbiBtYXAuXCIpIC8vIGZvciBwZXJmb3JtYW5jZVxuLy8gICAgICAgICB9XG4vLyAgICAgfVxuLy8gICAgIGludmFyaWFudChcbi8vICAgICAgICAgbGlzdC5sZW5ndGggPT09IDAgfHwgT2JqZWN0LmtleXMobWFwKS5sZW5ndGggPT09IGxpc3QubGVuZ3RoIC0gMSxcbi8vICAgICAgICAgXCJJTlRFUk5BTCBFUlJPUiB0aGVyZSBpcyBubyBqdW5rIGluIG1hcFwiXG4vLyAgICAgKVxuLy8gfVxuXG5mdW5jdGlvbiBhZGRPYnNlcnZlcihvYnNlcnZhYmxlLCBub2RlKSB7XG4gIC8vIGludmFyaWFudChub2RlLmRlcGVuZGVuY2llc1N0YXRlICE9PSAtMSwgXCJJTlRFUk5BTCBFUlJPUiwgY2FuIGFkZCBvbmx5IGRlcGVuZGVuY2llc1N0YXRlICE9PSAtMVwiKTtcbiAgLy8gaW52YXJpYW50KG9ic2VydmFibGUuX29ic2VydmVycy5pbmRleE9mKG5vZGUpID09PSAtMSwgXCJJTlRFUk5BTCBFUlJPUiBhZGQgYWxyZWFkeSBhZGRlZCBub2RlXCIpO1xuICAvLyBpbnZhcmlhbnRPYnNlcnZlcnMob2JzZXJ2YWJsZSk7XG4gIG9ic2VydmFibGUub2JzZXJ2ZXJzXy5hZGQobm9kZSk7XG5cbiAgaWYgKG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPiBub2RlLmRlcGVuZGVuY2llc1N0YXRlXykge1xuICAgIG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPSBub2RlLmRlcGVuZGVuY2llc1N0YXRlXztcbiAgfSAvLyBpbnZhcmlhbnRPYnNlcnZlcnMob2JzZXJ2YWJsZSk7XG4gIC8vIGludmFyaWFudChvYnNlcnZhYmxlLl9vYnNlcnZlcnMuaW5kZXhPZihub2RlKSAhPT0gLTEsIFwiSU5URVJOQUwgRVJST1IgZGlkbid0IGFkZCBub2RlXCIpO1xuXG59XG5mdW5jdGlvbiByZW1vdmVPYnNlcnZlcihvYnNlcnZhYmxlLCBub2RlKSB7XG4gIC8vIGludmFyaWFudChnbG9iYWxTdGF0ZS5pbkJhdGNoID4gMCwgXCJJTlRFUk5BTCBFUlJPUiwgcmVtb3ZlIHNob3VsZCBiZSBjYWxsZWQgb25seSBpbnNpZGUgYmF0Y2hcIik7XG4gIC8vIGludmFyaWFudChvYnNlcnZhYmxlLl9vYnNlcnZlcnMuaW5kZXhPZihub2RlKSAhPT0gLTEsIFwiSU5URVJOQUwgRVJST1IgcmVtb3ZlIGFscmVhZHkgcmVtb3ZlZCBub2RlXCIpO1xuICAvLyBpbnZhcmlhbnRPYnNlcnZlcnMob2JzZXJ2YWJsZSk7XG4gIG9ic2VydmFibGUub2JzZXJ2ZXJzX1tcImRlbGV0ZVwiXShub2RlKTtcblxuICBpZiAob2JzZXJ2YWJsZS5vYnNlcnZlcnNfLnNpemUgPT09IDApIHtcbiAgICAvLyBkZWxldGluZyBsYXN0IG9ic2VydmVyXG4gICAgcXVldWVGb3JVbm9ic2VydmF0aW9uKG9ic2VydmFibGUpO1xuICB9IC8vIGludmFyaWFudE9ic2VydmVycyhvYnNlcnZhYmxlKTtcbiAgLy8gaW52YXJpYW50KG9ic2VydmFibGUuX29ic2VydmVycy5pbmRleE9mKG5vZGUpID09PSAtMSwgXCJJTlRFUk5BTCBFUlJPUiByZW1vdmUgYWxyZWFkeSByZW1vdmVkIG5vZGUyXCIpO1xuXG59XG5mdW5jdGlvbiBxdWV1ZUZvclVub2JzZXJ2YXRpb24ob2JzZXJ2YWJsZSkge1xuICBpZiAob2JzZXJ2YWJsZS5pc1BlbmRpbmdVbm9ic2VydmF0aW9uXyA9PT0gZmFsc2UpIHtcbiAgICAvLyBpbnZhcmlhbnQob2JzZXJ2YWJsZS5fb2JzZXJ2ZXJzLmxlbmd0aCA9PT0gMCwgXCJJTlRFUk5BTCBFUlJPUiwgc2hvdWxkIG9ubHkgcXVldWUgZm9yIHVub2JzZXJ2YXRpb24gdW5vYnNlcnZlZCBvYnNlcnZhYmxlc1wiKTtcbiAgICBvYnNlcnZhYmxlLmlzUGVuZGluZ1Vub2JzZXJ2YXRpb25fID0gdHJ1ZTtcbiAgICBnbG9iYWxTdGF0ZS5wZW5kaW5nVW5vYnNlcnZhdGlvbnMucHVzaChvYnNlcnZhYmxlKTtcbiAgfVxufVxuLyoqXHJcbiAqIEJhdGNoIHN0YXJ0cyBhIHRyYW5zYWN0aW9uLCBhdCBsZWFzdCBmb3IgcHVycG9zZXMgb2YgbWVtb2l6aW5nIENvbXB1dGVkVmFsdWVzIHdoZW4gbm90aGluZyBlbHNlIGRvZXMuXHJcbiAqIER1cmluZyBhIGJhdGNoIGBvbkJlY29tZVVub2JzZXJ2ZWRgIHdpbGwgYmUgY2FsbGVkIGF0IG1vc3Qgb25jZSBwZXIgb2JzZXJ2YWJsZS5cclxuICogQXZvaWRzIHVubmVjZXNzYXJ5IHJlY2FsY3VsYXRpb25zLlxyXG4gKi9cblxuZnVuY3Rpb24gc3RhcnRCYXRjaCgpIHtcbiAgZ2xvYmFsU3RhdGUuaW5CYXRjaCsrO1xufVxuZnVuY3Rpb24gZW5kQmF0Y2goKSB7XG4gIGlmICgtLWdsb2JhbFN0YXRlLmluQmF0Y2ggPT09IDApIHtcbiAgICBydW5SZWFjdGlvbnMoKTsgLy8gdGhlIGJhdGNoIGlzIGFjdHVhbGx5IGFib3V0IHRvIGZpbmlzaCwgYWxsIHVub2JzZXJ2aW5nIHNob3VsZCBoYXBwZW4gaGVyZS5cblxuICAgIHZhciBsaXN0ID0gZ2xvYmFsU3RhdGUucGVuZGluZ1Vub2JzZXJ2YXRpb25zO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb2JzZXJ2YWJsZSA9IGxpc3RbaV07XG4gICAgICBvYnNlcnZhYmxlLmlzUGVuZGluZ1Vub2JzZXJ2YXRpb25fID0gZmFsc2U7XG5cbiAgICAgIGlmIChvYnNlcnZhYmxlLm9ic2VydmVyc18uc2l6ZSA9PT0gMCkge1xuICAgICAgICBpZiAob2JzZXJ2YWJsZS5pc0JlaW5nT2JzZXJ2ZWRfKSB7XG4gICAgICAgICAgLy8gaWYgdGhpcyBvYnNlcnZhYmxlIGhhZCByZWFjdGl2ZSBvYnNlcnZlcnMsIHRyaWdnZXIgdGhlIGhvb2tzXG4gICAgICAgICAgb2JzZXJ2YWJsZS5pc0JlaW5nT2JzZXJ2ZWRfID0gZmFsc2U7XG4gICAgICAgICAgb2JzZXJ2YWJsZS5vbkJVTygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9ic2VydmFibGUgaW5zdGFuY2VvZiBDb21wdXRlZFZhbHVlKSB7XG4gICAgICAgICAgLy8gY29tcHV0ZWQgdmFsdWVzIGFyZSBhdXRvbWF0aWNhbGx5IHRlYXJlZCBkb3duIHdoZW4gdGhlIGxhc3Qgb2JzZXJ2ZXIgbGVhdmVzXG4gICAgICAgICAgLy8gdGhpcyBwcm9jZXNzIGhhcHBlbnMgcmVjdXJzaXZlbHksIHRoaXMgY29tcHV0ZWQgbWlnaHQgYmUgdGhlIGxhc3Qgb2JzZXJ2YWJlIG9mIGFub3RoZXIsIGV0Yy4uXG4gICAgICAgICAgb2JzZXJ2YWJsZS5zdXNwZW5kXygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ2xvYmFsU3RhdGUucGVuZGluZ1Vub2JzZXJ2YXRpb25zID0gW107XG4gIH1cbn1cbmZ1bmN0aW9uIHJlcG9ydE9ic2VydmVkKG9ic2VydmFibGUpIHtcbiAgY2hlY2tJZlN0YXRlUmVhZHNBcmVBbGxvd2VkKG9ic2VydmFibGUpO1xuICB2YXIgZGVyaXZhdGlvbiA9IGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbjtcblxuICBpZiAoZGVyaXZhdGlvbiAhPT0gbnVsbCkge1xuICAgIC8qKlxyXG4gICAgICogU2ltcGxlIG9wdGltaXphdGlvbiwgZ2l2ZSBlYWNoIGRlcml2YXRpb24gcnVuIGFuIHVuaXF1ZSBpZCAocnVuSWQpXHJcbiAgICAgKiBDaGVjayBpZiBsYXN0IHRpbWUgdGhpcyBvYnNlcnZhYmxlIHdhcyBhY2Nlc3NlZCB0aGUgc2FtZSBydW5JZCBpcyB1c2VkXHJcbiAgICAgKiBpZiB0aGlzIGlzIHRoZSBjYXNlLCB0aGUgcmVsYXRpb24gaXMgYWxyZWFkeSBrbm93blxyXG4gICAgICovXG4gICAgaWYgKGRlcml2YXRpb24ucnVuSWRfICE9PSBvYnNlcnZhYmxlLmxhc3RBY2Nlc3NlZEJ5Xykge1xuICAgICAgb2JzZXJ2YWJsZS5sYXN0QWNjZXNzZWRCeV8gPSBkZXJpdmF0aW9uLnJ1bklkXzsgLy8gVHJpZWQgc3RvcmluZyBuZXdPYnNlcnZpbmcsIG9yIG9ic2VydmluZywgb3IgYm90aCBhcyBTZXQsIGJ1dCBwZXJmb3JtYW5jZSBkaWRuJ3QgY29tZSBjbG9zZS4uLlxuXG4gICAgICBkZXJpdmF0aW9uLm5ld09ic2VydmluZ19bZGVyaXZhdGlvbi51bmJvdW5kRGVwc0NvdW50XysrXSA9IG9ic2VydmFibGU7XG5cbiAgICAgIGlmICghb2JzZXJ2YWJsZS5pc0JlaW5nT2JzZXJ2ZWRfICYmIGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dCkge1xuICAgICAgICBvYnNlcnZhYmxlLmlzQmVpbmdPYnNlcnZlZF8gPSB0cnVlO1xuICAgICAgICBvYnNlcnZhYmxlLm9uQk8oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JzZXJ2YWJsZS5pc0JlaW5nT2JzZXJ2ZWRfO1xuICB9IGVsc2UgaWYgKG9ic2VydmFibGUub2JzZXJ2ZXJzXy5zaXplID09PSAwICYmIGdsb2JhbFN0YXRlLmluQmF0Y2ggPiAwKSB7XG4gICAgcXVldWVGb3JVbm9ic2VydmF0aW9uKG9ic2VydmFibGUpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufSAvLyBmdW5jdGlvbiBpbnZhcmlhbnRMT1Mob2JzZXJ2YWJsZTogSU9ic2VydmFibGUsIG1zZzogc3RyaW5nKSB7XG4vLyAgICAgLy8gaXQncyBleHBlbnNpdmUgc28gYmV0dGVyIG5vdCBydW4gaXQgaW4gcHJvZHVjaXRvbi4gYnV0IHRlbXBvcmFyaWx5IGhlbHBmdWwgZm9yIHRlc3Rpbmdcbi8vICAgICBjb25zdCBtaW4gPSBnZXRPYnNlcnZlcnMob2JzZXJ2YWJsZSkucmVkdWNlKChhLCBiKSA9PiBNYXRoLm1pbihhLCBiLmRlcGVuZGVuY2llc1N0YXRlKSwgMilcbi8vICAgICBpZiAobWluID49IG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZSkgcmV0dXJuIC8vIDwtIHRoZSBvbmx5IGFzc3VtcHRpb24gYWJvdXQgYGxvd2VzdE9ic2VydmVyU3RhdGVgXG4vLyAgICAgdGhyb3cgbmV3IEVycm9yKFxuLy8gICAgICAgICBcImxvd2VzdE9ic2VydmVyU3RhdGUgaXMgd3JvbmcgZm9yIFwiICtcbi8vICAgICAgICAgICAgIG1zZyArXG4vLyAgICAgICAgICAgICBcIiBiZWNhdXNlIFwiICtcbi8vICAgICAgICAgICAgIG1pbiArXG4vLyAgICAgICAgICAgICBcIiA8IFwiICtcbi8vICAgICAgICAgICAgIG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZVxuLy8gICAgIClcbi8vIH1cblxuLyoqXHJcbiAqIE5PVEU6IGN1cnJlbnQgcHJvcGFnYXRpb24gbWVjaGFuaXNtIHdpbGwgaW4gY2FzZSBvZiBzZWxmIHJlcnVuaW5nIGF1dG9ydW5zIGJlaGF2ZSB1bmV4cGVjdGVkbHlcclxuICogSXQgd2lsbCBwcm9wYWdhdGUgY2hhbmdlcyB0byBvYnNlcnZlcnMgZnJvbSBwcmV2aW91cyBydW5cclxuICogSXQncyBoYXJkIG9yIG1heWJlIGltcG9zc2libGUgKHdpdGggcmVhc29uYWJsZSBwZXJmKSB0byBnZXQgaXQgcmlnaHQgd2l0aCBjdXJyZW50IGFwcHJvYWNoXHJcbiAqIEhvcGVmdWxseSBzZWxmIHJlcnVuaW5nIGF1dG9ydW5zIGFyZW4ndCBhIGZlYXR1cmUgcGVvcGxlIHNob3VsZCBkZXBlbmQgb25cclxuICogQWxzbyBtb3N0IGJhc2ljIHVzZSBjYXNlcyBzaG91bGQgYmUgb2tcclxuICovXG4vLyBDYWxsZWQgYnkgQXRvbSB3aGVuIGl0cyB2YWx1ZSBjaGFuZ2VzXG5cbmZ1bmN0aW9uIHByb3BhZ2F0ZUNoYW5nZWQob2JzZXJ2YWJsZSkge1xuICAvLyBpbnZhcmlhbnRMT1Mob2JzZXJ2YWJsZSwgXCJjaGFuZ2VkIHN0YXJ0XCIpO1xuICBpZiAob2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uU1RBTEVfKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlNUQUxFXzsgLy8gSWRlYWxseSB3ZSB1c2UgZm9yLi5vZiBoZXJlLCBidXQgdGhlIGRvd25jb21waWxlZCB2ZXJzaW9uIGlzIHJlYWxseSBzbG93Li4uXG5cbiAgb2JzZXJ2YWJsZS5vYnNlcnZlcnNfLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICBpZiAoZC5kZXBlbmRlbmNpZXNTdGF0ZV8gPT09IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGQuaXNUcmFjaW5nXyAhPT0gVHJhY2VNb2RlLk5PTkUpIHtcbiAgICAgICAgbG9nVHJhY2VJbmZvKGQsIG9ic2VydmFibGUpO1xuICAgICAgfVxuXG4gICAgICBkLm9uQmVjb21lU3RhbGVfKCk7XG4gICAgfVxuXG4gICAgZC5kZXBlbmRlbmNpZXNTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5TVEFMRV87XG4gIH0pOyAvLyBpbnZhcmlhbnRMT1Mob2JzZXJ2YWJsZSwgXCJjaGFuZ2VkIGVuZFwiKTtcbn0gLy8gQ2FsbGVkIGJ5IENvbXB1dGVkVmFsdWUgd2hlbiBpdCByZWNhbGN1bGF0ZSBhbmQgaXRzIHZhbHVlIGNoYW5nZWRcblxuZnVuY3Rpb24gcHJvcGFnYXRlQ2hhbmdlQ29uZmlybWVkKG9ic2VydmFibGUpIHtcbiAgLy8gaW52YXJpYW50TE9TKG9ic2VydmFibGUsIFwiY29uZmlybWVkIHN0YXJ0XCIpO1xuICBpZiAob2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uU1RBTEVfKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlNUQUxFXztcbiAgb2JzZXJ2YWJsZS5vYnNlcnZlcnNfLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICBpZiAoZC5kZXBlbmRlbmNpZXNTdGF0ZV8gPT09IElEZXJpdmF0aW9uU3RhdGVfLlBPU1NJQkxZX1NUQUxFXykge1xuICAgICAgZC5kZXBlbmRlbmNpZXNTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5TVEFMRV87XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZC5pc1RyYWNpbmdfICE9PSBUcmFjZU1vZGUuTk9ORSkge1xuICAgICAgICBsb2dUcmFjZUluZm8oZCwgb2JzZXJ2YWJsZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkLmRlcGVuZGVuY2llc1N0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV8gLy8gdGhpcyBoYXBwZW5zIGR1cmluZyBjb21wdXRpbmcgb2YgYGRgLCBqdXN0IGtlZXAgbG93ZXN0T2JzZXJ2ZXJTdGF0ZSB1cCB0byBkYXRlLlxuICAgICkge1xuICAgICAgb2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfO1xuICAgIH1cbiAgfSk7IC8vIGludmFyaWFudExPUyhvYnNlcnZhYmxlLCBcImNvbmZpcm1lZCBlbmRcIik7XG59IC8vIFVzZWQgYnkgY29tcHV0ZWQgd2hlbiBpdHMgZGVwZW5kZW5jeSBjaGFuZ2VkLCBidXQgd2UgZG9uJ3Qgd2FuJ3QgdG8gaW1tZWRpYXRlbHkgcmVjb21wdXRlLlxuXG5mdW5jdGlvbiBwcm9wYWdhdGVNYXliZUNoYW5nZWQob2JzZXJ2YWJsZSkge1xuICAvLyBpbnZhcmlhbnRMT1Mob2JzZXJ2YWJsZSwgXCJtYXliZSBzdGFydFwiKTtcbiAgaWYgKG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gIT09IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlBPU1NJQkxZX1NUQUxFXztcbiAgb2JzZXJ2YWJsZS5vYnNlcnZlcnNfLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICBpZiAoZC5kZXBlbmRlbmNpZXNTdGF0ZV8gPT09IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfKSB7XG4gICAgICBkLmRlcGVuZGVuY2llc1N0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlBPU1NJQkxZX1NUQUxFXztcbiAgICAgIGQub25CZWNvbWVTdGFsZV8oKTtcbiAgICB9XG4gIH0pOyAvLyBpbnZhcmlhbnRMT1Mob2JzZXJ2YWJsZSwgXCJtYXliZSBlbmRcIik7XG59XG5cbmZ1bmN0aW9uIGxvZ1RyYWNlSW5mbyhkZXJpdmF0aW9uLCBvYnNlcnZhYmxlKSB7XG4gIGNvbnNvbGUubG9nKFwiW21vYngudHJhY2VdICdcIiArIGRlcml2YXRpb24ubmFtZV8gKyBcIicgaXMgaW52YWxpZGF0ZWQgZHVlIHRvIGEgY2hhbmdlIGluOiAnXCIgKyBvYnNlcnZhYmxlLm5hbWVfICsgXCInXCIpO1xuXG4gIGlmIChkZXJpdmF0aW9uLmlzVHJhY2luZ18gPT09IFRyYWNlTW9kZS5CUkVBSykge1xuICAgIHZhciBsaW5lcyA9IFtdO1xuICAgIHByaW50RGVwVHJlZShnZXREZXBlbmRlbmN5VHJlZShkZXJpdmF0aW9uKSwgbGluZXMsIDEpOyAvLyBwcmV0dGllci1pZ25vcmVcblxuICAgIG5ldyBGdW5jdGlvbihcImRlYnVnZ2VyO1xcbi8qXFxuVHJhY2luZyAnXCIgKyBkZXJpdmF0aW9uLm5hbWVfICsgXCInXFxuXFxuWW91IGFyZSBlbnRlcmluZyB0aGlzIGJyZWFrIHBvaW50IGJlY2F1c2UgZGVyaXZhdGlvbiAnXCIgKyBkZXJpdmF0aW9uLm5hbWVfICsgXCInIGlzIGJlaW5nIHRyYWNlZCBhbmQgJ1wiICsgb2JzZXJ2YWJsZS5uYW1lXyArIFwiJyBpcyBub3cgZm9yY2luZyBpdCB0byB1cGRhdGUuXFxuSnVzdCBmb2xsb3cgdGhlIHN0YWNrdHJhY2UgeW91IHNob3VsZCBub3cgc2VlIGluIHRoZSBkZXZ0b29scyB0byBzZWUgcHJlY2lzZWx5IHdoYXQgcGllY2Ugb2YgeW91ciBjb2RlIGlzIGNhdXNpbmcgdGhpcyB1cGRhdGVcXG5UaGUgc3RhY2tmcmFtZSB5b3UgYXJlIGxvb2tpbmcgZm9yIGlzIGF0IGxlYXN0IH42LTggc3RhY2stZnJhbWVzIHVwLlxcblxcblwiICsgKGRlcml2YXRpb24gaW5zdGFuY2VvZiBDb21wdXRlZFZhbHVlID8gZGVyaXZhdGlvbi5kZXJpdmF0aW9uLnRvU3RyaW5nKCkucmVwbGFjZSgvWypdXFwvL2csIFwiL1wiKSA6IFwiXCIpICsgXCJcXG5cXG5UaGUgZGVwZW5kZW5jaWVzIGZvciB0aGlzIGRlcml2YXRpb24gYXJlOlxcblxcblwiICsgbGluZXMuam9pbihcIlxcblwiKSArIFwiXFxuKi9cXG4gICAgXCIpKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnREZXBUcmVlKHRyZWUsIGxpbmVzLCBkZXB0aCkge1xuICBpZiAobGluZXMubGVuZ3RoID49IDEwMDApIHtcbiAgICBsaW5lcy5wdXNoKFwiKGFuZCBtYW55IG1vcmUpXCIpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxpbmVzLnB1c2goXCJcIiArIFwiXFx0XCIucmVwZWF0KGRlcHRoIC0gMSkgKyB0cmVlLm5hbWUpO1xuXG4gIGlmICh0cmVlLmRlcGVuZGVuY2llcykge1xuICAgIHRyZWUuZGVwZW5kZW5jaWVzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICByZXR1cm4gcHJpbnREZXBUcmVlKGNoaWxkLCBsaW5lcywgZGVwdGggKyAxKTtcbiAgICB9KTtcbiAgfVxufVxuXG52YXIgUmVhY3Rpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvLyBub2RlcyB3ZSBhcmUgbG9va2luZyBhdC4gT3VyIHZhbHVlIGRlcGVuZHMgb24gdGhlc2Ugbm9kZXNcbiAgZnVuY3Rpb24gUmVhY3Rpb24obmFtZV8sIG9uSW52YWxpZGF0ZV8sIGVycm9ySGFuZGxlcl8sIHJlcXVpcmVzT2JzZXJ2YWJsZV8pIHtcbiAgICBpZiAobmFtZV8gPT09IHZvaWQgMCkge1xuICAgICAgbmFtZV8gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIlJlYWN0aW9uQFwiICsgZ2V0TmV4dElkKCkgOiBcIlJlYWN0aW9uXCI7XG4gICAgfVxuXG4gICAgdGhpcy5uYW1lXyA9IHZvaWQgMDtcbiAgICB0aGlzLm9uSW52YWxpZGF0ZV8gPSB2b2lkIDA7XG4gICAgdGhpcy5lcnJvckhhbmRsZXJfID0gdm9pZCAwO1xuICAgIHRoaXMucmVxdWlyZXNPYnNlcnZhYmxlXyA9IHZvaWQgMDtcbiAgICB0aGlzLm9ic2VydmluZ18gPSBbXTtcbiAgICB0aGlzLm5ld09ic2VydmluZ18gPSBbXTtcbiAgICB0aGlzLmRlcGVuZGVuY2llc1N0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLk5PVF9UUkFDS0lOR187XG4gICAgdGhpcy5kaWZmVmFsdWVfID0gMDtcbiAgICB0aGlzLnJ1bklkXyA9IDA7XG4gICAgdGhpcy51bmJvdW5kRGVwc0NvdW50XyA9IDA7XG4gICAgdGhpcy5pc0Rpc3Bvc2VkXyA9IGZhbHNlO1xuICAgIHRoaXMuaXNTY2hlZHVsZWRfID0gZmFsc2U7XG4gICAgdGhpcy5pc1RyYWNrUGVuZGluZ18gPSBmYWxzZTtcbiAgICB0aGlzLmlzUnVubmluZ18gPSBmYWxzZTtcbiAgICB0aGlzLmlzVHJhY2luZ18gPSBUcmFjZU1vZGUuTk9ORTtcbiAgICB0aGlzLm5hbWVfID0gbmFtZV87XG4gICAgdGhpcy5vbkludmFsaWRhdGVfID0gb25JbnZhbGlkYXRlXztcbiAgICB0aGlzLmVycm9ySGFuZGxlcl8gPSBlcnJvckhhbmRsZXJfO1xuICAgIHRoaXMucmVxdWlyZXNPYnNlcnZhYmxlXyA9IHJlcXVpcmVzT2JzZXJ2YWJsZV87XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUmVhY3Rpb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5vbkJlY29tZVN0YWxlXyA9IGZ1bmN0aW9uIG9uQmVjb21lU3RhbGVfKCkge1xuICAgIHRoaXMuc2NoZWR1bGVfKCk7XG4gIH07XG5cbiAgX3Byb3RvLnNjaGVkdWxlXyA9IGZ1bmN0aW9uIHNjaGVkdWxlXygpIHtcbiAgICBpZiAoIXRoaXMuaXNTY2hlZHVsZWRfKSB7XG4gICAgICB0aGlzLmlzU2NoZWR1bGVkXyA9IHRydWU7XG4gICAgICBnbG9iYWxTdGF0ZS5wZW5kaW5nUmVhY3Rpb25zLnB1c2godGhpcyk7XG4gICAgICBydW5SZWFjdGlvbnMoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmlzU2NoZWR1bGVkID0gZnVuY3Rpb24gaXNTY2hlZHVsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTY2hlZHVsZWRfO1xuICB9XG4gIC8qKlxyXG4gICAqIGludGVybmFsLCB1c2Ugc2NoZWR1bGUoKSBpZiB5b3UgaW50ZW5kIHRvIGtpY2sgb2ZmIGEgcmVhY3Rpb25cclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5ydW5SZWFjdGlvbl8gPSBmdW5jdGlvbiBydW5SZWFjdGlvbl8oKSB7XG4gICAgaWYgKCF0aGlzLmlzRGlzcG9zZWRfKSB7XG4gICAgICBzdGFydEJhdGNoKCk7XG4gICAgICB0aGlzLmlzU2NoZWR1bGVkXyA9IGZhbHNlO1xuICAgICAgdmFyIHByZXYgPSBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQ7XG4gICAgICBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQgPSB0aGlzO1xuXG4gICAgICBpZiAoc2hvdWxkQ29tcHV0ZSh0aGlzKSkge1xuICAgICAgICB0aGlzLmlzVHJhY2tQZW5kaW5nXyA9IHRydWU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLm9uSW52YWxpZGF0ZV8oKTtcblxuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdGhpcy5pc1RyYWNrUGVuZGluZ18gJiYgaXNTcHlFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIC8vIG9uSW52YWxpZGF0ZSBkaWRuJ3QgdHJpZ2dlciB0cmFjayByaWdodCBhd2F5Li5cbiAgICAgICAgICAgIHNweVJlcG9ydCh7XG4gICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgICAgICAgIHR5cGU6IFwic2NoZWR1bGVkLXJlYWN0aW9uXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMucmVwb3J0RXhjZXB0aW9uSW5EZXJpdmF0aW9uXyhlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQgPSBwcmV2O1xuICAgICAgZW5kQmF0Y2goKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnRyYWNrID0gZnVuY3Rpb24gdHJhY2soZm4pIHtcbiAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkXykge1xuICAgICAgcmV0dXJuOyAvLyBjb25zb2xlLndhcm4oXCJSZWFjdGlvbiBhbHJlYWR5IGRpc3Bvc2VkXCIpIC8vIE5vdGU6IE5vdCBhIHdhcm5pbmcgLyBlcnJvciBpbiBtb2J4IDQgZWl0aGVyXG4gICAgfVxuXG4gICAgc3RhcnRCYXRjaCgpO1xuICAgIHZhciBub3RpZnkgPSBpc1NweUVuYWJsZWQoKTtcbiAgICB2YXIgc3RhcnRUaW1lO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnkpIHtcbiAgICAgIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBzcHlSZXBvcnRTdGFydCh7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIHR5cGU6IFwicmVhY3Rpb25cIlxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5pc1J1bm5pbmdfID0gdHJ1ZTtcbiAgICB2YXIgcHJldlJlYWN0aW9uID0gZ2xvYmFsU3RhdGUudHJhY2tpbmdDb250ZXh0OyAvLyByZWFjdGlvbnMgY291bGQgY3JlYXRlIHJlYWN0aW9ucy4uLlxuXG4gICAgZ2xvYmFsU3RhdGUudHJhY2tpbmdDb250ZXh0ID0gdGhpcztcbiAgICB2YXIgcmVzdWx0ID0gdHJhY2tEZXJpdmVkRnVuY3Rpb24odGhpcywgZm4sIHVuZGVmaW5lZCk7XG4gICAgZ2xvYmFsU3RhdGUudHJhY2tpbmdDb250ZXh0ID0gcHJldlJlYWN0aW9uO1xuICAgIHRoaXMuaXNSdW5uaW5nXyA9IGZhbHNlO1xuICAgIHRoaXMuaXNUcmFja1BlbmRpbmdfID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkXykge1xuICAgICAgLy8gZGlzcG9zZWQgZHVyaW5nIGxhc3QgcnVuLiBDbGVhbiB1cCBldmVyeXRoaW5nIHRoYXQgd2FzIGJvdW5kIGFmdGVyIHRoZSBkaXNwb3NlIGNhbGwuXG4gICAgICBjbGVhck9ic2VydmluZyh0aGlzKTtcbiAgICB9XG5cbiAgICBpZiAoaXNDYXVnaHRFeGNlcHRpb24ocmVzdWx0KSkge1xuICAgICAgdGhpcy5yZXBvcnRFeGNlcHRpb25JbkRlcml2YXRpb25fKHJlc3VsdC5jYXVzZSk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnkpIHtcbiAgICAgIHNweVJlcG9ydEVuZCh7XG4gICAgICAgIHRpbWU6IERhdGUubm93KCkgLSBzdGFydFRpbWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGVuZEJhdGNoKCk7XG4gIH07XG5cbiAgX3Byb3RvLnJlcG9ydEV4Y2VwdGlvbkluRGVyaXZhdGlvbl8gPSBmdW5jdGlvbiByZXBvcnRFeGNlcHRpb25JbkRlcml2YXRpb25fKGVycm9yKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICh0aGlzLmVycm9ySGFuZGxlcl8pIHtcbiAgICAgIHRoaXMuZXJyb3JIYW5kbGVyXyhlcnJvciwgdGhpcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGdsb2JhbFN0YXRlLmRpc2FibGVFcnJvckJvdW5kYXJpZXMpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHZhciBtZXNzYWdlID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJbbW9ieF0gRW5jb3VudGVyZWQgYW4gdW5jYXVnaHQgZXhjZXB0aW9uIHRoYXQgd2FzIHRocm93biBieSBhIHJlYWN0aW9uIG9yIG9ic2VydmVyIGNvbXBvbmVudCwgaW46ICdcIiArIHRoaXMgKyBcIidcIiA6IFwiW21vYnhdIHVuY2F1Z2h0IGVycm9yIGluICdcIiArIHRoaXMgKyBcIidcIjtcblxuICAgIGlmICghZ2xvYmFsU3RhdGUuc3VwcHJlc3NSZWFjdGlvbkVycm9ycykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlLCBlcnJvcik7XG4gICAgICAvKiogSWYgZGVidWdnaW5nIGJyb3VnaHQgeW91IGhlcmUsIHBsZWFzZSwgcmVhZCB0aGUgYWJvdmUgbWVzc2FnZSA6LSkuIFRueCEgKi9cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc29sZS53YXJuKFwiW21vYnhdIChlcnJvciBpbiByZWFjdGlvbiAnXCIgKyB0aGlzLm5hbWVfICsgXCInIHN1cHByZXNzZWQsIGZpeCBlcnJvciBvZiBjYXVzaW5nIGFjdGlvbiBiZWxvdylcIik7XG4gICAgfSAvLyBwcmV0dGllci1pZ25vcmVcblxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc1NweUVuYWJsZWQoKSkge1xuICAgICAgc3B5UmVwb3J0KHtcbiAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICBuYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICBlcnJvcjogXCJcIiArIGVycm9yXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBnbG9iYWxTdGF0ZS5nbG9iYWxSZWFjdGlvbkVycm9ySGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgcmV0dXJuIGYoZXJyb3IsIF90aGlzKTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgaWYgKCF0aGlzLmlzRGlzcG9zZWRfKSB7XG4gICAgICB0aGlzLmlzRGlzcG9zZWRfID0gdHJ1ZTtcblxuICAgICAgaWYgKCF0aGlzLmlzUnVubmluZ18pIHtcbiAgICAgICAgLy8gaWYgZGlzcG9zZWQgd2hpbGUgcnVubmluZywgY2xlYW4gdXAgbGF0ZXIuIE1heWJlIG5vdCBvcHRpbWFsLCBidXQgcmFyZSBjYXNlXG4gICAgICAgIHN0YXJ0QmF0Y2goKTtcbiAgICAgICAgY2xlYXJPYnNlcnZpbmcodGhpcyk7XG4gICAgICAgIGVuZEJhdGNoKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5nZXREaXNwb3Nlcl8gPSBmdW5jdGlvbiBnZXREaXNwb3Nlcl8oKSB7XG4gICAgdmFyIHIgPSB0aGlzLmRpc3Bvc2UuYmluZCh0aGlzKTtcbiAgICByWyRtb2J4XSA9IHRoaXM7XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiUmVhY3Rpb25bXCIgKyB0aGlzLm5hbWVfICsgXCJdXCI7XG4gIH07XG5cbiAgX3Byb3RvLnRyYWNlID0gZnVuY3Rpb24gdHJhY2UkMShlbnRlckJyZWFrUG9pbnQpIHtcbiAgICBpZiAoZW50ZXJCcmVha1BvaW50ID09PSB2b2lkIDApIHtcbiAgICAgIGVudGVyQnJlYWtQb2ludCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRyYWNlKHRoaXMsIGVudGVyQnJlYWtQb2ludCk7XG4gIH07XG5cbiAgcmV0dXJuIFJlYWN0aW9uO1xufSgpO1xuZnVuY3Rpb24gb25SZWFjdGlvbkVycm9yKGhhbmRsZXIpIHtcbiAgZ2xvYmFsU3RhdGUuZ2xvYmFsUmVhY3Rpb25FcnJvckhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlkeCA9IGdsb2JhbFN0YXRlLmdsb2JhbFJlYWN0aW9uRXJyb3JIYW5kbGVycy5pbmRleE9mKGhhbmRsZXIpO1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBnbG9iYWxTdGF0ZS5nbG9iYWxSZWFjdGlvbkVycm9ySGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfVxuICB9O1xufVxuLyoqXHJcbiAqIE1hZ2ljIG51bWJlciBhbGVydCFcclxuICogRGVmaW5lcyB3aXRoaW4gaG93IG1hbnkgdGltZXMgYSByZWFjdGlvbiBpcyBhbGxvd2VkIHRvIHJlLXRyaWdnZXIgaXRzZWxmXHJcbiAqIHVudGlsIGl0IGlzIGFzc3VtZWQgdGhhdCB0aGlzIGlzIGdvbm5hIGJlIGEgbmV2ZXIgZW5kaW5nIGxvb3AuLi5cclxuICovXG5cbnZhciBNQVhfUkVBQ1RJT05fSVRFUkFUSU9OUyA9IDEwMDtcblxudmFyIHJlYWN0aW9uU2NoZWR1bGVyID0gZnVuY3Rpb24gcmVhY3Rpb25TY2hlZHVsZXIoZikge1xuICByZXR1cm4gZigpO1xufTtcblxuZnVuY3Rpb24gcnVuUmVhY3Rpb25zKCkge1xuICAvLyBUcmFtcG9saW5pbmcsIGlmIHJ1blJlYWN0aW9ucyBhcmUgYWxyZWFkeSBydW5uaW5nLCBuZXcgcmVhY3Rpb25zIHdpbGwgYmUgcGlja2VkIHVwXG4gIGlmIChnbG9iYWxTdGF0ZS5pbkJhdGNoID4gMCB8fCBnbG9iYWxTdGF0ZS5pc1J1bm5pbmdSZWFjdGlvbnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZWFjdGlvblNjaGVkdWxlcihydW5SZWFjdGlvbnNIZWxwZXIpO1xufVxuXG5mdW5jdGlvbiBydW5SZWFjdGlvbnNIZWxwZXIoKSB7XG4gIGdsb2JhbFN0YXRlLmlzUnVubmluZ1JlYWN0aW9ucyA9IHRydWU7XG4gIHZhciBhbGxSZWFjdGlvbnMgPSBnbG9iYWxTdGF0ZS5wZW5kaW5nUmVhY3Rpb25zO1xuICB2YXIgaXRlcmF0aW9ucyA9IDA7IC8vIFdoaWxlIHJ1bm5pbmcgcmVhY3Rpb25zLCBuZXcgcmVhY3Rpb25zIG1pZ2h0IGJlIHRyaWdnZXJlZC5cbiAgLy8gSGVuY2Ugd2Ugd29yayB3aXRoIHR3byB2YXJpYWJsZXMgYW5kIGNoZWNrIHdoZXRoZXJcbiAgLy8gd2UgY29udmVyZ2UgdG8gbm8gcmVtYWluaW5nIHJlYWN0aW9ucyBhZnRlciBhIHdoaWxlLlxuXG4gIHdoaWxlIChhbGxSZWFjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgIGlmICgrK2l0ZXJhdGlvbnMgPT09IE1BWF9SRUFDVElPTl9JVEVSQVRJT05TKSB7XG4gICAgICBjb25zb2xlLmVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiUmVhY3Rpb24gZG9lc24ndCBjb252ZXJnZSB0byBhIHN0YWJsZSBzdGF0ZSBhZnRlciBcIiArIE1BWF9SRUFDVElPTl9JVEVSQVRJT05TICsgXCIgaXRlcmF0aW9ucy5cIiArIChcIiBQcm9iYWJseSB0aGVyZSBpcyBhIGN5Y2xlIGluIHRoZSByZWFjdGl2ZSBmdW5jdGlvbjogXCIgKyBhbGxSZWFjdGlvbnNbMF0pIDogXCJbbW9ieF0gY3ljbGUgaW4gcmVhY3Rpb246IFwiICsgYWxsUmVhY3Rpb25zWzBdKTtcbiAgICAgIGFsbFJlYWN0aW9ucy5zcGxpY2UoMCk7IC8vIGNsZWFyIHJlYWN0aW9uc1xuICAgIH1cblxuICAgIHZhciByZW1haW5pbmdSZWFjdGlvbnMgPSBhbGxSZWFjdGlvbnMuc3BsaWNlKDApO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSByZW1haW5pbmdSZWFjdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZW1haW5pbmdSZWFjdGlvbnNbaV0ucnVuUmVhY3Rpb25fKCk7XG4gICAgfVxuICB9XG5cbiAgZ2xvYmFsU3RhdGUuaXNSdW5uaW5nUmVhY3Rpb25zID0gZmFsc2U7XG59XG5cbnZhciBpc1JlYWN0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUoXCJSZWFjdGlvblwiLCBSZWFjdGlvbik7XG5mdW5jdGlvbiBzZXRSZWFjdGlvblNjaGVkdWxlcihmbikge1xuICB2YXIgYmFzZVNjaGVkdWxlciA9IHJlYWN0aW9uU2NoZWR1bGVyO1xuXG4gIHJlYWN0aW9uU2NoZWR1bGVyID0gZnVuY3Rpb24gcmVhY3Rpb25TY2hlZHVsZXIoZikge1xuICAgIHJldHVybiBmbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYmFzZVNjaGVkdWxlcihmKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNTcHlFbmFibGVkKCkge1xuICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICEhZ2xvYmFsU3RhdGUuc3B5TGlzdGVuZXJzLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIHNweVJlcG9ydChldmVudCkge1xuICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIGRlYWQgY29kZSBlbGltaW5hdGlvbiBjYW4gZG8gdGhlIHJlc3RcblxuXG4gIGlmICghZ2xvYmFsU3RhdGUuc3B5TGlzdGVuZXJzLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSBnbG9iYWxTdGF0ZS5zcHlMaXN0ZW5lcnM7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGlzdGVuZXJzW2ldKGV2ZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gc3B5UmVwb3J0U3RhcnQoZXZlbnQpIHtcbiAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjaGFuZ2UgPSBfZXh0ZW5kcyh7fSwgZXZlbnQsIHtcbiAgICBzcHlSZXBvcnRTdGFydDogdHJ1ZVxuICB9KTtcblxuICBzcHlSZXBvcnQoY2hhbmdlKTtcbn1cbnZhciBFTkRfRVZFTlQgPSB7XG4gIHR5cGU6IFwicmVwb3J0LWVuZFwiLFxuICBzcHlSZXBvcnRFbmQ6IHRydWVcbn07XG5mdW5jdGlvbiBzcHlSZXBvcnRFbmQoY2hhbmdlKSB7XG4gIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY2hhbmdlKSB7XG4gICAgc3B5UmVwb3J0KF9leHRlbmRzKHt9LCBjaGFuZ2UsIHtcbiAgICAgIHR5cGU6IFwicmVwb3J0LWVuZFwiLFxuICAgICAgc3B5UmVwb3J0RW5kOiB0cnVlXG4gICAgfSkpO1xuICB9IGVsc2Uge1xuICAgIHNweVJlcG9ydChFTkRfRVZFTlQpO1xuICB9XG59XG5mdW5jdGlvbiBzcHkobGlzdGVuZXIpIHtcbiAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnNvbGUud2FybihcIlttb2J4LnNweV0gSXMgYSBuby1vcCBpbiBwcm9kdWN0aW9uIGJ1aWxkc1wiKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge307XG4gIH0gZWxzZSB7XG4gICAgZ2xvYmFsU3RhdGUuc3B5TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIHJldHVybiBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGdsb2JhbFN0YXRlLnNweUxpc3RlbmVycyA9IGdsb2JhbFN0YXRlLnNweUxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgcmV0dXJuIGwgIT09IGxpc3RlbmVyO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxudmFyIEFDVElPTiA9IFwiYWN0aW9uXCI7XG52YXIgQUNUSU9OX0JPVU5EID0gXCJhY3Rpb24uYm91bmRcIjtcbnZhciBBVVRPQUNUSU9OID0gXCJhdXRvQWN0aW9uXCI7XG52YXIgQVVUT0FDVElPTl9CT1VORCA9IFwiYXV0b0FjdGlvbi5ib3VuZFwiO1xudmFyIERFRkFVTFRfQUNUSU9OX05BTUUgPSBcIjx1bm5hbWVkIGFjdGlvbj5cIjtcbnZhciBhY3Rpb25Bbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUFjdGlvbkFubm90YXRpb24oQUNUSU9OKTtcbnZhciBhY3Rpb25Cb3VuZEFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlQWN0aW9uQW5ub3RhdGlvbihBQ1RJT05fQk9VTkQsIHtcbiAgYm91bmQ6IHRydWVcbn0pO1xudmFyIGF1dG9BY3Rpb25Bbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUFjdGlvbkFubm90YXRpb24oQVVUT0FDVElPTiwge1xuICBhdXRvQWN0aW9uOiB0cnVlXG59KTtcbnZhciBhdXRvQWN0aW9uQm91bmRBbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUFjdGlvbkFubm90YXRpb24oQVVUT0FDVElPTl9CT1VORCwge1xuICBhdXRvQWN0aW9uOiB0cnVlLFxuICBib3VuZDogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbkZhY3RvcnkoYXV0b0FjdGlvbikge1xuICB2YXIgcmVzID0gZnVuY3Rpb24gYWN0aW9uKGFyZzEsIGFyZzIpIHtcbiAgICAvLyBhY3Rpb24oZm4oKSB7fSlcbiAgICBpZiAoaXNGdW5jdGlvbihhcmcxKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUFjdGlvbihhcmcxLm5hbWUgfHwgREVGQVVMVF9BQ1RJT05fTkFNRSwgYXJnMSwgYXV0b0FjdGlvbik7XG4gICAgfSAvLyBhY3Rpb24oXCJuYW1lXCIsIGZuKCkge30pXG5cblxuICAgIGlmIChpc0Z1bmN0aW9uKGFyZzIpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQWN0aW9uKGFyZzEsIGFyZzIsIGF1dG9BY3Rpb24pO1xuICAgIH0gLy8gQGFjdGlvblxuXG5cbiAgICBpZiAoaXNTdHJpbmdpc2goYXJnMikpIHtcbiAgICAgIHJldHVybiBzdG9yZUFubm90YXRpb24oYXJnMSwgYXJnMiwgYXV0b0FjdGlvbiA/IGF1dG9BY3Rpb25Bbm5vdGF0aW9uIDogYWN0aW9uQW5ub3RhdGlvbik7XG4gICAgfSAvLyBhY3Rpb24oXCJuYW1lXCIpICYgQGFjdGlvbihcIm5hbWVcIilcblxuXG4gICAgaWYgKGlzU3RyaW5naXNoKGFyZzEpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihjcmVhdGVBY3Rpb25Bbm5vdGF0aW9uKGF1dG9BY3Rpb24gPyBBVVRPQUNUSU9OIDogQUNUSU9OLCB7XG4gICAgICAgIG5hbWU6IGFyZzEsXG4gICAgICAgIGF1dG9BY3Rpb246IGF1dG9BY3Rpb25cbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBkaWUoXCJJbnZhbGlkIGFyZ3VtZW50cyBmb3IgYGFjdGlvbmBcIik7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiByZXM7XG59XG5cbnZhciBhY3Rpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlQWN0aW9uRmFjdG9yeShmYWxzZSk7XG5PYmplY3QuYXNzaWduKGFjdGlvbiwgYWN0aW9uQW5ub3RhdGlvbik7XG52YXIgYXV0b0FjdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVBY3Rpb25GYWN0b3J5KHRydWUpO1xuT2JqZWN0LmFzc2lnbihhdXRvQWN0aW9uLCBhdXRvQWN0aW9uQW5ub3RhdGlvbik7XG5hY3Rpb24uYm91bmQgPSAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihhY3Rpb25Cb3VuZEFubm90YXRpb24pO1xuYXV0b0FjdGlvbi5ib3VuZCA9IC8qI19fUFVSRV9fKi9jcmVhdGVEZWNvcmF0b3JBbm5vdGF0aW9uKGF1dG9BY3Rpb25Cb3VuZEFubm90YXRpb24pO1xuZnVuY3Rpb24gcnVuSW5BY3Rpb24oZm4pIHtcbiAgcmV0dXJuIGV4ZWN1dGVBY3Rpb24oZm4ubmFtZSB8fCBERUZBVUxUX0FDVElPTl9OQU1FLCBmYWxzZSwgZm4sIHRoaXMsIHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBpc0FjdGlvbih0aGluZykge1xuICByZXR1cm4gaXNGdW5jdGlvbih0aGluZykgJiYgdGhpbmcuaXNNb2J4QWN0aW9uID09PSB0cnVlO1xufVxuXG4vKipcclxuICogQ3JlYXRlcyBhIG5hbWVkIHJlYWN0aXZlIHZpZXcgYW5kIGtlZXBzIGl0IGFsaXZlLCBzbyB0aGF0IHRoZSB2aWV3IGlzIGFsd2F5c1xyXG4gKiB1cGRhdGVkIGlmIG9uZSBvZiB0aGUgZGVwZW5kZW5jaWVzIGNoYW5nZXMsIGV2ZW4gd2hlbiB0aGUgdmlldyBpcyBub3QgZnVydGhlciB1c2VkIGJ5IHNvbWV0aGluZyBlbHNlLlxyXG4gKiBAcGFyYW0gdmlldyBUaGUgcmVhY3RpdmUgdmlld1xyXG4gKiBAcmV0dXJucyBkaXNwb3NlciBmdW5jdGlvbiwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gc3RvcCB0aGUgdmlldyBmcm9tIGJlaW5nIHVwZGF0ZWQgaW4gdGhlIGZ1dHVyZS5cclxuICovXG5cbmZ1bmN0aW9uIGF1dG9ydW4odmlldywgb3B0cykge1xuICB2YXIgX29wdHMkbmFtZSwgX29wdHM7XG5cbiAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgIG9wdHMgPSBFTVBUWV9PQkpFQ1Q7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKHZpZXcpKSB7XG4gICAgICBkaWUoXCJBdXRvcnVuIGV4cGVjdHMgYSBmdW5jdGlvbiBhcyBmaXJzdCBhcmd1bWVudFwiKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBY3Rpb24odmlldykpIHtcbiAgICAgIGRpZShcIkF1dG9ydW4gZG9lcyBub3QgYWNjZXB0IGFjdGlvbnMgc2luY2UgYWN0aW9ucyBhcmUgdW50cmFja2FibGVcIik7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5hbWUgPSAoX29wdHMkbmFtZSA9IChfb3B0cyA9IG9wdHMpID09IG51bGwgPyB2b2lkIDAgOiBfb3B0cy5uYW1lKSAhPSBudWxsID8gX29wdHMkbmFtZSA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHZpZXcubmFtZSB8fCBcIkF1dG9ydW5AXCIgKyBnZXROZXh0SWQoKSA6IFwiQXV0b3J1blwiO1xuICB2YXIgcnVuU3luYyA9ICFvcHRzLnNjaGVkdWxlciAmJiAhb3B0cy5kZWxheTtcbiAgdmFyIHJlYWN0aW9uO1xuXG4gIGlmIChydW5TeW5jKSB7XG4gICAgLy8gbm9ybWFsIGF1dG9ydW5cbiAgICByZWFjdGlvbiA9IG5ldyBSZWFjdGlvbihuYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnRyYWNrKHJlYWN0aW9uUnVubmVyKTtcbiAgICB9LCBvcHRzLm9uRXJyb3IsIG9wdHMucmVxdWlyZXNPYnNlcnZhYmxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2NoZWR1bGVyID0gY3JlYXRlU2NoZWR1bGVyRnJvbU9wdGlvbnMob3B0cyk7IC8vIGRlYm91bmNlZCBhdXRvcnVuXG5cbiAgICB2YXIgaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICByZWFjdGlvbiA9IG5ldyBSZWFjdGlvbihuYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWlzU2NoZWR1bGVkKSB7XG4gICAgICAgIGlzU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgc2NoZWR1bGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpc1NjaGVkdWxlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKCFyZWFjdGlvbi5pc0Rpc3Bvc2VkXykge1xuICAgICAgICAgICAgcmVhY3Rpb24udHJhY2socmVhY3Rpb25SdW5uZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgb3B0cy5vbkVycm9yLCBvcHRzLnJlcXVpcmVzT2JzZXJ2YWJsZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGlvblJ1bm5lcigpIHtcbiAgICB2aWV3KHJlYWN0aW9uKTtcbiAgfVxuXG4gIHJlYWN0aW9uLnNjaGVkdWxlXygpO1xuICByZXR1cm4gcmVhY3Rpb24uZ2V0RGlzcG9zZXJfKCk7XG59XG5cbnZhciBydW4gPSBmdW5jdGlvbiBydW4oZikge1xuICByZXR1cm4gZigpO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlU2NoZWR1bGVyRnJvbU9wdGlvbnMob3B0cykge1xuICByZXR1cm4gb3B0cy5zY2hlZHVsZXIgPyBvcHRzLnNjaGVkdWxlciA6IG9wdHMuZGVsYXkgPyBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGYsIG9wdHMuZGVsYXkpO1xuICB9IDogcnVuO1xufVxuXG5mdW5jdGlvbiByZWFjdGlvbihleHByZXNzaW9uLCBlZmZlY3QsIG9wdHMpIHtcbiAgdmFyIF9vcHRzJG5hbWUyO1xuXG4gIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICBvcHRzID0gRU1QVFlfT0JKRUNUO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghaXNGdW5jdGlvbihleHByZXNzaW9uKSB8fCAhaXNGdW5jdGlvbihlZmZlY3QpKSB7XG4gICAgICBkaWUoXCJGaXJzdCBhbmQgc2Vjb25kIGFyZ3VtZW50IHRvIHJlYWN0aW9uIHNob3VsZCBiZSBmdW5jdGlvbnNcIik7XG4gICAgfVxuXG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KG9wdHMpKSB7XG4gICAgICBkaWUoXCJUaGlyZCBhcmd1bWVudCBvZiByZWFjdGlvbnMgc2hvdWxkIGJlIGFuIG9iamVjdFwiKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbmFtZSA9IChfb3B0cyRuYW1lMiA9IG9wdHMubmFtZSkgIT0gbnVsbCA/IF9vcHRzJG5hbWUyIDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJSZWFjdGlvbkBcIiArIGdldE5leHRJZCgpIDogXCJSZWFjdGlvblwiO1xuICB2YXIgZWZmZWN0QWN0aW9uID0gYWN0aW9uKG5hbWUsIG9wdHMub25FcnJvciA/IHdyYXBFcnJvckhhbmRsZXIob3B0cy5vbkVycm9yLCBlZmZlY3QpIDogZWZmZWN0KTtcbiAgdmFyIHJ1blN5bmMgPSAhb3B0cy5zY2hlZHVsZXIgJiYgIW9wdHMuZGVsYXk7XG4gIHZhciBzY2hlZHVsZXIgPSBjcmVhdGVTY2hlZHVsZXJGcm9tT3B0aW9ucyhvcHRzKTtcbiAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG4gIHZhciBpc1NjaGVkdWxlZCA9IGZhbHNlO1xuICB2YXIgdmFsdWU7XG4gIHZhciBvbGRWYWx1ZTtcbiAgdmFyIGVxdWFscyA9IG9wdHMuY29tcGFyZVN0cnVjdHVyYWwgPyBjb21wYXJlci5zdHJ1Y3R1cmFsIDogb3B0cy5lcXVhbHMgfHwgY29tcGFyZXJbXCJkZWZhdWx0XCJdO1xuICB2YXIgciA9IG5ldyBSZWFjdGlvbihuYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGZpcnN0VGltZSB8fCBydW5TeW5jKSB7XG4gICAgICByZWFjdGlvblJ1bm5lcigpO1xuICAgIH0gZWxzZSBpZiAoIWlzU2NoZWR1bGVkKSB7XG4gICAgICBpc1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICBzY2hlZHVsZXIocmVhY3Rpb25SdW5uZXIpO1xuICAgIH1cbiAgfSwgb3B0cy5vbkVycm9yLCBvcHRzLnJlcXVpcmVzT2JzZXJ2YWJsZSk7XG5cbiAgZnVuY3Rpb24gcmVhY3Rpb25SdW5uZXIoKSB7XG4gICAgaXNTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAgIGlmIChyLmlzRGlzcG9zZWRfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICByLnRyYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuZXh0VmFsdWUgPSBhbGxvd1N0YXRlQ2hhbmdlcyhmYWxzZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbihyKTtcbiAgICAgIH0pO1xuICAgICAgY2hhbmdlZCA9IGZpcnN0VGltZSB8fCAhZXF1YWxzKHZhbHVlLCBuZXh0VmFsdWUpO1xuICAgICAgb2xkVmFsdWUgPSB2YWx1ZTtcbiAgICAgIHZhbHVlID0gbmV4dFZhbHVlO1xuICAgIH0pO1xuXG4gICAgaWYgKGZpcnN0VGltZSAmJiBvcHRzLmZpcmVJbW1lZGlhdGVseSkge1xuICAgICAgZWZmZWN0QWN0aW9uKHZhbHVlLCBvbGRWYWx1ZSwgcik7XG4gICAgfSBlbHNlIGlmICghZmlyc3RUaW1lICYmIGNoYW5nZWQpIHtcbiAgICAgIGVmZmVjdEFjdGlvbih2YWx1ZSwgb2xkVmFsdWUsIHIpO1xuICAgIH1cblxuICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICB9XG5cbiAgci5zY2hlZHVsZV8oKTtcbiAgcmV0dXJuIHIuZ2V0RGlzcG9zZXJfKCk7XG59XG5cbmZ1bmN0aW9uIHdyYXBFcnJvckhhbmRsZXIoZXJyb3JIYW5kbGVyLCBiYXNlRm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGJhc2VGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9ySGFuZGxlci5jYWxsKHRoaXMsIGUpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIE9OX0JFQ09NRV9PQlNFUlZFRCA9IFwib25CT1wiO1xudmFyIE9OX0JFQ09NRV9VTk9CU0VSVkVEID0gXCJvbkJVT1wiO1xuZnVuY3Rpb24gb25CZWNvbWVPYnNlcnZlZCh0aGluZywgYXJnMiwgYXJnMykge1xuICByZXR1cm4gaW50ZXJjZXB0SG9vayhPTl9CRUNPTUVfT0JTRVJWRUQsIHRoaW5nLCBhcmcyLCBhcmczKTtcbn1cbmZ1bmN0aW9uIG9uQmVjb21lVW5vYnNlcnZlZCh0aGluZywgYXJnMiwgYXJnMykge1xuICByZXR1cm4gaW50ZXJjZXB0SG9vayhPTl9CRUNPTUVfVU5PQlNFUlZFRCwgdGhpbmcsIGFyZzIsIGFyZzMpO1xufVxuXG5mdW5jdGlvbiBpbnRlcmNlcHRIb29rKGhvb2ssIHRoaW5nLCBhcmcyLCBhcmczKSB7XG4gIHZhciBhdG9tID0gdHlwZW9mIGFyZzMgPT09IFwiZnVuY3Rpb25cIiA/IGdldEF0b20odGhpbmcsIGFyZzIpIDogZ2V0QXRvbSh0aGluZyk7XG4gIHZhciBjYiA9IGlzRnVuY3Rpb24oYXJnMykgPyBhcmczIDogYXJnMjtcbiAgdmFyIGxpc3RlbmVyc0tleSA9IGhvb2sgKyBcIkxcIjtcblxuICBpZiAoYXRvbVtsaXN0ZW5lcnNLZXldKSB7XG4gICAgYXRvbVtsaXN0ZW5lcnNLZXldLmFkZChjYik7XG4gIH0gZWxzZSB7XG4gICAgYXRvbVtsaXN0ZW5lcnNLZXldID0gbmV3IFNldChbY2JdKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhvb2tMaXN0ZW5lcnMgPSBhdG9tW2xpc3RlbmVyc0tleV07XG5cbiAgICBpZiAoaG9va0xpc3RlbmVycykge1xuICAgICAgaG9va0xpc3RlbmVyc1tcImRlbGV0ZVwiXShjYik7XG5cbiAgICAgIGlmIChob29rTGlzdGVuZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgZGVsZXRlIGF0b21bbGlzdGVuZXJzS2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbnZhciBORVZFUiA9IFwibmV2ZXJcIjtcbnZhciBBTFdBWVMgPSBcImFsd2F5c1wiO1xudmFyIE9CU0VSVkVEID0gXCJvYnNlcnZlZFwiOyAvLyBjb25zdCBJRl9BVkFJTEFCTEUgPSBcImlmYXZhaWxhYmxlXCJcblxuZnVuY3Rpb24gY29uZmlndXJlKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuaXNvbGF0ZUdsb2JhbFN0YXRlID09PSB0cnVlKSB7XG4gICAgaXNvbGF0ZUdsb2JhbFN0YXRlKCk7XG4gIH1cblxuICB2YXIgdXNlUHJveGllcyA9IG9wdGlvbnMudXNlUHJveGllcyxcbiAgICAgIGVuZm9yY2VBY3Rpb25zID0gb3B0aW9ucy5lbmZvcmNlQWN0aW9ucztcblxuICBpZiAodXNlUHJveGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZ2xvYmFsU3RhdGUudXNlUHJveGllcyA9IHVzZVByb3hpZXMgPT09IEFMV0FZUyA/IHRydWUgOiB1c2VQcm94aWVzID09PSBORVZFUiA/IGZhbHNlIDogdHlwZW9mIFByb3h5ICE9PSBcInVuZGVmaW5lZFwiO1xuICB9XG5cbiAgaWYgKHVzZVByb3hpZXMgPT09IFwiaWZhdmFpbGFibGVcIikge1xuICAgIGdsb2JhbFN0YXRlLnZlcmlmeVByb3hpZXMgPSB0cnVlO1xuICB9XG5cbiAgaWYgKGVuZm9yY2VBY3Rpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZWEgPSBlbmZvcmNlQWN0aW9ucyA9PT0gQUxXQVlTID8gQUxXQVlTIDogZW5mb3JjZUFjdGlvbnMgPT09IE9CU0VSVkVEO1xuICAgIGdsb2JhbFN0YXRlLmVuZm9yY2VBY3Rpb25zID0gZWE7XG4gICAgZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZUNoYW5nZXMgPSBlYSA9PT0gdHJ1ZSB8fCBlYSA9PT0gQUxXQVlTID8gZmFsc2UgOiB0cnVlO1xuICB9XG4gIFtcImNvbXB1dGVkUmVxdWlyZXNSZWFjdGlvblwiLCBcInJlYWN0aW9uUmVxdWlyZXNPYnNlcnZhYmxlXCIsIFwib2JzZXJ2YWJsZVJlcXVpcmVzUmVhY3Rpb25cIiwgXCJkaXNhYmxlRXJyb3JCb3VuZGFyaWVzXCIsIFwic2FmZURlc2NyaXB0b3JzXCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChrZXkgaW4gb3B0aW9ucykge1xuICAgICAgZ2xvYmFsU3RhdGVba2V5XSA9ICEhb3B0aW9uc1trZXldO1xuICAgIH1cbiAgfSk7XG4gIGdsb2JhbFN0YXRlLmFsbG93U3RhdGVSZWFkcyA9ICFnbG9iYWxTdGF0ZS5vYnNlcnZhYmxlUmVxdWlyZXNSZWFjdGlvbjtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGdsb2JhbFN0YXRlLmRpc2FibGVFcnJvckJvdW5kYXJpZXMgPT09IHRydWUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJXQVJOSU5HOiBEZWJ1ZyBmZWF0dXJlIG9ubHkuIE1vYlggd2lsbCBOT1QgcmVjb3ZlciBmcm9tIGVycm9ycyB3aGVuIGBkaXNhYmxlRXJyb3JCb3VuZGFyaWVzYCBpcyBlbmFibGVkLlwiKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnJlYWN0aW9uU2NoZWR1bGVyKSB7XG4gICAgc2V0UmVhY3Rpb25TY2hlZHVsZXIob3B0aW9ucy5yZWFjdGlvblNjaGVkdWxlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0ZW5kT2JzZXJ2YWJsZSh0YXJnZXQsIHByb3BlcnRpZXMsIGFubm90YXRpb25zLCBvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDQpIHtcbiAgICAgIGRpZShcIidleHRlbmRPYnNlcnZhYmxlJyBleHBlY3RlZCAyLTQgYXJndW1lbnRzXCIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICBkaWUoXCInZXh0ZW5kT2JzZXJ2YWJsZScgZXhwZWN0cyBhbiBvYmplY3QgYXMgZmlyc3QgYXJndW1lbnRcIik7XG4gICAgfVxuXG4gICAgaWYgKGlzT2JzZXJ2YWJsZU1hcCh0YXJnZXQpKSB7XG4gICAgICBkaWUoXCInZXh0ZW5kT2JzZXJ2YWJsZScgc2hvdWxkIG5vdCBiZSB1c2VkIG9uIG1hcHMsIHVzZSBtYXAubWVyZ2UgaW5zdGVhZFwiKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzUGxhaW5PYmplY3QocHJvcGVydGllcykpIHtcbiAgICAgIGRpZShcIidleHRlbmRPYnNlcnZhYmxlJyBvbmx5IGFjY2VwdHMgcGxhaW4gb2JqZWN0cyBhcyBzZWNvbmQgYXJndW1lbnRcIik7XG4gICAgfVxuXG4gICAgaWYgKGlzT2JzZXJ2YWJsZShwcm9wZXJ0aWVzKSB8fCBpc09ic2VydmFibGUoYW5ub3RhdGlvbnMpKSB7XG4gICAgICBkaWUoXCJFeHRlbmRpbmcgYW4gb2JqZWN0IHdpdGggYW5vdGhlciBvYnNlcnZhYmxlIChvYmplY3QpIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuICB9IC8vIFB1bGwgZGVzY3JpcHRvcnMgZmlyc3QsIHNvIHdlIGRvbid0IGhhdmUgdG8gZGVhbCB3aXRoIHByb3BzIGFkZGVkIGJ5IGFkbWluaXN0cmF0aW9uICgkbW9ieClcblxuXG4gIHZhciBkZXNjcmlwdG9ycyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMocHJvcGVydGllcyk7XG4gIHZhciBhZG0gPSBhc09ic2VydmFibGVPYmplY3QodGFyZ2V0LCBvcHRpb25zKVskbW9ieF07XG4gIHN0YXJ0QmF0Y2goKTtcblxuICB0cnkge1xuICAgIG93bktleXMoZGVzY3JpcHRvcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgYWRtLmV4dGVuZF8oa2V5LCBkZXNjcmlwdG9yc1trZXldLCAvLyBtdXN0IHBhc3MgXCJ1bmRlZmluZWRcIiBmb3IgeyBrZXk6IHVuZGVmaW5lZCB9XG4gICAgICAhYW5ub3RhdGlvbnMgPyB0cnVlIDoga2V5IGluIGFubm90YXRpb25zID8gYW5ub3RhdGlvbnNba2V5XSA6IHRydWUpO1xuICAgIH0pO1xuICB9IGZpbmFsbHkge1xuICAgIGVuZEJhdGNoKCk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBnZXREZXBlbmRlbmN5VHJlZSh0aGluZywgcHJvcGVydHkpIHtcbiAgcmV0dXJuIG5vZGVUb0RlcGVuZGVuY3lUcmVlKGdldEF0b20odGhpbmcsIHByb3BlcnR5KSk7XG59XG5cbmZ1bmN0aW9uIG5vZGVUb0RlcGVuZGVuY3lUcmVlKG5vZGUpIHtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBuYW1lOiBub2RlLm5hbWVfXG4gIH07XG5cbiAgaWYgKG5vZGUub2JzZXJ2aW5nXyAmJiBub2RlLm9ic2VydmluZ18ubGVuZ3RoID4gMCkge1xuICAgIHJlc3VsdC5kZXBlbmRlbmNpZXMgPSB1bmlxdWUobm9kZS5vYnNlcnZpbmdfKS5tYXAobm9kZVRvRGVwZW5kZW5jeVRyZWUpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0T2JzZXJ2ZXJUcmVlKHRoaW5nLCBwcm9wZXJ0eSkge1xuICByZXR1cm4gbm9kZVRvT2JzZXJ2ZXJUcmVlKGdldEF0b20odGhpbmcsIHByb3BlcnR5KSk7XG59XG5cbmZ1bmN0aW9uIG5vZGVUb09ic2VydmVyVHJlZShub2RlKSB7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgbmFtZTogbm9kZS5uYW1lX1xuICB9O1xuXG4gIGlmIChoYXNPYnNlcnZlcnMobm9kZSkpIHtcbiAgICByZXN1bHQub2JzZXJ2ZXJzID0gQXJyYXkuZnJvbShnZXRPYnNlcnZlcnMobm9kZSkpLm1hcChub2RlVG9PYnNlcnZlclRyZWUpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gdW5pcXVlKGxpc3QpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChsaXN0KSk7XG59XG5cbnZhciBnZW5lcmF0b3JJZCA9IDA7XG5mdW5jdGlvbiBGbG93Q2FuY2VsbGF0aW9uRXJyb3IoKSB7XG4gIHRoaXMubWVzc2FnZSA9IFwiRkxPV19DQU5DRUxMRURcIjtcbn1cbkZsb3dDYW5jZWxsYXRpb25FcnJvci5wcm90b3R5cGUgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuZnVuY3Rpb24gaXNGbG93Q2FuY2VsbGF0aW9uRXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRmxvd0NhbmNlbGxhdGlvbkVycm9yO1xufVxudmFyIGZsb3dBbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUZsb3dBbm5vdGF0aW9uKFwiZmxvd1wiKTtcbnZhciBmbG93Qm91bmRBbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUZsb3dBbm5vdGF0aW9uKFwiZmxvdy5ib3VuZFwiLCB7XG4gIGJvdW5kOiB0cnVlXG59KTtcbnZhciBmbG93ID0gLyojX19QVVJFX18qL09iamVjdC5hc3NpZ24oZnVuY3Rpb24gZmxvdyhhcmcxLCBhcmcyKSB7XG4gIC8vIEBmbG93XG4gIGlmIChpc1N0cmluZ2lzaChhcmcyKSkge1xuICAgIHJldHVybiBzdG9yZUFubm90YXRpb24oYXJnMSwgYXJnMiwgZmxvd0Fubm90YXRpb24pO1xuICB9IC8vIGZsb3coZm4pXG5cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICBkaWUoXCJGbG93IGV4cGVjdHMgc2luZ2xlIGFyZ3VtZW50IHdpdGggZ2VuZXJhdG9yIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgdmFyIGdlbmVyYXRvciA9IGFyZzE7XG4gIHZhciBuYW1lID0gZ2VuZXJhdG9yLm5hbWUgfHwgXCI8dW5uYW1lZCBmbG93PlwiOyAvLyBJbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vdGovY28vYmxvYi9tYXN0ZXIvaW5kZXguanNcblxuICB2YXIgcmVzID0gZnVuY3Rpb24gcmVzKCkge1xuICAgIHZhciBjdHggPSB0aGlzO1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBydW5JZCA9ICsrZ2VuZXJhdG9ySWQ7XG4gICAgdmFyIGdlbiA9IGFjdGlvbihuYW1lICsgXCIgLSBydW5pZDogXCIgKyBydW5JZCArIFwiIC0gaW5pdFwiLCBnZW5lcmF0b3IpLmFwcGx5KGN0eCwgYXJncyk7XG4gICAgdmFyIHJlamVjdG9yO1xuICAgIHZhciBwZW5kaW5nUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBzdGVwSWQgPSAwO1xuICAgICAgcmVqZWN0b3IgPSByZWplY3Q7XG5cbiAgICAgIGZ1bmN0aW9uIG9uRnVsZmlsbGVkKHJlcykge1xuICAgICAgICBwZW5kaW5nUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHJldDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldCA9IGFjdGlvbihuYW1lICsgXCIgLSBydW5pZDogXCIgKyBydW5JZCArIFwiIC0geWllbGQgXCIgKyBzdGVwSWQrKywgZ2VuLm5leHQpLmNhbGwoZ2VuLCByZXMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQocmV0KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25SZWplY3RlZChlcnIpIHtcbiAgICAgICAgcGVuZGluZ1Byb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciByZXQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXQgPSBhY3Rpb24obmFtZSArIFwiIC0gcnVuaWQ6IFwiICsgcnVuSWQgKyBcIiAtIHlpZWxkIFwiICsgc3RlcElkKyssIGdlbltcInRocm93XCJdKS5jYWxsKGdlbiwgZXJyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0KHJldCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG5leHQocmV0KSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHJldCA9PSBudWxsID8gdm9pZCAwIDogcmV0LnRoZW4pKSB7XG4gICAgICAgICAgLy8gYW4gYXN5bmMgaXRlcmF0b3JcbiAgICAgICAgICByZXQudGhlbihuZXh0LCByZWplY3QpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXQuZG9uZSkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKHJldC52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBwZW5kaW5nUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShyZXQudmFsdWUpO1xuICAgICAgICByZXR1cm4gcGVuZGluZ1Byb21pc2UudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gICAgICB9XG5cbiAgICAgIG9uRnVsZmlsbGVkKHVuZGVmaW5lZCk7IC8vIGtpY2sgb2ZmIHRoZSBwcm9jZXNzXG4gICAgfSk7XG4gICAgcHJvbWlzZS5jYW5jZWwgPSBhY3Rpb24obmFtZSArIFwiIC0gcnVuaWQ6IFwiICsgcnVuSWQgKyBcIiAtIGNhbmNlbFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAocGVuZGluZ1Byb21pc2UpIHtcbiAgICAgICAgICBjYW5jZWxQcm9taXNlKHBlbmRpbmdQcm9taXNlKTtcbiAgICAgICAgfSAvLyBGaW5hbGx5IGJsb2NrIGNhbiByZXR1cm4gKG9yIHlpZWxkKSBzdHVmZi4uXG5cblxuICAgICAgICB2YXIgX3JlcyA9IGdlbltcInJldHVyblwiXSh1bmRlZmluZWQpOyAvLyBlYXQgYW55dGhpbmcgdGhhdCBwcm9taXNlIHdvdWxkIGRvLCBpdCdzIGNhbmNlbGxlZCFcblxuXG4gICAgICAgIHZhciB5aWVsZGVkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShfcmVzLnZhbHVlKTtcbiAgICAgICAgeWllbGRlZFByb21pc2UudGhlbihub29wLCBub29wKTtcbiAgICAgICAgY2FuY2VsUHJvbWlzZSh5aWVsZGVkUHJvbWlzZSk7IC8vIG1heWJlIGl0IGNhbiBiZSBjYW5jZWxsZWQgOilcbiAgICAgICAgLy8gcmVqZWN0IG91ciBvcmlnaW5hbCBwcm9taXNlXG5cbiAgICAgICAgcmVqZWN0b3IobmV3IEZsb3dDYW5jZWxsYXRpb25FcnJvcigpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0b3IoZSk7IC8vIHRoZXJlIGNvdWxkIGJlIGEgdGhyb3dpbmcgZmluYWxseSBibG9ja1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIHJlcy5pc01vYlhGbG93ID0gdHJ1ZTtcbiAgcmV0dXJuIHJlcztcbn0sIGZsb3dBbm5vdGF0aW9uKTtcbmZsb3cuYm91bmQgPSAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihmbG93Qm91bmRBbm5vdGF0aW9uKTtcblxuZnVuY3Rpb24gY2FuY2VsUHJvbWlzZShwcm9taXNlKSB7XG4gIGlmIChpc0Z1bmN0aW9uKHByb21pc2UuY2FuY2VsKSkge1xuICAgIHByb21pc2UuY2FuY2VsKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmxvd1Jlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHJlc3VsdDsgLy8ganVzdCB0cmlja2luZyBUeXBlU2NyaXB0IDopXG59XG5mdW5jdGlvbiBpc0Zsb3coZm4pIHtcbiAgcmV0dXJuIChmbiA9PSBudWxsID8gdm9pZCAwIDogZm4uaXNNb2JYRmxvdykgPT09IHRydWU7XG59XG5cbmZ1bmN0aW9uIGludGVyY2VwdFJlYWRzKHRoaW5nLCBwcm9wT3JIYW5kbGVyLCBoYW5kbGVyKSB7XG4gIHZhciB0YXJnZXQ7XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZU1hcCh0aGluZykgfHwgaXNPYnNlcnZhYmxlQXJyYXkodGhpbmcpIHx8IGlzT2JzZXJ2YWJsZVZhbHVlKHRoaW5nKSkge1xuICAgIHRhcmdldCA9IGdldEFkbWluaXN0cmF0aW9uKHRoaW5nKTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVPYmplY3QodGhpbmcpKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhaXNTdHJpbmdpc2gocHJvcE9ySGFuZGxlcikpIHtcbiAgICAgIHJldHVybiBkaWUoXCJJbnRlcmNlcHRSZWFkcyBjYW4gb25seSBiZSB1c2VkIHdpdGggYSBzcGVjaWZpYyBwcm9wZXJ0eSwgbm90IHdpdGggYW4gb2JqZWN0IGluIGdlbmVyYWxcIik7XG4gICAgfVxuXG4gICAgdGFyZ2V0ID0gZ2V0QWRtaW5pc3RyYXRpb24odGhpbmcsIHByb3BPckhhbmRsZXIpO1xuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHJldHVybiBkaWUoXCJFeHBlY3RlZCBvYnNlcnZhYmxlIG1hcCwgb2JqZWN0IG9yIGFycmF5IGFzIGZpcnN0IGFycmF5XCIpO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0YXJnZXQuZGVoYW5jZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBkaWUoXCJBbiBpbnRlcmNlcHQgcmVhZGVyIHdhcyBhbHJlYWR5IGVzdGFibGlzaGVkXCIpO1xuICB9XG5cbiAgdGFyZ2V0LmRlaGFuY2VyID0gdHlwZW9mIHByb3BPckhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIiA/IHByb3BPckhhbmRsZXIgOiBoYW5kbGVyO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHRhcmdldC5kZWhhbmNlciA9IHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW50ZXJjZXB0KHRoaW5nLCBwcm9wT3JIYW5kbGVyLCBoYW5kbGVyKSB7XG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgcmV0dXJuIGludGVyY2VwdFByb3BlcnR5KHRoaW5nLCBwcm9wT3JIYW5kbGVyLCBoYW5kbGVyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaW50ZXJjZXB0SW50ZXJjZXB0YWJsZSh0aGluZywgcHJvcE9ySGFuZGxlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50ZXJjZXB0SW50ZXJjZXB0YWJsZSh0aGluZywgaGFuZGxlcikge1xuICByZXR1cm4gZ2V0QWRtaW5pc3RyYXRpb24odGhpbmcpLmludGVyY2VwdF8oaGFuZGxlcik7XG59XG5cbmZ1bmN0aW9uIGludGVyY2VwdFByb3BlcnR5KHRoaW5nLCBwcm9wZXJ0eSwgaGFuZGxlcikge1xuICByZXR1cm4gZ2V0QWRtaW5pc3RyYXRpb24odGhpbmcsIHByb3BlcnR5KS5pbnRlcmNlcHRfKGhhbmRsZXIpO1xufVxuXG5mdW5jdGlvbiBfaXNDb21wdXRlZCh2YWx1ZSwgcHJvcGVydHkpIHtcbiAgaWYgKHByb3BlcnR5ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gaXNDb21wdXRlZFZhbHVlKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChpc09ic2VydmFibGVPYmplY3QodmFsdWUpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghdmFsdWVbJG1vYnhdLnZhbHVlc18uaGFzKHByb3BlcnR5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBhdG9tID0gZ2V0QXRvbSh2YWx1ZSwgcHJvcGVydHkpO1xuICByZXR1cm4gaXNDb21wdXRlZFZhbHVlKGF0b20pO1xufVxuZnVuY3Rpb24gaXNDb21wdXRlZCh2YWx1ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIGRpZShcImlzQ29tcHV0ZWQgZXhwZWN0cyBvbmx5IDEgYXJndW1lbnQuIFVzZSBpc0NvbXB1dGVkUHJvcCB0byBpbnNwZWN0IHRoZSBvYnNlcnZhYmlsaXR5IG9mIGEgcHJvcGVydHlcIik7XG4gIH1cblxuICByZXR1cm4gX2lzQ29tcHV0ZWQodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNDb21wdXRlZFByb3AodmFsdWUsIHByb3BOYW1lKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWlzU3RyaW5naXNoKHByb3BOYW1lKSkge1xuICAgIHJldHVybiBkaWUoXCJpc0NvbXB1dGVkIGV4cGVjdGVkIGEgcHJvcGVydHkgbmFtZSBhcyBzZWNvbmQgYXJndW1lbnRcIik7XG4gIH1cblxuICByZXR1cm4gX2lzQ29tcHV0ZWQodmFsdWUsIHByb3BOYW1lKTtcbn1cblxuZnVuY3Rpb24gX2lzT2JzZXJ2YWJsZSh2YWx1ZSwgcHJvcGVydHkpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChwcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoaXNPYnNlcnZhYmxlTWFwKHZhbHVlKSB8fCBpc09ic2VydmFibGVBcnJheSh2YWx1ZSkpKSB7XG4gICAgICByZXR1cm4gZGllKFwiaXNPYnNlcnZhYmxlKG9iamVjdCwgcHJvcGVydHlOYW1lKSBpcyBub3Qgc3VwcG9ydGVkIGZvciBhcnJheXMgYW5kIG1hcHMuIFVzZSBtYXAuaGFzIG9yIGFycmF5Lmxlbmd0aCBpbnN0ZWFkLlwiKTtcbiAgICB9XG5cbiAgICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlWyRtb2J4XS52YWx1ZXNfLmhhcyhwcm9wZXJ0eSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIEZvciBmaXJzdCBjaGVjaywgc2VlICM3MDFcblxuXG4gIHJldHVybiBpc09ic2VydmFibGVPYmplY3QodmFsdWUpIHx8ICEhdmFsdWVbJG1vYnhdIHx8IGlzQXRvbSh2YWx1ZSkgfHwgaXNSZWFjdGlvbih2YWx1ZSkgfHwgaXNDb21wdXRlZFZhbHVlKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gaXNPYnNlcnZhYmxlKHZhbHVlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgIGRpZShcImlzT2JzZXJ2YWJsZSBleHBlY3RzIG9ubHkgMSBhcmd1bWVudC4gVXNlIGlzT2JzZXJ2YWJsZVByb3AgdG8gaW5zcGVjdCB0aGUgb2JzZXJ2YWJpbGl0eSBvZiBhIHByb3BlcnR5XCIpO1xuICB9XG5cbiAgcmV0dXJuIF9pc09ic2VydmFibGUodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNPYnNlcnZhYmxlUHJvcCh2YWx1ZSwgcHJvcE5hbWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhaXNTdHJpbmdpc2gocHJvcE5hbWUpKSB7XG4gICAgcmV0dXJuIGRpZShcImV4cGVjdGVkIGEgcHJvcGVydHkgbmFtZSBhcyBzZWNvbmQgYXJndW1lbnRcIik7XG4gIH1cblxuICByZXR1cm4gX2lzT2JzZXJ2YWJsZSh2YWx1ZSwgcHJvcE5hbWUpO1xufVxuXG5mdW5jdGlvbiBrZXlzKG9iaikge1xuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4gb2JqWyRtb2J4XS5rZXlzXygpO1xuICB9XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZU1hcChvYmopIHx8IGlzT2JzZXJ2YWJsZVNldChvYmopKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20ob2JqLmtleXMoKSk7XG4gIH1cblxuICBpZiAoaXNPYnNlcnZhYmxlQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmoubWFwKGZ1bmN0aW9uIChfLCBpbmRleCkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0pO1xuICB9XG5cbiAgZGllKDUpO1xufVxuZnVuY3Rpb24gdmFsdWVzKG9iaikge1xuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4ga2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfSk7XG4gIH1cblxuICBpZiAoaXNPYnNlcnZhYmxlTWFwKG9iaikpIHtcbiAgICByZXR1cm4ga2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gb2JqLmdldChrZXkpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZVNldChvYmopKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20ob2JqLnZhbHVlcygpKTtcbiAgfVxuXG4gIGlmIChpc09ic2VydmFibGVBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5zbGljZSgpO1xuICB9XG5cbiAgZGllKDYpO1xufVxuZnVuY3Rpb24gZW50cmllcyhvYmopIHtcbiAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIGtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIFtrZXksIG9ialtrZXldXTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChpc09ic2VydmFibGVNYXAob2JqKSkge1xuICAgIHJldHVybiBrZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBba2V5LCBvYmouZ2V0KGtleSldO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZVNldChvYmopKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20ob2JqLmVudHJpZXMoKSk7XG4gIH1cblxuICBpZiAoaXNPYnNlcnZhYmxlQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmoubWFwKGZ1bmN0aW9uIChrZXksIGluZGV4KSB7XG4gICAgICByZXR1cm4gW2luZGV4LCBrZXldO1xuICAgIH0pO1xuICB9XG5cbiAgZGllKDcpO1xufVxuZnVuY3Rpb24gc2V0KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiAhaXNPYnNlcnZhYmxlU2V0KG9iaikpIHtcbiAgICBzdGFydEJhdGNoKCk7XG4gICAgdmFyIF92YWx1ZXMgPSBrZXk7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2tleSBpbiBfdmFsdWVzKSB7XG4gICAgICAgIHNldChvYmosIF9rZXksIF92YWx1ZXNbX2tleV0pO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBlbmRCYXRjaCgpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpc09ic2VydmFibGVPYmplY3Qob2JqKSkge1xuICAgIG9ialskbW9ieF0uc2V0XyhrZXksIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVNYXAob2JqKSkge1xuICAgIG9iai5zZXQoa2V5LCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlU2V0KG9iaikpIHtcbiAgICBvYmouYWRkKGtleSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlQXJyYXkob2JqKSkge1xuICAgIGlmICh0eXBlb2Yga2V5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICBrZXkgPSBwYXJzZUludChrZXksIDEwKTtcbiAgICB9XG5cbiAgICBpZiAoa2V5IDwgMCkge1xuICAgICAgZGllKFwiSW52YWxpZCBpbmRleDogJ1wiICsga2V5ICsgXCInXCIpO1xuICAgIH1cblxuICAgIHN0YXJ0QmF0Y2goKTtcblxuICAgIGlmIChrZXkgPj0gb2JqLmxlbmd0aCkge1xuICAgICAgb2JqLmxlbmd0aCA9IGtleSArIDE7XG4gICAgfVxuXG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICBlbmRCYXRjaCgpO1xuICB9IGVsc2Uge1xuICAgIGRpZSg4KTtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlKG9iaiwga2V5KSB7XG4gIGlmIChpc09ic2VydmFibGVPYmplY3Qob2JqKSkge1xuICAgIG9ialskbW9ieF0uZGVsZXRlXyhrZXkpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZU1hcChvYmopKSB7XG4gICAgb2JqW1wiZGVsZXRlXCJdKGtleSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlU2V0KG9iaikpIHtcbiAgICBvYmpbXCJkZWxldGVcIl0oa2V5KTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVBcnJheShvYmopKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGtleSA9IHBhcnNlSW50KGtleSwgMTApO1xuICAgIH1cblxuICAgIG9iai5zcGxpY2Uoa2V5LCAxKTtcbiAgfSBlbHNlIHtcbiAgICBkaWUoOSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhcyhvYmosIGtleSkge1xuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4gb2JqWyRtb2J4XS5oYXNfKGtleSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlTWFwKG9iaikpIHtcbiAgICByZXR1cm4gb2JqLmhhcyhrZXkpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZVNldChvYmopKSB7XG4gICAgcmV0dXJuIG9iai5oYXMoa2V5KTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIGtleSA+PSAwICYmIGtleSA8IG9iai5sZW5ndGg7XG4gIH1cblxuICBkaWUoMTApO1xufVxuZnVuY3Rpb24gZ2V0KG9iaiwga2V5KSB7XG4gIGlmICghaGFzKG9iaiwga2V5KSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4gb2JqWyRtb2J4XS5nZXRfKGtleSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlTWFwKG9iaikpIHtcbiAgICByZXR1cm4gb2JqLmdldChrZXkpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH1cblxuICBkaWUoMTEpO1xufVxuZnVuY3Rpb24gYXBpRGVmaW5lUHJvcGVydHkob2JqLCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIG9ialskbW9ieF0uZGVmaW5lUHJvcGVydHlfKGtleSwgZGVzY3JpcHRvcik7XG4gIH1cblxuICBkaWUoMzkpO1xufVxuZnVuY3Rpb24gYXBpT3duS2V5cyhvYmopIHtcbiAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIG9ialskbW9ieF0ub3duS2V5c18oKTtcbiAgfVxuXG4gIGRpZSgzOCk7XG59XG5cbmZ1bmN0aW9uIG9ic2VydmUodGhpbmcsIHByb3BPckNiLCBjYk9yRmlyZSwgZmlyZUltbWVkaWF0ZWx5KSB7XG4gIGlmIChpc0Z1bmN0aW9uKGNiT3JGaXJlKSkge1xuICAgIHJldHVybiBvYnNlcnZlT2JzZXJ2YWJsZVByb3BlcnR5KHRoaW5nLCBwcm9wT3JDYiwgY2JPckZpcmUsIGZpcmVJbW1lZGlhdGVseSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9ic2VydmVPYnNlcnZhYmxlKHRoaW5nLCBwcm9wT3JDYiwgY2JPckZpcmUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ic2VydmVPYnNlcnZhYmxlKHRoaW5nLCBsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KSB7XG4gIHJldHVybiBnZXRBZG1pbmlzdHJhdGlvbih0aGluZykub2JzZXJ2ZV8obGlzdGVuZXIsIGZpcmVJbW1lZGlhdGVseSk7XG59XG5cbmZ1bmN0aW9uIG9ic2VydmVPYnNlcnZhYmxlUHJvcGVydHkodGhpbmcsIHByb3BlcnR5LCBsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KSB7XG4gIHJldHVybiBnZXRBZG1pbmlzdHJhdGlvbih0aGluZywgcHJvcGVydHkpLm9ic2VydmVfKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpO1xufVxuXG5mdW5jdGlvbiBjYWNoZShtYXAsIGtleSwgdmFsdWUpIHtcbiAgbWFwLnNldChrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB0b0pTSGVscGVyKHNvdXJjZSwgX19hbHJlYWR5U2Vlbikge1xuICBpZiAoc291cmNlID09IG51bGwgfHwgdHlwZW9mIHNvdXJjZSAhPT0gXCJvYmplY3RcIiB8fCBzb3VyY2UgaW5zdGFuY2VvZiBEYXRlIHx8ICFpc09ic2VydmFibGUoc291cmNlKSkge1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICBpZiAoaXNPYnNlcnZhYmxlVmFsdWUoc291cmNlKSB8fCBpc0NvbXB1dGVkVmFsdWUoc291cmNlKSkge1xuICAgIHJldHVybiB0b0pTSGVscGVyKHNvdXJjZS5nZXQoKSwgX19hbHJlYWR5U2Vlbik7XG4gIH1cblxuICBpZiAoX19hbHJlYWR5U2Vlbi5oYXMoc291cmNlKSkge1xuICAgIHJldHVybiBfX2FscmVhZHlTZWVuLmdldChzb3VyY2UpO1xuICB9XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KHNvdXJjZSkpIHtcbiAgICB2YXIgcmVzID0gY2FjaGUoX19hbHJlYWR5U2Vlbiwgc291cmNlLCBuZXcgQXJyYXkoc291cmNlLmxlbmd0aCkpO1xuICAgIHNvdXJjZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaWR4KSB7XG4gICAgICByZXNbaWR4XSA9IHRvSlNIZWxwZXIodmFsdWUsIF9fYWxyZWFkeVNlZW4pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICBpZiAoaXNPYnNlcnZhYmxlU2V0KHNvdXJjZSkpIHtcbiAgICB2YXIgX3JlcyA9IGNhY2hlKF9fYWxyZWFkeVNlZW4sIHNvdXJjZSwgbmV3IFNldCgpKTtcblxuICAgIHNvdXJjZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgX3Jlcy5hZGQodG9KU0hlbHBlcih2YWx1ZSwgX19hbHJlYWR5U2VlbikpO1xuICAgIH0pO1xuICAgIHJldHVybiBfcmVzO1xuICB9XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZU1hcChzb3VyY2UpKSB7XG4gICAgdmFyIF9yZXMyID0gY2FjaGUoX19hbHJlYWR5U2Vlbiwgc291cmNlLCBuZXcgTWFwKCkpO1xuXG4gICAgc291cmNlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIF9yZXMyLnNldChrZXksIHRvSlNIZWxwZXIodmFsdWUsIF9fYWxyZWFkeVNlZW4pKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3JlczI7XG4gIH0gZWxzZSB7XG4gICAgLy8gbXVzdCBiZSBvYnNlcnZhYmxlIG9iamVjdFxuICAgIHZhciBfcmVzMyA9IGNhY2hlKF9fYWxyZWFkeVNlZW4sIHNvdXJjZSwge30pO1xuXG4gICAgYXBpT3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKG9iamVjdFByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICBfcmVzM1trZXldID0gdG9KU0hlbHBlcihzb3VyY2Vba2V5XSwgX19hbHJlYWR5U2Vlbik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9yZXMzO1xuICB9XG59XG4vKipcclxuICogUmVjdXJzaXZlbHkgY29udmVydHMgYW4gb2JzZXJ2YWJsZSB0byBpdCdzIG5vbi1vYnNlcnZhYmxlIG5hdGl2ZSBjb3VudGVycGFydC5cclxuICogSXQgZG9lcyBOT1QgcmVjdXJzZSBpbnRvIG5vbi1vYnNlcnZhYmxlcywgdGhlc2UgYXJlIGxlZnQgYXMgdGhleSBhcmUsIGV2ZW4gaWYgdGhleSBjb250YWluIG9ic2VydmFibGVzLlxyXG4gKiBDb21wdXRlZCBhbmQgb3RoZXIgbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBhcmUgY29tcGxldGVseSBpZ25vcmVkLlxyXG4gKiBDb21wbGV4IHNjZW5hcmlvcyByZXF1aXJlIGN1c3RvbSBzb2x1dGlvbiwgZWcgaW1wbGVtZW50aW5nIGB0b0pTT05gIG9yIHVzaW5nIGBzZXJpYWxpenJgIGxpYi5cclxuICovXG5cblxuZnVuY3Rpb24gdG9KUyhzb3VyY2UsIG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBvcHRpb25zKSB7XG4gICAgZGllKFwidG9KUyBubyBsb25nZXIgc3VwcG9ydHMgb3B0aW9uc1wiKTtcbiAgfVxuXG4gIHJldHVybiB0b0pTSGVscGVyKHNvdXJjZSwgbmV3IE1hcCgpKTtcbn1cblxuZnVuY3Rpb24gdHJhY2UoKSB7XG4gIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBkaWUoXCJ0cmFjZSgpIGlzIG5vdCBhdmFpbGFibGUgaW4gcHJvZHVjdGlvbiBidWlsZHNcIik7XG4gIH1cblxuICB2YXIgZW50ZXJCcmVha1BvaW50ID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSBcImJvb2xlYW5cIikge1xuICAgIGVudGVyQnJlYWtQb2ludCA9IGFyZ3MucG9wKCk7XG4gIH1cblxuICB2YXIgZGVyaXZhdGlvbiA9IGdldEF0b21Gcm9tQXJncyhhcmdzKTtcblxuICBpZiAoIWRlcml2YXRpb24pIHtcbiAgICByZXR1cm4gZGllKFwiJ3RyYWNlKGJyZWFrPyknIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIGEgdHJhY2tlZCBjb21wdXRlZCB2YWx1ZSBvciBhIFJlYWN0aW9uLiBDb25zaWRlciBwYXNzaW5nIGluIHRoZSBjb21wdXRlZCB2YWx1ZSBvciByZWFjdGlvbiBleHBsaWNpdGx5XCIpO1xuICB9XG5cbiAgaWYgKGRlcml2YXRpb24uaXNUcmFjaW5nXyA9PT0gVHJhY2VNb2RlLk5PTkUpIHtcbiAgICBjb25zb2xlLmxvZyhcIlttb2J4LnRyYWNlXSAnXCIgKyBkZXJpdmF0aW9uLm5hbWVfICsgXCInIHRyYWNpbmcgZW5hYmxlZFwiKTtcbiAgfVxuXG4gIGRlcml2YXRpb24uaXNUcmFjaW5nXyA9IGVudGVyQnJlYWtQb2ludCA/IFRyYWNlTW9kZS5CUkVBSyA6IFRyYWNlTW9kZS5MT0c7XG59XG5cbmZ1bmN0aW9uIGdldEF0b21Gcm9tQXJncyhhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uO1xuXG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGdldEF0b20oYXJnc1swXSk7XG5cbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gZ2V0QXRvbShhcmdzWzBdLCBhcmdzWzFdKTtcbiAgfVxufVxuXG4vKipcclxuICogRHVyaW5nIGEgdHJhbnNhY3Rpb24gbm8gdmlld3MgYXJlIHVwZGF0ZWQgdW50aWwgdGhlIGVuZCBvZiB0aGUgdHJhbnNhY3Rpb24uXHJcbiAqIFRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIHJ1biBzeW5jaHJvbm91c2x5IG5vbmV0aGVsZXNzLlxyXG4gKlxyXG4gKiBAcGFyYW0gYWN0aW9uIGEgZnVuY3Rpb24gdGhhdCB1cGRhdGVzIHNvbWUgcmVhY3RpdmUgc3RhdGVcclxuICogQHJldHVybnMgYW55IHZhbHVlIHRoYXQgd2FzIHJldHVybmVkIGJ5IHRoZSAnYWN0aW9uJyBwYXJhbWV0ZXIuXHJcbiAqL1xuXG5mdW5jdGlvbiB0cmFuc2FjdGlvbihhY3Rpb24sIHRoaXNBcmcpIHtcbiAgaWYgKHRoaXNBcmcgPT09IHZvaWQgMCkge1xuICAgIHRoaXNBcmcgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBzdGFydEJhdGNoKCk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gYWN0aW9uLmFwcGx5KHRoaXNBcmcpO1xuICB9IGZpbmFsbHkge1xuICAgIGVuZEJhdGNoKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2hlbihwcmVkaWNhdGUsIGFyZzEsIGFyZzIpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgfHwgYXJnMSAmJiB0eXBlb2YgYXJnMSA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiB3aGVuUHJvbWlzZShwcmVkaWNhdGUsIGFyZzEpO1xuICB9XG5cbiAgcmV0dXJuIF93aGVuKHByZWRpY2F0ZSwgYXJnMSwgYXJnMiB8fCB7fSk7XG59XG5cbmZ1bmN0aW9uIF93aGVuKHByZWRpY2F0ZSwgZWZmZWN0LCBvcHRzKSB7XG4gIHZhciB0aW1lb3V0SGFuZGxlO1xuXG4gIGlmICh0eXBlb2Ygb3B0cy50aW1lb3V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiV0hFTl9USU1FT1VUXCIpO1xuICAgIHRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghZGlzcG9zZXJbJG1vYnhdLmlzRGlzcG9zZWRfKSB7XG4gICAgICAgIGRpc3Bvc2VyKCk7XG5cbiAgICAgICAgaWYgKG9wdHMub25FcnJvcikge1xuICAgICAgICAgIG9wdHMub25FcnJvcihlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBvcHRzLnRpbWVvdXQpO1xuICB9XG5cbiAgb3B0cy5uYW1lID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gb3B0cy5uYW1lIHx8IFwiV2hlbkBcIiArIGdldE5leHRJZCgpIDogXCJXaGVuXCI7XG4gIHZhciBlZmZlY3RBY3Rpb24gPSBjcmVhdGVBY3Rpb24ocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gb3B0cy5uYW1lICsgXCItZWZmZWN0XCIgOiBcIldoZW4tZWZmZWN0XCIsIGVmZmVjdCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuXG4gIHZhciBkaXNwb3NlciA9IGF1dG9ydW4oZnVuY3Rpb24gKHIpIHtcbiAgICAvLyBwcmVkaWNhdGUgc2hvdWxkIG5vdCBjaGFuZ2Ugc3RhdGVcbiAgICB2YXIgY29uZCA9IGFsbG93U3RhdGVDaGFuZ2VzKGZhbHNlLCBwcmVkaWNhdGUpO1xuXG4gICAgaWYgKGNvbmQpIHtcbiAgICAgIHIuZGlzcG9zZSgpO1xuXG4gICAgICBpZiAodGltZW91dEhhbmRsZSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dEhhbmRsZSk7XG4gICAgICB9XG5cbiAgICAgIGVmZmVjdEFjdGlvbigpO1xuICAgIH1cbiAgfSwgb3B0cyk7XG4gIHJldHVybiBkaXNwb3Nlcjtcbn1cblxuZnVuY3Rpb24gd2hlblByb21pc2UocHJlZGljYXRlLCBvcHRzKSB7XG4gIHZhciBfb3B0cyRzaWduYWw7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBvcHRzICYmIG9wdHMub25FcnJvcikge1xuICAgIHJldHVybiBkaWUoXCJ0aGUgb3B0aW9ucyAnb25FcnJvcicgYW5kICdwcm9taXNlJyBjYW5ub3QgYmUgY29tYmluZWRcIik7XG4gIH1cblxuICBpZiAob3B0cyAhPSBudWxsICYmIChfb3B0cyRzaWduYWwgPSBvcHRzLnNpZ25hbCkgIT0gbnVsbCAmJiBfb3B0cyRzaWduYWwuYWJvcnRlZCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIldIRU5fQUJPUlRFRFwiKSksIHtcbiAgICAgIGNhbmNlbDogZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBjYW5jZWw7XG4gIHZhciBhYm9ydDtcbiAgdmFyIHJlcyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgX29wdHMkc2lnbmFsMjtcblxuICAgIHZhciBkaXNwb3NlciA9IF93aGVuKHByZWRpY2F0ZSwgcmVzb2x2ZSwgX2V4dGVuZHMoe30sIG9wdHMsIHtcbiAgICAgIG9uRXJyb3I6IHJlamVjdFxuICAgIH0pKTtcblxuICAgIGNhbmNlbCA9IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgIGRpc3Bvc2VyKCk7XG4gICAgICByZWplY3QobmV3IEVycm9yKFwiV0hFTl9DQU5DRUxMRURcIikpO1xuICAgIH07XG5cbiAgICBhYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgZGlzcG9zZXIoKTtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJXSEVOX0FCT1JURURcIikpO1xuICAgIH07XG5cbiAgICBvcHRzID09IG51bGwgPyB2b2lkIDAgOiAoX29wdHMkc2lnbmFsMiA9IG9wdHMuc2lnbmFsKSA9PSBudWxsID8gdm9pZCAwIDogX29wdHMkc2lnbmFsMi5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnQpO1xuICB9KVtcImZpbmFsbHlcIl0oZnVuY3Rpb24gKCkge1xuICAgIHZhciBfb3B0cyRzaWduYWwzO1xuXG4gICAgcmV0dXJuIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IChfb3B0cyRzaWduYWwzID0gb3B0cy5zaWduYWwpID09IG51bGwgPyB2b2lkIDAgOiBfb3B0cyRzaWduYWwzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBhYm9ydCk7XG4gIH0pO1xuICByZXMuY2FuY2VsID0gY2FuY2VsO1xuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBnZXRBZG0odGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXRbJG1vYnhdO1xufSAvLyBPcHRpbWl6YXRpb246IHdlIGRvbid0IG5lZWQgdGhlIGludGVybWVkaWF0ZSBvYmplY3RzIGFuZCBjb3VsZCBoYXZlIGEgY29tcGxldGVseSBjdXN0b20gYWRtaW5pc3RyYXRpb24gZm9yIER5bmFtaWNPYmplY3RzLFxuLy8gYW5kIHNraXAgZWl0aGVyIHRoZSBpbnRlcm5hbCB2YWx1ZXMgbWFwLCBvciB0aGUgYmFzZSBvYmplY3Qgd2l0aCBpdHMgcHJvcGVydHkgZGVzY3JpcHRvcnMhXG5cblxudmFyIG9iamVjdFByb3h5VHJhcHMgPSB7XG4gIGhhczogZnVuY3Rpb24gaGFzKHRhcmdldCwgbmFtZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uKSB7XG4gICAgICB3YXJuQWJvdXRQcm94eVJlcXVpcmVtZW50KFwiZGV0ZWN0IG5ldyBwcm9wZXJ0aWVzIHVzaW5nIHRoZSAnaW4nIG9wZXJhdG9yLiBVc2UgJ2hhcycgZnJvbSAnbW9ieCcgaW5zdGVhZC5cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldEFkbSh0YXJnZXQpLmhhc18obmFtZSk7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24gZ2V0KHRhcmdldCwgbmFtZSkge1xuICAgIHJldHVybiBnZXRBZG0odGFyZ2V0KS5nZXRfKG5hbWUpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh0YXJnZXQsIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIF9nZXRBZG0kc2V0XztcblxuICAgIGlmICghaXNTdHJpbmdpc2gobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFnZXRBZG0odGFyZ2V0KS52YWx1ZXNfLmhhcyhuYW1lKSkge1xuICAgICAgd2FybkFib3V0UHJveHlSZXF1aXJlbWVudChcImFkZCBhIG5ldyBvYnNlcnZhYmxlIHByb3BlcnR5IHRocm91Z2ggZGlyZWN0IGFzc2lnbm1lbnQuIFVzZSAnc2V0JyBmcm9tICdtb2J4JyBpbnN0ZWFkLlwiKTtcbiAgICB9IC8vIG51bGwgKGludGVyY2VwdGVkKSAtPiB0cnVlIChzdWNjZXNzKVxuXG5cbiAgICByZXR1cm4gKF9nZXRBZG0kc2V0XyA9IGdldEFkbSh0YXJnZXQpLnNldF8obmFtZSwgdmFsdWUsIHRydWUpKSAhPSBudWxsID8gX2dldEFkbSRzZXRfIDogdHJ1ZTtcbiAgfSxcbiAgZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgbmFtZSkge1xuICAgIHZhciBfZ2V0QWRtJGRlbGV0ZV87XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICB3YXJuQWJvdXRQcm94eVJlcXVpcmVtZW50KFwiZGVsZXRlIHByb3BlcnRpZXMgZnJvbSBhbiBvYnNlcnZhYmxlIG9iamVjdC4gVXNlICdyZW1vdmUnIGZyb20gJ21vYngnIGluc3RlYWQuXCIpO1xuICAgIH1cblxuICAgIGlmICghaXNTdHJpbmdpc2gobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIG51bGwgKGludGVyY2VwdGVkKSAtPiB0cnVlIChzdWNjZXNzKVxuXG5cbiAgICByZXR1cm4gKF9nZXRBZG0kZGVsZXRlXyA9IGdldEFkbSh0YXJnZXQpLmRlbGV0ZV8obmFtZSwgdHJ1ZSkpICE9IG51bGwgPyBfZ2V0QWRtJGRlbGV0ZV8gOiB0cnVlO1xuICB9LFxuICBkZWZpbmVQcm9wZXJ0eTogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKSB7XG4gICAgdmFyIF9nZXRBZG0kZGVmaW5lUHJvcGVydDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHdhcm5BYm91dFByb3h5UmVxdWlyZW1lbnQoXCJkZWZpbmUgcHJvcGVydHkgb24gYW4gb2JzZXJ2YWJsZSBvYmplY3QuIFVzZSAnZGVmaW5lUHJvcGVydHknIGZyb20gJ21vYngnIGluc3RlYWQuXCIpO1xuICAgIH0gLy8gbnVsbCAoaW50ZXJjZXB0ZWQpIC0+IHRydWUgKHN1Y2Nlc3MpXG5cblxuICAgIHJldHVybiAoX2dldEFkbSRkZWZpbmVQcm9wZXJ0ID0gZ2V0QWRtKHRhcmdldCkuZGVmaW5lUHJvcGVydHlfKG5hbWUsIGRlc2NyaXB0b3IpKSAhPSBudWxsID8gX2dldEFkbSRkZWZpbmVQcm9wZXJ0IDogdHJ1ZTtcbiAgfSxcbiAgb3duS2V5czogZnVuY3Rpb24gb3duS2V5cyh0YXJnZXQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbikge1xuICAgICAgd2FybkFib3V0UHJveHlSZXF1aXJlbWVudChcIml0ZXJhdGUga2V5cyB0byBkZXRlY3QgYWRkZWQgLyByZW1vdmVkIHByb3BlcnRpZXMuIFVzZSAna2V5cycgZnJvbSAnbW9ieCcgaW5zdGVhZC5cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldEFkbSh0YXJnZXQpLm93bktleXNfKCk7XG4gIH0sXG4gIHByZXZlbnRFeHRlbnNpb25zOiBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpIHtcbiAgICBkaWUoMTMpO1xuICB9XG59O1xuZnVuY3Rpb24gYXNEeW5hbWljT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgdmFyIF90YXJnZXQkJG1vYngsIF90YXJnZXQkJG1vYngkcHJveHlfO1xuXG4gIGFzc2VydFByb3hpZXMoKTtcbiAgdGFyZ2V0ID0gYXNPYnNlcnZhYmxlT2JqZWN0KHRhcmdldCwgb3B0aW9ucyk7XG4gIHJldHVybiAoX3RhcmdldCQkbW9ieCRwcm94eV8gPSAoX3RhcmdldCQkbW9ieCA9IHRhcmdldFskbW9ieF0pLnByb3h5XykgIT0gbnVsbCA/IF90YXJnZXQkJG1vYngkcHJveHlfIDogX3RhcmdldCQkbW9ieC5wcm94eV8gPSBuZXcgUHJveHkodGFyZ2V0LCBvYmplY3RQcm94eVRyYXBzKTtcbn1cblxuZnVuY3Rpb24gaGFzSW50ZXJjZXB0b3JzKGludGVyY2VwdGFibGUpIHtcbiAgcmV0dXJuIGludGVyY2VwdGFibGUuaW50ZXJjZXB0b3JzXyAhPT0gdW5kZWZpbmVkICYmIGludGVyY2VwdGFibGUuaW50ZXJjZXB0b3JzXy5sZW5ndGggPiAwO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJJbnRlcmNlcHRvcihpbnRlcmNlcHRhYmxlLCBoYW5kbGVyKSB7XG4gIHZhciBpbnRlcmNlcHRvcnMgPSBpbnRlcmNlcHRhYmxlLmludGVyY2VwdG9yc18gfHwgKGludGVyY2VwdGFibGUuaW50ZXJjZXB0b3JzXyA9IFtdKTtcbiAgaW50ZXJjZXB0b3JzLnB1c2goaGFuZGxlcik7XG4gIHJldHVybiBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaWR4ID0gaW50ZXJjZXB0b3JzLmluZGV4T2YoaGFuZGxlcik7XG5cbiAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgaW50ZXJjZXB0b3JzLnNwbGljZShpZHgsIDEpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBpbnRlcmNlcHRDaGFuZ2UoaW50ZXJjZXB0YWJsZSwgY2hhbmdlKSB7XG4gIHZhciBwcmV2VSA9IHVudHJhY2tlZFN0YXJ0KCk7XG5cbiAgdHJ5IHtcbiAgICAvLyBJbnRlcmNlcHRvciBjYW4gbW9kaWZ5IHRoZSBhcnJheSwgY29weSBpdCB0byBhdm9pZCBjb25jdXJyZW50IG1vZGlmaWNhdGlvbiwgc2VlICMxOTUwXG4gICAgdmFyIGludGVyY2VwdG9ycyA9IFtdLmNvbmNhdChpbnRlcmNlcHRhYmxlLmludGVyY2VwdG9yc18gfHwgW10pO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpbnRlcmNlcHRvcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjaGFuZ2UgPSBpbnRlcmNlcHRvcnNbaV0oY2hhbmdlKTtcblxuICAgICAgaWYgKGNoYW5nZSAmJiAhY2hhbmdlLnR5cGUpIHtcbiAgICAgICAgZGllKDE0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYW5nZTtcbiAgfSBmaW5hbGx5IHtcbiAgICB1bnRyYWNrZWRFbmQocHJldlUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc0xpc3RlbmVycyhsaXN0ZW5hYmxlKSB7XG4gIHJldHVybiBsaXN0ZW5hYmxlLmNoYW5nZUxpc3RlbmVyc18gIT09IHVuZGVmaW5lZCAmJiBsaXN0ZW5hYmxlLmNoYW5nZUxpc3RlbmVyc18ubGVuZ3RoID4gMDtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXIobGlzdGVuYWJsZSwgaGFuZGxlcikge1xuICB2YXIgbGlzdGVuZXJzID0gbGlzdGVuYWJsZS5jaGFuZ2VMaXN0ZW5lcnNfIHx8IChsaXN0ZW5hYmxlLmNoYW5nZUxpc3RlbmVyc18gPSBbXSk7XG4gIGxpc3RlbmVycy5wdXNoKGhhbmRsZXIpO1xuICByZXR1cm4gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlkeCA9IGxpc3RlbmVycy5pbmRleE9mKGhhbmRsZXIpO1xuXG4gICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgIGxpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gbm90aWZ5TGlzdGVuZXJzKGxpc3RlbmFibGUsIGNoYW5nZSkge1xuICB2YXIgcHJldlUgPSB1bnRyYWNrZWRTdGFydCgpO1xuICB2YXIgbGlzdGVuZXJzID0gbGlzdGVuYWJsZS5jaGFuZ2VMaXN0ZW5lcnNfO1xuXG4gIGlmICghbGlzdGVuZXJzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLnNsaWNlKCk7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGlzdGVuZXJzW2ldKGNoYW5nZSk7XG4gIH1cblxuICB1bnRyYWNrZWRFbmQocHJldlUpO1xufVxuXG5mdW5jdGlvbiBtYWtlT2JzZXJ2YWJsZSh0YXJnZXQsIGFubm90YXRpb25zLCBvcHRpb25zKSB7XG4gIHZhciBhZG0gPSBhc09ic2VydmFibGVPYmplY3QodGFyZ2V0LCBvcHRpb25zKVskbW9ieF07XG4gIHN0YXJ0QmF0Y2goKTtcblxuICB0cnkge1xuICAgIHZhciBfYW5ub3RhdGlvbnM7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGFubm90YXRpb25zICYmIHRhcmdldFtzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF0pIHtcbiAgICAgIGRpZShcIm1ha2VPYnNlcnZhYmxlIHNlY29uZCBhcmcgbXVzdCBiZSBudWxsaXNoIHdoZW4gdXNpbmcgZGVjb3JhdG9ycy4gTWl4aW5nIEBkZWNvcmF0b3Igc3ludGF4IHdpdGggYW5ub3RhdGlvbnMgaXMgbm90IHN1cHBvcnRlZC5cIik7XG4gICAgfSAvLyBEZWZhdWx0IHRvIGRlY29yYXRvcnNcblxuXG4gICAgKF9hbm5vdGF0aW9ucyA9IGFubm90YXRpb25zKSAhPSBudWxsID8gX2Fubm90YXRpb25zIDogYW5ub3RhdGlvbnMgPSBjb2xsZWN0U3RvcmVkQW5ub3RhdGlvbnModGFyZ2V0KTsgLy8gQW5ub3RhdGVcblxuICAgIG93bktleXMoYW5ub3RhdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGFkbS5tYWtlXyhrZXksIGFubm90YXRpb25zW2tleV0pO1xuICAgIH0pO1xuICB9IGZpbmFsbHkge1xuICAgIGVuZEJhdGNoKCk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufSAvLyBwcm90b1trZXlzU3ltYm9sXSA9IG5ldyBTZXQ8UHJvcGVydHlLZXk+KClcblxudmFyIGtleXNTeW1ib2wgPSAvKiNfX1BVUkVfXyovU3ltYm9sKFwibW9ieC1rZXlzXCIpO1xuZnVuY3Rpb24gbWFrZUF1dG9PYnNlcnZhYmxlKHRhcmdldCwgb3ZlcnJpZGVzLCBvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodGFyZ2V0KSAmJiAhaXNQbGFpbk9iamVjdChPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSkpIHtcbiAgICAgIGRpZShcIidtYWtlQXV0b09ic2VydmFibGUnIGNhbiBvbmx5IGJlIHVzZWQgZm9yIGNsYXNzZXMgdGhhdCBkb24ndCBoYXZlIGEgc3VwZXJjbGFzc1wiKTtcbiAgICB9XG5cbiAgICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHRhcmdldCkpIHtcbiAgICAgIGRpZShcIm1ha2VBdXRvT2JzZXJ2YWJsZSBjYW4gb25seSBiZSB1c2VkIG9uIG9iamVjdHMgbm90IGFscmVhZHkgbWFkZSBvYnNlcnZhYmxlXCIpO1xuICAgIH1cbiAgfSAvLyBPcHRpbWl6YXRpb246IGF2b2lkIHZpc2l0aW5nIHByb3Rvc1xuICAvLyBBc3N1bWVzIHRoYXQgYW5ub3RhdGlvbi5tYWtlXy8uZXh0ZW5kXyB3b3JrcyB0aGUgc2FtZSBmb3IgcGxhaW4gb2JqZWN0c1xuXG5cbiAgaWYgKGlzUGxhaW5PYmplY3QodGFyZ2V0KSkge1xuICAgIHJldHVybiBleHRlbmRPYnNlcnZhYmxlKHRhcmdldCwgdGFyZ2V0LCBvdmVycmlkZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIGFkbSA9IGFzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQsIG9wdGlvbnMpWyRtb2J4XTsgLy8gT3B0aW1pemF0aW9uOiBjYWNoZSBrZXlzIG9uIHByb3RvXG4gIC8vIEFzc3VtZXMgbWFrZUF1dG9PYnNlcnZhYmxlIGNhbiBiZSBjYWxsZWQgb25seSBvbmNlIHBlciBvYmplY3QgYW5kIGNhbid0IGJlIHVzZWQgaW4gc3ViY2xhc3NcblxuICBpZiAoIXRhcmdldFtrZXlzU3ltYm9sXSkge1xuICAgIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpO1xuICAgIHZhciBrZXlzID0gbmV3IFNldChbXS5jb25jYXQob3duS2V5cyh0YXJnZXQpLCBvd25LZXlzKHByb3RvKSkpO1xuICAgIGtleXNbXCJkZWxldGVcIl0oXCJjb25zdHJ1Y3RvclwiKTtcbiAgICBrZXlzW1wiZGVsZXRlXCJdKCRtb2J4KTtcbiAgICBhZGRIaWRkZW5Qcm9wKHByb3RvLCBrZXlzU3ltYm9sLCBrZXlzKTtcbiAgfVxuXG4gIHN0YXJ0QmF0Y2goKTtcblxuICB0cnkge1xuICAgIHRhcmdldFtrZXlzU3ltYm9sXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBhZG0ubWFrZV8oa2V5LCAvLyBtdXN0IHBhc3MgXCJ1bmRlZmluZWRcIiBmb3IgeyBrZXk6IHVuZGVmaW5lZCB9XG4gICAgICAhb3ZlcnJpZGVzID8gdHJ1ZSA6IGtleSBpbiBvdmVycmlkZXMgPyBvdmVycmlkZXNba2V5XSA6IHRydWUpO1xuICAgIH0pO1xuICB9IGZpbmFsbHkge1xuICAgIGVuZEJhdGNoKCk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG52YXIgU1BMSUNFID0gXCJzcGxpY2VcIjtcbnZhciBVUERBVEUgPSBcInVwZGF0ZVwiO1xudmFyIE1BWF9TUExJQ0VfU0laRSA9IDEwMDAwOyAvLyBTZWUgZS5nLiBodHRwczovL2dpdGh1Yi5jb20vbW9ieGpzL21vYngvaXNzdWVzLzg1OVxuXG52YXIgYXJyYXlUcmFwcyA9IHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQodGFyZ2V0LCBuYW1lKSB7XG4gICAgdmFyIGFkbSA9IHRhcmdldFskbW9ieF07XG5cbiAgICBpZiAobmFtZSA9PT0gJG1vYngpIHtcbiAgICAgIHJldHVybiBhZG07XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgIHJldHVybiBhZG0uZ2V0QXJyYXlMZW5ndGhfKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiICYmICFpc05hTihuYW1lKSkge1xuICAgICAgcmV0dXJuIGFkbS5nZXRfKHBhcnNlSW50KG5hbWUpKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzUHJvcChhcnJheUV4dGVuc2lvbnMsIG5hbWUpKSB7XG4gICAgICByZXR1cm4gYXJyYXlFeHRlbnNpb25zW25hbWVdO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRbbmFtZV07XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHRhcmdldCwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgYWRtID0gdGFyZ2V0WyRtb2J4XTtcblxuICAgIGlmIChuYW1lID09PSBcImxlbmd0aFwiKSB7XG4gICAgICBhZG0uc2V0QXJyYXlMZW5ndGhfKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIgfHwgaXNOYU4obmFtZSkpIHtcbiAgICAgIHRhcmdldFtuYW1lXSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBudW1lcmljIHN0cmluZ1xuICAgICAgYWRtLnNldF8ocGFyc2VJbnQobmFtZSksIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgcHJldmVudEV4dGVuc2lvbnM6IGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKCkge1xuICAgIGRpZSgxNSk7XG4gIH1cbn07XG52YXIgT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvLyB0aGlzIGlzIHRoZSBwcm9wIHRoYXQgZ2V0cyBwcm94aWVkLCBzbyBjYW4ndCByZXBsYWNlIGl0IVxuICBmdW5jdGlvbiBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbihuYW1lLCBlbmhhbmNlciwgb3duZWRfLCBsZWdhY3lNb2RlXykge1xuICAgIGlmIChuYW1lID09PSB2b2lkIDApIHtcbiAgICAgIG5hbWUgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIk9ic2VydmFibGVBcnJheUBcIiArIGdldE5leHRJZCgpIDogXCJPYnNlcnZhYmxlQXJyYXlcIjtcbiAgICB9XG5cbiAgICB0aGlzLm93bmVkXyA9IHZvaWQgMDtcbiAgICB0aGlzLmxlZ2FjeU1vZGVfID0gdm9pZCAwO1xuICAgIHRoaXMuYXRvbV8gPSB2b2lkIDA7XG4gICAgdGhpcy52YWx1ZXNfID0gW107XG4gICAgdGhpcy5pbnRlcmNlcHRvcnNfID0gdm9pZCAwO1xuICAgIHRoaXMuY2hhbmdlTGlzdGVuZXJzXyA9IHZvaWQgMDtcbiAgICB0aGlzLmVuaGFuY2VyXyA9IHZvaWQgMDtcbiAgICB0aGlzLmRlaGFuY2VyID0gdm9pZCAwO1xuICAgIHRoaXMucHJveHlfID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdEtub3duTGVuZ3RoXyA9IDA7XG4gICAgdGhpcy5vd25lZF8gPSBvd25lZF87XG4gICAgdGhpcy5sZWdhY3lNb2RlXyA9IGxlZ2FjeU1vZGVfO1xuICAgIHRoaXMuYXRvbV8gPSBuZXcgQXRvbShuYW1lKTtcblxuICAgIHRoaXMuZW5oYW5jZXJfID0gZnVuY3Rpb24gKG5ld1YsIG9sZFYpIHtcbiAgICAgIHJldHVybiBlbmhhbmNlcihuZXdWLCBvbGRWLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBuYW1lICsgXCJbLi5dXCIgOiBcIk9ic2VydmFibGVBcnJheVsuLl1cIik7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRlaGFuY2VWYWx1ZV8gPSBmdW5jdGlvbiBkZWhhbmNlVmFsdWVfKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZGVoYW5jZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVoYW5jZXIodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBfcHJvdG8uZGVoYW5jZVZhbHVlc18gPSBmdW5jdGlvbiBkZWhhbmNlVmFsdWVzXyh2YWx1ZXMpIHtcbiAgICBpZiAodGhpcy5kZWhhbmNlciAhPT0gdW5kZWZpbmVkICYmIHZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdmFsdWVzLm1hcCh0aGlzLmRlaGFuY2VyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG4gIF9wcm90by5pbnRlcmNlcHRfID0gZnVuY3Rpb24gaW50ZXJjZXB0XyhoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHJlZ2lzdGVySW50ZXJjZXB0b3IodGhpcywgaGFuZGxlcik7XG4gIH07XG5cbiAgX3Byb3RvLm9ic2VydmVfID0gZnVuY3Rpb24gb2JzZXJ2ZV8obGlzdGVuZXIsIGZpcmVJbW1lZGlhdGVseSkge1xuICAgIGlmIChmaXJlSW1tZWRpYXRlbHkgPT09IHZvaWQgMCkge1xuICAgICAgZmlyZUltbWVkaWF0ZWx5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGZpcmVJbW1lZGlhdGVseSkge1xuICAgICAgbGlzdGVuZXIoe1xuICAgICAgICBvYnNlcnZhYmxlS2luZDogXCJhcnJheVwiLFxuICAgICAgICBvYmplY3Q6IHRoaXMucHJveHlfLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMuYXRvbV8ubmFtZV8sXG4gICAgICAgIHR5cGU6IFwic3BsaWNlXCIsXG4gICAgICAgIGluZGV4OiAwLFxuICAgICAgICBhZGRlZDogdGhpcy52YWx1ZXNfLnNsaWNlKCksXG4gICAgICAgIGFkZGVkQ291bnQ6IHRoaXMudmFsdWVzXy5sZW5ndGgsXG4gICAgICAgIHJlbW92ZWQ6IFtdLFxuICAgICAgICByZW1vdmVkQ291bnQ6IDBcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZWdpc3Rlckxpc3RlbmVyKHRoaXMsIGxpc3RlbmVyKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0QXJyYXlMZW5ndGhfID0gZnVuY3Rpb24gZ2V0QXJyYXlMZW5ndGhfKCkge1xuICAgIHRoaXMuYXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNfLmxlbmd0aDtcbiAgfTtcblxuICBfcHJvdG8uc2V0QXJyYXlMZW5ndGhfID0gZnVuY3Rpb24gc2V0QXJyYXlMZW5ndGhfKG5ld0xlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgbmV3TGVuZ3RoICE9PSBcIm51bWJlclwiIHx8IGlzTmFOKG5ld0xlbmd0aCkgfHwgbmV3TGVuZ3RoIDwgMCkge1xuICAgICAgZGllKFwiT3V0IG9mIHJhbmdlOiBcIiArIG5ld0xlbmd0aCk7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRMZW5ndGggPSB0aGlzLnZhbHVlc18ubGVuZ3RoO1xuXG4gICAgaWYgKG5ld0xlbmd0aCA9PT0gY3VycmVudExlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAobmV3TGVuZ3RoID4gY3VycmVudExlbmd0aCkge1xuICAgICAgdmFyIG5ld0l0ZW1zID0gbmV3IEFycmF5KG5ld0xlbmd0aCAtIGN1cnJlbnRMZW5ndGgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0xlbmd0aCAtIGN1cnJlbnRMZW5ndGg7IGkrKykge1xuICAgICAgICBuZXdJdGVtc1tpXSA9IHVuZGVmaW5lZDtcbiAgICAgIH0gLy8gTm8gQXJyYXkuZmlsbCBldmVyeXdoZXJlLi4uXG5cblxuICAgICAgdGhpcy5zcGxpY2VXaXRoQXJyYXlfKGN1cnJlbnRMZW5ndGgsIDAsIG5ld0l0ZW1zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zcGxpY2VXaXRoQXJyYXlfKG5ld0xlbmd0aCwgY3VycmVudExlbmd0aCAtIG5ld0xlbmd0aCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by51cGRhdGVBcnJheUxlbmd0aF8gPSBmdW5jdGlvbiB1cGRhdGVBcnJheUxlbmd0aF8ob2xkTGVuZ3RoLCBkZWx0YSkge1xuICAgIGlmIChvbGRMZW5ndGggIT09IHRoaXMubGFzdEtub3duTGVuZ3RoXykge1xuICAgICAgZGllKDE2KTtcbiAgICB9XG5cbiAgICB0aGlzLmxhc3RLbm93bkxlbmd0aF8gKz0gZGVsdGE7XG5cbiAgICBpZiAodGhpcy5sZWdhY3lNb2RlXyAmJiBkZWx0YSA+IDApIHtcbiAgICAgIHJlc2VydmVBcnJheUJ1ZmZlcihvbGRMZW5ndGggKyBkZWx0YSArIDEpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uc3BsaWNlV2l0aEFycmF5XyA9IGZ1bmN0aW9uIHNwbGljZVdpdGhBcnJheV8oaW5kZXgsIGRlbGV0ZUNvdW50LCBuZXdJdGVtcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZCh0aGlzLmF0b21fKTtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy52YWx1ZXNfLmxlbmd0aDtcblxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbmRleCA9IDA7XG4gICAgfSBlbHNlIGlmIChpbmRleCA+IGxlbmd0aCkge1xuICAgICAgaW5kZXggPSBsZW5ndGg7XG4gICAgfSBlbHNlIGlmIChpbmRleCA8IDApIHtcbiAgICAgIGluZGV4ID0gTWF0aC5tYXgoMCwgbGVuZ3RoICsgaW5kZXgpO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBkZWxldGVDb3VudCA9IGxlbmd0aCAtIGluZGV4O1xuICAgIH0gZWxzZSBpZiAoZGVsZXRlQ291bnQgPT09IHVuZGVmaW5lZCB8fCBkZWxldGVDb3VudCA9PT0gbnVsbCkge1xuICAgICAgZGVsZXRlQ291bnQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGVDb3VudCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGRlbGV0ZUNvdW50LCBsZW5ndGggLSBpbmRleCkpO1xuICAgIH1cblxuICAgIGlmIChuZXdJdGVtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdJdGVtcyA9IEVNUFRZX0FSUkFZO1xuICAgIH1cblxuICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICBvYmplY3Q6IHRoaXMucHJveHlfLFxuICAgICAgICB0eXBlOiBTUExJQ0UsXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgcmVtb3ZlZENvdW50OiBkZWxldGVDb3VudCxcbiAgICAgICAgYWRkZWQ6IG5ld0l0ZW1zXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIEVNUFRZX0FSUkFZO1xuICAgICAgfVxuXG4gICAgICBkZWxldGVDb3VudCA9IGNoYW5nZS5yZW1vdmVkQ291bnQ7XG4gICAgICBuZXdJdGVtcyA9IGNoYW5nZS5hZGRlZDtcbiAgICB9XG5cbiAgICBuZXdJdGVtcyA9IG5ld0l0ZW1zLmxlbmd0aCA9PT0gMCA/IG5ld0l0ZW1zIDogbmV3SXRlbXMubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gX3RoaXMuZW5oYW5jZXJfKHYsIHVuZGVmaW5lZCk7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5sZWdhY3lNb2RlXyB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHZhciBsZW5ndGhEZWx0YSA9IG5ld0l0ZW1zLmxlbmd0aCAtIGRlbGV0ZUNvdW50O1xuICAgICAgdGhpcy51cGRhdGVBcnJheUxlbmd0aF8obGVuZ3RoLCBsZW5ndGhEZWx0YSk7IC8vIGNoZWNrcyBpZiBpbnRlcm5hbCBhcnJheSB3YXNuJ3QgbW9kaWZpZWRcbiAgICB9XG5cbiAgICB2YXIgcmVzID0gdGhpcy5zcGxpY2VJdGVtc0ludG9WYWx1ZXNfKGluZGV4LCBkZWxldGVDb3VudCwgbmV3SXRlbXMpO1xuXG4gICAgaWYgKGRlbGV0ZUNvdW50ICE9PSAwIHx8IG5ld0l0ZW1zLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdGhpcy5ub3RpZnlBcnJheVNwbGljZV8oaW5kZXgsIG5ld0l0ZW1zLCByZXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRlaGFuY2VWYWx1ZXNfKHJlcyk7XG4gIH07XG5cbiAgX3Byb3RvLnNwbGljZUl0ZW1zSW50b1ZhbHVlc18gPSBmdW5jdGlvbiBzcGxpY2VJdGVtc0ludG9WYWx1ZXNfKGluZGV4LCBkZWxldGVDb3VudCwgbmV3SXRlbXMpIHtcbiAgICBpZiAobmV3SXRlbXMubGVuZ3RoIDwgTUFYX1NQTElDRV9TSVpFKSB7XG4gICAgICB2YXIgX3RoaXMkdmFsdWVzXztcblxuICAgICAgcmV0dXJuIChfdGhpcyR2YWx1ZXNfID0gdGhpcy52YWx1ZXNfKS5zcGxpY2UuYXBwbHkoX3RoaXMkdmFsdWVzXywgW2luZGV4LCBkZWxldGVDb3VudF0uY29uY2F0KG5ld0l0ZW1zKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBpdGVtcyByZW1vdmVkIGJ5IHRoZSBzcGxpY2VcbiAgICAgIHZhciByZXMgPSB0aGlzLnZhbHVlc18uc2xpY2UoaW5kZXgsIGluZGV4ICsgZGVsZXRlQ291bnQpOyAvLyBUaGUgaXRlbXMgdGhhdCB0aGF0IHNob3VsZCByZW1haW4gYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXlcblxuICAgICAgdmFyIG9sZEl0ZW1zID0gdGhpcy52YWx1ZXNfLnNsaWNlKGluZGV4ICsgZGVsZXRlQ291bnQpOyAvLyBOZXcgbGVuZ3RoIGlzIHRoZSBwcmV2aW91cyBsZW5ndGggKyBhZGRpdGlvbiBjb3VudCAtIGRlbGV0aW9uIGNvdW50XG5cbiAgICAgIHRoaXMudmFsdWVzXy5sZW5ndGggKz0gbmV3SXRlbXMubGVuZ3RoIC0gZGVsZXRlQ291bnQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3SXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy52YWx1ZXNfW2luZGV4ICsgaV0gPSBuZXdJdGVtc1tpXTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG9sZEl0ZW1zLmxlbmd0aDsgX2krKykge1xuICAgICAgICB0aGlzLnZhbHVlc19baW5kZXggKyBuZXdJdGVtcy5sZW5ndGggKyBfaV0gPSBvbGRJdGVtc1tfaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5ub3RpZnlBcnJheUNoaWxkVXBkYXRlXyA9IGZ1bmN0aW9uIG5vdGlmeUFycmF5Q2hpbGRVcGRhdGVfKGluZGV4LCBuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICB2YXIgbm90aWZ5U3B5ID0gIXRoaXMub3duZWRfICYmIGlzU3B5RW5hYmxlZCgpO1xuICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgdmFyIGNoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICBvYnNlcnZhYmxlS2luZDogXCJhcnJheVwiLFxuICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyxcbiAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5hdG9tXy5uYW1lXyxcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZVxuICAgIH0gOiBudWxsOyAvLyBUaGUgcmVhc29uIHdoeSB0aGlzIGlzIG9uIHJpZ2h0IGhhbmQgc2lkZSBoZXJlIChhbmQgbm90IGFib3ZlKSwgaXMgdGhpcyB3YXkgdGhlIHVnbGlmaWVyIHdpbGwgZHJvcCBpdCwgYnV0IGl0IHdvbid0XG4gICAgLy8gY2F1c2UgYW55IHJ1bnRpbWUgb3ZlcmhlYWQgaW4gZGV2ZWxvcG1lbnQgbW9kZSB3aXRob3V0IE5PREVfRU5WIHNldCwgdW5sZXNzIHNweWluZyBpcyBlbmFibGVkXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSkge1xuICAgICAgc3B5UmVwb3J0U3RhcnQoY2hhbmdlKTtcbiAgICB9XG5cbiAgICB0aGlzLmF0b21fLnJlcG9ydENoYW5nZWQoKTtcblxuICAgIGlmIChub3RpZnkpIHtcbiAgICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBjaGFuZ2UpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSB7XG4gICAgICBzcHlSZXBvcnRFbmQoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm5vdGlmeUFycmF5U3BsaWNlXyA9IGZ1bmN0aW9uIG5vdGlmeUFycmF5U3BsaWNlXyhpbmRleCwgYWRkZWQsIHJlbW92ZWQpIHtcbiAgICB2YXIgbm90aWZ5U3B5ID0gIXRoaXMub3duZWRfICYmIGlzU3B5RW5hYmxlZCgpO1xuICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgdmFyIGNoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICBvYnNlcnZhYmxlS2luZDogXCJhcnJheVwiLFxuICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyxcbiAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5hdG9tXy5uYW1lXyxcbiAgICAgIHR5cGU6IFNQTElDRSxcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIHJlbW92ZWQ6IHJlbW92ZWQsXG4gICAgICBhZGRlZDogYWRkZWQsXG4gICAgICByZW1vdmVkQ291bnQ6IHJlbW92ZWQubGVuZ3RoLFxuICAgICAgYWRkZWRDb3VudDogYWRkZWQubGVuZ3RoXG4gICAgfSA6IG51bGw7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSkge1xuICAgICAgc3B5UmVwb3J0U3RhcnQoY2hhbmdlKTtcbiAgICB9XG5cbiAgICB0aGlzLmF0b21fLnJlcG9ydENoYW5nZWQoKTsgLy8gY29uZm9ybTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvb2JzZXJ2ZVxuXG4gICAgaWYgKG5vdGlmeSkge1xuICAgICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIGNoYW5nZSk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHtcbiAgICAgIHNweVJlcG9ydEVuZCgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZ2V0XyA9IGZ1bmN0aW9uIGdldF8oaW5kZXgpIHtcbiAgICBpZiAodGhpcy5sZWdhY3lNb2RlXyAmJiBpbmRleCA+PSB0aGlzLnZhbHVlc18ubGVuZ3RoKSB7XG4gICAgICBjb25zb2xlLndhcm4ocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJbbW9ieC5hcnJheV0gQXR0ZW1wdCB0byByZWFkIGFuIGFycmF5IGluZGV4IChcIiArIGluZGV4ICsgXCIpIHRoYXQgaXMgb3V0IG9mIGJvdW5kcyAoXCIgKyB0aGlzLnZhbHVlc18ubGVuZ3RoICsgXCIpLiBQbGVhc2UgY2hlY2sgbGVuZ3RoIGZpcnN0LiBPdXQgb2YgYm91bmQgaW5kaWNlcyB3aWxsIG5vdCBiZSB0cmFja2VkIGJ5IE1vYlhcIiA6IFwiW21vYnhdIE91dCBvZiBib3VuZHMgcmVhZDogXCIgKyBpbmRleCk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRoaXMuYXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICByZXR1cm4gdGhpcy5kZWhhbmNlVmFsdWVfKHRoaXMudmFsdWVzX1tpbmRleF0pO1xuICB9O1xuXG4gIF9wcm90by5zZXRfID0gZnVuY3Rpb24gc2V0XyhpbmRleCwgbmV3VmFsdWUpIHtcbiAgICB2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXNfO1xuXG4gICAgaWYgKHRoaXMubGVnYWN5TW9kZV8gJiYgaW5kZXggPiB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAvLyBvdXQgb2YgYm91bmRzXG4gICAgICBkaWUoMTcsIGluZGV4LCB2YWx1ZXMubGVuZ3RoKTtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggPCB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAvLyB1cGRhdGUgYXQgaW5kZXggaW4gcmFuZ2VcbiAgICAgIGNoZWNrSWZTdGF0ZU1vZGlmaWNhdGlvbnNBcmVBbGxvd2VkKHRoaXMuYXRvbV8pO1xuICAgICAgdmFyIG9sZFZhbHVlID0gdmFsdWVzW2luZGV4XTtcblxuICAgICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgICB0eXBlOiBVUERBVEUsXG4gICAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyxcbiAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghY2hhbmdlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3VmFsdWUgPSBjaGFuZ2UubmV3VmFsdWU7XG4gICAgICB9XG5cbiAgICAgIG5ld1ZhbHVlID0gdGhpcy5lbmhhbmNlcl8obmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIHZhciBjaGFuZ2VkID0gbmV3VmFsdWUgIT09IG9sZFZhbHVlO1xuXG4gICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICB2YWx1ZXNbaW5kZXhdID0gbmV3VmFsdWU7XG4gICAgICAgIHRoaXMubm90aWZ5QXJyYXlDaGlsZFVwZGF0ZV8oaW5kZXgsIG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBvdXQgb2YgYm91bmQgaW5kZXgsIHdlIGRvbid0IGNyZWF0ZSBhbiBhY3R1YWwgc3BhcnNlIGFycmF5LFxuICAgICAgLy8gYnV0IHJhdGhlciBmaWxsIHRoZSBob2xlcyB3aXRoIHVuZGVmaW5lZCAoc2FtZSBhcyBzZXRBcnJheUxlbmd0aF8pLlxuICAgICAgLy8gVGhpcyBjb3VsZCBiZSBjb25zaWRlcmVkIGEgYnVnLlxuICAgICAgdmFyIG5ld0l0ZW1zID0gbmV3IEFycmF5KGluZGV4ICsgMSAtIHZhbHVlcy5sZW5ndGgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0l0ZW1zLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBuZXdJdGVtc1tpXSA9IHVuZGVmaW5lZDtcbiAgICAgIH0gLy8gTm8gQXJyYXkuZmlsbCBldmVyeXdoZXJlLi4uXG5cblxuICAgICAgbmV3SXRlbXNbbmV3SXRlbXMubGVuZ3RoIC0gMV0gPSBuZXdWYWx1ZTtcbiAgICAgIHRoaXMuc3BsaWNlV2l0aEFycmF5Xyh2YWx1ZXMubGVuZ3RoLCAwLCBuZXdJdGVtcyk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbjtcbn0oKTtcbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmFibGVBcnJheShpbml0aWFsVmFsdWVzLCBlbmhhbmNlciwgbmFtZSwgb3duZWQpIHtcbiAgaWYgKG5hbWUgPT09IHZvaWQgMCkge1xuICAgIG5hbWUgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIk9ic2VydmFibGVBcnJheUBcIiArIGdldE5leHRJZCgpIDogXCJPYnNlcnZhYmxlQXJyYXlcIjtcbiAgfVxuXG4gIGlmIChvd25lZCA9PT0gdm9pZCAwKSB7XG4gICAgb3duZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGFzc2VydFByb3hpZXMoKTtcbiAgdmFyIGFkbSA9IG5ldyBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbihuYW1lLCBlbmhhbmNlciwgb3duZWQsIGZhbHNlKTtcbiAgYWRkSGlkZGVuRmluYWxQcm9wKGFkbS52YWx1ZXNfLCAkbW9ieCwgYWRtKTtcbiAgdmFyIHByb3h5ID0gbmV3IFByb3h5KGFkbS52YWx1ZXNfLCBhcnJheVRyYXBzKTtcbiAgYWRtLnByb3h5XyA9IHByb3h5O1xuXG4gIGlmIChpbml0aWFsVmFsdWVzICYmIGluaXRpYWxWYWx1ZXMubGVuZ3RoKSB7XG4gICAgdmFyIHByZXYgPSBhbGxvd1N0YXRlQ2hhbmdlc1N0YXJ0KHRydWUpO1xuICAgIGFkbS5zcGxpY2VXaXRoQXJyYXlfKDAsIDAsIGluaXRpYWxWYWx1ZXMpO1xuICAgIGFsbG93U3RhdGVDaGFuZ2VzRW5kKHByZXYpO1xuICB9XG5cbiAgcmV0dXJuIHByb3h5O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcblxudmFyIGFycmF5RXh0ZW5zaW9ucyA9IHtcbiAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHJldHVybiB0aGlzLnNwbGljZSgwKTtcbiAgfSxcbiAgcmVwbGFjZTogZnVuY3Rpb24gcmVwbGFjZShuZXdJdGVtcykge1xuICAgIHZhciBhZG0gPSB0aGlzWyRtb2J4XTtcbiAgICByZXR1cm4gYWRtLnNwbGljZVdpdGhBcnJheV8oMCwgYWRtLnZhbHVlc18ubGVuZ3RoLCBuZXdJdGVtcyk7XG4gIH0sXG4gIC8vIFVzZWQgYnkgSlNPTi5zdHJpbmdpZnlcbiAgdG9KU09OOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2xpY2UoKTtcbiAgfSxcblxuICAvKlxyXG4gICAqIGZ1bmN0aW9ucyB0aGF0IGRvIGFsdGVyIHRoZSBpbnRlcm5hbCBzdHJ1Y3R1cmUgb2YgdGhlIGFycmF5LCAoYmFzZWQgb24gbGliLmVzNi5kLnRzKVxyXG4gICAqIHNpbmNlIHRoZXNlIGZ1bmN0aW9ucyBhbHRlciB0aGUgaW5uZXIgc3RydWN0dXJlIG9mIHRoZSBhcnJheSwgdGhlIGhhdmUgc2lkZSBlZmZlY3RzLlxyXG4gICAqIEJlY2F1c2UgdGhlIGhhdmUgc2lkZSBlZmZlY3RzLCB0aGV5IHNob3VsZCBub3QgYmUgdXNlZCBpbiBjb21wdXRlZCBmdW5jdGlvbixcclxuICAgKiBhbmQgZm9yIHRoYXQgcmVhc29uIHRoZSBkbyBub3QgY2FsbCBkZXBlbmRlbmN5U3RhdGUubm90aWZ5T2JzZXJ2ZWRcclxuICAgKi9cbiAgc3BsaWNlOiBmdW5jdGlvbiBzcGxpY2UoaW5kZXgsIGRlbGV0ZUNvdW50KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG5ld0l0ZW1zID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIG5ld0l0ZW1zW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYWRtID0gdGhpc1skbW9ieF07XG5cbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIFtdO1xuXG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBhZG0uc3BsaWNlV2l0aEFycmF5XyhpbmRleCk7XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIGFkbS5zcGxpY2VXaXRoQXJyYXlfKGluZGV4LCBkZWxldGVDb3VudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkbS5zcGxpY2VXaXRoQXJyYXlfKGluZGV4LCBkZWxldGVDb3VudCwgbmV3SXRlbXMpO1xuICB9LFxuICBzcGxpY2VXaXRoQXJyYXk6IGZ1bmN0aW9uIHNwbGljZVdpdGhBcnJheShpbmRleCwgZGVsZXRlQ291bnQsIG5ld0l0ZW1zKSB7XG4gICAgcmV0dXJuIHRoaXNbJG1vYnhdLnNwbGljZVdpdGhBcnJheV8oaW5kZXgsIGRlbGV0ZUNvdW50LCBuZXdJdGVtcyk7XG4gIH0sXG4gIHB1c2g6IGZ1bmN0aW9uIHB1c2goKSB7XG4gICAgdmFyIGFkbSA9IHRoaXNbJG1vYnhdO1xuXG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBpdGVtcyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgaXRlbXNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBhZG0uc3BsaWNlV2l0aEFycmF5XyhhZG0udmFsdWVzXy5sZW5ndGgsIDAsIGl0ZW1zKTtcbiAgICByZXR1cm4gYWRtLnZhbHVlc18ubGVuZ3RoO1xuICB9LFxuICBwb3A6IGZ1bmN0aW9uIHBvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5zcGxpY2UoTWF0aC5tYXgodGhpc1skbW9ieF0udmFsdWVzXy5sZW5ndGggLSAxLCAwKSwgMSlbMF07XG4gIH0sXG4gIHNoaWZ0OiBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5zcGxpY2UoMCwgMSlbMF07XG4gIH0sXG4gIHVuc2hpZnQ6IGZ1bmN0aW9uIHVuc2hpZnQoKSB7XG4gICAgdmFyIGFkbSA9IHRoaXNbJG1vYnhdO1xuXG4gICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBpdGVtcyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgaXRlbXNbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICB9XG5cbiAgICBhZG0uc3BsaWNlV2l0aEFycmF5XygwLCAwLCBpdGVtcyk7XG4gICAgcmV0dXJuIGFkbS52YWx1ZXNfLmxlbmd0aDtcbiAgfSxcbiAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSgpIHtcbiAgICAvLyByZXZlcnNlIGJ5IGRlZmF1bHQgbXV0YXRlcyBpbiBwbGFjZSBiZWZvcmUgcmV0dXJuaW5nIHRoZSByZXN1bHRcbiAgICAvLyB3aGljaCBtYWtlcyBpdCBib3RoIGEgJ2Rlcml2YXRpb24nIGFuZCBhICdtdXRhdGlvbicuXG4gICAgaWYgKGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbikge1xuICAgICAgZGllKDM3LCBcInJldmVyc2VcIik7XG4gICAgfVxuXG4gICAgdGhpcy5yZXBsYWNlKHRoaXMuc2xpY2UoKS5yZXZlcnNlKCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzb3J0OiBmdW5jdGlvbiBzb3J0KCkge1xuICAgIC8vIHNvcnQgYnkgZGVmYXVsdCBtdXRhdGVzIGluIHBsYWNlIGJlZm9yZSByZXR1cm5pbmcgdGhlIHJlc3VsdFxuICAgIC8vIHdoaWNoIGdvZXMgYWdhaW5zdCBhbGwgZ29vZCBwcmFjdGljZXMuIExldCdzIG5vdCBjaGFuZ2UgdGhlIGFycmF5IGluIHBsYWNlIVxuICAgIGlmIChnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24pIHtcbiAgICAgIGRpZSgzNywgXCJzb3J0XCIpO1xuICAgIH1cblxuICAgIHZhciBjb3B5ID0gdGhpcy5zbGljZSgpO1xuICAgIGNvcHkuc29ydC5hcHBseShjb3B5LCBhcmd1bWVudHMpO1xuICAgIHRoaXMucmVwbGFjZShjb3B5KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUodmFsdWUpIHtcbiAgICB2YXIgYWRtID0gdGhpc1skbW9ieF07XG4gICAgdmFyIGlkeCA9IGFkbS5kZWhhbmNlVmFsdWVzXyhhZG0udmFsdWVzXykuaW5kZXhPZih2YWx1ZSk7XG5cbiAgICBpZiAoaWR4ID4gLTEpIHtcbiAgICAgIHRoaXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG4vKipcclxuICogV3JhcCBmdW5jdGlvbiBmcm9tIHByb3RvdHlwZVxyXG4gKiBXaXRob3V0IHRoaXMsIGV2ZXJ5dGhpbmcgd29ya3MgYXMgd2VsbCwgYnV0IHRoaXMgd29ya3NcclxuICogZmFzdGVyIGFzIGV2ZXJ5dGhpbmcgd29ya3Mgb24gdW5wcm94aWVkIHZhbHVlc1xyXG4gKi9cblxuYWRkQXJyYXlFeHRlbnNpb24oXCJjb25jYXRcIiwgc2ltcGxlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImZsYXRcIiwgc2ltcGxlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImluY2x1ZGVzXCIsIHNpbXBsZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJpbmRleE9mXCIsIHNpbXBsZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJqb2luXCIsIHNpbXBsZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJsYXN0SW5kZXhPZlwiLCBzaW1wbGVGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwic2xpY2VcIiwgc2ltcGxlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcInRvU3RyaW5nXCIsIHNpbXBsZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJ0b0xvY2FsZVN0cmluZ1wiLCBzaW1wbGVGdW5jKTsgLy8gbWFwXG5cbmFkZEFycmF5RXh0ZW5zaW9uKFwiZXZlcnlcIiwgbWFwTGlrZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJmaWx0ZXJcIiwgbWFwTGlrZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJmaW5kXCIsIG1hcExpa2VGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwiZmluZEluZGV4XCIsIG1hcExpa2VGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwiZmxhdE1hcFwiLCBtYXBMaWtlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImZvckVhY2hcIiwgbWFwTGlrZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJtYXBcIiwgbWFwTGlrZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJzb21lXCIsIG1hcExpa2VGdW5jKTsgLy8gcmVkdWNlXG5cbmFkZEFycmF5RXh0ZW5zaW9uKFwicmVkdWNlXCIsIHJlZHVjZUxpa2VGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwicmVkdWNlUmlnaHRcIiwgcmVkdWNlTGlrZUZ1bmMpO1xuXG5mdW5jdGlvbiBhZGRBcnJheUV4dGVuc2lvbihmdW5jTmFtZSwgZnVuY0ZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBBcnJheS5wcm90b3R5cGVbZnVuY05hbWVdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBhcnJheUV4dGVuc2lvbnNbZnVuY05hbWVdID0gZnVuY0ZhY3RvcnkoZnVuY05hbWUpO1xuICB9XG59IC8vIFJlcG9ydCBhbmQgZGVsZWdhdGUgdG8gZGVoYW5jZWQgYXJyYXlcblxuXG5mdW5jdGlvbiBzaW1wbGVGdW5jKGZ1bmNOYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFkbSA9IHRoaXNbJG1vYnhdO1xuICAgIGFkbS5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHZhciBkZWhhbmNlZFZhbHVlcyA9IGFkbS5kZWhhbmNlVmFsdWVzXyhhZG0udmFsdWVzXyk7XG4gICAgcmV0dXJuIGRlaGFuY2VkVmFsdWVzW2Z1bmNOYW1lXS5hcHBseShkZWhhbmNlZFZhbHVlcywgYXJndW1lbnRzKTtcbiAgfTtcbn0gLy8gTWFrZSBzdXJlIGNhbGxiYWNrcyByZWNpZXZlIGNvcnJlY3QgYXJyYXkgYXJnICMyMzI2XG5cblxuZnVuY3Rpb24gbWFwTGlrZUZ1bmMoZnVuY05hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIGFkbSA9IHRoaXNbJG1vYnhdO1xuICAgIGFkbS5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHZhciBkZWhhbmNlZFZhbHVlcyA9IGFkbS5kZWhhbmNlVmFsdWVzXyhhZG0udmFsdWVzXyk7XG4gICAgcmV0dXJuIGRlaGFuY2VkVmFsdWVzW2Z1bmNOYW1lXShmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIGVsZW1lbnQsIGluZGV4LCBfdGhpczIpO1xuICAgIH0pO1xuICB9O1xufSAvLyBNYWtlIHN1cmUgY2FsbGJhY2tzIHJlY2lldmUgY29ycmVjdCBhcnJheSBhcmcgIzIzMjZcblxuXG5mdW5jdGlvbiByZWR1Y2VMaWtlRnVuYyhmdW5jTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgdmFyIGFkbSA9IHRoaXNbJG1vYnhdO1xuICAgIGFkbS5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHZhciBkZWhhbmNlZFZhbHVlcyA9IGFkbS5kZWhhbmNlVmFsdWVzXyhhZG0udmFsdWVzXyk7IC8vICMyNDMyIC0gcmVkdWNlIGJlaGF2aW9yIGRlcGVuZHMgb24gYXJndW1lbnRzLmxlbmd0aFxuXG4gICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzBdO1xuXG4gICAgYXJndW1lbnRzWzBdID0gZnVuY3Rpb24gKGFjY3VtdWxhdG9yLCBjdXJyZW50VmFsdWUsIGluZGV4KSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soYWNjdW11bGF0b3IsIGN1cnJlbnRWYWx1ZSwgaW5kZXgsIF90aGlzMyk7XG4gICAgfTtcblxuICAgIHJldHVybiBkZWhhbmNlZFZhbHVlc1tmdW5jTmFtZV0uYXBwbHkoZGVoYW5jZWRWYWx1ZXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbnZhciBpc09ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUoXCJPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvblwiLCBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbik7XG5mdW5jdGlvbiBpc09ic2VydmFibGVBcnJheSh0aGluZykge1xuICByZXR1cm4gaXNPYmplY3QodGhpbmcpICYmIGlzT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24odGhpbmdbJG1vYnhdKTtcbn1cblxudmFyIF9TeW1ib2wkaXRlcmF0b3IsIF9TeW1ib2wkdG9TdHJpbmdUYWc7XG52YXIgT2JzZXJ2YWJsZU1hcE1hcmtlciA9IHt9O1xudmFyIEFERCA9IFwiYWRkXCI7XG52YXIgREVMRVRFID0gXCJkZWxldGVcIjsgLy8ganVzdCBleHRlbmQgTWFwPyBTZWUgYWxzbyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9uZXN0aGFydXMvMTNiNGQ3NGYyZWY0YTJmNDM1N2RiZDNmYzIzYzFlNTRcbi8vIEJ1dDogaHR0cHM6Ly9naXRodWIuY29tL21vYnhqcy9tb2J4L2lzc3Vlcy8xNTU2XG5cbl9TeW1ib2wkaXRlcmF0b3IgPSBTeW1ib2wuaXRlcmF0b3I7XG5fU3ltYm9sJHRvU3RyaW5nVGFnID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xudmFyIE9ic2VydmFibGVNYXAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvLyBoYXNNYXAsIG5vdCBoYXNoTWFwID4tKS5cbiAgZnVuY3Rpb24gT2JzZXJ2YWJsZU1hcChpbml0aWFsRGF0YSwgZW5oYW5jZXJfLCBuYW1lXykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoZW5oYW5jZXJfID09PSB2b2lkIDApIHtcbiAgICAgIGVuaGFuY2VyXyA9IGRlZXBFbmhhbmNlcjtcbiAgICB9XG5cbiAgICBpZiAobmFtZV8gPT09IHZvaWQgMCkge1xuICAgICAgbmFtZV8gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIk9ic2VydmFibGVNYXBAXCIgKyBnZXROZXh0SWQoKSA6IFwiT2JzZXJ2YWJsZU1hcFwiO1xuICAgIH1cblxuICAgIHRoaXMuZW5oYW5jZXJfID0gdm9pZCAwO1xuICAgIHRoaXMubmFtZV8gPSB2b2lkIDA7XG4gICAgdGhpc1skbW9ieF0gPSBPYnNlcnZhYmxlTWFwTWFya2VyO1xuICAgIHRoaXMuZGF0YV8gPSB2b2lkIDA7XG4gICAgdGhpcy5oYXNNYXBfID0gdm9pZCAwO1xuICAgIHRoaXMua2V5c0F0b21fID0gdm9pZCAwO1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzXyA9IHZvaWQgMDtcbiAgICB0aGlzLmNoYW5nZUxpc3RlbmVyc18gPSB2b2lkIDA7XG4gICAgdGhpcy5kZWhhbmNlciA9IHZvaWQgMDtcbiAgICB0aGlzLmVuaGFuY2VyXyA9IGVuaGFuY2VyXztcbiAgICB0aGlzLm5hbWVfID0gbmFtZV87XG5cbiAgICBpZiAoIWlzRnVuY3Rpb24oTWFwKSkge1xuICAgICAgZGllKDE4KTtcbiAgICB9XG5cbiAgICB0aGlzLmtleXNBdG9tXyA9IGNyZWF0ZUF0b20ocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gdGhpcy5uYW1lXyArIFwiLmtleXMoKVwiIDogXCJPYnNlcnZhYmxlTWFwLmtleXMoKVwiKTtcbiAgICB0aGlzLmRhdGFfID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuaGFzTWFwXyA9IG5ldyBNYXAoKTtcbiAgICBhbGxvd1N0YXRlQ2hhbmdlcyh0cnVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5tZXJnZShpbml0aWFsRGF0YSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gT2JzZXJ2YWJsZU1hcC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmhhc18gPSBmdW5jdGlvbiBoYXNfKGtleSkge1xuICAgIHJldHVybiB0aGlzLmRhdGFfLmhhcyhrZXkpO1xuICB9O1xuXG4gIF9wcm90by5oYXMgPSBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBpZiAoIWdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzXyhrZXkpO1xuICAgIH1cblxuICAgIHZhciBlbnRyeSA9IHRoaXMuaGFzTWFwXy5nZXQoa2V5KTtcblxuICAgIGlmICghZW50cnkpIHtcbiAgICAgIHZhciBuZXdFbnRyeSA9IGVudHJ5ID0gbmV3IE9ic2VydmFibGVWYWx1ZSh0aGlzLmhhc18oa2V5KSwgcmVmZXJlbmNlRW5oYW5jZXIsIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHRoaXMubmFtZV8gKyBcIi5cIiArIHN0cmluZ2lmeUtleShrZXkpICsgXCI/XCIgOiBcIk9ic2VydmFibGVNYXAua2V5P1wiLCBmYWxzZSk7XG4gICAgICB0aGlzLmhhc01hcF8uc2V0KGtleSwgbmV3RW50cnkpO1xuICAgICAgb25CZWNvbWVVbm9ic2VydmVkKG5ld0VudHJ5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuaGFzTWFwX1tcImRlbGV0ZVwiXShrZXkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudHJ5LmdldCgpO1xuICB9O1xuXG4gIF9wcm90by5zZXQgPSBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBoYXNLZXkgPSB0aGlzLmhhc18oa2V5KTtcblxuICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICB0eXBlOiBoYXNLZXkgPyBVUERBVEUgOiBBREQsXG4gICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgbmV3VmFsdWU6IHZhbHVlLFxuICAgICAgICBuYW1lOiBrZXlcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWNoYW5nZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFsdWUgPSBjaGFuZ2UubmV3VmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGhhc0tleSkge1xuICAgICAgdGhpcy51cGRhdGVWYWx1ZV8oa2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkVmFsdWVfKGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90b1tcImRlbGV0ZVwiXSA9IGZ1bmN0aW9uIF9kZWxldGUoa2V5KSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICBjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZCh0aGlzLmtleXNBdG9tXyk7XG5cbiAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgdHlwZTogREVMRVRFLFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG5hbWU6IGtleVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghY2hhbmdlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNfKGtleSkpIHtcbiAgICAgIHZhciBub3RpZnlTcHkgPSBpc1NweUVuYWJsZWQoKTtcbiAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG5cbiAgICAgIHZhciBfY2hhbmdlID0gbm90aWZ5IHx8IG5vdGlmeVNweSA/IHtcbiAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwibWFwXCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgdHlwZTogREVMRVRFLFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG9sZFZhbHVlOiB0aGlzLmRhdGFfLmdldChrZXkpLnZhbHVlXyxcbiAgICAgICAgbmFtZToga2V5XG4gICAgICB9IDogbnVsbDtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHtcbiAgICAgICAgc3B5UmVwb3J0U3RhcnQoX2NoYW5nZSk7XG4gICAgICB9IC8vIFRPRE8gZml4IHR5cGVcblxuXG4gICAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpczMkaGFzTWFwXyRnZXQ7XG5cbiAgICAgICAgX3RoaXMzLmtleXNBdG9tXy5yZXBvcnRDaGFuZ2VkKCk7XG5cbiAgICAgICAgKF90aGlzMyRoYXNNYXBfJGdldCA9IF90aGlzMy5oYXNNYXBfLmdldChrZXkpKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMzJGhhc01hcF8kZ2V0LnNldE5ld1ZhbHVlXyhmYWxzZSk7XG5cbiAgICAgICAgdmFyIG9ic2VydmFibGUgPSBfdGhpczMuZGF0YV8uZ2V0KGtleSk7XG5cbiAgICAgICAgb2JzZXJ2YWJsZS5zZXROZXdWYWx1ZV8odW5kZWZpbmVkKTtcblxuICAgICAgICBfdGhpczMuZGF0YV9bXCJkZWxldGVcIl0oa2V5KTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobm90aWZ5KSB7XG4gICAgICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBfY2hhbmdlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHtcbiAgICAgICAgc3B5UmVwb3J0RW5kKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8udXBkYXRlVmFsdWVfID0gZnVuY3Rpb24gdXBkYXRlVmFsdWVfKGtleSwgbmV3VmFsdWUpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZSA9IHRoaXMuZGF0YV8uZ2V0KGtleSk7XG4gICAgbmV3VmFsdWUgPSBvYnNlcnZhYmxlLnByZXBhcmVOZXdWYWx1ZV8obmV3VmFsdWUpO1xuXG4gICAgaWYgKG5ld1ZhbHVlICE9PSBnbG9iYWxTdGF0ZS5VTkNIQU5HRUQpIHtcbiAgICAgIHZhciBub3RpZnlTcHkgPSBpc1NweUVuYWJsZWQoKTtcbiAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgICB2YXIgY2hhbmdlID0gbm90aWZ5IHx8IG5vdGlmeVNweSA/IHtcbiAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwibWFwXCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG9sZFZhbHVlOiBvYnNlcnZhYmxlLnZhbHVlXyxcbiAgICAgICAgbmFtZToga2V5LFxuICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcbiAgICAgIH0gOiBudWxsO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSkge1xuICAgICAgICBzcHlSZXBvcnRTdGFydChjaGFuZ2UpO1xuICAgICAgfSAvLyBUT0RPIGZpeCB0eXBlXG5cblxuICAgICAgb2JzZXJ2YWJsZS5zZXROZXdWYWx1ZV8obmV3VmFsdWUpO1xuXG4gICAgICBpZiAobm90aWZ5KSB7XG4gICAgICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBjaGFuZ2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSkge1xuICAgICAgICBzcHlSZXBvcnRFbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmFkZFZhbHVlXyA9IGZ1bmN0aW9uIGFkZFZhbHVlXyhrZXksIG5ld1ZhbHVlKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICBjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZCh0aGlzLmtleXNBdG9tXyk7XG4gICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzNCRoYXNNYXBfJGdldDtcblxuICAgICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZVZhbHVlKG5ld1ZhbHVlLCBfdGhpczQuZW5oYW5jZXJfLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBfdGhpczQubmFtZV8gKyBcIi5cIiArIHN0cmluZ2lmeUtleShrZXkpIDogXCJPYnNlcnZhYmxlTWFwLmtleVwiLCBmYWxzZSk7XG5cbiAgICAgIF90aGlzNC5kYXRhXy5zZXQoa2V5LCBvYnNlcnZhYmxlKTtcblxuICAgICAgbmV3VmFsdWUgPSBvYnNlcnZhYmxlLnZhbHVlXzsgLy8gdmFsdWUgbWlnaHQgaGF2ZSBiZWVuIGNoYW5nZWRcblxuICAgICAgKF90aGlzNCRoYXNNYXBfJGdldCA9IF90aGlzNC5oYXNNYXBfLmdldChrZXkpKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXM0JGhhc01hcF8kZ2V0LnNldE5ld1ZhbHVlXyh0cnVlKTtcblxuICAgICAgX3RoaXM0LmtleXNBdG9tXy5yZXBvcnRDaGFuZ2VkKCk7XG4gICAgfSk7XG4gICAgdmFyIG5vdGlmeVNweSA9IGlzU3B5RW5hYmxlZCgpO1xuICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgdmFyIGNoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICBvYnNlcnZhYmxlS2luZDogXCJtYXBcIixcbiAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgIHR5cGU6IEFERCxcbiAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgIG5hbWU6IGtleSxcbiAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgIH0gOiBudWxsO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHtcbiAgICAgIHNweVJlcG9ydFN0YXJ0KGNoYW5nZSk7XG4gICAgfSAvLyBUT0RPIGZpeCB0eXBlXG5cblxuICAgIGlmIChub3RpZnkpIHtcbiAgICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBjaGFuZ2UpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSB7XG4gICAgICBzcHlSZXBvcnRFbmQoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICBpZiAodGhpcy5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVoYW5jZVZhbHVlXyh0aGlzLmRhdGFfLmdldChrZXkpLmdldCgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kZWhhbmNlVmFsdWVfKHVuZGVmaW5lZCk7XG4gIH07XG5cbiAgX3Byb3RvLmRlaGFuY2VWYWx1ZV8gPSBmdW5jdGlvbiBkZWhhbmNlVmFsdWVfKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZGVoYW5jZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVoYW5jZXIodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBfcHJvdG8ua2V5cyA9IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgdGhpcy5rZXlzQXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICByZXR1cm4gdGhpcy5kYXRhXy5rZXlzKCk7XG4gIH07XG5cbiAgX3Byb3RvLnZhbHVlcyA9IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGtleXMgPSB0aGlzLmtleXMoKTtcbiAgICByZXR1cm4gbWFrZUl0ZXJhYmxlKHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHZhciBfa2V5cyRuZXh0ID0ga2V5cy5uZXh0KCksXG4gICAgICAgICAgICBkb25lID0gX2tleXMkbmV4dC5kb25lLFxuICAgICAgICAgICAgdmFsdWUgPSBfa2V5cyRuZXh0LnZhbHVlO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogZG9uZSxcbiAgICAgICAgICB2YWx1ZTogZG9uZSA/IHVuZGVmaW5lZCA6IHNlbGYuZ2V0KHZhbHVlKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5lbnRyaWVzID0gZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGtleXMgPSB0aGlzLmtleXMoKTtcbiAgICByZXR1cm4gbWFrZUl0ZXJhYmxlKHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHZhciBfa2V5cyRuZXh0MiA9IGtleXMubmV4dCgpLFxuICAgICAgICAgICAgZG9uZSA9IF9rZXlzJG5leHQyLmRvbmUsXG4gICAgICAgICAgICB2YWx1ZSA9IF9rZXlzJG5leHQyLnZhbHVlO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogZG9uZSxcbiAgICAgICAgICB2YWx1ZTogZG9uZSA/IHVuZGVmaW5lZCA6IFt2YWx1ZSwgc2VsZi5nZXQodmFsdWUpXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90b1tfU3ltYm9sJGl0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG4gIH07XG5cbiAgX3Byb3RvLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSh0aGlzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcbiAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zdGVwLnZhbHVlLFxuICAgICAgICAgIGtleSA9IF9zdGVwJHZhbHVlWzBdLFxuICAgICAgICAgIHZhbHVlID0gX3N0ZXAkdmFsdWVbMV07XG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBrZXksIHRoaXMpO1xuICAgIH1cbiAgfVxuICAvKiogTWVyZ2UgYW5vdGhlciBvYmplY3QgaW50byB0aGlzIG9iamVjdCwgcmV0dXJucyB0aGlzLiAqL1xuICA7XG5cbiAgX3Byb3RvLm1lcmdlID0gZnVuY3Rpb24gbWVyZ2Uob3RoZXIpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIGlmIChpc09ic2VydmFibGVNYXAob3RoZXIpKSB7XG4gICAgICBvdGhlciA9IG5ldyBNYXAob3RoZXIpO1xuICAgIH1cblxuICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KG90aGVyKSkge1xuICAgICAgICBnZXRQbGFpbk9iamVjdEtleXMob3RoZXIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczUuc2V0KGtleSwgb3RoZXJba2V5XSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG90aGVyKSkge1xuICAgICAgICBvdGhlci5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgdmFyIGtleSA9IF9yZWZbMF0sXG4gICAgICAgICAgICAgIHZhbHVlID0gX3JlZlsxXTtcbiAgICAgICAgICByZXR1cm4gX3RoaXM1LnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRVM2TWFwKG90aGVyKSkge1xuICAgICAgICBpZiAob3RoZXIuY29uc3RydWN0b3IgIT09IE1hcCkge1xuICAgICAgICAgIGRpZSgxOSwgb3RoZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXIuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczUuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAob3RoZXIgIT09IG51bGwgJiYgb3RoZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkaWUoMjAsIG90aGVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIHVudHJhY2tlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKF90aGlzNi5rZXlzKCkpLCBfc3RlcDI7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBrZXkgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICBfdGhpczZbXCJkZWxldGVcIl0oa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHZhbHVlcykge1xuICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgLy8gSW1wbGVtZW50YXRpb24gcmVxdWlyZW1lbnRzOlxuICAgIC8vIC0gcmVzcGVjdCBvcmRlcmluZyBvZiByZXBsYWNlbWVudCBtYXBcbiAgICAvLyAtIGFsbG93IGludGVyY2VwdG9ycyB0byBydW4gYW5kIHBvdGVudGlhbGx5IHByZXZlbnQgaW5kaXZpZHVhbCBvcGVyYXRpb25zXG4gICAgLy8gLSBkb24ndCByZWNyZWF0ZSBvYnNlcnZhYmxlcyB0aGF0IGFscmVhZHkgZXhpc3QgaW4gb3JpZ2luYWwgbWFwIChzbyB3ZSBkb24ndCBkZXN0cm95IGV4aXN0aW5nIHN1YnNjcmlwdGlvbnMpXG4gICAgLy8gLSBkb24ndCBfa2V5c0F0b20ucmVwb3J0Q2hhbmdlZCBpZiB0aGUga2V5cyBvZiByZXN1bHRpbmcgbWFwIGFyZSBpbmRlbnRpY2FsIChvcmRlciBtYXR0ZXJzISlcbiAgICAvLyAtIG5vdGUgdGhhdCByZXN1bHQgbWFwIG1heSBkaWZmZXIgZnJvbSByZXBsYWNlbWVudCBtYXAgZHVlIHRvIHRoZSBpbnRlcmNlcHRvcnNcbiAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBDb252ZXJ0IHRvIG1hcCBzbyB3ZSBjYW4gZG8gcXVpY2sga2V5IGxvb2t1cHNcbiAgICAgIHZhciByZXBsYWNlbWVudE1hcCA9IGNvbnZlcnRUb01hcCh2YWx1ZXMpO1xuICAgICAgdmFyIG9yZGVyZWREYXRhID0gbmV3IE1hcCgpOyAvLyBVc2VkIGZvciBvcHRpbWl6YXRpb25cblxuICAgICAgdmFyIGtleXNSZXBvcnRDaGFuZ2VkQ2FsbGVkID0gZmFsc2U7IC8vIERlbGV0ZSBrZXlzIHRoYXQgZG9uJ3QgZXhpc3QgaW4gcmVwbGFjZW1lbnQgbWFwXG4gICAgICAvLyBpZiB0aGUga2V5IGRlbGV0aW9uIGlzIHByZXZlbnRlZCBieSBpbnRlcmNlcHRvclxuICAgICAgLy8gYWRkIGVudHJ5IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJlc3VsdCBtYXBcblxuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoX3RoaXM3LmRhdGFfLmtleXMoKSksIF9zdGVwMzsgIShfc3RlcDMgPSBfaXRlcmF0b3IzKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBrZXkgPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgICAgLy8gQ29uY3VycmVudGx5IGl0ZXJhdGluZy9kZWxldGluZyBrZXlzXG4gICAgICAgIC8vIGl0ZXJhdG9yIHNob3VsZCBoYW5kbGUgdGhpcyBjb3JyZWN0bHlcbiAgICAgICAgaWYgKCFyZXBsYWNlbWVudE1hcC5oYXMoa2V5KSkge1xuICAgICAgICAgIHZhciBkZWxldGVkID0gX3RoaXM3W1wiZGVsZXRlXCJdKGtleSk7IC8vIFdhcyB0aGUga2V5IHJlbW92ZWQ/XG5cblxuICAgICAgICAgIGlmIChkZWxldGVkKSB7XG4gICAgICAgICAgICAvLyBfa2V5c0F0b20ucmVwb3J0Q2hhbmdlZCgpIHdhcyBhbHJlYWR5IGNhbGxlZFxuICAgICAgICAgICAga2V5c1JlcG9ydENoYW5nZWRDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEZWxldGUgcHJldmVudGVkIGJ5IGludGVyY2VwdG9yXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfdGhpczcuZGF0YV8uZ2V0KGtleSk7XG5cbiAgICAgICAgICAgIG9yZGVyZWREYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gTWVyZ2UgZW50cmllc1xuXG5cbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHJlcGxhY2VtZW50TWFwLmVudHJpZXMoKSksIF9zdGVwNDsgIShfc3RlcDQgPSBfaXRlcmF0b3I0KCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RlcDQkdmFsdWUgPSBfc3RlcDQudmFsdWUsXG4gICAgICAgICAgICBfa2V5ID0gX3N0ZXA0JHZhbHVlWzBdLFxuICAgICAgICAgICAgX3ZhbHVlID0gX3N0ZXA0JHZhbHVlWzFdO1xuXG4gICAgICAgIC8vIFdlIHdpbGwgd2FudCB0byBrbm93IHdoZXRoZXIgYSBuZXcga2V5IGlzIGFkZGVkXG4gICAgICAgIHZhciBrZXlFeGlzdGVkID0gX3RoaXM3LmRhdGFfLmhhcyhfa2V5KTsgLy8gQWRkIG9yIHVwZGF0ZSB2YWx1ZVxuXG5cbiAgICAgICAgX3RoaXM3LnNldChfa2V5LCBfdmFsdWUpOyAvLyBUaGUgYWRkaXRpb24gY291bGQgaGF2ZSBiZWVuIHByZXZlbnQgYnkgaW50ZXJjZXB0b3JcblxuXG4gICAgICAgIGlmIChfdGhpczcuZGF0YV8uaGFzKF9rZXkpKSB7XG4gICAgICAgICAgLy8gVGhlIHVwZGF0ZSBjb3VsZCBoYXZlIGJlZW4gcHJldmVudGVkIGJ5IGludGVyY2VwdG9yXG4gICAgICAgICAgLy8gYW5kIGFsc28gd2Ugd2FudCB0byBwcmVzZXJ2ZSBleGlzdGluZyB2YWx1ZXNcbiAgICAgICAgICAvLyBzbyB1c2UgdmFsdWUgZnJvbSBfZGF0YSBtYXAgKGluc3RlYWQgb2YgcmVwbGFjZW1lbnQgbWFwKVxuICAgICAgICAgIHZhciBfdmFsdWUyID0gX3RoaXM3LmRhdGFfLmdldChfa2V5KTtcblxuICAgICAgICAgIG9yZGVyZWREYXRhLnNldChfa2V5LCBfdmFsdWUyKTsgLy8gV2FzIGEgbmV3IGtleSBhZGRlZD9cblxuICAgICAgICAgIGlmICgha2V5RXhpc3RlZCkge1xuICAgICAgICAgICAgLy8gX2tleXNBdG9tLnJlcG9ydENoYW5nZWQoKSB3YXMgYWxyZWFkeSBjYWxsZWRcbiAgICAgICAgICAgIGtleXNSZXBvcnRDaGFuZ2VkQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ2hlY2sgZm9yIHBvc3NpYmxlIGtleSBvcmRlciBjaGFuZ2VcblxuXG4gICAgICBpZiAoIWtleXNSZXBvcnRDaGFuZ2VkQ2FsbGVkKSB7XG4gICAgICAgIGlmIChfdGhpczcuZGF0YV8uc2l6ZSAhPT0gb3JkZXJlZERhdGEuc2l6ZSkge1xuICAgICAgICAgIC8vIElmIHNpemUgZGlmZmVycywga2V5cyBhcmUgZGVmaW5pdGVseSBtb2RpZmllZFxuICAgICAgICAgIF90aGlzNy5rZXlzQXRvbV8ucmVwb3J0Q2hhbmdlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBpdGVyMSA9IF90aGlzNy5kYXRhXy5rZXlzKCk7XG5cbiAgICAgICAgICB2YXIgaXRlcjIgPSBvcmRlcmVkRGF0YS5rZXlzKCk7XG4gICAgICAgICAgdmFyIG5leHQxID0gaXRlcjEubmV4dCgpO1xuICAgICAgICAgIHZhciBuZXh0MiA9IGl0ZXIyLm5leHQoKTtcblxuICAgICAgICAgIHdoaWxlICghbmV4dDEuZG9uZSkge1xuICAgICAgICAgICAgaWYgKG5leHQxLnZhbHVlICE9PSBuZXh0Mi52YWx1ZSkge1xuICAgICAgICAgICAgICBfdGhpczcua2V5c0F0b21fLnJlcG9ydENoYW5nZWQoKTtcblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV4dDEgPSBpdGVyMS5uZXh0KCk7XG4gICAgICAgICAgICBuZXh0MiA9IGl0ZXIyLm5leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gVXNlIGNvcnJlY3RseSBvcmRlcmVkIG1hcFxuXG5cbiAgICAgIF90aGlzNy5kYXRhXyA9IG9yZGVyZWREYXRhO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgT2JzZXJ2YWJsZU1hcF1cIjtcbiAgfTtcblxuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxyXG4gICAqIE9ic2VydmVzIHRoaXMgb2JqZWN0LiBUcmlnZ2VycyBmb3IgdGhlIGV2ZW50cyAnYWRkJywgJ3VwZGF0ZScgYW5kICdkZWxldGUnLlxyXG4gICAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L29ic2VydmVcclxuICAgKiBmb3IgY2FsbGJhY2sgZGV0YWlsc1xyXG4gICAqL1xuICBfcHJvdG8ub2JzZXJ2ZV8gPSBmdW5jdGlvbiBvYnNlcnZlXyhsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBmaXJlSW1tZWRpYXRlbHkgPT09IHRydWUpIHtcbiAgICAgIGRpZShcImBvYnNlcnZlYCBkb2Vzbid0IHN1cHBvcnQgZmlyZUltbWVkaWF0ZWx5PXRydWUgaW4gY29tYmluYXRpb24gd2l0aCBtYXBzLlwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVnaXN0ZXJMaXN0ZW5lcih0aGlzLCBsaXN0ZW5lcik7XG4gIH07XG5cbiAgX3Byb3RvLmludGVyY2VwdF8gPSBmdW5jdGlvbiBpbnRlcmNlcHRfKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gcmVnaXN0ZXJJbnRlcmNlcHRvcih0aGlzLCBoYW5kbGVyKTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoT2JzZXJ2YWJsZU1hcCwgW3tcbiAgICBrZXk6IFwic2l6ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdGhpcy5rZXlzQXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFfLnNpemU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBfU3ltYm9sJHRvU3RyaW5nVGFnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIFwiTWFwXCI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE9ic2VydmFibGVNYXA7XG59KCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuXG52YXIgaXNPYnNlcnZhYmxlTWFwID0gLyojX19QVVJFX18qL2NyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUoXCJPYnNlcnZhYmxlTWFwXCIsIE9ic2VydmFibGVNYXApO1xuXG5mdW5jdGlvbiBjb252ZXJ0VG9NYXAoZGF0YVN0cnVjdHVyZSkge1xuICBpZiAoaXNFUzZNYXAoZGF0YVN0cnVjdHVyZSkgfHwgaXNPYnNlcnZhYmxlTWFwKGRhdGFTdHJ1Y3R1cmUpKSB7XG4gICAgcmV0dXJuIGRhdGFTdHJ1Y3R1cmU7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkYXRhU3RydWN0dXJlKSkge1xuICAgIHJldHVybiBuZXcgTWFwKGRhdGFTdHJ1Y3R1cmUpO1xuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoZGF0YVN0cnVjdHVyZSkpIHtcbiAgICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuXG4gICAgZm9yICh2YXIga2V5IGluIGRhdGFTdHJ1Y3R1cmUpIHtcbiAgICAgIG1hcC5zZXQoa2V5LCBkYXRhU3RydWN0dXJlW2tleV0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYXA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRpZSgyMSwgZGF0YVN0cnVjdHVyZSk7XG4gIH1cbn1cblxudmFyIF9TeW1ib2wkaXRlcmF0b3IkMSwgX1N5bWJvbCR0b1N0cmluZ1RhZyQxO1xudmFyIE9ic2VydmFibGVTZXRNYXJrZXIgPSB7fTtcbl9TeW1ib2wkaXRlcmF0b3IkMSA9IFN5bWJvbC5pdGVyYXRvcjtcbl9TeW1ib2wkdG9TdHJpbmdUYWckMSA9IFN5bWJvbC50b1N0cmluZ1RhZztcbnZhciBPYnNlcnZhYmxlU2V0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT2JzZXJ2YWJsZVNldChpbml0aWFsRGF0YSwgZW5oYW5jZXIsIG5hbWVfKSB7XG4gICAgaWYgKGVuaGFuY2VyID09PSB2b2lkIDApIHtcbiAgICAgIGVuaGFuY2VyID0gZGVlcEVuaGFuY2VyO1xuICAgIH1cblxuICAgIGlmIChuYW1lXyA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW1lXyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiT2JzZXJ2YWJsZVNldEBcIiArIGdldE5leHRJZCgpIDogXCJPYnNlcnZhYmxlU2V0XCI7XG4gICAgfVxuXG4gICAgdGhpcy5uYW1lXyA9IHZvaWQgMDtcbiAgICB0aGlzWyRtb2J4XSA9IE9ic2VydmFibGVTZXRNYXJrZXI7XG4gICAgdGhpcy5kYXRhXyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmF0b21fID0gdm9pZCAwO1xuICAgIHRoaXMuY2hhbmdlTGlzdGVuZXJzXyA9IHZvaWQgMDtcbiAgICB0aGlzLmludGVyY2VwdG9yc18gPSB2b2lkIDA7XG4gICAgdGhpcy5kZWhhbmNlciA9IHZvaWQgMDtcbiAgICB0aGlzLmVuaGFuY2VyXyA9IHZvaWQgMDtcbiAgICB0aGlzLm5hbWVfID0gbmFtZV87XG5cbiAgICBpZiAoIWlzRnVuY3Rpb24oU2V0KSkge1xuICAgICAgZGllKDIyKTtcbiAgICB9XG5cbiAgICB0aGlzLmF0b21fID0gY3JlYXRlQXRvbSh0aGlzLm5hbWVfKTtcblxuICAgIHRoaXMuZW5oYW5jZXJfID0gZnVuY3Rpb24gKG5ld1YsIG9sZFYpIHtcbiAgICAgIHJldHVybiBlbmhhbmNlcihuZXdWLCBvbGRWLCBuYW1lXyk7XG4gICAgfTtcblxuICAgIGlmIChpbml0aWFsRGF0YSkge1xuICAgICAgdGhpcy5yZXBsYWNlKGluaXRpYWxEYXRhKTtcbiAgICB9XG4gIH1cblxuICB2YXIgX3Byb3RvID0gT2JzZXJ2YWJsZVNldC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRlaGFuY2VWYWx1ZV8gPSBmdW5jdGlvbiBkZWhhbmNlVmFsdWVfKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZGVoYW5jZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVoYW5jZXIodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBfcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgdW50cmFja2VkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShfdGhpcy5kYXRhXy52YWx1ZXMoKSksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICBfdGhpc1tcImRlbGV0ZVwiXSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja0ZuLCB0aGlzQXJnKSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodGhpcyksIF9zdGVwMjsgIShfc3RlcDIgPSBfaXRlcmF0b3IyKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgdmFsdWUgPSBfc3RlcDIudmFsdWU7XG4gICAgICBjYWxsYmFja0ZuLmNhbGwodGhpc0FyZywgdmFsdWUsIHZhbHVlLCB0aGlzKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgY2hlY2tJZlN0YXRlTW9kaWZpY2F0aW9uc0FyZUFsbG93ZWQodGhpcy5hdG9tXyk7XG5cbiAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgdHlwZTogQURELFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG5ld1ZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghY2hhbmdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSAvLyBpZGVhbGx5LCB2YWx1ZSA9IGNoYW5nZS52YWx1ZSB3b3VsZCBiZSBkb25lIGhlcmUsIHNvIHRoYXQgdmFsdWVzIGNhbiBiZVxuICAgICAgLy8gY2hhbmdlZCBieSBpbnRlcmNlcHRvci4gU2FtZSBhcHBsaWVzIGZvciBvdGhlciBTZXQgYW5kIE1hcCBhcGkncy5cblxuICAgIH1cblxuICAgIGlmICghdGhpcy5oYXModmFsdWUpKSB7XG4gICAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5kYXRhXy5hZGQoX3RoaXMyLmVuaGFuY2VyXyh2YWx1ZSwgdW5kZWZpbmVkKSk7XG5cbiAgICAgICAgX3RoaXMyLmF0b21fLnJlcG9ydENoYW5nZWQoKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIG5vdGlmeVNweSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc1NweUVuYWJsZWQoKTtcbiAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG5cbiAgICAgIHZhciBfY2hhbmdlID0gbm90aWZ5IHx8IG5vdGlmeVNweSA/IHtcbiAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwic2V0XCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgdHlwZTogQURELFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG5ld1ZhbHVlOiB2YWx1ZVxuICAgICAgfSA6IG51bGw7XG5cbiAgICAgIGlmIChub3RpZnlTcHkgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHNweVJlcG9ydFN0YXJ0KF9jaGFuZ2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAobm90aWZ5KSB7XG4gICAgICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBfY2hhbmdlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vdGlmeVNweSAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgc3B5UmVwb3J0RW5kKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvW1wiZGVsZXRlXCJdID0gZnVuY3Rpb24gX2RlbGV0ZSh2YWx1ZSkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgIHR5cGU6IERFTEVURSxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBvbGRWYWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWNoYW5nZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzKHZhbHVlKSkge1xuICAgICAgdmFyIG5vdGlmeVNweSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc1NweUVuYWJsZWQoKTtcbiAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG5cbiAgICAgIHZhciBfY2hhbmdlMiA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcInNldFwiLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIHR5cGU6IERFTEVURSxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBvbGRWYWx1ZTogdmFsdWVcbiAgICAgIH0gOiBudWxsO1xuXG4gICAgICBpZiAobm90aWZ5U3B5ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBzcHlSZXBvcnRTdGFydChfY2hhbmdlMik7XG4gICAgICB9XG5cbiAgICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLmF0b21fLnJlcG9ydENoYW5nZWQoKTtcblxuICAgICAgICBfdGhpczMuZGF0YV9bXCJkZWxldGVcIl0odmFsdWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChub3RpZnkpIHtcbiAgICAgICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIF9jaGFuZ2UyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vdGlmeVNweSAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgc3B5UmVwb3J0RW5kKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uaGFzID0gZnVuY3Rpb24gaGFzKHZhbHVlKSB7XG4gICAgdGhpcy5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHJldHVybiB0aGlzLmRhdGFfLmhhcyh0aGlzLmRlaGFuY2VWYWx1ZV8odmFsdWUpKTtcbiAgfTtcblxuICBfcHJvdG8uZW50cmllcyA9IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IDA7XG4gICAgdmFyIGtleXMgPSBBcnJheS5mcm9tKHRoaXMua2V5cygpKTtcbiAgICB2YXIgdmFsdWVzID0gQXJyYXkuZnJvbSh0aGlzLnZhbHVlcygpKTtcbiAgICByZXR1cm4gbWFrZUl0ZXJhYmxlKHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgbmV4dEluZGV4ICs9IDE7XG4gICAgICAgIHJldHVybiBpbmRleCA8IHZhbHVlcy5sZW5ndGggPyB7XG4gICAgICAgICAgdmFsdWU6IFtrZXlzW2luZGV4XSwgdmFsdWVzW2luZGV4XV0sXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmtleXMgPSBmdW5jdGlvbiBrZXlzKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlcygpO1xuICB9O1xuXG4gIF9wcm90by52YWx1ZXMgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgdGhpcy5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbmV4dEluZGV4ID0gMDtcbiAgICB2YXIgb2JzZXJ2YWJsZVZhbHVlcyA9IEFycmF5LmZyb20odGhpcy5kYXRhXy52YWx1ZXMoKSk7XG4gICAgcmV0dXJuIG1ha2VJdGVyYWJsZSh7XG4gICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICByZXR1cm4gbmV4dEluZGV4IDwgb2JzZXJ2YWJsZVZhbHVlcy5sZW5ndGggPyB7XG4gICAgICAgICAgdmFsdWU6IHNlbGYuZGVoYW5jZVZhbHVlXyhvYnNlcnZhYmxlVmFsdWVzW25leHRJbmRleCsrXSksXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKG90aGVyKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICBpZiAoaXNPYnNlcnZhYmxlU2V0KG90aGVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2V0KG90aGVyKTtcbiAgICB9XG5cbiAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvdGhlcikpIHtcbiAgICAgICAgX3RoaXM0LmNsZWFyKCk7XG5cbiAgICAgICAgb3RoZXIuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM0LmFkZCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpc0VTNlNldChvdGhlcikpIHtcbiAgICAgICAgX3RoaXM0LmNsZWFyKCk7XG5cbiAgICAgICAgb3RoZXIuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM0LmFkZCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChvdGhlciAhPT0gbnVsbCAmJiBvdGhlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRpZShcIkNhbm5vdCBpbml0aWFsaXplIHNldCBmcm9tIFwiICsgb3RoZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5vYnNlcnZlXyA9IGZ1bmN0aW9uIG9ic2VydmVfKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICAvLyAuLi4gJ2ZpcmVJbW1lZGlhdGVseScgY291bGQgYWxzbyBiZSB0cnVlP1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZmlyZUltbWVkaWF0ZWx5ID09PSB0cnVlKSB7XG4gICAgICBkaWUoXCJgb2JzZXJ2ZWAgZG9lc24ndCBzdXBwb3J0IGZpcmVJbW1lZGlhdGVseT10cnVlIGluIGNvbWJpbmF0aW9uIHdpdGggc2V0cy5cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZ2lzdGVyTGlzdGVuZXIodGhpcywgbGlzdGVuZXIpO1xuICB9O1xuXG4gIF9wcm90by5pbnRlcmNlcHRfID0gZnVuY3Rpb24gaW50ZXJjZXB0XyhoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHJlZ2lzdGVySW50ZXJjZXB0b3IodGhpcywgaGFuZGxlcik7XG4gIH07XG5cbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IE9ic2VydmFibGVTZXRdXCI7XG4gIH07XG5cbiAgX3Byb3RvW19TeW1ib2wkaXRlcmF0b3IkMV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKE9ic2VydmFibGVTZXQsIFt7XG4gICAga2V5OiBcInNpemVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHRoaXMuYXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFfLnNpemU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBfU3ltYm9sJHRvU3RyaW5nVGFnJDEsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gXCJTZXRcIjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gT2JzZXJ2YWJsZVNldDtcbn0oKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbnZhciBpc09ic2VydmFibGVTZXQgPSAvKiNfX1BVUkVfXyovY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIk9ic2VydmFibGVTZXRcIiwgT2JzZXJ2YWJsZVNldCk7XG5cbnZhciBkZXNjcmlwdG9yQ2FjaGUgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbnZhciBSRU1PVkUgPSBcInJlbW92ZVwiO1xudmFyIE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbih0YXJnZXRfLCB2YWx1ZXNfLCBuYW1lXywgLy8gVXNlZCBhbnl0aW1lIGFubm90YXRpb24gaXMgbm90IGV4cGxpY2l0ZWx5IHByb3ZpZGVkXG4gIGRlZmF1bHRBbm5vdGF0aW9uXykge1xuICAgIGlmICh2YWx1ZXNfID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlc18gPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgaWYgKGRlZmF1bHRBbm5vdGF0aW9uXyA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWZhdWx0QW5ub3RhdGlvbl8gPSBhdXRvQW5ub3RhdGlvbjtcbiAgICB9XG5cbiAgICB0aGlzLnRhcmdldF8gPSB2b2lkIDA7XG4gICAgdGhpcy52YWx1ZXNfID0gdm9pZCAwO1xuICAgIHRoaXMubmFtZV8gPSB2b2lkIDA7XG4gICAgdGhpcy5kZWZhdWx0QW5ub3RhdGlvbl8gPSB2b2lkIDA7XG4gICAgdGhpcy5rZXlzQXRvbV8gPSB2b2lkIDA7XG4gICAgdGhpcy5jaGFuZ2VMaXN0ZW5lcnNfID0gdm9pZCAwO1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzXyA9IHZvaWQgMDtcbiAgICB0aGlzLnByb3h5XyA9IHZvaWQgMDtcbiAgICB0aGlzLmlzUGxhaW5PYmplY3RfID0gdm9pZCAwO1xuICAgIHRoaXMuYXBwbGllZEFubm90YXRpb25zXyA9IHZvaWQgMDtcbiAgICB0aGlzLnBlbmRpbmdLZXlzXyA9IHZvaWQgMDtcbiAgICB0aGlzLnRhcmdldF8gPSB0YXJnZXRfO1xuICAgIHRoaXMudmFsdWVzXyA9IHZhbHVlc187XG4gICAgdGhpcy5uYW1lXyA9IG5hbWVfO1xuICAgIHRoaXMuZGVmYXVsdEFubm90YXRpb25fID0gZGVmYXVsdEFubm90YXRpb25fO1xuICAgIHRoaXMua2V5c0F0b21fID0gbmV3IEF0b20ocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gdGhpcy5uYW1lXyArIFwiLmtleXNcIiA6IFwiT2JzZXJ2YWJsZU9iamVjdC5rZXlzXCIpOyAvLyBPcHRpbWl6YXRpb246IHdlIHVzZSB0aGlzIGZyZXF1ZW50bHlcblxuICAgIHRoaXMuaXNQbGFpbk9iamVjdF8gPSBpc1BsYWluT2JqZWN0KHRoaXMudGFyZ2V0Xyk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFpc0Fubm90YXRpb24odGhpcy5kZWZhdWx0QW5ub3RhdGlvbl8pKSB7XG4gICAgICBkaWUoXCJkZWZhdWx0QW5ub3RhdGlvbiBtdXN0IGJlIHZhbGlkIGFubm90YXRpb25cIik7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgLy8gUHJlcGFyZSBzdHJ1Y3R1cmUgZm9yIHRyYWNraW5nIHdoaWNoIGZpZWxkcyB3ZXJlIGFscmVhZHkgYW5ub3RhdGVkXG4gICAgICB0aGlzLmFwcGxpZWRBbm5vdGF0aW9uc18gPSB7fTtcbiAgICB9XG4gIH1cblxuICB2YXIgX3Byb3RvID0gT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8gPSBmdW5jdGlvbiBnZXRPYnNlcnZhYmxlUHJvcFZhbHVlXyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNfLmdldChrZXkpLmdldCgpO1xuICB9O1xuXG4gIF9wcm90by5zZXRPYnNlcnZhYmxlUHJvcFZhbHVlXyA9IGZ1bmN0aW9uIHNldE9ic2VydmFibGVQcm9wVmFsdWVfKGtleSwgbmV3VmFsdWUpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZSA9IHRoaXMudmFsdWVzXy5nZXQoa2V5KTtcblxuICAgIGlmIChvYnNlcnZhYmxlIGluc3RhbmNlb2YgQ29tcHV0ZWRWYWx1ZSkge1xuICAgICAgb2JzZXJ2YWJsZS5zZXQobmV3VmFsdWUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBpbnRlcmNlcHRcblxuXG4gICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyB8fCB0aGlzLnRhcmdldF8sXG4gICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIG5ld1ZhbHVlID0gY2hhbmdlLm5ld1ZhbHVlO1xuICAgIH1cblxuICAgIG5ld1ZhbHVlID0gb2JzZXJ2YWJsZS5wcmVwYXJlTmV3VmFsdWVfKG5ld1ZhbHVlKTsgLy8gbm90aWZ5IHNweSAmIG9ic2VydmVyc1xuXG4gICAgaWYgKG5ld1ZhbHVlICE9PSBnbG9iYWxTdGF0ZS5VTkNIQU5HRUQpIHtcbiAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgICB2YXIgbm90aWZ5U3B5ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGlzU3B5RW5hYmxlZCgpO1xuXG4gICAgICB2YXIgX2NoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwib2JqZWN0XCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyB8fCB0aGlzLnRhcmdldF8sXG4gICAgICAgIG9sZFZhbHVlOiBvYnNlcnZhYmxlLnZhbHVlXyxcbiAgICAgICAgbmFtZToga2V5LFxuICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcbiAgICAgIH0gOiBudWxsO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSkge1xuICAgICAgICBzcHlSZXBvcnRTdGFydChfY2hhbmdlKTtcbiAgICAgIH1cbiAgICAgIG9ic2VydmFibGUuc2V0TmV3VmFsdWVfKG5ld1ZhbHVlKTtcblxuICAgICAgaWYgKG5vdGlmeSkge1xuICAgICAgICBub3RpZnlMaXN0ZW5lcnModGhpcywgX2NoYW5nZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSB7XG4gICAgICAgIHNweVJlcG9ydEVuZCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9wcm90by5nZXRfID0gZnVuY3Rpb24gZ2V0XyhrZXkpIHtcbiAgICBpZiAoZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uICYmICFoYXNQcm9wKHRoaXMudGFyZ2V0Xywga2V5KSkge1xuICAgICAgLy8gS2V5IGRvZXNuJ3QgZXhpc3QgeWV0LCBzdWJzY3JpYmUgZm9yIGl0IGluIGNhc2UgaXQncyBhZGRlZCBsYXRlclxuICAgICAgdGhpcy5oYXNfKGtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudGFyZ2V0X1trZXldO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7UHJvcGVydHlLZXl9IGtleVxyXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZVxyXG4gICAqIEBwYXJhbSB7QW5ub3RhdGlvbnxib29sZWFufSBhbm5vdGF0aW9uIHRydWUgLSB1c2UgZGVmYXVsdCBhbm5vdGF0aW9uLCBmYWxzZSAtIGNvcHkgYXMgaXNcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByb3h5VHJhcCB3aGV0aGVyIGl0J3MgY2FsbGVkIGZyb20gcHJveHkgdHJhcFxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufG51bGx9IHRydWUgb24gc3VjY2VzcywgZmFsc2Ugb24gZmFpbHVyZSAocHJveHlUcmFwICsgbm9uLWNvbmZpZ3VyYWJsZSksIG51bGwgd2hlbiBjYW5jZWxsZWQgYnkgaW50ZXJjZXB0b3JcclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zZXRfID0gZnVuY3Rpb24gc2V0XyhrZXksIHZhbHVlLCBwcm94eVRyYXApIHtcbiAgICBpZiAocHJveHlUcmFwID09PSB2b2lkIDApIHtcbiAgICAgIHByb3h5VHJhcCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIERvbid0IHVzZSAuaGFzKGtleSkgLSB3ZSBjYXJlIGFib3V0IG93blxuICAgIGlmIChoYXNQcm9wKHRoaXMudGFyZ2V0Xywga2V5KSkge1xuICAgICAgLy8gRXhpc3RpbmcgcHJvcFxuICAgICAgaWYgKHRoaXMudmFsdWVzXy5oYXMoa2V5KSkge1xuICAgICAgICAvLyBPYnNlcnZhYmxlIChjYW4gYmUgaW50ZXJjZXB0ZWQpXG4gICAgICAgIHJldHVybiB0aGlzLnNldE9ic2VydmFibGVQcm9wVmFsdWVfKGtleSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChwcm94eVRyYXApIHtcbiAgICAgICAgLy8gTm9uLW9ic2VydmFibGUgLSBwcm94eVxuICAgICAgICByZXR1cm4gUmVmbGVjdC5zZXQodGhpcy50YXJnZXRfLCBrZXksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vbi1vYnNlcnZhYmxlXG4gICAgICAgIHRoaXMudGFyZ2V0X1trZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOZXcgcHJvcFxuICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5kXyhrZXksIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9LCB0aGlzLmRlZmF1bHRBbm5vdGF0aW9uXywgcHJveHlUcmFwKTtcbiAgICB9XG4gIH0gLy8gVHJhcCBmb3IgXCJpblwiXG4gIDtcblxuICBfcHJvdG8uaGFzXyA9IGZ1bmN0aW9uIGhhc18oa2V5KSB7XG4gICAgaWYgKCFnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24pIHtcbiAgICAgIC8vIFNraXAga2V5IHN1YnNjcmlwdGlvbiBvdXRzaWRlIGRlcml2YXRpb25cbiAgICAgIHJldHVybiBrZXkgaW4gdGhpcy50YXJnZXRfO1xuICAgIH1cblxuICAgIHRoaXMucGVuZGluZ0tleXNfIHx8ICh0aGlzLnBlbmRpbmdLZXlzXyA9IG5ldyBNYXAoKSk7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5wZW5kaW5nS2V5c18uZ2V0KGtleSk7XG5cbiAgICBpZiAoIWVudHJ5KSB7XG4gICAgICBlbnRyeSA9IG5ldyBPYnNlcnZhYmxlVmFsdWUoa2V5IGluIHRoaXMudGFyZ2V0XywgcmVmZXJlbmNlRW5oYW5jZXIsIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHRoaXMubmFtZV8gKyBcIi5cIiArIHN0cmluZ2lmeUtleShrZXkpICsgXCI/XCIgOiBcIk9ic2VydmFibGVPYmplY3Qua2V5P1wiLCBmYWxzZSk7XG4gICAgICB0aGlzLnBlbmRpbmdLZXlzXy5zZXQoa2V5LCBlbnRyeSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudHJ5LmdldCgpO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7UHJvcGVydHlLZXl9IGtleVxyXG4gICAqIEBwYXJhbSB7QW5ub3RhdGlvbnxib29sZWFufSBhbm5vdGF0aW9uIHRydWUgLSB1c2UgZGVmYXVsdCBhbm5vdGF0aW9uLCBmYWxzZSAtIGlnbm9yZSBwcm9wXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8ubWFrZV8gPSBmdW5jdGlvbiBtYWtlXyhrZXksIGFubm90YXRpb24pIHtcbiAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgYW5ub3RhdGlvbiA9IHRoaXMuZGVmYXVsdEFubm90YXRpb25fO1xuICAgIH1cblxuICAgIGlmIChhbm5vdGF0aW9uID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGFzc2VydEFubm90YWJsZSh0aGlzLCBhbm5vdGF0aW9uLCBrZXkpO1xuXG4gICAgaWYgKCEoa2V5IGluIHRoaXMudGFyZ2V0XykpIHtcbiAgICAgIHZhciBfdGhpcyR0YXJnZXRfJHN0b3JlZEE7XG5cbiAgICAgIC8vIFRocm93IG9uIG1pc3Npbmcga2V5LCBleGNlcHQgZm9yIGRlY29yYXRvcnM6XG4gICAgICAvLyBEZWNvcmF0b3IgYW5ub3RhdGlvbnMgYXJlIGNvbGxlY3RlZCBmcm9tIHdob2xlIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgIC8vIFdoZW4gY2FsbGVkIGZyb20gc3VwZXIoKSBzb21lIHByb3BzIG1heSBub3QgZXhpc3QgeWV0LlxuICAgICAgLy8gSG93ZXZlciB3ZSBkb24ndCBoYXZlIHRvIHdvcnJ5IGFib3V0IG1pc3NpbmcgcHJvcCxcbiAgICAgIC8vIGJlY2F1c2UgdGhlIGRlY29yYXRvciBtdXN0IGhhdmUgYmVlbiBhcHBsaWVkIHRvIHNvbWV0aGluZy5cbiAgICAgIGlmICgoX3RoaXMkdGFyZ2V0XyRzdG9yZWRBID0gdGhpcy50YXJnZXRfW3N0b3JlZEFubm90YXRpb25zU3ltYm9sXSkgIT0gbnVsbCAmJiBfdGhpcyR0YXJnZXRfJHN0b3JlZEFba2V5XSkge1xuICAgICAgICByZXR1cm47IC8vIHdpbGwgYmUgYW5ub3RhdGVkIGJ5IHN1YmNsYXNzIGNvbnN0cnVjdG9yXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWUoMSwgYW5ub3RhdGlvbi5hbm5vdGF0aW9uVHlwZV8sIHRoaXMubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc291cmNlID0gdGhpcy50YXJnZXRfO1xuXG4gICAgd2hpbGUgKHNvdXJjZSAmJiBzb3VyY2UgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBnZXREZXNjcmlwdG9yKHNvdXJjZSwga2V5KTtcblxuICAgICAgaWYgKGRlc2NyaXB0b3IpIHtcbiAgICAgICAgdmFyIG91dGNvbWUgPSBhbm5vdGF0aW9uLm1ha2VfKHRoaXMsIGtleSwgZGVzY3JpcHRvciwgc291cmNlKTtcblxuICAgICAgICBpZiAob3V0Y29tZSA9PT0gMFxuICAgICAgICAvKiBDYW5jZWwgKi9cbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG91dGNvbWUgPT09IDFcbiAgICAgICAgLyogQnJlYWsgKi9cbiAgICAgICAgKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc291cmNlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHNvdXJjZSk7XG4gICAgfVxuXG4gICAgcmVjb3JkQW5ub3RhdGlvbkFwcGxpZWQodGhpcywgYW5ub3RhdGlvbiwga2V5KTtcbiAgfVxuICAvKipcclxuICAgKiBAcGFyYW0ge1Byb3BlcnR5S2V5fSBrZXlcclxuICAgKiBAcGFyYW0ge1Byb3BlcnR5RGVzY3JpcHRvcn0gZGVzY3JpcHRvclxyXG4gICAqIEBwYXJhbSB7QW5ub3RhdGlvbnxib29sZWFufSBhbm5vdGF0aW9uIHRydWUgLSB1c2UgZGVmYXVsdCBhbm5vdGF0aW9uLCBmYWxzZSAtIGNvcHkgYXMgaXNcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByb3h5VHJhcCB3aGV0aGVyIGl0J3MgY2FsbGVkIGZyb20gcHJveHkgdHJhcFxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufG51bGx9IHRydWUgb24gc3VjY2VzcywgZmFsc2Ugb24gZmFpbHVyZSAocHJveHlUcmFwICsgbm9uLWNvbmZpZ3VyYWJsZSksIG51bGwgd2hlbiBjYW5jZWxsZWQgYnkgaW50ZXJjZXB0b3JcclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5leHRlbmRfID0gZnVuY3Rpb24gZXh0ZW5kXyhrZXksIGRlc2NyaXB0b3IsIGFubm90YXRpb24sIHByb3h5VHJhcCkge1xuICAgIGlmIChwcm94eVRyYXAgPT09IHZvaWQgMCkge1xuICAgICAgcHJveHlUcmFwID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGFubm90YXRpb24gPT09IHRydWUpIHtcbiAgICAgIGFubm90YXRpb24gPSB0aGlzLmRlZmF1bHRBbm5vdGF0aW9uXztcbiAgICB9XG5cbiAgICBpZiAoYW5ub3RhdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZmluZVByb3BlcnR5XyhrZXksIGRlc2NyaXB0b3IsIHByb3h5VHJhcCk7XG4gICAgfVxuXG4gICAgYXNzZXJ0QW5ub3RhYmxlKHRoaXMsIGFubm90YXRpb24sIGtleSk7XG4gICAgdmFyIG91dGNvbWUgPSBhbm5vdGF0aW9uLmV4dGVuZF8odGhpcywga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApO1xuXG4gICAgaWYgKG91dGNvbWUpIHtcbiAgICAgIHJlY29yZEFubm90YXRpb25BcHBsaWVkKHRoaXMsIGFubm90YXRpb24sIGtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dGNvbWU7XG4gIH1cbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQcm9wZXJ0eUtleX0ga2V5XHJcbiAgICogQHBhcmFtIHtQcm9wZXJ0eURlc2NyaXB0b3J9IGRlc2NyaXB0b3JcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByb3h5VHJhcCB3aGV0aGVyIGl0J3MgY2FsbGVkIGZyb20gcHJveHkgdHJhcFxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufG51bGx9IHRydWUgb24gc3VjY2VzcywgZmFsc2Ugb24gZmFpbHVyZSAocHJveHlUcmFwICsgbm9uLWNvbmZpZ3VyYWJsZSksIG51bGwgd2hlbiBjYW5jZWxsZWQgYnkgaW50ZXJjZXB0b3JcclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZWZpbmVQcm9wZXJ0eV8gPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eV8oa2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApIHtcbiAgICBpZiAocHJveHlUcmFwID09PSB2b2lkIDApIHtcbiAgICAgIHByb3h5VHJhcCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBzdGFydEJhdGNoKCk7IC8vIERlbGV0ZVxuXG4gICAgICB2YXIgZGVsZXRlT3V0Y29tZSA9IHRoaXMuZGVsZXRlXyhrZXkpO1xuXG4gICAgICBpZiAoIWRlbGV0ZU91dGNvbWUpIHtcbiAgICAgICAgLy8gRmFpbHVyZSBvciBpbnRlcmNlcHRlZFxuICAgICAgICByZXR1cm4gZGVsZXRlT3V0Y29tZTtcbiAgICAgIH0gLy8gQUREIGludGVyY2VwdG9yXG5cblxuICAgICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgICBvYmplY3Q6IHRoaXMucHJveHlfIHx8IHRoaXMudGFyZ2V0XyxcbiAgICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgICAgdHlwZTogQURELFxuICAgICAgICAgIG5ld1ZhbHVlOiBkZXNjcmlwdG9yLnZhbHVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghY2hhbmdlKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3VmFsdWUgPSBjaGFuZ2UubmV3VmFsdWU7XG5cbiAgICAgICAgaWYgKGRlc2NyaXB0b3IudmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgZGVzY3JpcHRvciA9IF9leHRlbmRzKHt9LCBkZXNjcmlwdG9yLCB7XG4gICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBEZWZpbmVcblxuXG4gICAgICBpZiAocHJveHlUcmFwKSB7XG4gICAgICAgIGlmICghUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnRhcmdldF8sIGtleSwgZGVzY3JpcHRvcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KHRoaXMudGFyZ2V0Xywga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgIH0gLy8gTm90aWZ5XG5cblxuICAgICAgdGhpcy5ub3RpZnlQcm9wZXJ0eUFkZGl0aW9uXyhrZXksIGRlc2NyaXB0b3IudmFsdWUpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBlbmRCYXRjaCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIElmIG9yaWdpbmFsIGRlc2NyaXB0b3IgYmVjb21lcyByZWxldmFudCwgbW92ZSB0aGlzIHRvIGFubm90YXRpb24gZGlyZWN0bHlcbiAgO1xuXG4gIF9wcm90by5kZWZpbmVPYnNlcnZhYmxlUHJvcGVydHlfID0gZnVuY3Rpb24gZGVmaW5lT2JzZXJ2YWJsZVByb3BlcnR5XyhrZXksIHZhbHVlLCBlbmhhbmNlciwgcHJveHlUcmFwKSB7XG4gICAgaWYgKHByb3h5VHJhcCA9PT0gdm9pZCAwKSB7XG4gICAgICBwcm94eVRyYXAgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgc3RhcnRCYXRjaCgpOyAvLyBEZWxldGVcblxuICAgICAgdmFyIGRlbGV0ZU91dGNvbWUgPSB0aGlzLmRlbGV0ZV8oa2V5KTtcblxuICAgICAgaWYgKCFkZWxldGVPdXRjb21lKSB7XG4gICAgICAgIC8vIEZhaWx1cmUgb3IgaW50ZXJjZXB0ZWRcbiAgICAgICAgcmV0dXJuIGRlbGV0ZU91dGNvbWU7XG4gICAgICB9IC8vIEFERCBpbnRlcmNlcHRvclxuXG5cbiAgICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyB8fCB0aGlzLnRhcmdldF8sXG4gICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgIHR5cGU6IEFERCxcbiAgICAgICAgICBuZXdWYWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gY2hhbmdlLm5ld1ZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FjaGVkRGVzY3JpcHRvciA9IGdldENhY2hlZE9ic2VydmFibGVQcm9wRGVzY3JpcHRvcihrZXkpO1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZ2xvYmFsU3RhdGUuc2FmZURlc2NyaXB0b3JzID8gdGhpcy5pc1BsYWluT2JqZWN0XyA6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogY2FjaGVkRGVzY3JpcHRvci5nZXQsXG4gICAgICAgIHNldDogY2FjaGVkRGVzY3JpcHRvci5zZXRcbiAgICAgIH07IC8vIERlZmluZVxuXG4gICAgICBpZiAocHJveHlUcmFwKSB7XG4gICAgICAgIGlmICghUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnRhcmdldF8sIGtleSwgZGVzY3JpcHRvcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KHRoaXMudGFyZ2V0Xywga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZVZhbHVlKHZhbHVlLCBlbmhhbmNlciwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gdGhpcy5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgOiBcIk9ic2VydmFibGVPYmplY3Qua2V5XCIsIGZhbHNlKTtcbiAgICAgIHRoaXMudmFsdWVzXy5zZXQoa2V5LCBvYnNlcnZhYmxlKTsgLy8gTm90aWZ5ICh2YWx1ZSBwb3NzaWJseSBjaGFuZ2VkIGJ5IE9ic2VydmFibGVWYWx1ZSlcblxuICAgICAgdGhpcy5ub3RpZnlQcm9wZXJ0eUFkZGl0aW9uXyhrZXksIG9ic2VydmFibGUudmFsdWVfKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZW5kQmF0Y2goKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBJZiBvcmlnaW5hbCBkZXNjcmlwdG9yIGJlY29tZXMgcmVsZXZhbnQsIG1vdmUgdGhpcyB0byBhbm5vdGF0aW9uIGRpcmVjdGx5XG4gIDtcblxuICBfcHJvdG8uZGVmaW5lQ29tcHV0ZWRQcm9wZXJ0eV8gPSBmdW5jdGlvbiBkZWZpbmVDb21wdXRlZFByb3BlcnR5XyhrZXksIG9wdGlvbnMsIHByb3h5VHJhcCkge1xuICAgIGlmIChwcm94eVRyYXAgPT09IHZvaWQgMCkge1xuICAgICAgcHJveHlUcmFwID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHN0YXJ0QmF0Y2goKTsgLy8gRGVsZXRlXG5cbiAgICAgIHZhciBkZWxldGVPdXRjb21lID0gdGhpcy5kZWxldGVfKGtleSk7XG5cbiAgICAgIGlmICghZGVsZXRlT3V0Y29tZSkge1xuICAgICAgICAvLyBGYWlsdXJlIG9yIGludGVyY2VwdGVkXG4gICAgICAgIHJldHVybiBkZWxldGVPdXRjb21lO1xuICAgICAgfSAvLyBBREQgaW50ZXJjZXB0b3JcblxuXG4gICAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfLFxuICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICB0eXBlOiBBREQsXG4gICAgICAgICAgbmV3VmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWNoYW5nZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMubmFtZSB8fCAob3B0aW9ucy5uYW1lID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gdGhpcy5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgOiBcIk9ic2VydmFibGVPYmplY3Qua2V5XCIpO1xuICAgICAgb3B0aW9ucy5jb250ZXh0ID0gdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfO1xuICAgICAgdmFyIGNhY2hlZERlc2NyaXB0b3IgPSBnZXRDYWNoZWRPYnNlcnZhYmxlUHJvcERlc2NyaXB0b3Ioa2V5KTtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IGdsb2JhbFN0YXRlLnNhZmVEZXNjcmlwdG9ycyA/IHRoaXMuaXNQbGFpbk9iamVjdF8gOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZ2V0OiBjYWNoZWREZXNjcmlwdG9yLmdldCxcbiAgICAgICAgc2V0OiBjYWNoZWREZXNjcmlwdG9yLnNldFxuICAgICAgfTsgLy8gRGVmaW5lXG5cbiAgICAgIGlmIChwcm94eVRyYXApIHtcbiAgICAgICAgaWYgKCFSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRoaXMudGFyZ2V0Xywga2V5LCBkZXNjcmlwdG9yKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkodGhpcy50YXJnZXRfLCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnZhbHVlc18uc2V0KGtleSwgbmV3IENvbXB1dGVkVmFsdWUob3B0aW9ucykpOyAvLyBOb3RpZnlcblxuICAgICAgdGhpcy5ub3RpZnlQcm9wZXJ0eUFkZGl0aW9uXyhrZXksIHVuZGVmaW5lZCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVuZEJhdGNoKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQcm9wZXJ0eUtleX0ga2V5XHJcbiAgICogQHBhcmFtIHtQcm9wZXJ0eURlc2NyaXB0b3J9IGRlc2NyaXB0b3JcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByb3h5VHJhcCB3aGV0aGVyIGl0J3MgY2FsbGVkIGZyb20gcHJveHkgdHJhcFxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufG51bGx9IHRydWUgb24gc3VjY2VzcywgZmFsc2Ugb24gZmFpbHVyZSAocHJveHlUcmFwICsgbm9uLWNvbmZpZ3VyYWJsZSksIG51bGwgd2hlbiBjYW5jZWxsZWQgYnkgaW50ZXJjZXB0b3JcclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZWxldGVfID0gZnVuY3Rpb24gZGVsZXRlXyhrZXksIHByb3h5VHJhcCkge1xuICAgIGlmIChwcm94eVRyYXAgPT09IHZvaWQgMCkge1xuICAgICAgcHJveHlUcmFwID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gTm8gc3VjaCBwcm9wXG4gICAgaWYgKCFoYXNQcm9wKHRoaXMudGFyZ2V0Xywga2V5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBJbnRlcmNlcHRcblxuXG4gICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfLFxuICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgIHR5cGU6IFJFTU9WRVxuICAgICAgfSk7IC8vIENhbmNlbGxlZFxuXG4gICAgICBpZiAoIWNoYW5nZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IC8vIERlbGV0ZVxuXG5cbiAgICB0cnkge1xuICAgICAgdmFyIF90aGlzJHBlbmRpbmdLZXlzXywgX3RoaXMkcGVuZGluZ0tleXNfJGdlO1xuXG4gICAgICBzdGFydEJhdGNoKCk7XG4gICAgICB2YXIgbm90aWZ5ID0gaGFzTGlzdGVuZXJzKHRoaXMpO1xuICAgICAgdmFyIG5vdGlmeVNweSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc1NweUVuYWJsZWQoKTtcbiAgICAgIHZhciBvYnNlcnZhYmxlID0gdGhpcy52YWx1ZXNfLmdldChrZXkpOyAvLyBWYWx1ZSBuZWVkZWQgZm9yIHNwaWVzL2xpc3RlbmVyc1xuXG4gICAgICB2YXIgdmFsdWUgPSB1bmRlZmluZWQ7IC8vIE9wdGltaXphdGlvbjogZG9uJ3QgcHVsbCB0aGUgdmFsdWUgdW5sZXNzIHdlIHdpbGwgbmVlZCBpdFxuXG4gICAgICBpZiAoIW9ic2VydmFibGUgJiYgKG5vdGlmeSB8fCBub3RpZnlTcHkpKSB7XG4gICAgICAgIHZhciBfZ2V0RGVzY3JpcHRvcjtcblxuICAgICAgICB2YWx1ZSA9IChfZ2V0RGVzY3JpcHRvciA9IGdldERlc2NyaXB0b3IodGhpcy50YXJnZXRfLCBrZXkpKSA9PSBudWxsID8gdm9pZCAwIDogX2dldERlc2NyaXB0b3IudmFsdWU7XG4gICAgICB9IC8vIGRlbGV0ZSBwcm9wIChkbyBmaXJzdCwgbWF5IGZhaWwpXG5cblxuICAgICAgaWYgKHByb3h5VHJhcCkge1xuICAgICAgICBpZiAoIVJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGhpcy50YXJnZXRfLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy50YXJnZXRfW2tleV07XG4gICAgICB9IC8vIEFsbG93IHJlLWFubm90YXRpbmcgdGhpcyBmaWVsZFxuXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuYXBwbGllZEFubm90YXRpb25zX1trZXldO1xuICAgICAgfSAvLyBDbGVhciBvYnNlcnZhYmxlXG5cblxuICAgICAgaWYgKG9ic2VydmFibGUpIHtcbiAgICAgICAgdGhpcy52YWx1ZXNfW1wiZGVsZXRlXCJdKGtleSk7IC8vIGZvciBjb21wdXRlZCwgdmFsdWUgaXMgdW5kZWZpbmVkXG5cbiAgICAgICAgaWYgKG9ic2VydmFibGUgaW5zdGFuY2VvZiBPYnNlcnZhYmxlVmFsdWUpIHtcbiAgICAgICAgICB2YWx1ZSA9IG9ic2VydmFibGUudmFsdWVfO1xuICAgICAgICB9IC8vIE5vdGlmeTogYXV0b3J1bigoKSA9PiBvYmpba2V5XSksIHNlZSAjMTc5NlxuXG5cbiAgICAgICAgcHJvcGFnYXRlQ2hhbmdlZChvYnNlcnZhYmxlKTtcbiAgICAgIH0gLy8gTm90aWZ5IFwia2V5cy9lbnRyaWVzL3ZhbHVlc1wiIG9ic2VydmVyc1xuXG5cbiAgICAgIHRoaXMua2V5c0F0b21fLnJlcG9ydENoYW5nZWQoKTsgLy8gTm90aWZ5IFwiaGFzXCIgb2JzZXJ2ZXJzXG4gICAgICAvLyBcImluXCIgYXMgaXQgbWF5IHN0aWxsIGV4aXN0IGluIHByb3RvXG5cbiAgICAgIChfdGhpcyRwZW5kaW5nS2V5c18gPSB0aGlzLnBlbmRpbmdLZXlzXykgPT0gbnVsbCA/IHZvaWQgMCA6IChfdGhpcyRwZW5kaW5nS2V5c18kZ2UgPSBfdGhpcyRwZW5kaW5nS2V5c18uZ2V0KGtleSkpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRwZW5kaW5nS2V5c18kZ2Uuc2V0KGtleSBpbiB0aGlzLnRhcmdldF8pOyAvLyBOb3RpZnkgc3BpZXMvbGlzdGVuZXJzXG5cbiAgICAgIGlmIChub3RpZnkgfHwgbm90aWZ5U3B5KSB7XG4gICAgICAgIHZhciBfY2hhbmdlMiA9IHtcbiAgICAgICAgICB0eXBlOiBSRU1PVkUsXG4gICAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwib2JqZWN0XCIsXG4gICAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyB8fCB0aGlzLnRhcmdldF8sXG4gICAgICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICAgIG9sZFZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBuYW1lOiBrZXlcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSkge1xuICAgICAgICAgIHNweVJlcG9ydFN0YXJ0KF9jaGFuZ2UyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub3RpZnkpIHtcbiAgICAgICAgICBub3RpZnlMaXN0ZW5lcnModGhpcywgX2NoYW5nZTIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHtcbiAgICAgICAgICBzcHlSZXBvcnRFbmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBlbmRCYXRjaCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxyXG4gICAqIE9ic2VydmVzIHRoaXMgb2JqZWN0LiBUcmlnZ2VycyBmb3IgdGhlIGV2ZW50cyAnYWRkJywgJ3VwZGF0ZScgYW5kICdkZWxldGUnLlxyXG4gICAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L29ic2VydmVcclxuICAgKiBmb3IgY2FsbGJhY2sgZGV0YWlsc1xyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm9ic2VydmVfID0gZnVuY3Rpb24gb2JzZXJ2ZV8oY2FsbGJhY2ssIGZpcmVJbW1lZGlhdGVseSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZmlyZUltbWVkaWF0ZWx5ID09PSB0cnVlKSB7XG4gICAgICBkaWUoXCJgb2JzZXJ2ZWAgZG9lc24ndCBzdXBwb3J0IHRoZSBmaXJlIGltbWVkaWF0ZWx5IHByb3BlcnR5IGZvciBvYnNlcnZhYmxlIG9iamVjdHMuXCIpO1xuICAgIH1cblxuICAgIHJldHVybiByZWdpc3Rlckxpc3RlbmVyKHRoaXMsIGNhbGxiYWNrKTtcbiAgfTtcblxuICBfcHJvdG8uaW50ZXJjZXB0XyA9IGZ1bmN0aW9uIGludGVyY2VwdF8oaGFuZGxlcikge1xuICAgIHJldHVybiByZWdpc3RlckludGVyY2VwdG9yKHRoaXMsIGhhbmRsZXIpO1xuICB9O1xuXG4gIF9wcm90by5ub3RpZnlQcm9wZXJ0eUFkZGl0aW9uXyA9IGZ1bmN0aW9uIG5vdGlmeVByb3BlcnR5QWRkaXRpb25fKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgX3RoaXMkcGVuZGluZ0tleXNfMiwgX3RoaXMkcGVuZGluZ0tleXNfMiRnO1xuXG4gICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcbiAgICB2YXIgbm90aWZ5U3B5ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGlzU3B5RW5hYmxlZCgpO1xuXG4gICAgaWYgKG5vdGlmeSB8fCBub3RpZnlTcHkpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBub3RpZnkgfHwgbm90aWZ5U3B5ID8ge1xuICAgICAgICB0eXBlOiBBREQsXG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcIm9iamVjdFwiLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfLFxuICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgIG5ld1ZhbHVlOiB2YWx1ZVxuICAgICAgfSA6IG51bGw7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSB7XG4gICAgICAgIHNweVJlcG9ydFN0YXJ0KGNoYW5nZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChub3RpZnkpIHtcbiAgICAgICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIGNoYW5nZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSB7XG4gICAgICAgIHNweVJlcG9ydEVuZCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIChfdGhpcyRwZW5kaW5nS2V5c18yID0gdGhpcy5wZW5kaW5nS2V5c18pID09IG51bGwgPyB2b2lkIDAgOiAoX3RoaXMkcGVuZGluZ0tleXNfMiRnID0gX3RoaXMkcGVuZGluZ0tleXNfMi5nZXQoa2V5KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHBlbmRpbmdLZXlzXzIkZy5zZXQodHJ1ZSk7IC8vIE5vdGlmeSBcImtleXMvZW50cmllcy92YWx1ZXNcIiBvYnNlcnZlcnNcblxuICAgIHRoaXMua2V5c0F0b21fLnJlcG9ydENoYW5nZWQoKTtcbiAgfTtcblxuICBfcHJvdG8ub3duS2V5c18gPSBmdW5jdGlvbiBvd25LZXlzXygpIHtcbiAgICB0aGlzLmtleXNBdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHJldHVybiBvd25LZXlzKHRoaXMudGFyZ2V0Xyk7XG4gIH07XG5cbiAgX3Byb3RvLmtleXNfID0gZnVuY3Rpb24ga2V5c18oKSB7XG4gICAgLy8gUmV0dXJucyBlbnVtZXJhYmxlICYmIG93biwgYnV0IHVuZm9ydHVuYXRlbHkga2V5c0F0b20gd2lsbCByZXBvcnQgb24gQU5ZIGtleSBjaGFuZ2UuXG4gICAgLy8gVGhlcmUgaXMgbm8gd2F5IHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gT2JqZWN0LmtleXMob2JqZWN0KSBhbmQgUmVmbGVjdC5vd25LZXlzKG9iamVjdCkgLSBib3RoIGFyZSBoYW5kbGVkIGJ5IG93bktleXMgdHJhcC5cbiAgICAvLyBXZSBjYW4gZWl0aGVyIG92ZXItcmVwb3J0IGluIE9iamVjdC5rZXlzKG9iamVjdCkgb3IgdW5kZXItcmVwb3J0IGluIFJlZmxlY3Qub3duS2V5cyhvYmplY3QpXG4gICAgLy8gV2UgY2hvb3NlIHRvIG92ZXItcmVwb3J0IGluIE9iamVjdC5rZXlzKG9iamVjdCksIGJlY2F1c2U6XG4gICAgLy8gLSB0eXBpY2FsbHkgaXQncyB1c2VkIHdpdGggc2ltcGxlIGRhdGEgb2JqZWN0c1xuICAgIC8vIC0gd2hlbiBzeW1ib2xpYy9ub24tZW51bWVyYWJsZSBrZXlzIGFyZSByZWxldmFudCBSZWZsZWN0Lm93bktleXMgd29ya3MgYXMgZXhwZWN0ZWRcbiAgICB0aGlzLmtleXNBdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnRhcmdldF8pO1xuICB9O1xuXG4gIHJldHVybiBPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb247XG59KCk7XG5mdW5jdGlvbiBhc09ic2VydmFibGVPYmplY3QodGFyZ2V0LCBvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucyRuYW1lO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgb3B0aW9ucyAmJiBpc09ic2VydmFibGVPYmplY3QodGFyZ2V0KSkge1xuICAgIGRpZShcIk9wdGlvbnMgY2FuJ3QgYmUgcHJvdmlkZWQgZm9yIGFscmVhZHkgb2JzZXJ2YWJsZSBvYmplY3RzLlwiKTtcbiAgfVxuXG4gIGlmIChoYXNQcm9wKHRhcmdldCwgJG1vYngpKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhKGdldEFkbWluaXN0cmF0aW9uKHRhcmdldCkgaW5zdGFuY2VvZiBPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24pKSB7XG4gICAgICBkaWUoXCJDYW5ub3QgY29udmVydCAnXCIgKyBnZXREZWJ1Z05hbWUodGFyZ2V0KSArIFwiJyBpbnRvIG9ic2VydmFibGUgb2JqZWN0OlwiICsgXCJcXG5UaGUgdGFyZ2V0IGlzIGFscmVhZHkgb2JzZXJ2YWJsZSBvZiBkaWZmZXJlbnQgdHlwZS5cIiArIFwiXFxuRXh0ZW5kaW5nIGJ1aWx0aW5zIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFPYmplY3QuaXNFeHRlbnNpYmxlKHRhcmdldCkpIHtcbiAgICBkaWUoXCJDYW5ub3QgbWFrZSB0aGUgZGVzaWduYXRlZCBvYmplY3Qgb2JzZXJ2YWJsZTsgaXQgaXMgbm90IGV4dGVuc2libGVcIik7XG4gIH1cblxuICB2YXIgbmFtZSA9IChfb3B0aW9ucyRuYW1lID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5uYW1lKSAhPSBudWxsID8gX29wdGlvbnMkbmFtZSA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IChpc1BsYWluT2JqZWN0KHRhcmdldCkgPyBcIk9ic2VydmFibGVPYmplY3RcIiA6IHRhcmdldC5jb25zdHJ1Y3Rvci5uYW1lKSArIFwiQFwiICsgZ2V0TmV4dElkKCkgOiBcIk9ic2VydmFibGVPYmplY3RcIjtcbiAgdmFyIGFkbSA9IG5ldyBPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24odGFyZ2V0LCBuZXcgTWFwKCksIFN0cmluZyhuYW1lKSwgZ2V0QW5ub3RhdGlvbkZyb21PcHRpb25zKG9wdGlvbnMpKTtcbiAgYWRkSGlkZGVuUHJvcCh0YXJnZXQsICRtb2J4LCBhZG0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxudmFyIGlzT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUoXCJPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb25cIiwgT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uKTtcblxuZnVuY3Rpb24gZ2V0Q2FjaGVkT2JzZXJ2YWJsZVByb3BEZXNjcmlwdG9yKGtleSkge1xuICByZXR1cm4gZGVzY3JpcHRvckNhY2hlW2tleV0gfHwgKGRlc2NyaXB0b3JDYWNoZVtrZXldID0ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXNbJG1vYnhdLmdldE9ic2VydmFibGVQcm9wVmFsdWVfKGtleSk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXNbJG1vYnhdLnNldE9ic2VydmFibGVQcm9wVmFsdWVfKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzT2JzZXJ2YWJsZU9iamVjdCh0aGluZykge1xuICBpZiAoaXNPYmplY3QodGhpbmcpKSB7XG4gICAgcmV0dXJuIGlzT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uKHRoaW5nWyRtb2J4XSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiByZWNvcmRBbm5vdGF0aW9uQXBwbGllZChhZG0sIGFubm90YXRpb24sIGtleSkge1xuICB2YXIgX2FkbSR0YXJnZXRfJHN0b3JlZEFuO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBhZG0uYXBwbGllZEFubm90YXRpb25zX1trZXldID0gYW5ub3RhdGlvbjtcbiAgfSAvLyBSZW1vdmUgYXBwbGllZCBkZWNvcmF0b3IgYW5ub3RhdGlvbiBzbyB3ZSBkb24ndCB0cnkgdG8gYXBwbHkgaXQgYWdhaW4gaW4gc3ViY2xhc3MgY29uc3RydWN0b3JcblxuXG4gIChfYWRtJHRhcmdldF8kc3RvcmVkQW4gPSBhZG0udGFyZ2V0X1tzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF0pID09IG51bGwgPyB0cnVlIDogZGVsZXRlIF9hZG0kdGFyZ2V0XyRzdG9yZWRBbltrZXldO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRBbm5vdGFibGUoYWRtLCBhbm5vdGF0aW9uLCBrZXkpIHtcbiAgLy8gVmFsaWQgYW5ub3RhdGlvblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFpc0Fubm90YXRpb24oYW5ub3RhdGlvbikpIHtcbiAgICBkaWUoXCJDYW5ub3QgYW5ub3RhdGUgJ1wiICsgYWRtLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKSArIFwiJzogSW52YWxpZCBhbm5vdGF0aW9uLlwiKTtcbiAgfVxuICAvKlxyXG4gIC8vIENvbmZpZ3VyYWJsZSwgbm90IHNlYWxlZCwgbm90IGZyb3plblxyXG4gIC8vIFBvc3NpYmx5IG5vdCBuZWVkZWQsIGp1c3QgYSBsaXR0bGUgYmV0dGVyIGVycm9yIHRoZW4gdGhlIG9uZSB0aHJvd24gYnkgZW5naW5lLlxyXG4gIC8vIENhc2VzIHdoZXJlIHRoaXMgd291bGQgYmUgdXNlZnVsIHRoZSBtb3N0IChzdWJjbGFzcyBmaWVsZCBpbml0aWFsaXplcikgYXJlIG5vdCBpbnRlcmNlcHRhYmxlIGJ5IHRoaXMuXHJcbiAgaWYgKF9fREVWX18pIHtcclxuICAgICAgY29uc3QgY29uZmlndXJhYmxlID0gZ2V0RGVzY3JpcHRvcihhZG0udGFyZ2V0Xywga2V5KT8uY29uZmlndXJhYmxlXHJcbiAgICAgIGNvbnN0IGZyb3plbiA9IE9iamVjdC5pc0Zyb3plbihhZG0udGFyZ2V0XylcclxuICAgICAgY29uc3Qgc2VhbGVkID0gT2JqZWN0LmlzU2VhbGVkKGFkbS50YXJnZXRfKVxyXG4gICAgICBpZiAoIWNvbmZpZ3VyYWJsZSB8fCBmcm96ZW4gfHwgc2VhbGVkKSB7XHJcbiAgICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBgJHthZG0ubmFtZV99LiR7a2V5LnRvU3RyaW5nKCl9YFxyXG4gICAgICAgICAgY29uc3QgcmVxdWVzdGVkQW5ub3RhdGlvblR5cGUgPSBhbm5vdGF0aW9uLmFubm90YXRpb25UeXBlX1xyXG4gICAgICAgICAgbGV0IGVycm9yID0gYENhbm5vdCBhcHBseSAnJHtyZXF1ZXN0ZWRBbm5vdGF0aW9uVHlwZX0nIHRvICcke2ZpZWxkTmFtZX0nOmBcclxuICAgICAgICAgIGlmIChmcm96ZW4pIHtcclxuICAgICAgICAgICAgICBlcnJvciArPSBgXFxuT2JqZWN0IGlzIGZyb3plbi5gXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoc2VhbGVkKSB7XHJcbiAgICAgICAgICAgICAgZXJyb3IgKz0gYFxcbk9iamVjdCBpcyBzZWFsZWQuYFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCFjb25maWd1cmFibGUpIHtcclxuICAgICAgICAgICAgICBlcnJvciArPSBgXFxucHJvcGVydHkgaXMgbm90IGNvbmZpZ3VyYWJsZS5gXHJcbiAgICAgICAgICAgICAgLy8gTWVudGlvbiBvbmx5IGlmIGNhdXNlZCBieSB1cyB0byBhdm9pZCBjb25mdXNpb25cclxuICAgICAgICAgICAgICBpZiAoaGFzUHJvcChhZG0uYXBwbGllZEFubm90YXRpb25zISwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICBlcnJvciArPSBgXFxuVG8gcHJldmVudCBhY2NpZGVudGFsIHJlLWRlZmluaXRpb24gb2YgYSBmaWVsZCBieSBhIHN1YmNsYXNzLCBgXHJcbiAgICAgICAgICAgICAgICAgIGVycm9yICs9IGBhbGwgYW5ub3RhdGVkIGZpZWxkcyBvZiBub24tcGxhaW4gb2JqZWN0cyAoY2xhc3NlcykgYXJlIG5vdCBjb25maWd1cmFibGUuYFxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGRpZShlcnJvcilcclxuICAgICAgfVxyXG4gIH1cclxuICAqL1xuICAvLyBOb3QgYW5ub3RhdGVkXG5cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFpc092ZXJyaWRlKGFubm90YXRpb24pICYmIGhhc1Byb3AoYWRtLmFwcGxpZWRBbm5vdGF0aW9uc18sIGtleSkpIHtcbiAgICB2YXIgZmllbGROYW1lID0gYWRtLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKTtcbiAgICB2YXIgY3VycmVudEFubm90YXRpb25UeXBlID0gYWRtLmFwcGxpZWRBbm5vdGF0aW9uc19ba2V5XS5hbm5vdGF0aW9uVHlwZV87XG4gICAgdmFyIHJlcXVlc3RlZEFubm90YXRpb25UeXBlID0gYW5ub3RhdGlvbi5hbm5vdGF0aW9uVHlwZV87XG4gICAgZGllKFwiQ2Fubm90IGFwcGx5ICdcIiArIHJlcXVlc3RlZEFubm90YXRpb25UeXBlICsgXCInIHRvICdcIiArIGZpZWxkTmFtZSArIFwiJzpcIiArIChcIlxcblRoZSBmaWVsZCBpcyBhbHJlYWR5IGFubm90YXRlZCB3aXRoICdcIiArIGN1cnJlbnRBbm5vdGF0aW9uVHlwZSArIFwiJy5cIikgKyBcIlxcblJlLWFubm90YXRpbmcgZmllbGRzIGlzIG5vdCBhbGxvd2VkLlwiICsgXCJcXG5Vc2UgJ292ZXJyaWRlJyBhbm5vdGF0aW9uIGZvciBtZXRob2RzIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3MuXCIpO1xuICB9XG59XG5cbnZhciBFTlRSWV8wID0gLyojX19QVVJFX18qL2NyZWF0ZUFycmF5RW50cnlEZXNjcmlwdG9yKDApO1xuLyoqXHJcbiAqIFRoaXMgYXJyYXkgYnVmZmVyIGNvbnRhaW5zIHR3byBsaXN0cyBvZiBwcm9wZXJ0aWVzLCBzbyB0aGF0IGFsbCBhcnJheXNcclxuICogY2FuIHJlY3ljbGUgdGhlaXIgcHJvcGVydHkgZGVmaW5pdGlvbnMsIHdoaWNoIHNpZ25pZmljYW50bHkgaW1wcm92ZXMgcGVyZm9ybWFuY2Ugb2YgY3JlYXRpbmdcclxuICogcHJvcGVydGllcyBvbiB0aGUgZmx5LlxyXG4gKi9cblxuXG52YXIgT0JTRVJWQUJMRV9BUlJBWV9CVUZGRVJfU0laRSA9IDA7IC8vIFR5cGVzY3JpcHQgd29ya2Fyb3VuZCB0byBtYWtlIHN1cmUgT2JzZXJ2YWJsZUFycmF5IGV4dGVuZHMgQXJyYXlcblxudmFyIFN0dWJBcnJheSA9IGZ1bmN0aW9uIFN0dWJBcnJheSgpIHt9O1xuXG5mdW5jdGlvbiBpbmhlcml0KGN0b3IsIHByb3RvKSB7XG4gIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoY3Rvci5wcm90b3R5cGUsIHByb3RvKTtcbiAgfSBlbHNlIGlmIChjdG9yLnByb3RvdHlwZS5fX3Byb3RvX18gIT09IHVuZGVmaW5lZCkge1xuICAgIGN0b3IucHJvdG90eXBlLl9fcHJvdG9fXyA9IHByb3RvO1xuICB9IGVsc2Uge1xuICAgIGN0b3IucHJvdG90eXBlID0gcHJvdG87XG4gIH1cbn1cblxuaW5oZXJpdChTdHViQXJyYXksIEFycmF5LnByb3RvdHlwZSk7IC8vIFdlZXggcHJvdG8gZnJlZXplIHByb3RlY3Rpb24gd2FzIGhlcmUsXG4vLyBidXQgaXQgaXMgdW5jbGVhciB3aHkgdGhlIGhhY2sgaXMgbmVlZCBhcyBNb2JYIG5ldmVyIGNoYW5nZWQgdGhlIHByb3RvdHlwZVxuLy8gYW55d2F5LCBzbyByZW1vdmVkIGl0IGluIFY2XG5cbnZhciBMZWdhY3lPYnNlcnZhYmxlQXJyYXkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdHViQXJyYXksIF9TeW1ib2wkdG9TdHJpbmdUYWcsIF9TeW1ib2wkaXRlcmF0b3IpIHtcbiAgX2luaGVyaXRzTG9vc2UoTGVnYWN5T2JzZXJ2YWJsZUFycmF5LCBfU3R1YkFycmF5KTtcblxuICBmdW5jdGlvbiBMZWdhY3lPYnNlcnZhYmxlQXJyYXkoaW5pdGlhbFZhbHVlcywgZW5oYW5jZXIsIG5hbWUsIG93bmVkKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgaWYgKG5hbWUgPT09IHZvaWQgMCkge1xuICAgICAgbmFtZSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiT2JzZXJ2YWJsZUFycmF5QFwiICsgZ2V0TmV4dElkKCkgOiBcIk9ic2VydmFibGVBcnJheVwiO1xuICAgIH1cblxuICAgIGlmIChvd25lZCA9PT0gdm9pZCAwKSB7XG4gICAgICBvd25lZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIF90aGlzID0gX1N0dWJBcnJheS5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgdmFyIGFkbSA9IG5ldyBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbihuYW1lLCBlbmhhbmNlciwgb3duZWQsIHRydWUpO1xuICAgIGFkbS5wcm94eV8gPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKTtcbiAgICBhZGRIaWRkZW5GaW5hbFByb3AoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksICRtb2J4LCBhZG0pO1xuXG4gICAgaWYgKGluaXRpYWxWYWx1ZXMgJiYgaW5pdGlhbFZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIHZhciBwcmV2ID0gYWxsb3dTdGF0ZUNoYW5nZXNTdGFydCh0cnVlKTsgLy8gQHRzLWlnbm9yZVxuXG4gICAgICBfdGhpcy5zcGxpY2VXaXRoQXJyYXkoMCwgMCwgaW5pdGlhbFZhbHVlcyk7XG5cbiAgICAgIGFsbG93U3RhdGVDaGFuZ2VzRW5kKHByZXYpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIC8vIFNlZW1zIHRoYXQgU2FmYXJpIHdvbid0IHVzZSBudW1lcmljIHByb3RvdHlwZSBzZXR0ZXIgdW50aWxsIGFueSAqIG51bWVyaWMgcHJvcGVydHkgaXNcbiAgICAgIC8vIGRlZmluZWQgb24gdGhlIGluc3RhbmNlLiBBZnRlciB0aGF0IGl0IHdvcmtzIGZpbmUsIGV2ZW4gaWYgdGhpcyBwcm9wZXJ0eSBpcyBkZWxldGVkLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIjBcIiwgRU5UUllfMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IExlZ2FjeU9ic2VydmFibGVBcnJheS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICB0aGlzWyRtb2J4XS5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFycmF5cyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFycmF5c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseSh0aGlzLnNsaWNlKCksIC8vQHRzLWlnbm9yZVxuICAgIGFycmF5cy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBpc09ic2VydmFibGVBcnJheShhKSA/IGEuc2xpY2UoKSA6IGE7XG4gICAgfSkpO1xuICB9O1xuXG4gIF9wcm90b1tfU3ltYm9sJGl0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG5leHRJbmRleCA9IDA7XG4gICAgcmV0dXJuIG1ha2VJdGVyYWJsZSh7XG4gICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICByZXR1cm4gbmV4dEluZGV4IDwgc2VsZi5sZW5ndGggPyB7XG4gICAgICAgICAgdmFsdWU6IHNlbGZbbmV4dEluZGV4KytdLFxuICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKExlZ2FjeU9ic2VydmFibGVBcnJheSwgW3tcbiAgICBrZXk6IFwibGVuZ3RoXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1skbW9ieF0uZ2V0QXJyYXlMZW5ndGhfKCk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdMZW5ndGgpIHtcbiAgICAgIHRoaXNbJG1vYnhdLnNldEFycmF5TGVuZ3RoXyhuZXdMZW5ndGgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogX1N5bWJvbCR0b1N0cmluZ1RhZyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBcIkFycmF5XCI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExlZ2FjeU9ic2VydmFibGVBcnJheTtcbn0oU3R1YkFycmF5LCBTeW1ib2wudG9TdHJpbmdUYWcsIFN5bWJvbC5pdGVyYXRvcik7XG5cbk9iamVjdC5lbnRyaWVzKGFycmF5RXh0ZW5zaW9ucykuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgcHJvcCA9IF9yZWZbMF0sXG4gICAgICBmbiA9IF9yZWZbMV07XG5cbiAgaWYgKHByb3AgIT09IFwiY29uY2F0XCIpIHtcbiAgICBhZGRIaWRkZW5Qcm9wKExlZ2FjeU9ic2VydmFibGVBcnJheS5wcm90b3R5cGUsIHByb3AsIGZuKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5RW50cnlEZXNjcmlwdG9yKGluZGV4KSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXNbJG1vYnhdLmdldF8oaW5kZXgpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXNbJG1vYnhdLnNldF8oaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5QnVmZmVySXRlbShpbmRleCkge1xuICBkZWZpbmVQcm9wZXJ0eShMZWdhY3lPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLCBcIlwiICsgaW5kZXgsIGNyZWF0ZUFycmF5RW50cnlEZXNjcmlwdG9yKGluZGV4KSk7XG59XG5cbmZ1bmN0aW9uIHJlc2VydmVBcnJheUJ1ZmZlcihtYXgpIHtcbiAgaWYgKG1heCA+IE9CU0VSVkFCTEVfQVJSQVlfQlVGRkVSX1NJWkUpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IE9CU0VSVkFCTEVfQVJSQVlfQlVGRkVSX1NJWkU7IGluZGV4IDwgbWF4ICsgMTAwOyBpbmRleCsrKSB7XG4gICAgICBjcmVhdGVBcnJheUJ1ZmZlckl0ZW0oaW5kZXgpO1xuICAgIH1cblxuICAgIE9CU0VSVkFCTEVfQVJSQVlfQlVGRkVSX1NJWkUgPSBtYXg7XG4gIH1cbn1cbnJlc2VydmVBcnJheUJ1ZmZlcigxMDAwKTtcbmZ1bmN0aW9uIGNyZWF0ZUxlZ2FjeUFycmF5KGluaXRpYWxWYWx1ZXMsIGVuaGFuY2VyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgTGVnYWN5T2JzZXJ2YWJsZUFycmF5KGluaXRpYWxWYWx1ZXMsIGVuaGFuY2VyLCBuYW1lKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXRvbSh0aGluZywgcHJvcGVydHkpIHtcbiAgaWYgKHR5cGVvZiB0aGluZyA9PT0gXCJvYmplY3RcIiAmJiB0aGluZyAhPT0gbnVsbCkge1xuICAgIGlmIChpc09ic2VydmFibGVBcnJheSh0aGluZykpIHtcbiAgICAgIGlmIChwcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRpZSgyMyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGluZ1skbW9ieF0uYXRvbV87XG4gICAgfVxuXG4gICAgaWYgKGlzT2JzZXJ2YWJsZVNldCh0aGluZykpIHtcbiAgICAgIHJldHVybiB0aGluZ1skbW9ieF07XG4gICAgfVxuXG4gICAgaWYgKGlzT2JzZXJ2YWJsZU1hcCh0aGluZykpIHtcbiAgICAgIGlmIChwcm9wZXJ0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGluZy5rZXlzQXRvbV87XG4gICAgICB9XG5cbiAgICAgIHZhciBvYnNlcnZhYmxlID0gdGhpbmcuZGF0YV8uZ2V0KHByb3BlcnR5KSB8fCB0aGluZy5oYXNNYXBfLmdldChwcm9wZXJ0eSk7XG5cbiAgICAgIGlmICghb2JzZXJ2YWJsZSkge1xuICAgICAgICBkaWUoMjUsIHByb3BlcnR5LCBnZXREZWJ1Z05hbWUodGhpbmcpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgfVxuXG5cbiAgICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHRoaW5nKSkge1xuICAgICAgaWYgKCFwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gZGllKDI2KTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9vYnNlcnZhYmxlID0gdGhpbmdbJG1vYnhdLnZhbHVlc18uZ2V0KHByb3BlcnR5KTtcblxuICAgICAgaWYgKCFfb2JzZXJ2YWJsZSkge1xuICAgICAgICBkaWUoMjcsIHByb3BlcnR5LCBnZXREZWJ1Z05hbWUodGhpbmcpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9vYnNlcnZhYmxlO1xuICAgIH1cblxuICAgIGlmIChpc0F0b20odGhpbmcpIHx8IGlzQ29tcHV0ZWRWYWx1ZSh0aGluZykgfHwgaXNSZWFjdGlvbih0aGluZykpIHtcbiAgICAgIHJldHVybiB0aGluZztcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih0aGluZykpIHtcbiAgICBpZiAoaXNSZWFjdGlvbih0aGluZ1skbW9ieF0pKSB7XG4gICAgICAvLyBkaXNwb3NlciBmdW5jdGlvblxuICAgICAgcmV0dXJuIHRoaW5nWyRtb2J4XTtcbiAgICB9XG4gIH1cblxuICBkaWUoMjgpO1xufVxuZnVuY3Rpb24gZ2V0QWRtaW5pc3RyYXRpb24odGhpbmcsIHByb3BlcnR5KSB7XG4gIGlmICghdGhpbmcpIHtcbiAgICBkaWUoMjkpO1xuICB9XG5cbiAgaWYgKHByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZ2V0QWRtaW5pc3RyYXRpb24oZ2V0QXRvbSh0aGluZywgcHJvcGVydHkpKTtcbiAgfVxuXG4gIGlmIChpc0F0b20odGhpbmcpIHx8IGlzQ29tcHV0ZWRWYWx1ZSh0aGluZykgfHwgaXNSZWFjdGlvbih0aGluZykpIHtcbiAgICByZXR1cm4gdGhpbmc7XG4gIH1cblxuICBpZiAoaXNPYnNlcnZhYmxlTWFwKHRoaW5nKSB8fCBpc09ic2VydmFibGVTZXQodGhpbmcpKSB7XG4gICAgcmV0dXJuIHRoaW5nO1xuICB9XG5cbiAgaWYgKHRoaW5nWyRtb2J4XSkge1xuICAgIHJldHVybiB0aGluZ1skbW9ieF07XG4gIH1cblxuICBkaWUoMjQsIHRoaW5nKTtcbn1cbmZ1bmN0aW9uIGdldERlYnVnTmFtZSh0aGluZywgcHJvcGVydHkpIHtcbiAgdmFyIG5hbWVkO1xuXG4gIGlmIChwcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbmFtZWQgPSBnZXRBdG9tKHRoaW5nLCBwcm9wZXJ0eSk7XG4gIH0gZWxzZSBpZiAoaXNBY3Rpb24odGhpbmcpKSB7XG4gICAgcmV0dXJuIHRoaW5nLm5hbWU7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHRoaW5nKSB8fCBpc09ic2VydmFibGVNYXAodGhpbmcpIHx8IGlzT2JzZXJ2YWJsZVNldCh0aGluZykpIHtcbiAgICBuYW1lZCA9IGdldEFkbWluaXN0cmF0aW9uKHRoaW5nKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB2YWxpZCBmb3IgYXJyYXlzIGFzIHdlbGxcbiAgICBuYW1lZCA9IGdldEF0b20odGhpbmcpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWVkLm5hbWVfO1xufVxuXG52YXIgdG9TdHJpbmcgPSBvYmplY3RQcm90b3R5cGUudG9TdHJpbmc7XG5mdW5jdGlvbiBkZWVwRXF1YWwoYSwgYiwgZGVwdGgpIHtcbiAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcbiAgICBkZXB0aCA9IC0xO1xuICB9XG5cbiAgcmV0dXJuIGVxKGEsIGIsIGRlcHRoKTtcbn0gLy8gQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL2Jsb2IvNWMyMzdhN2M2ODJmYjY4ZmQ1Mzc4MjAzZjBiZjIyZGNlMTYyNDg1NC91bmRlcnNjb3JlLmpzI0wxMTg2LUwxMjg5XG4vLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYGlzRXF1YWxgLlxuXG5mdW5jdGlvbiBlcShhLCBiLCBkZXB0aCwgYVN0YWNrLCBiU3RhY2spIHtcbiAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAvLyBTZWUgdGhlIFtIYXJtb255IGBlZ2FsYCBwcm9wb3NhbF0oaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTplZ2FsKS5cbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gIH0gLy8gYG51bGxgIG9yIGB1bmRlZmluZWRgIG9ubHkgZXF1YWwgdG8gaXRzZWxmIChzdHJpY3QgY29tcGFyaXNvbikuXG5cblxuICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLlxuXG5cbiAgaWYgKGEgIT09IGEpIHtcbiAgICByZXR1cm4gYiAhPT0gYjtcbiAgfSAvLyBFeGhhdXN0IHByaW1pdGl2ZSBjaGVja3NcblxuXG4gIHZhciB0eXBlID0gdHlwZW9mIGE7XG5cbiAgaWYgKHR5cGUgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBiICE9IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cblxuXG4gIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuXG4gIGlmIChjbGFzc05hbWUgIT09IHRvU3RyaW5nLmNhbGwoYikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgIGNhc2UgXCJbb2JqZWN0IFJlZ0V4cF1cIjogLy8gUmVnRXhwcyBhcmUgY29lcmNlZCB0byBzdHJpbmdzIGZvciBjb21wYXJpc29uIChOb3RlOiAnJyArIC9hL2kgPT09ICcvYS9pJylcblxuICAgIGNhc2UgXCJbb2JqZWN0IFN0cmluZ11cIjpcbiAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICByZXR1cm4gXCJcIiArIGEgPT09IFwiXCIgKyBiO1xuXG4gICAgY2FzZSBcIltvYmplY3QgTnVtYmVyXVwiOlxuICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS5cbiAgICAgIC8vIE9iamVjdChOYU4pIGlzIGVxdWl2YWxlbnQgdG8gTmFOLlxuICAgICAgaWYgKCthICE9PSArYSkge1xuICAgICAgICByZXR1cm4gK2IgIT09ICtiO1xuICAgICAgfSAvLyBBbiBgZWdhbGAgY29tcGFyaXNvbiBpcyBwZXJmb3JtZWQgZm9yIG90aGVyIG51bWVyaWMgdmFsdWVzLlxuXG5cbiAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XG5cbiAgICBjYXNlIFwiW29iamVjdCBEYXRlXVwiOlxuICAgIGNhc2UgXCJbb2JqZWN0IEJvb2xlYW5dXCI6XG4gICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXG4gICAgICAvLyBvZiBgTmFOYCBhcmUgbm90IGVxdWl2YWxlbnQuXG4gICAgICByZXR1cm4gK2EgPT09ICtiO1xuXG4gICAgY2FzZSBcIltvYmplY3QgU3ltYm9sXVwiOlxuICAgICAgcmV0dXJuIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLnZhbHVlT2YuY2FsbChhKSA9PT0gU3ltYm9sLnZhbHVlT2YuY2FsbChiKTtcblxuICAgIGNhc2UgXCJbb2JqZWN0IE1hcF1cIjpcbiAgICBjYXNlIFwiW29iamVjdCBTZXRdXCI6XG4gICAgICAvLyBNYXBzIGFuZCBTZXRzIGFyZSB1bndyYXBwZWQgdG8gYXJyYXlzIG9mIGVudHJ5LXBhaXJzLCBhZGRpbmcgYW4gaW5jaWRlbnRhbCBsZXZlbC5cbiAgICAgIC8vIEhpZGUgdGhpcyBleHRyYSBsZXZlbCBieSBpbmNyZWFzaW5nIHRoZSBkZXB0aC5cbiAgICAgIGlmIChkZXB0aCA+PSAwKSB7XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICB9IC8vIFVud3JhcCBhbnkgd3JhcHBlZCBvYmplY3RzLlxuXG5cbiAgYSA9IHVud3JhcChhKTtcbiAgYiA9IHVud3JhcChiKTtcbiAgdmFyIGFyZUFycmF5cyA9IGNsYXNzTmFtZSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuXG4gIGlmICghYXJlQXJyYXlzKSB7XG4gICAgaWYgKHR5cGVvZiBhICE9IFwib2JqZWN0XCIgfHwgdHlwZW9mIGIgIT0gXCJvYmplY3RcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzIG9yIGBBcnJheWBzXG4gICAgLy8gZnJvbSBkaWZmZXJlbnQgZnJhbWVzIGFyZS5cblxuXG4gICAgdmFyIGFDdG9yID0gYS5jb25zdHJ1Y3RvcixcbiAgICAgICAgYkN0b3IgPSBiLmNvbnN0cnVjdG9yO1xuXG4gICAgaWYgKGFDdG9yICE9PSBiQ3RvciAmJiAhKGlzRnVuY3Rpb24oYUN0b3IpICYmIGFDdG9yIGluc3RhbmNlb2YgYUN0b3IgJiYgaXNGdW5jdGlvbihiQ3RvcikgJiYgYkN0b3IgaW5zdGFuY2VvZiBiQ3RvcikgJiYgXCJjb25zdHJ1Y3RvclwiIGluIGEgJiYgXCJjb25zdHJ1Y3RvclwiIGluIGIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGVwdGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoZGVwdGggPCAwKSB7XG4gICAgZGVwdGggPSAtMTtcbiAgfSAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gIC8vIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gLlxuICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gIC8vIEl0J3MgZG9uZSBoZXJlIHNpbmNlIHdlIG9ubHkgbmVlZCB0aGVtIGZvciBvYmplY3RzIGFuZCBhcnJheXMgY29tcGFyaXNvbi5cblxuXG4gIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcbiAgYlN0YWNrID0gYlN0YWNrIHx8IFtdO1xuICB2YXIgbGVuZ3RoID0gYVN0YWNrLmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAvLyB1bmlxdWUgbmVzdGVkIHN0cnVjdHVyZXMuXG4gICAgaWYgKGFTdGFja1tsZW5ndGhdID09PSBhKSB7XG4gICAgICByZXR1cm4gYlN0YWNrW2xlbmd0aF0gPT09IGI7XG4gICAgfVxuICB9IC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cblxuXG4gIGFTdGFjay5wdXNoKGEpO1xuICBiU3RhY2sucHVzaChiKTsgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMuXG5cbiAgaWYgKGFyZUFycmF5cykge1xuICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuXG4gICAgaWYgKGxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIERlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXMuXG5cblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgaWYgKCFlcShhW2xlbmd0aF0sIGJbbGVuZ3RoXSwgZGVwdGggLSAxLCBhU3RhY2ssIGJTdGFjaykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBEZWVwIGNvbXBhcmUgb2JqZWN0cy5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIHZhciBrZXk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzIGJlZm9yZSBjb21wYXJpbmcgZGVlcCBlcXVhbGl0eS5cblxuICAgIGlmIChPYmplY3Qua2V5cyhiKS5sZW5ndGggIT09IGxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICBrZXkgPSBrZXlzW2xlbmd0aF07XG5cbiAgICAgIGlmICghKGhhc1Byb3AoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgZGVwdGggLSAxLCBhU3RhY2ssIGJTdGFjaykpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG5cblxuICBhU3RhY2sucG9wKCk7XG4gIGJTdGFjay5wb3AoKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHVud3JhcChhKSB7XG4gIGlmIChpc09ic2VydmFibGVBcnJheShhKSkge1xuICAgIHJldHVybiBhLnNsaWNlKCk7XG4gIH1cblxuICBpZiAoaXNFUzZNYXAoYSkgfHwgaXNPYnNlcnZhYmxlTWFwKGEpKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oYS5lbnRyaWVzKCkpO1xuICB9XG5cbiAgaWYgKGlzRVM2U2V0KGEpIHx8IGlzT2JzZXJ2YWJsZVNldChhKSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGEuZW50cmllcygpKTtcbiAgfVxuXG4gIHJldHVybiBhO1xufVxuXG5mdW5jdGlvbiBtYWtlSXRlcmFibGUoaXRlcmF0b3IpIHtcbiAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGdldFNlbGY7XG4gIHJldHVybiBpdGVyYXRvcjtcbn1cblxuZnVuY3Rpb24gZ2V0U2VsZigpIHtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGlzQW5ub3RhdGlvbih0aGluZykge1xuICByZXR1cm4gKC8vIENhbiBiZSBmdW5jdGlvblxuICAgIHRoaW5nIGluc3RhbmNlb2YgT2JqZWN0ICYmIHR5cGVvZiB0aGluZy5hbm5vdGF0aW9uVHlwZV8gPT09IFwic3RyaW5nXCIgJiYgaXNGdW5jdGlvbih0aGluZy5tYWtlXykgJiYgaXNGdW5jdGlvbih0aGluZy5leHRlbmRfKVxuICApO1xufVxuXG4vKipcclxuICogKGMpIE1pY2hlbCBXZXN0c3RyYXRlIDIwMTUgLSAyMDIwXHJcbiAqIE1JVCBMaWNlbnNlZFxyXG4gKlxyXG4gKiBXZWxjb21lIHRvIHRoZSBtb2J4IHNvdXJjZXMhIFRvIGdldCBhIGdsb2JhbCBvdmVydmlldyBvZiBob3cgTW9iWCBpbnRlcm5hbGx5IHdvcmtzLFxyXG4gKiB0aGlzIGlzIGEgZ29vZCBwbGFjZSB0byBzdGFydDpcclxuICogaHR0cHM6Ly9tZWRpdW0uY29tL0Btd2VzdHN0cmF0ZS9iZWNvbWluZy1mdWxseS1yZWFjdGl2ZS1hbi1pbi1kZXB0aC1leHBsYW5hdGlvbi1vZi1tb2JzZXJ2YWJsZS01NTk5NTI2MmEyNTQjLnh2Ymg2cWQ3NFxyXG4gKlxyXG4gKiBTb3VyY2UgZm9sZGVyczpcclxuICogPT09PT09PT09PT09PT09XHJcbiAqXHJcbiAqIC0gYXBpLyAgICAgTW9zdCBvZiB0aGUgcHVibGljIHN0YXRpYyBtZXRob2RzIGV4cG9zZWQgYnkgdGhlIG1vZHVsZSBjYW4gYmUgZm91bmQgaGVyZS5cclxuICogLSBjb3JlLyAgICBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgTW9iWCBhbGdvcml0aG07IGF0b21zLCBkZXJpdmF0aW9ucywgcmVhY3Rpb25zLCBkZXBlbmRlbmN5IHRyZWVzLCBvcHRpbWl6YXRpb25zLiBDb29sIHN0dWZmIGNhbiBiZSBmb3VuZCBoZXJlLlxyXG4gKiAtIHR5cGVzLyAgIEFsbCB0aGUgbWFnaWMgdGhhdCBpcyBuZWVkIHRvIGhhdmUgb2JzZXJ2YWJsZSBvYmplY3RzLCBhcnJheXMgYW5kIHZhbHVlcyBpcyBpbiB0aGlzIGZvbGRlci4gSW5jbHVkaW5nIHRoZSBtb2RpZmllcnMgbGlrZSBgYXNGbGF0YC5cclxuICogLSB1dGlscy8gICBVdGlsaXR5IHN0dWZmLlxyXG4gKlxyXG4gKi9cbltcIlN5bWJvbFwiLCBcIk1hcFwiLCBcIlNldFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gIHZhciBnID0gZ2V0R2xvYmFsKCk7XG5cbiAgaWYgKHR5cGVvZiBnW21dID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZGllKFwiTW9iWCByZXF1aXJlcyBnbG9iYWwgJ1wiICsgbSArIFwiJyB0byBiZSBhdmFpbGFibGUgb3IgcG9seWZpbGxlZFwiKTtcbiAgfVxufSk7XG5cbmlmICh0eXBlb2YgX19NT0JYX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09IFwib2JqZWN0XCIpIHtcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYW5keWtvZy9tb2J4LWRldnRvb2xzL1xuICBfX01PQlhfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5pbmplY3RNb2J4KHtcbiAgICBzcHk6IHNweSxcbiAgICBleHRyYXM6IHtcbiAgICAgIGdldERlYnVnTmFtZTogZ2V0RGVidWdOYW1lXG4gICAgfSxcbiAgICAkbW9ieDogJG1vYnhcbiAgfSk7XG59XG5cbmV4cG9ydCB7ICRtb2J4LCBGbG93Q2FuY2VsbGF0aW9uRXJyb3IsIE9ic2VydmFibGVNYXAsIE9ic2VydmFibGVTZXQsIFJlYWN0aW9uLCBhbGxvd1N0YXRlQ2hhbmdlcyBhcyBfYWxsb3dTdGF0ZUNoYW5nZXMsIHJ1bkluQWN0aW9uIGFzIF9hbGxvd1N0YXRlQ2hhbmdlc0luc2lkZUNvbXB1dGVkLCBhbGxvd1N0YXRlUmVhZHNFbmQgYXMgX2FsbG93U3RhdGVSZWFkc0VuZCwgYWxsb3dTdGF0ZVJlYWRzU3RhcnQgYXMgX2FsbG93U3RhdGVSZWFkc1N0YXJ0LCBhdXRvQWN0aW9uIGFzIF9hdXRvQWN0aW9uLCBfZW5kQWN0aW9uLCBnZXRBZG1pbmlzdHJhdGlvbiBhcyBfZ2V0QWRtaW5pc3RyYXRpb24sIGdldEdsb2JhbFN0YXRlIGFzIF9nZXRHbG9iYWxTdGF0ZSwgaW50ZXJjZXB0UmVhZHMgYXMgX2ludGVyY2VwdFJlYWRzLCBpc0NvbXB1dGluZ0Rlcml2YXRpb24gYXMgX2lzQ29tcHV0aW5nRGVyaXZhdGlvbiwgcmVzZXRHbG9iYWxTdGF0ZSBhcyBfcmVzZXRHbG9iYWxTdGF0ZSwgX3N0YXJ0QWN0aW9uLCBhY3Rpb24sIGF1dG9ydW4sIGNvbXBhcmVyLCBjb21wdXRlZCwgY29uZmlndXJlLCBjcmVhdGVBdG9tLCBhcGlEZWZpbmVQcm9wZXJ0eSBhcyBkZWZpbmVQcm9wZXJ0eSwgZW50cmllcywgZXh0ZW5kT2JzZXJ2YWJsZSwgZmxvdywgZmxvd1Jlc3VsdCwgZ2V0LCBnZXRBdG9tLCBnZXREZWJ1Z05hbWUsIGdldERlcGVuZGVuY3lUcmVlLCBnZXRPYnNlcnZlclRyZWUsIGhhcywgaW50ZXJjZXB0LCBpc0FjdGlvbiwgaXNPYnNlcnZhYmxlVmFsdWUgYXMgaXNCb3hlZE9ic2VydmFibGUsIGlzQ29tcHV0ZWQsIGlzQ29tcHV0ZWRQcm9wLCBpc0Zsb3csIGlzRmxvd0NhbmNlbGxhdGlvbkVycm9yLCBpc09ic2VydmFibGUsIGlzT2JzZXJ2YWJsZUFycmF5LCBpc09ic2VydmFibGVNYXAsIGlzT2JzZXJ2YWJsZU9iamVjdCwgaXNPYnNlcnZhYmxlUHJvcCwgaXNPYnNlcnZhYmxlU2V0LCBrZXlzLCBtYWtlQXV0b09ic2VydmFibGUsIG1ha2VPYnNlcnZhYmxlLCBvYnNlcnZhYmxlLCBvYnNlcnZlLCBvbkJlY29tZU9ic2VydmVkLCBvbkJlY29tZVVub2JzZXJ2ZWQsIG9uUmVhY3Rpb25FcnJvciwgb3ZlcnJpZGUsIGFwaU93bktleXMgYXMgb3duS2V5cywgcmVhY3Rpb24sIHJlbW92ZSwgcnVuSW5BY3Rpb24sIHNldCwgc3B5LCB0b0pTLCB0cmFjZSwgdHJhbnNhY3Rpb24sIHVudHJhY2tlZCwgdmFsdWVzLCB3aGVuIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2J4LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mobx/dist/mobx.esm.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/object-assign.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/object-assign.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar assign = Object.assign.bind(Object);\nmodule.exports = assign;\nmodule.exports[\"default\"] = module.exports;\n\n//# sourceMappingURL=object-assign.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9vYmplY3QtYXNzaWduLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLHlCQUFzQjs7QUFFdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC9wb2x5ZmlsbHMvb2JqZWN0LWFzc2lnbi5qcz9lN2QxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24uYmluZChPYmplY3QpO1xubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ247XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9iamVjdC1hc3NpZ24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/polyfills/object-assign.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[2]!./src/assets/styles/Home.module.css":
/*!***********************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[2]!./src/assets/styles/Home.module.css ***!
  \***********************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".Home_container__AICvM {\\r\\n  min-height: 100vh;\\r\\n  padding: 0 0.5rem;\\r\\n  display: flex;\\r\\n  flex-direction: column;\\r\\n  justify-content: center;\\r\\n  align-items: center;\\r\\n}\\r\\n\\r\\n.Home_title__i__Gz a {\\r\\n  color: #0070f3;\\r\\n  text-decoration: none;\\r\\n}\\r\\n\\r\\n.Home_title__i__Gz a:hover,\\r\\n.Home_title__i__Gz a:focus,\\r\\n.Home_title__i__Gz a:active {\\r\\n  text-decoration: underline;\\r\\n}\\r\\n\\r\\n.Home_title__i__Gz {\\r\\n  margin: 0 0 1rem;\\r\\n  line-height: 1.15;\\r\\n  font-size: 3.6rem;\\r\\n}\\r\\n\\r\\n.Home_title__i__Gz {\\r\\n  text-align: center;\\r\\n}\\r\\n\\r\\n.Home_title__i__Gz,\\r\\n.Home_description__SfUjv {\\r\\n  text-align: center;\\r\\n}\\r\\n\\r\\n\\r\\n.Home_description__SfUjv {\\r\\n  line-height: 1.5;\\r\\n  font-size: 1.5rem;\\r\\n}\\r\\n\\r\\n.Home_grid__Lu8ZJ {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: center;\\r\\n  flex-wrap: wrap;\\r\\n\\r\\n  max-width: 800px;\\r\\n  margin-top: 3rem;\\r\\n}\\r\\n\\r\\n.Home_card__vuM_6 {\\r\\n  margin: 1rem;\\r\\n  flex-basis: 45%;\\r\\n  padding: 1.5rem;\\r\\n  text-align: left;\\r\\n  color: inherit;\\r\\n  text-decoration: none;\\r\\n  border: 1px solid #eaeaea;\\r\\n  border-radius: 10px;\\r\\n  transition: color 0.15s ease, border-color 0.15s ease;\\r\\n}\\r\\n\\r\\n.Home_card__vuM_6:hover,\\r\\n.Home_card__vuM_6:focus,\\r\\n.Home_card__vuM_6:active {\\r\\n  color: #0070f3;\\r\\n  border-color: #0070f3;\\r\\n}\\r\\n\\r\\n.Home_card__vuM_6 h3 {\\r\\n  margin: 0 0 1rem 0;\\r\\n  font-size: 1.5rem;\\r\\n}\\r\\n\\r\\n.Home_card__vuM_6 p {\\r\\n  margin: 0;\\r\\n  font-size: 1.25rem;\\r\\n  line-height: 1.5;\\r\\n}\\r\\n\\r\\n.Home_logo__j9bCC {\\r\\n  height: 1em;\\r\\n}\\r\\n\\r\\n@media (max-width: 600px) {\\r\\n  .Home_grid__Lu8ZJ {\\r\\n    width: 100%;\\r\\n    flex-direction: column;\\r\\n  }\\r\\n}\\r\\n\\r\\n.Home_masthead__H_QBp {\\r\\n  background-image: url(\\\"https://cdn.pixabay.com/photo/2017/02/15/10/39/salad-2068220_1280.jpg\\\");\\r\\n  background-size: cover;\\r\\n  height: 85vh;\\r\\n  margin-top: 80px;\\r\\n  display: flex;\\r\\n  flex-direction: column;\\r\\n  justify-content: center;\\r\\n  box-shadow: 0.5rem -0.5rem 1.5rem 1rem rgba(0, 0, 0, 0.15) !important;\\r\\n}\\r\\n\\r\\n.Home_masthead__H_QBp h2 {\\r\\n  line-height: 140px;\\r\\n  font-size: 52px;\\r\\n}\\r\\n\\r\\n.Home_homeSection1___Efu7 {\\r\\n  height: 35vh;\\r\\n}\\r\\n\\r\\n.Home_homeSection2__cvhmf {\\r\\n  background-color: #8FC0A9;\\r\\n  height: 35vh;\\r\\n  margin-top: 40px;\\r\\n  box-shadow: 0.5rem -0.5rem 1.5rem 1rem rgba(0, 0, 0, 0.15) !important;\\r\\n}\\r\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://src/assets/styles/Home.module.css\"],\"names\":[],\"mappings\":\"AAAA;EACE,iBAAiB;EACjB,iBAAiB;EACjB,aAAa;EACb,sBAAsB;EACtB,uBAAuB;EACvB,mBAAmB;AACrB;;AAEA;EACE,cAAc;EACd,qBAAqB;AACvB;;AAEA;;;EAGE,0BAA0B;AAC5B;;AAEA;EACE,gBAAgB;EAChB,iBAAiB;EACjB,iBAAiB;AACnB;;AAEA;EACE,kBAAkB;AACpB;;AAEA;;EAEE,kBAAkB;AACpB;;;AAGA;EACE,gBAAgB;EAChB,iBAAiB;AACnB;;AAEA;EACE,aAAa;EACb,mBAAmB;EACnB,uBAAuB;EACvB,eAAe;;EAEf,gBAAgB;EAChB,gBAAgB;AAClB;;AAEA;EACE,YAAY;EACZ,eAAe;EACf,eAAe;EACf,gBAAgB;EAChB,cAAc;EACd,qBAAqB;EACrB,yBAAyB;EACzB,mBAAmB;EACnB,qDAAqD;AACvD;;AAEA;;;EAGE,cAAc;EACd,qBAAqB;AACvB;;AAEA;EACE,kBAAkB;EAClB,iBAAiB;AACnB;;AAEA;EACE,SAAS;EACT,kBAAkB;EAClB,gBAAgB;AAClB;;AAEA;EACE,WAAW;AACb;;AAEA;EACE;IACE,WAAW;IACX,sBAAsB;EACxB;AACF;;AAEA;EACE,8FAA8F;EAC9F,sBAAsB;EACtB,YAAY;EACZ,gBAAgB;EAChB,aAAa;EACb,sBAAsB;EACtB,uBAAuB;EACvB,qEAAqE;AACvE;;AAEA;EACE,kBAAkB;EAClB,eAAe;AACjB;;AAEA;EACE,YAAY;AACd;;AAEA;EACE,yBAAyB;EACzB,YAAY;EACZ,gBAAgB;EAChB,qEAAqE;AACvE\",\"sourcesContent\":[\".container {\\r\\n  min-height: 100vh;\\r\\n  padding: 0 0.5rem;\\r\\n  display: flex;\\r\\n  flex-direction: column;\\r\\n  justify-content: center;\\r\\n  align-items: center;\\r\\n}\\r\\n\\r\\n.title a {\\r\\n  color: #0070f3;\\r\\n  text-decoration: none;\\r\\n}\\r\\n\\r\\n.title a:hover,\\r\\n.title a:focus,\\r\\n.title a:active {\\r\\n  text-decoration: underline;\\r\\n}\\r\\n\\r\\n.title {\\r\\n  margin: 0 0 1rem;\\r\\n  line-height: 1.15;\\r\\n  font-size: 3.6rem;\\r\\n}\\r\\n\\r\\n.title {\\r\\n  text-align: center;\\r\\n}\\r\\n\\r\\n.title,\\r\\n.description {\\r\\n  text-align: center;\\r\\n}\\r\\n\\r\\n\\r\\n.description {\\r\\n  line-height: 1.5;\\r\\n  font-size: 1.5rem;\\r\\n}\\r\\n\\r\\n.grid {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: center;\\r\\n  flex-wrap: wrap;\\r\\n\\r\\n  max-width: 800px;\\r\\n  margin-top: 3rem;\\r\\n}\\r\\n\\r\\n.card {\\r\\n  margin: 1rem;\\r\\n  flex-basis: 45%;\\r\\n  padding: 1.5rem;\\r\\n  text-align: left;\\r\\n  color: inherit;\\r\\n  text-decoration: none;\\r\\n  border: 1px solid #eaeaea;\\r\\n  border-radius: 10px;\\r\\n  transition: color 0.15s ease, border-color 0.15s ease;\\r\\n}\\r\\n\\r\\n.card:hover,\\r\\n.card:focus,\\r\\n.card:active {\\r\\n  color: #0070f3;\\r\\n  border-color: #0070f3;\\r\\n}\\r\\n\\r\\n.card h3 {\\r\\n  margin: 0 0 1rem 0;\\r\\n  font-size: 1.5rem;\\r\\n}\\r\\n\\r\\n.card p {\\r\\n  margin: 0;\\r\\n  font-size: 1.25rem;\\r\\n  line-height: 1.5;\\r\\n}\\r\\n\\r\\n.logo {\\r\\n  height: 1em;\\r\\n}\\r\\n\\r\\n@media (max-width: 600px) {\\r\\n  .grid {\\r\\n    width: 100%;\\r\\n    flex-direction: column;\\r\\n  }\\r\\n}\\r\\n\\r\\n.masthead {\\r\\n  background-image: url(\\\"https://cdn.pixabay.com/photo/2017/02/15/10/39/salad-2068220_1280.jpg\\\");\\r\\n  background-size: cover;\\r\\n  height: 85vh;\\r\\n  margin-top: 80px;\\r\\n  display: flex;\\r\\n  flex-direction: column;\\r\\n  justify-content: center;\\r\\n  box-shadow: 0.5rem -0.5rem 1.5rem 1rem rgba(0, 0, 0, 0.15) !important;\\r\\n}\\r\\n\\r\\n.masthead h2 {\\r\\n  line-height: 140px;\\r\\n  font-size: 52px;\\r\\n}\\r\\n\\r\\n.homeSection1 {\\r\\n  height: 35vh;\\r\\n}\\r\\n\\r\\n.homeSection2 {\\r\\n  background-color: #8FC0A9;\\r\\n  height: 35vh;\\r\\n  margin-top: 40px;\\r\\n  box-shadow: 0.5rem -0.5rem 1.5rem 1rem rgba(0, 0, 0, 0.15) !important;\\r\\n}\\r\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"container\": \"Home_container__AICvM\",\n\t\"title\": \"Home_title__i__Gz\",\n\t\"description\": \"Home_description__SfUjv\",\n\t\"grid\": \"Home_grid__Lu8ZJ\",\n\t\"card\": \"Home_card__vuM_6\",\n\t\"logo\": \"Home_logo__j9bCC\",\n\t\"masthead\": \"Home_masthead__H_QBp\",\n\t\"homeSection1\": \"Home_homeSection1___Efu7\",\n\t\"homeSection2\": \"Home_homeSection2__cvhmf\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1sxXS5vbmVPZls4XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMV0ub25lT2ZbOF0udXNlWzJdIS4vc3JjL2Fzc2V0cy9zdHlsZXMvSG9tZS5tb2R1bGUuY3NzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esa0NBQWtDLG1CQUFPLENBQUMseUtBQXFGO0FBQy9IO0FBQ0E7QUFDQSxrRUFBa0Usd0JBQXdCLHdCQUF3QixvQkFBb0IsNkJBQTZCLDhCQUE4QiwwQkFBMEIsS0FBSyw4QkFBOEIscUJBQXFCLDRCQUE0QixLQUFLLG1HQUFtRyxpQ0FBaUMsS0FBSyw0QkFBNEIsdUJBQXVCLHdCQUF3Qix3QkFBd0IsS0FBSyw0QkFBNEIseUJBQXlCLEtBQUsseURBQXlELHlCQUF5QixLQUFLLHNDQUFzQyx1QkFBdUIsd0JBQXdCLEtBQUssMkJBQTJCLG9CQUFvQiwwQkFBMEIsOEJBQThCLHNCQUFzQiwyQkFBMkIsdUJBQXVCLEtBQUssMkJBQTJCLG1CQUFtQixzQkFBc0Isc0JBQXNCLHVCQUF1QixxQkFBcUIsNEJBQTRCLGdDQUFnQywwQkFBMEIsNERBQTRELEtBQUssMEZBQTBGLHFCQUFxQiw0QkFBNEIsS0FBSyw4QkFBOEIseUJBQXlCLHdCQUF3QixLQUFLLDZCQUE2QixnQkFBZ0IseUJBQXlCLHVCQUF1QixLQUFLLDJCQUEyQixrQkFBa0IsS0FBSyxtQ0FBbUMseUJBQXlCLG9CQUFvQiwrQkFBK0IsT0FBTyxLQUFLLCtCQUErQix1R0FBdUcsNkJBQTZCLG1CQUFtQix1QkFBdUIsb0JBQW9CLDZCQUE2Qiw4QkFBOEIsNEVBQTRFLEtBQUssa0NBQWtDLHlCQUF5QixzQkFBc0IsS0FBSyxtQ0FBbUMsbUJBQW1CLEtBQUssbUNBQW1DLGdDQUFnQyxtQkFBbUIsdUJBQXVCLDRFQUE0RSxLQUFLLFdBQVcsa0dBQWtHLFlBQVksYUFBYSxXQUFXLFlBQVksYUFBYSxhQUFhLE9BQU8sS0FBSyxVQUFVLFlBQVksT0FBTyxPQUFPLFlBQVksT0FBTyxLQUFLLFlBQVksYUFBYSxhQUFhLE9BQU8sS0FBSyxZQUFZLE9BQU8sTUFBTSxZQUFZLFFBQVEsS0FBSyxZQUFZLGFBQWEsT0FBTyxLQUFLLFVBQVUsWUFBWSxhQUFhLFlBQVksWUFBWSxhQUFhLE9BQU8sS0FBSyxVQUFVLFVBQVUsVUFBVSxZQUFZLFdBQVcsWUFBWSxhQUFhLGFBQWEsYUFBYSxPQUFPLE9BQU8sVUFBVSxZQUFZLE9BQU8sS0FBSyxZQUFZLGFBQWEsT0FBTyxLQUFLLFVBQVUsWUFBWSxhQUFhLE9BQU8sS0FBSyxVQUFVLE1BQU0sS0FBSyxLQUFLLFVBQVUsWUFBWSxNQUFNLE1BQU0sS0FBSyxZQUFZLGFBQWEsV0FBVyxZQUFZLFdBQVcsWUFBWSxhQUFhLGFBQWEsT0FBTyxLQUFLLFlBQVksV0FBVyxPQUFPLEtBQUssVUFBVSxNQUFNLEtBQUssWUFBWSxXQUFXLFlBQVksYUFBYSxzQ0FBc0Msd0JBQXdCLHdCQUF3QixvQkFBb0IsNkJBQTZCLDhCQUE4QiwwQkFBMEIsS0FBSyxrQkFBa0IscUJBQXFCLDRCQUE0QixLQUFLLCtEQUErRCxpQ0FBaUMsS0FBSyxnQkFBZ0IsdUJBQXVCLHdCQUF3Qix3QkFBd0IsS0FBSyxnQkFBZ0IseUJBQXlCLEtBQUssaUNBQWlDLHlCQUF5QixLQUFLLDBCQUEwQix1QkFBdUIsd0JBQXdCLEtBQUssZUFBZSxvQkFBb0IsMEJBQTBCLDhCQUE4QixzQkFBc0IsMkJBQTJCLHVCQUF1QixLQUFLLGVBQWUsbUJBQW1CLHNCQUFzQixzQkFBc0IsdUJBQXVCLHFCQUFxQiw0QkFBNEIsZ0NBQWdDLDBCQUEwQiw0REFBNEQsS0FBSyxzREFBc0QscUJBQXFCLDRCQUE0QixLQUFLLGtCQUFrQix5QkFBeUIsd0JBQXdCLEtBQUssaUJBQWlCLGdCQUFnQix5QkFBeUIsdUJBQXVCLEtBQUssZUFBZSxrQkFBa0IsS0FBSyxtQ0FBbUMsYUFBYSxvQkFBb0IsK0JBQStCLE9BQU8sS0FBSyxtQkFBbUIsdUdBQXVHLDZCQUE2QixtQkFBbUIsdUJBQXVCLG9CQUFvQiw2QkFBNkIsOEJBQThCLDRFQUE0RSxLQUFLLHNCQUFzQix5QkFBeUIsc0JBQXNCLEtBQUssdUJBQXVCLG1CQUFtQixLQUFLLHVCQUF1QixnQ0FBZ0MsbUJBQW1CLHVCQUF1Qiw0RUFBNEUsS0FBSyx1QkFBdUI7QUFDai9LO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hc3NldHMvc3R5bGVzL0hvbWUubW9kdWxlLmNzcz9iNTM5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIuSG9tZV9jb250YWluZXJfX0FJQ3ZNIHtcXHJcXG4gIG1pbi1oZWlnaHQ6IDEwMHZoO1xcclxcbiAgcGFkZGluZzogMCAwLjVyZW07XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuLkhvbWVfdGl0bGVfX2lfX0d6IGEge1xcclxcbiAgY29sb3I6ICMwMDcwZjM7XFxyXFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxyXFxufVxcclxcblxcclxcbi5Ib21lX3RpdGxlX19pX19HeiBhOmhvdmVyLFxcclxcbi5Ib21lX3RpdGxlX19pX19HeiBhOmZvY3VzLFxcclxcbi5Ib21lX3RpdGxlX19pX19HeiBhOmFjdGl2ZSB7XFxyXFxuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXHJcXG59XFxyXFxuXFxyXFxuLkhvbWVfdGl0bGVfX2lfX0d6IHtcXHJcXG4gIG1hcmdpbjogMCAwIDFyZW07XFxyXFxuICBsaW5lLWhlaWdodDogMS4xNTtcXHJcXG4gIGZvbnQtc2l6ZTogMy42cmVtO1xcclxcbn1cXHJcXG5cXHJcXG4uSG9tZV90aXRsZV9faV9fR3oge1xcclxcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbn1cXHJcXG5cXHJcXG4uSG9tZV90aXRsZV9faV9fR3osXFxyXFxuLkhvbWVfZGVzY3JpcHRpb25fX1NmVWp2IHtcXHJcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuXFxyXFxuLkhvbWVfZGVzY3JpcHRpb25fX1NmVWp2IHtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAxLjU7XFxyXFxuICBmb250LXNpemU6IDEuNXJlbTtcXHJcXG59XFxyXFxuXFxyXFxuLkhvbWVfZ3JpZF9fTHU4Wkoge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gIGZsZXgtd3JhcDogd3JhcDtcXHJcXG5cXHJcXG4gIG1heC13aWR0aDogODAwcHg7XFxyXFxuICBtYXJnaW4tdG9wOiAzcmVtO1xcclxcbn1cXHJcXG5cXHJcXG4uSG9tZV9jYXJkX192dU1fNiB7XFxyXFxuICBtYXJnaW46IDFyZW07XFxyXFxuICBmbGV4LWJhc2lzOiA0NSU7XFxyXFxuICBwYWRkaW5nOiAxLjVyZW07XFxyXFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcclxcbiAgY29sb3I6IGluaGVyaXQ7XFxyXFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxyXFxuICBib3JkZXI6IDFweCBzb2xpZCAjZWFlYWVhO1xcclxcbiAgYm9yZGVyLXJhZGl1czogMTBweDtcXHJcXG4gIHRyYW5zaXRpb246IGNvbG9yIDAuMTVzIGVhc2UsIGJvcmRlci1jb2xvciAwLjE1cyBlYXNlO1xcclxcbn1cXHJcXG5cXHJcXG4uSG9tZV9jYXJkX192dU1fNjpob3ZlcixcXHJcXG4uSG9tZV9jYXJkX192dU1fNjpmb2N1cyxcXHJcXG4uSG9tZV9jYXJkX192dU1fNjphY3RpdmUge1xcclxcbiAgY29sb3I6ICMwMDcwZjM7XFxyXFxuICBib3JkZXItY29sb3I6ICMwMDcwZjM7XFxyXFxufVxcclxcblxcclxcbi5Ib21lX2NhcmRfX3Z1TV82IGgzIHtcXHJcXG4gIG1hcmdpbjogMCAwIDFyZW0gMDtcXHJcXG4gIGZvbnQtc2l6ZTogMS41cmVtO1xcclxcbn1cXHJcXG5cXHJcXG4uSG9tZV9jYXJkX192dU1fNiBwIHtcXHJcXG4gIG1hcmdpbjogMDtcXHJcXG4gIGZvbnQtc2l6ZTogMS4yNXJlbTtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAxLjU7XFxyXFxufVxcclxcblxcclxcbi5Ib21lX2xvZ29fX2o5YkNDIHtcXHJcXG4gIGhlaWdodDogMWVtO1xcclxcbn1cXHJcXG5cXHJcXG5AbWVkaWEgKG1heC13aWR0aDogNjAwcHgpIHtcXHJcXG4gIC5Ib21lX2dyaWRfX0x1OFpKIHtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbi5Ib21lX21hc3RoZWFkX19IX1FCcCB7XFxyXFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXFxcImh0dHBzOi8vY2RuLnBpeGFiYXkuY29tL3Bob3RvLzIwMTcvMDIvMTUvMTAvMzkvc2FsYWQtMjA2ODIyMF8xMjgwLmpwZ1xcXCIpO1xcclxcbiAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcXHJcXG4gIGhlaWdodDogODV2aDtcXHJcXG4gIG1hcmdpbi10b3A6IDgwcHg7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcbiAgYm94LXNoYWRvdzogMC41cmVtIC0wLjVyZW0gMS41cmVtIDFyZW0gcmdiYSgwLCAwLCAwLCAwLjE1KSAhaW1wb3J0YW50O1xcclxcbn1cXHJcXG5cXHJcXG4uSG9tZV9tYXN0aGVhZF9fSF9RQnAgaDIge1xcclxcbiAgbGluZS1oZWlnaHQ6IDE0MHB4O1xcclxcbiAgZm9udC1zaXplOiA1MnB4O1xcclxcbn1cXHJcXG5cXHJcXG4uSG9tZV9ob21lU2VjdGlvbjFfX19FZnU3IHtcXHJcXG4gIGhlaWdodDogMzV2aDtcXHJcXG59XFxyXFxuXFxyXFxuLkhvbWVfaG9tZVNlY3Rpb24yX19jdmhtZiB7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjOEZDMEE5O1xcclxcbiAgaGVpZ2h0OiAzNXZoO1xcclxcbiAgbWFyZ2luLXRvcDogNDBweDtcXHJcXG4gIGJveC1zaGFkb3c6IDAuNXJlbSAtMC41cmVtIDEuNXJlbSAxcmVtIHJnYmEoMCwgMCwgMCwgMC4xNSkgIWltcG9ydGFudDtcXHJcXG59XFxyXFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL3NyYy9hc3NldHMvc3R5bGVzL0hvbWUubW9kdWxlLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLGlCQUFpQjtFQUNqQixpQkFBaUI7RUFDakIsYUFBYTtFQUNiLHNCQUFzQjtFQUN0Qix1QkFBdUI7RUFDdkIsbUJBQW1CO0FBQ3JCOztBQUVBO0VBQ0UsY0FBYztFQUNkLHFCQUFxQjtBQUN2Qjs7QUFFQTs7O0VBR0UsMEJBQTBCO0FBQzVCOztBQUVBO0VBQ0UsZ0JBQWdCO0VBQ2hCLGlCQUFpQjtFQUNqQixpQkFBaUI7QUFDbkI7O0FBRUE7RUFDRSxrQkFBa0I7QUFDcEI7O0FBRUE7O0VBRUUsa0JBQWtCO0FBQ3BCOzs7QUFHQTtFQUNFLGdCQUFnQjtFQUNoQixpQkFBaUI7QUFDbkI7O0FBRUE7RUFDRSxhQUFhO0VBQ2IsbUJBQW1CO0VBQ25CLHVCQUF1QjtFQUN2QixlQUFlOztFQUVmLGdCQUFnQjtFQUNoQixnQkFBZ0I7QUFDbEI7O0FBRUE7RUFDRSxZQUFZO0VBQ1osZUFBZTtFQUNmLGVBQWU7RUFDZixnQkFBZ0I7RUFDaEIsY0FBYztFQUNkLHFCQUFxQjtFQUNyQix5QkFBeUI7RUFDekIsbUJBQW1CO0VBQ25CLHFEQUFxRDtBQUN2RDs7QUFFQTs7O0VBR0UsY0FBYztFQUNkLHFCQUFxQjtBQUN2Qjs7QUFFQTtFQUNFLGtCQUFrQjtFQUNsQixpQkFBaUI7QUFDbkI7O0FBRUE7RUFDRSxTQUFTO0VBQ1Qsa0JBQWtCO0VBQ2xCLGdCQUFnQjtBQUNsQjs7QUFFQTtFQUNFLFdBQVc7QUFDYjs7QUFFQTtFQUNFO0lBQ0UsV0FBVztJQUNYLHNCQUFzQjtFQUN4QjtBQUNGOztBQUVBO0VBQ0UsOEZBQThGO0VBQzlGLHNCQUFzQjtFQUN0QixZQUFZO0VBQ1osZ0JBQWdCO0VBQ2hCLGFBQWE7RUFDYixzQkFBc0I7RUFDdEIsdUJBQXVCO0VBQ3ZCLHFFQUFxRTtBQUN2RTs7QUFFQTtFQUNFLGtCQUFrQjtFQUNsQixlQUFlO0FBQ2pCOztBQUVBO0VBQ0UsWUFBWTtBQUNkOztBQUVBO0VBQ0UseUJBQXlCO0VBQ3pCLFlBQVk7RUFDWixnQkFBZ0I7RUFDaEIscUVBQXFFO0FBQ3ZFXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5jb250YWluZXIge1xcclxcbiAgbWluLWhlaWdodDogMTAwdmg7XFxyXFxuICBwYWRkaW5nOiAwIDAuNXJlbTtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbn1cXHJcXG5cXHJcXG4udGl0bGUgYSB7XFxyXFxuICBjb2xvcjogIzAwNzBmMztcXHJcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuLnRpdGxlIGE6aG92ZXIsXFxyXFxuLnRpdGxlIGE6Zm9jdXMsXFxyXFxuLnRpdGxlIGE6YWN0aXZlIHtcXHJcXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcclxcbn1cXHJcXG5cXHJcXG4udGl0bGUge1xcclxcbiAgbWFyZ2luOiAwIDAgMXJlbTtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAxLjE1O1xcclxcbiAgZm9udC1zaXplOiAzLjZyZW07XFxyXFxufVxcclxcblxcclxcbi50aXRsZSB7XFxyXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxufVxcclxcblxcclxcbi50aXRsZSxcXHJcXG4uZGVzY3JpcHRpb24ge1xcclxcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbn1cXHJcXG5cXHJcXG5cXHJcXG4uZGVzY3JpcHRpb24ge1xcclxcbiAgbGluZS1oZWlnaHQ6IDEuNTtcXHJcXG4gIGZvbnQtc2l6ZTogMS41cmVtO1xcclxcbn1cXHJcXG5cXHJcXG4uZ3JpZCB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcbiAgZmxleC13cmFwOiB3cmFwO1xcclxcblxcclxcbiAgbWF4LXdpZHRoOiA4MDBweDtcXHJcXG4gIG1hcmdpbi10b3A6IDNyZW07XFxyXFxufVxcclxcblxcclxcbi5jYXJkIHtcXHJcXG4gIG1hcmdpbjogMXJlbTtcXHJcXG4gIGZsZXgtYmFzaXM6IDQ1JTtcXHJcXG4gIHBhZGRpbmc6IDEuNXJlbTtcXHJcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxyXFxuICBjb2xvcjogaW5oZXJpdDtcXHJcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXHJcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNlYWVhZWE7XFxyXFxuICBib3JkZXItcmFkaXVzOiAxMHB4O1xcclxcbiAgdHJhbnNpdGlvbjogY29sb3IgMC4xNXMgZWFzZSwgYm9yZGVyLWNvbG9yIDAuMTVzIGVhc2U7XFxyXFxufVxcclxcblxcclxcbi5jYXJkOmhvdmVyLFxcclxcbi5jYXJkOmZvY3VzLFxcclxcbi5jYXJkOmFjdGl2ZSB7XFxyXFxuICBjb2xvcjogIzAwNzBmMztcXHJcXG4gIGJvcmRlci1jb2xvcjogIzAwNzBmMztcXHJcXG59XFxyXFxuXFxyXFxuLmNhcmQgaDMge1xcclxcbiAgbWFyZ2luOiAwIDAgMXJlbSAwO1xcclxcbiAgZm9udC1zaXplOiAxLjVyZW07XFxyXFxufVxcclxcblxcclxcbi5jYXJkIHAge1xcclxcbiAgbWFyZ2luOiAwO1xcclxcbiAgZm9udC1zaXplOiAxLjI1cmVtO1xcclxcbiAgbGluZS1oZWlnaHQ6IDEuNTtcXHJcXG59XFxyXFxuXFxyXFxuLmxvZ28ge1xcclxcbiAgaGVpZ2h0OiAxZW07XFxyXFxufVxcclxcblxcclxcbkBtZWRpYSAobWF4LXdpZHRoOiA2MDBweCkge1xcclxcbiAgLmdyaWQge1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLm1hc3RoZWFkIHtcXHJcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybChcXFwiaHR0cHM6Ly9jZG4ucGl4YWJheS5jb20vcGhvdG8vMjAxNy8wMi8xNS8xMC8zOS9zYWxhZC0yMDY4MjIwXzEyODAuanBnXFxcIik7XFxyXFxuICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xcclxcbiAgaGVpZ2h0OiA4NXZoO1xcclxcbiAgbWFyZ2luLXRvcDogODBweDtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxyXFxuICBib3gtc2hhZG93OiAwLjVyZW0gLTAuNXJlbSAxLjVyZW0gMXJlbSByZ2JhKDAsIDAsIDAsIDAuMTUpICFpbXBvcnRhbnQ7XFxyXFxufVxcclxcblxcclxcbi5tYXN0aGVhZCBoMiB7XFxyXFxuICBsaW5lLWhlaWdodDogMTQwcHg7XFxyXFxuICBmb250LXNpemU6IDUycHg7XFxyXFxufVxcclxcblxcclxcbi5ob21lU2VjdGlvbjEge1xcclxcbiAgaGVpZ2h0OiAzNXZoO1xcclxcbn1cXHJcXG5cXHJcXG4uaG9tZVNlY3Rpb24yIHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICM4RkMwQTk7XFxyXFxuICBoZWlnaHQ6IDM1dmg7XFxyXFxuICBtYXJnaW4tdG9wOiA0MHB4O1xcclxcbiAgYm94LXNoYWRvdzogMC41cmVtIC0wLjVyZW0gMS41cmVtIDFyZW0gcmdiYSgwLCAwLCAwLCAwLjE1KSAhaW1wb3J0YW50O1xcclxcbn1cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmxvY2FscyA9IHtcblx0XCJjb250YWluZXJcIjogXCJIb21lX2NvbnRhaW5lcl9fQUlDdk1cIixcblx0XCJ0aXRsZVwiOiBcIkhvbWVfdGl0bGVfX2lfX0d6XCIsXG5cdFwiZGVzY3JpcHRpb25cIjogXCJIb21lX2Rlc2NyaXB0aW9uX19TZlVqdlwiLFxuXHRcImdyaWRcIjogXCJIb21lX2dyaWRfX0x1OFpKXCIsXG5cdFwiY2FyZFwiOiBcIkhvbWVfY2FyZF9fdnVNXzZcIixcblx0XCJsb2dvXCI6IFwiSG9tZV9sb2dvX19qOWJDQ1wiLFxuXHRcIm1hc3RoZWFkXCI6IFwiSG9tZV9tYXN0aGVhZF9fSF9RQnBcIixcblx0XCJob21lU2VjdGlvbjFcIjogXCJIb21lX2hvbWVTZWN0aW9uMV9fX0VmdTdcIixcblx0XCJob21lU2VjdGlvbjJcIjogXCJIb21lX2hvbWVTZWN0aW9uMl9fY3ZobWZcIlxufTtcbm1vZHVsZS5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[2]!./src/assets/styles/Home.module.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[2]!./src/assets/styles/utils.module.css":
/*!************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[2]!./src/assets/styles/utils.module.css ***!
  \************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".utils_heading2Xl__5lUSw {\\r\\n  font-size: 2.5rem;\\r\\n  line-height: 1.2;\\r\\n  font-weight: 800;\\r\\n  letter-spacing: -0.05rem;\\r\\n  margin: 1rem 0;\\r\\n}\\r\\n\\r\\n.utils_headingXl__wtl9_ {\\r\\n  font-size: 2rem;\\r\\n  line-height: 1.3;\\r\\n  font-weight: 800;\\r\\n  letter-spacing: -0.05rem;\\r\\n  margin: 1rem 0;\\r\\n}\\r\\n\\r\\n.utils_headingLg__b_Jen {\\r\\n  font-size: 1.5rem;\\r\\n  line-height: 1.4;\\r\\n  margin: 1rem 0;\\r\\n}\\r\\n\\r\\n.utils_headingMd__wMXKN {\\r\\n  font-size: 1.2rem;\\r\\n  line-height: 1.5;\\r\\n}\\r\\n\\r\\n.utils_borderCircle__0ehey {\\r\\n  border-radius: 9999px;\\r\\n}\\r\\n\\r\\n.utils_colorInherit__kOpJv {\\r\\n  color: inherit;\\r\\n}\\r\\n\\r\\n.utils_padding1px__Bkg_P {\\r\\n  padding-top: 1px;\\r\\n}\\r\\n\\r\\n.utils_list__xVhKF {\\r\\n  list-style: none;\\r\\n  padding: 0;\\r\\n  margin: 0;\\r\\n}\\r\\n\\r\\n.utils_listItem__EXxYi {\\r\\n  margin: 0 0 1.25rem;\\r\\n}\\r\\n\\r\\n.utils_lightText__JL_MZ {\\r\\n  color: #666;\\r\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://src/assets/styles/utils.module.css\"],\"names\":[],\"mappings\":\"AAAA;EACE,iBAAiB;EACjB,gBAAgB;EAChB,gBAAgB;EAChB,wBAAwB;EACxB,cAAc;AAChB;;AAEA;EACE,eAAe;EACf,gBAAgB;EAChB,gBAAgB;EAChB,wBAAwB;EACxB,cAAc;AAChB;;AAEA;EACE,iBAAiB;EACjB,gBAAgB;EAChB,cAAc;AAChB;;AAEA;EACE,iBAAiB;EACjB,gBAAgB;AAClB;;AAEA;EACE,qBAAqB;AACvB;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,gBAAgB;AAClB;;AAEA;EACE,gBAAgB;EAChB,UAAU;EACV,SAAS;AACX;;AAEA;EACE,mBAAmB;AACrB;;AAEA;EACE,WAAW;AACb\",\"sourcesContent\":[\".heading2Xl {\\r\\n  font-size: 2.5rem;\\r\\n  line-height: 1.2;\\r\\n  font-weight: 800;\\r\\n  letter-spacing: -0.05rem;\\r\\n  margin: 1rem 0;\\r\\n}\\r\\n\\r\\n.headingXl {\\r\\n  font-size: 2rem;\\r\\n  line-height: 1.3;\\r\\n  font-weight: 800;\\r\\n  letter-spacing: -0.05rem;\\r\\n  margin: 1rem 0;\\r\\n}\\r\\n\\r\\n.headingLg {\\r\\n  font-size: 1.5rem;\\r\\n  line-height: 1.4;\\r\\n  margin: 1rem 0;\\r\\n}\\r\\n\\r\\n.headingMd {\\r\\n  font-size: 1.2rem;\\r\\n  line-height: 1.5;\\r\\n}\\r\\n\\r\\n.borderCircle {\\r\\n  border-radius: 9999px;\\r\\n}\\r\\n\\r\\n.colorInherit {\\r\\n  color: inherit;\\r\\n}\\r\\n\\r\\n.padding1px {\\r\\n  padding-top: 1px;\\r\\n}\\r\\n\\r\\n.list {\\r\\n  list-style: none;\\r\\n  padding: 0;\\r\\n  margin: 0;\\r\\n}\\r\\n\\r\\n.listItem {\\r\\n  margin: 0 0 1.25rem;\\r\\n}\\r\\n\\r\\n.lightText {\\r\\n  color: #666;\\r\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"heading2Xl\": \"utils_heading2Xl__5lUSw\",\n\t\"headingXl\": \"utils_headingXl__wtl9_\",\n\t\"headingLg\": \"utils_headingLg__b_Jen\",\n\t\"headingMd\": \"utils_headingMd__wMXKN\",\n\t\"borderCircle\": \"utils_borderCircle__0ehey\",\n\t\"colorInherit\": \"utils_colorInherit__kOpJv\",\n\t\"padding1px\": \"utils_padding1px__Bkg_P\",\n\t\"list\": \"utils_list__xVhKF\",\n\t\"listItem\": \"utils_listItem__EXxYi\",\n\t\"lightText\": \"utils_lightText__JL_MZ\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1sxXS5vbmVPZls4XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMV0ub25lT2ZbOF0udXNlWzJdIS4vc3JjL2Fzc2V0cy9zdHlsZXMvdXRpbHMubW9kdWxlLmNzcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLHlLQUFxRjtBQUMvSDtBQUNBO0FBQ0Esb0VBQW9FLHdCQUF3Qix1QkFBdUIsdUJBQXVCLCtCQUErQixxQkFBcUIsS0FBSyxpQ0FBaUMsc0JBQXNCLHVCQUF1Qix1QkFBdUIsK0JBQStCLHFCQUFxQixLQUFLLGlDQUFpQyx3QkFBd0IsdUJBQXVCLHFCQUFxQixLQUFLLGlDQUFpQyx3QkFBd0IsdUJBQXVCLEtBQUssb0NBQW9DLDRCQUE0QixLQUFLLG9DQUFvQyxxQkFBcUIsS0FBSyxrQ0FBa0MsdUJBQXVCLEtBQUssNEJBQTRCLHVCQUF1QixpQkFBaUIsZ0JBQWdCLEtBQUssZ0NBQWdDLDBCQUEwQixLQUFLLGlDQUFpQyxrQkFBa0IsS0FBSyxPQUFPLG1HQUFtRyxZQUFZLGFBQWEsYUFBYSxhQUFhLFdBQVcsT0FBTyxLQUFLLFVBQVUsWUFBWSxhQUFhLGFBQWEsV0FBVyxPQUFPLEtBQUssWUFBWSxhQUFhLFdBQVcsT0FBTyxLQUFLLFlBQVksYUFBYSxPQUFPLEtBQUssWUFBWSxPQUFPLEtBQUssVUFBVSxPQUFPLEtBQUssWUFBWSxPQUFPLEtBQUssWUFBWSxXQUFXLFVBQVUsTUFBTSxLQUFLLFlBQVksT0FBTyxLQUFLLFVBQVUsc0NBQXNDLHdCQUF3Qix1QkFBdUIsdUJBQXVCLCtCQUErQixxQkFBcUIsS0FBSyxvQkFBb0Isc0JBQXNCLHVCQUF1Qix1QkFBdUIsK0JBQStCLHFCQUFxQixLQUFLLG9CQUFvQix3QkFBd0IsdUJBQXVCLHFCQUFxQixLQUFLLG9CQUFvQix3QkFBd0IsdUJBQXVCLEtBQUssdUJBQXVCLDRCQUE0QixLQUFLLHVCQUF1QixxQkFBcUIsS0FBSyxxQkFBcUIsdUJBQXVCLEtBQUssZUFBZSx1QkFBdUIsaUJBQWlCLGdCQUFnQixLQUFLLG1CQUFtQiwwQkFBMEIsS0FBSyxvQkFBb0Isa0JBQWtCLEtBQUssbUJBQW1CO0FBQ3RzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hc3NldHMvc3R5bGVzL3V0aWxzLm1vZHVsZS5jc3M/YjhhMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL3J1bnRpbWUvYXBpLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLnV0aWxzX2hlYWRpbmcyWGxfXzVsVVN3IHtcXHJcXG4gIGZvbnQtc2l6ZTogMi41cmVtO1xcclxcbiAgbGluZS1oZWlnaHQ6IDEuMjtcXHJcXG4gIGZvbnQtd2VpZ2h0OiA4MDA7XFxyXFxuICBsZXR0ZXItc3BhY2luZzogLTAuMDVyZW07XFxyXFxuICBtYXJnaW46IDFyZW0gMDtcXHJcXG59XFxyXFxuXFxyXFxuLnV0aWxzX2hlYWRpbmdYbF9fd3RsOV8ge1xcclxcbiAgZm9udC1zaXplOiAycmVtO1xcclxcbiAgbGluZS1oZWlnaHQ6IDEuMztcXHJcXG4gIGZvbnQtd2VpZ2h0OiA4MDA7XFxyXFxuICBsZXR0ZXItc3BhY2luZzogLTAuMDVyZW07XFxyXFxuICBtYXJnaW46IDFyZW0gMDtcXHJcXG59XFxyXFxuXFxyXFxuLnV0aWxzX2hlYWRpbmdMZ19fYl9KZW4ge1xcclxcbiAgZm9udC1zaXplOiAxLjVyZW07XFxyXFxuICBsaW5lLWhlaWdodDogMS40O1xcclxcbiAgbWFyZ2luOiAxcmVtIDA7XFxyXFxufVxcclxcblxcclxcbi51dGlsc19oZWFkaW5nTWRfX3dNWEtOIHtcXHJcXG4gIGZvbnQtc2l6ZTogMS4ycmVtO1xcclxcbiAgbGluZS1oZWlnaHQ6IDEuNTtcXHJcXG59XFxyXFxuXFxyXFxuLnV0aWxzX2JvcmRlckNpcmNsZV9fMGVoZXkge1xcclxcbiAgYm9yZGVyLXJhZGl1czogOTk5OXB4O1xcclxcbn1cXHJcXG5cXHJcXG4udXRpbHNfY29sb3JJbmhlcml0X19rT3BKdiB7XFxyXFxuICBjb2xvcjogaW5oZXJpdDtcXHJcXG59XFxyXFxuXFxyXFxuLnV0aWxzX3BhZGRpbmcxcHhfX0JrZ19QIHtcXHJcXG4gIHBhZGRpbmctdG9wOiAxcHg7XFxyXFxufVxcclxcblxcclxcbi51dGlsc19saXN0X194VmhLRiB7XFxyXFxuICBsaXN0LXN0eWxlOiBub25lO1xcclxcbiAgcGFkZGluZzogMDtcXHJcXG4gIG1hcmdpbjogMDtcXHJcXG59XFxyXFxuXFxyXFxuLnV0aWxzX2xpc3RJdGVtX19FWHhZaSB7XFxyXFxuICBtYXJnaW46IDAgMCAxLjI1cmVtO1xcclxcbn1cXHJcXG5cXHJcXG4udXRpbHNfbGlnaHRUZXh0X19KTF9NWiB7XFxyXFxuICBjb2xvcjogIzY2NjtcXHJcXG59XCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL3NyYy9hc3NldHMvc3R5bGVzL3V0aWxzLm1vZHVsZS5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7RUFDRSxpQkFBaUI7RUFDakIsZ0JBQWdCO0VBQ2hCLGdCQUFnQjtFQUNoQix3QkFBd0I7RUFDeEIsY0FBYztBQUNoQjs7QUFFQTtFQUNFLGVBQWU7RUFDZixnQkFBZ0I7RUFDaEIsZ0JBQWdCO0VBQ2hCLHdCQUF3QjtFQUN4QixjQUFjO0FBQ2hCOztBQUVBO0VBQ0UsaUJBQWlCO0VBQ2pCLGdCQUFnQjtFQUNoQixjQUFjO0FBQ2hCOztBQUVBO0VBQ0UsaUJBQWlCO0VBQ2pCLGdCQUFnQjtBQUNsQjs7QUFFQTtFQUNFLHFCQUFxQjtBQUN2Qjs7QUFFQTtFQUNFLGNBQWM7QUFDaEI7O0FBRUE7RUFDRSxnQkFBZ0I7QUFDbEI7O0FBRUE7RUFDRSxnQkFBZ0I7RUFDaEIsVUFBVTtFQUNWLFNBQVM7QUFDWDs7QUFFQTtFQUNFLG1CQUFtQjtBQUNyQjs7QUFFQTtFQUNFLFdBQVc7QUFDYlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuaGVhZGluZzJYbCB7XFxyXFxuICBmb250LXNpemU6IDIuNXJlbTtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAxLjI7XFxyXFxuICBmb250LXdlaWdodDogODAwO1xcclxcbiAgbGV0dGVyLXNwYWNpbmc6IC0wLjA1cmVtO1xcclxcbiAgbWFyZ2luOiAxcmVtIDA7XFxyXFxufVxcclxcblxcclxcbi5oZWFkaW5nWGwge1xcclxcbiAgZm9udC1zaXplOiAycmVtO1xcclxcbiAgbGluZS1oZWlnaHQ6IDEuMztcXHJcXG4gIGZvbnQtd2VpZ2h0OiA4MDA7XFxyXFxuICBsZXR0ZXItc3BhY2luZzogLTAuMDVyZW07XFxyXFxuICBtYXJnaW46IDFyZW0gMDtcXHJcXG59XFxyXFxuXFxyXFxuLmhlYWRpbmdMZyB7XFxyXFxuICBmb250LXNpemU6IDEuNXJlbTtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAxLjQ7XFxyXFxuICBtYXJnaW46IDFyZW0gMDtcXHJcXG59XFxyXFxuXFxyXFxuLmhlYWRpbmdNZCB7XFxyXFxuICBmb250LXNpemU6IDEuMnJlbTtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAxLjU7XFxyXFxufVxcclxcblxcclxcbi5ib3JkZXJDaXJjbGUge1xcclxcbiAgYm9yZGVyLXJhZGl1czogOTk5OXB4O1xcclxcbn1cXHJcXG5cXHJcXG4uY29sb3JJbmhlcml0IHtcXHJcXG4gIGNvbG9yOiBpbmhlcml0O1xcclxcbn1cXHJcXG5cXHJcXG4ucGFkZGluZzFweCB7XFxyXFxuICBwYWRkaW5nLXRvcDogMXB4O1xcclxcbn1cXHJcXG5cXHJcXG4ubGlzdCB7XFxyXFxuICBsaXN0LXN0eWxlOiBub25lO1xcclxcbiAgcGFkZGluZzogMDtcXHJcXG4gIG1hcmdpbjogMDtcXHJcXG59XFxyXFxuXFxyXFxuLmxpc3RJdGVtIHtcXHJcXG4gIG1hcmdpbjogMCAwIDEuMjVyZW07XFxyXFxufVxcclxcblxcclxcbi5saWdodFRleHQge1xcclxcbiAgY29sb3I6ICM2NjY7XFxyXFxufVwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ubG9jYWxzID0ge1xuXHRcImhlYWRpbmcyWGxcIjogXCJ1dGlsc19oZWFkaW5nMlhsX181bFVTd1wiLFxuXHRcImhlYWRpbmdYbFwiOiBcInV0aWxzX2hlYWRpbmdYbF9fd3RsOV9cIixcblx0XCJoZWFkaW5nTGdcIjogXCJ1dGlsc19oZWFkaW5nTGdfX2JfSmVuXCIsXG5cdFwiaGVhZGluZ01kXCI6IFwidXRpbHNfaGVhZGluZ01kX193TVhLTlwiLFxuXHRcImJvcmRlckNpcmNsZVwiOiBcInV0aWxzX2JvcmRlckNpcmNsZV9fMGVoZXlcIixcblx0XCJjb2xvckluaGVyaXRcIjogXCJ1dGlsc19jb2xvckluaGVyaXRfX2tPcEp2XCIsXG5cdFwicGFkZGluZzFweFwiOiBcInV0aWxzX3BhZGRpbmcxcHhfX0JrZ19QXCIsXG5cdFwibGlzdFwiOiBcInV0aWxzX2xpc3RfX3hWaEtGXCIsXG5cdFwibGlzdEl0ZW1cIjogXCJ1dGlsc19saXN0SXRlbV9fRVh4WWlcIixcblx0XCJsaWdodFRleHRcIjogXCJ1dGlsc19saWdodFRleHRfX0pMX01aXCJcbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[2]!./src/assets/styles/utils.module.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[2]!./src/components/layout.module.css":
/*!**********************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[2]!./src/components/layout.module.css ***!
  \**********************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".layout_container__XI0Sj {\\r\\n  max-width: 36rem;\\r\\n  padding: 0 1rem;\\r\\n  margin: 3rem auto 6rem;\\r\\n}\\r\\n\\r\\n.layout_header__h9sve {\\r\\n  display: flex;\\r\\n  flex-direction: column;\\r\\n  align-items: center;\\r\\n}\\r\\n\\r\\n.layout_backToHome__J0Vx8 {\\r\\n  margin: 3rem 0 0;\\r\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://src/components/layout.module.css\"],\"names\":[],\"mappings\":\"AAAA;EACE,gBAAgB;EAChB,eAAe;EACf,sBAAsB;AACxB;;AAEA;EACE,aAAa;EACb,sBAAsB;EACtB,mBAAmB;AACrB;;AAEA;EACE,gBAAgB;AAClB\",\"sourcesContent\":[\".container {\\r\\n  max-width: 36rem;\\r\\n  padding: 0 1rem;\\r\\n  margin: 3rem auto 6rem;\\r\\n}\\r\\n\\r\\n.header {\\r\\n  display: flex;\\r\\n  flex-direction: column;\\r\\n  align-items: center;\\r\\n}\\r\\n\\r\\n.backToHome {\\r\\n  margin: 3rem 0 0;\\r\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"container\": \"layout_container__XI0Sj\",\n\t\"header\": \"layout_header__h9sve\",\n\t\"backToHome\": \"layout_backToHome__J0Vx8\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1sxXS5vbmVPZls4XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMV0ub25lT2ZbOF0udXNlWzJdIS4vc3JjL2NvbXBvbmVudHMvbGF5b3V0Lm1vZHVsZS5jc3MuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQ0FBa0MsbUJBQU8sQ0FBQyxzS0FBa0Y7QUFDNUg7QUFDQTtBQUNBLG9FQUFvRSx1QkFBdUIsc0JBQXNCLDZCQUE2QixLQUFLLCtCQUErQixvQkFBb0IsNkJBQTZCLDBCQUEwQixLQUFLLG1DQUFtQyx1QkFBdUIsS0FBSyxPQUFPLGlHQUFpRyxZQUFZLFdBQVcsWUFBWSxPQUFPLEtBQUssVUFBVSxZQUFZLGFBQWEsT0FBTyxLQUFLLFlBQVksc0NBQXNDLHVCQUF1QixzQkFBc0IsNkJBQTZCLEtBQUssaUJBQWlCLG9CQUFvQiw2QkFBNkIsMEJBQTBCLEtBQUsscUJBQXFCLHVCQUF1QixLQUFLLG1CQUFtQjtBQUM3eUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvbGF5b3V0Lm1vZHVsZS5jc3M/ODQ1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL3J1bnRpbWUvYXBpLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLmxheW91dF9jb250YWluZXJfX1hJMFNqIHtcXHJcXG4gIG1heC13aWR0aDogMzZyZW07XFxyXFxuICBwYWRkaW5nOiAwIDFyZW07XFxyXFxuICBtYXJnaW46IDNyZW0gYXV0byA2cmVtO1xcclxcbn1cXHJcXG5cXHJcXG4ubGF5b3V0X2hlYWRlcl9faDlzdmUge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbn1cXHJcXG5cXHJcXG4ubGF5b3V0X2JhY2tUb0hvbWVfX0owVng4IHtcXHJcXG4gIG1hcmdpbjogM3JlbSAwIDA7XFxyXFxufVwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9zcmMvY29tcG9uZW50cy9sYXlvdXQubW9kdWxlLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLGdCQUFnQjtFQUNoQixlQUFlO0VBQ2Ysc0JBQXNCO0FBQ3hCOztBQUVBO0VBQ0UsYUFBYTtFQUNiLHNCQUFzQjtFQUN0QixtQkFBbUI7QUFDckI7O0FBRUE7RUFDRSxnQkFBZ0I7QUFDbEJcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLmNvbnRhaW5lciB7XFxyXFxuICBtYXgtd2lkdGg6IDM2cmVtO1xcclxcbiAgcGFkZGluZzogMCAxcmVtO1xcclxcbiAgbWFyZ2luOiAzcmVtIGF1dG8gNnJlbTtcXHJcXG59XFxyXFxuXFxyXFxuLmhlYWRlciB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxufVxcclxcblxcclxcbi5iYWNrVG9Ib21lIHtcXHJcXG4gIG1hcmdpbjogM3JlbSAwIDA7XFxyXFxufVwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ubG9jYWxzID0ge1xuXHRcImNvbnRhaW5lclwiOiBcImxheW91dF9jb250YWluZXJfX1hJMFNqXCIsXG5cdFwiaGVhZGVyXCI6IFwibGF5b3V0X2hlYWRlcl9faDlzdmVcIixcblx0XCJiYWNrVG9Ib21lXCI6IFwibGF5b3V0X2JhY2tUb0hvbWVfX0owVng4XCJcbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[2]!./src/components/layout.module.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5Csmith%5Csource%5Ccodeworks%5Creact%5Cmeal-master-fullstack%5Cmeal-master-fullstack.client%5Csrc%5Cpages%5Cindex.js&page=%2F!":
/*!***********************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5Csmith%5Csource%5Ccodeworks%5Creact%5Cmeal-master-fullstack%5Cmeal-master-fullstack.client%5Csrc%5Cpages%5Cindex.js&page=%2F! ***!
  \***********************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/\",\n      function () {\n        return __webpack_require__(/*! ./src/pages/index.js */ \"./src/pages/index.js\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD1DJTNBJTVDVXNlcnMlNUNzbWl0aCU1Q3NvdXJjZSU1Q2NvZGV3b3JrcyU1Q3JlYWN0JTVDbWVhbC1tYXN0ZXItZnVsbHN0YWNrJTVDbWVhbC1tYXN0ZXItZnVsbHN0YWNrLmNsaWVudCU1Q3NyYyU1Q3BhZ2VzJTVDaW5kZXguanMmcGFnZT0lMkYhLmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsa0RBQXNCO0FBQzdDO0FBQ0E7QUFDQSxPQUFPLElBQVU7QUFDakIsTUFBTSxVQUFVO0FBQ2hCO0FBQ0EsT0FBTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz82ZDg1Il0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgICh3aW5kb3cuX19ORVhUX1AgPSB3aW5kb3cuX19ORVhUX1AgfHwgW10pLnB1c2goW1xuICAgICAgXCIvXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwiLi9zcmMvcGFnZXMvaW5kZXguanNcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL1wiXSlcbiAgICAgIH0pO1xuICAgIH1cbiAgIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5Csmith%5Csource%5Ccodeworks%5Creact%5Cmeal-master-fullstack%5Cmeal-master-fullstack.client%5Csrc%5Cpages%5Cindex.js&page=%2F!\n"));

/***/ }),

/***/ "./src/assets/styles/Home.module.css":
/*!*******************************************!*\
  !*** ./src/assets/styles/Home.module.css ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[2]!./Home.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[2]!./src/assets/styles/Home.module.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[2]!./Home.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[2]!./src/assets/styles/Home.module.css\",\n      function () {\n        content = __webpack_require__(/*! !!../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[2]!./Home.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[2]!./src/assets/styles/Home.module.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXNzZXRzL3N0eWxlcy9Ib21lLm1vZHVsZS5jc3MuanMiLCJtYXBwaW5ncyI6IkFBQUEsVUFBVSxtQkFBTyxDQUFDLDBOQUE4RztBQUNoSSwwQkFBMEIsbUJBQU8sQ0FBQyxzZ0JBQStQOztBQUVqUzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsSUFBSSxJQUFVO0FBQ2QseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksaUJBQWlCO0FBQ3JCLE1BQU0sc2dCQUErUDtBQUNyUTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHNnQkFBK1A7O0FBRXpSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixVQUFVOztBQUUxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsVUFBVTtBQUNaO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hc3NldHMvc3R5bGVzL0hvbWUubW9kdWxlLmNzcz9jMzBjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1sxXS5vbmVPZls4XS51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzFdLm9uZU9mWzhdLnVzZVsyXSEuL0hvbWUubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgc3R5bGUtbG9hZGVyIGluamVjdHMgQ1NTIGludG8gdGhlIGJvdHRvbVxuICAgICAgICAgICAgICAgICAgICAvLyBvZiA8aGVhZD4uIFRoaXMgY2F1c2VzIG9yZGVyaW5nIHByb2JsZW1zIGJldHdlZW4gZGV2XG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBwcm9kLiBUbyBmaXggdGhpcywgd2UgcmVuZGVyIGEgPG5vc2NyaXB0PiB0YWcgYXNcbiAgICAgICAgICAgICAgICAgICAgLy8gYW4gYW5jaG9yIGZvciB0aGUgc3R5bGVzIHRvIGJlIHBsYWNlZCBiZWZvcmUuIFRoZXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0eWxlcyB3aWxsIGJlIGFwcGxpZWQgX2JlZm9yZV8gPHN0eWxlIGpzeCBnbG9iYWw+LlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVzZSBlbGVtZW50cyBzaG91bGQgYWx3YXlzIGV4aXN0LiBJZiB0aGV5IGRvIG5vdCxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5jaG9yRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGFuY2hvckVsZW1lbnQucGFyZW50Tm9kZS8vIE5vcm1hbGx5IDxoZWFkPlxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuICAgICAgICAgICAgICAgICAgICAvLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gdHJhY2sgdGhlIGxhc3QgaW5zZXJ0ZWQgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgYW5jaG9yRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfTtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgaWYgKCFjb250ZW50LmxvY2FscyB8fCBtb2R1bGUuaG90LmludmFsaWRhdGUpIHtcbiAgICB2YXIgaXNFcXVhbExvY2FscyA9IGZ1bmN0aW9uIGlzRXF1YWxMb2NhbHMoYSwgYiwgaXNOYW1lZEV4cG9ydCkge1xuICAgIGlmICghYSAmJiBiIHx8IGEgJiYgIWIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgcDtcbiAgICBmb3IocCBpbiBhKXtcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKHAgaW4gYil7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFbcF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMV0ub25lT2ZbOF0udXNlWzFdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1sxXS5vbmVPZls4XS51c2VbMl0hLi9Ib21lLm1vZHVsZS5jc3NcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzFdLm9uZU9mWzhdLnVzZVsxXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMV0ub25lT2ZbOF0udXNlWzJdIS4vSG9tZS5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/assets/styles/Home.module.css\n"));

/***/ }),

/***/ "./src/assets/styles/utils.module.css":
/*!********************************************!*\
  !*** ./src/assets/styles/utils.module.css ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[2]!./utils.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[2]!./src/assets/styles/utils.module.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[2]!./utils.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[2]!./src/assets/styles/utils.module.css\",\n      function () {\n        content = __webpack_require__(/*! !!../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[2]!./utils.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[2]!./src/assets/styles/utils.module.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXNzZXRzL3N0eWxlcy91dGlscy5tb2R1bGUuY3NzLmpzIiwibWFwcGluZ3MiOiJBQUFBLFVBQVUsbUJBQU8sQ0FBQywwTkFBOEc7QUFDaEksMEJBQTBCLG1CQUFPLENBQUMsd2dCQUFnUTs7QUFFbFM7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLElBQUksSUFBVTtBQUNkLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGlCQUFpQjtBQUNyQixNQUFNLHdnQkFBZ1E7QUFDdFE7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyx3Z0JBQWdROztBQUUxUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsVUFBVTs7QUFFMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLFVBQVU7QUFDWjtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXNzZXRzL3N0eWxlcy91dGlscy5tb2R1bGUuY3NzPzk4ZTkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzFdLm9uZU9mWzhdLnVzZVsxXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMV0ub25lT2ZbOF0udXNlWzJdIS4vdXRpbHMubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgc3R5bGUtbG9hZGVyIGluamVjdHMgQ1NTIGludG8gdGhlIGJvdHRvbVxuICAgICAgICAgICAgICAgICAgICAvLyBvZiA8aGVhZD4uIFRoaXMgY2F1c2VzIG9yZGVyaW5nIHByb2JsZW1zIGJldHdlZW4gZGV2XG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBwcm9kLiBUbyBmaXggdGhpcywgd2UgcmVuZGVyIGEgPG5vc2NyaXB0PiB0YWcgYXNcbiAgICAgICAgICAgICAgICAgICAgLy8gYW4gYW5jaG9yIGZvciB0aGUgc3R5bGVzIHRvIGJlIHBsYWNlZCBiZWZvcmUuIFRoZXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0eWxlcyB3aWxsIGJlIGFwcGxpZWQgX2JlZm9yZV8gPHN0eWxlIGpzeCBnbG9iYWw+LlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVzZSBlbGVtZW50cyBzaG91bGQgYWx3YXlzIGV4aXN0LiBJZiB0aGV5IGRvIG5vdCxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5jaG9yRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGFuY2hvckVsZW1lbnQucGFyZW50Tm9kZS8vIE5vcm1hbGx5IDxoZWFkPlxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuICAgICAgICAgICAgICAgICAgICAvLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gdHJhY2sgdGhlIGxhc3QgaW5zZXJ0ZWQgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgYW5jaG9yRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfTtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgaWYgKCFjb250ZW50LmxvY2FscyB8fCBtb2R1bGUuaG90LmludmFsaWRhdGUpIHtcbiAgICB2YXIgaXNFcXVhbExvY2FscyA9IGZ1bmN0aW9uIGlzRXF1YWxMb2NhbHMoYSwgYiwgaXNOYW1lZEV4cG9ydCkge1xuICAgIGlmICghYSAmJiBiIHx8IGEgJiYgIWIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgcDtcbiAgICBmb3IocCBpbiBhKXtcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKHAgaW4gYil7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFbcF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMV0ub25lT2ZbOF0udXNlWzFdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1sxXS5vbmVPZls4XS51c2VbMl0hLi91dGlscy5tb2R1bGUuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1sxXS5vbmVPZls4XS51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzFdLm9uZU9mWzhdLnVzZVsyXSEuL3V0aWxzLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/assets/styles/utils.module.css\n"));

/***/ }),

/***/ "./src/components/layout.module.css":
/*!******************************************!*\
  !*** ./src/components/layout.module.css ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[2]!./layout.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[2]!./src/components/layout.module.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[2]!./layout.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[2]!./src/components/layout.module.css\",\n      function () {\n        content = __webpack_require__(/*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[2]!./layout.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[8].use[2]!./src/components/layout.module.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9sYXlvdXQubW9kdWxlLmNzcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsdU5BQTJHO0FBQzdILDBCQUEwQixtQkFBTyxDQUFDLGlnQkFBMlA7O0FBRTdSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxJQUFJLElBQVU7QUFDZCx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxpQkFBaUI7QUFDckIsTUFBTSxpZ0JBQTJQO0FBQ2pRO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsaWdCQUEyUDs7QUFFclI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFVBQVU7O0FBRTFCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxVQUFVO0FBQ1o7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvbGF5b3V0Lm1vZHVsZS5jc3M/ZWJjMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMV0ub25lT2ZbOF0udXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1sxXS5vbmVPZls4XS51c2VbMl0hLi9sYXlvdXQubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgc3R5bGUtbG9hZGVyIGluamVjdHMgQ1NTIGludG8gdGhlIGJvdHRvbVxuICAgICAgICAgICAgICAgICAgICAvLyBvZiA8aGVhZD4uIFRoaXMgY2F1c2VzIG9yZGVyaW5nIHByb2JsZW1zIGJldHdlZW4gZGV2XG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBwcm9kLiBUbyBmaXggdGhpcywgd2UgcmVuZGVyIGEgPG5vc2NyaXB0PiB0YWcgYXNcbiAgICAgICAgICAgICAgICAgICAgLy8gYW4gYW5jaG9yIGZvciB0aGUgc3R5bGVzIHRvIGJlIHBsYWNlZCBiZWZvcmUuIFRoZXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0eWxlcyB3aWxsIGJlIGFwcGxpZWQgX2JlZm9yZV8gPHN0eWxlIGpzeCBnbG9iYWw+LlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVzZSBlbGVtZW50cyBzaG91bGQgYWx3YXlzIGV4aXN0LiBJZiB0aGV5IGRvIG5vdCxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5jaG9yRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGFuY2hvckVsZW1lbnQucGFyZW50Tm9kZS8vIE5vcm1hbGx5IDxoZWFkPlxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuICAgICAgICAgICAgICAgICAgICAvLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gdHJhY2sgdGhlIGxhc3QgaW5zZXJ0ZWQgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgYW5jaG9yRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfTtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgaWYgKCFjb250ZW50LmxvY2FscyB8fCBtb2R1bGUuaG90LmludmFsaWRhdGUpIHtcbiAgICB2YXIgaXNFcXVhbExvY2FscyA9IGZ1bmN0aW9uIGlzRXF1YWxMb2NhbHMoYSwgYiwgaXNOYW1lZEV4cG9ydCkge1xuICAgIGlmICghYSAmJiBiIHx8IGEgJiYgIWIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgcDtcbiAgICBmb3IocCBpbiBhKXtcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKHAgaW4gYil7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFbcF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMV0ub25lT2ZbOF0udXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1sxXS5vbmVPZls4XS51c2VbMl0hLi9sYXlvdXQubW9kdWxlLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMV0ub25lT2ZbOF0udXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1sxXS5vbmVPZls4XS51c2VbMl0hLi9sYXlvdXQubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsTG9jYWxzKG9sZExvY2FscywgY29udGVudC5sb2NhbHMpKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgICAgICAgICAgICB1cGRhdGUoY29udGVudCk7XG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkge1xuICAgIHVwZGF0ZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/layout.module.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js ***!
  \*****************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    PrefetchKind: function PrefetchKind1() {\n        return PrefetchKind;\n    },\n    ACTION_REFRESH: function ACTION_REFRESH1() {\n        return ACTION_REFRESH;\n    },\n    ACTION_NAVIGATE: function ACTION_NAVIGATE1() {\n        return ACTION_NAVIGATE;\n    },\n    ACTION_RESTORE: function ACTION_RESTORE1() {\n        return ACTION_RESTORE;\n    },\n    ACTION_SERVER_PATCH: function ACTION_SERVER_PATCH1() {\n        return ACTION_SERVER_PATCH;\n    },\n    ACTION_PREFETCH: function ACTION_PREFETCH1() {\n        return ACTION_PREFETCH;\n    },\n    ACTION_FAST_REFRESH: function ACTION_FAST_REFRESH1() {\n        return ACTION_FAST_REFRESH;\n    },\n    ACTION_SERVER_ACTION: function ACTION_SERVER_ACTION1() {\n        return ACTION_SERVER_ACTION;\n    }\n});\nvar ACTION_REFRESH = \"refresh\";\nvar ACTION_NAVIGATE = \"navigate\";\nvar ACTION_RESTORE = \"restore\";\nvar ACTION_SERVER_PATCH = \"server-patch\";\nvar ACTION_PREFETCH = \"prefetch\";\nvar ACTION_FAST_REFRESH = \"fast-refresh\";\nvar ACTION_SERVER_ACTION = \"server-action\";\nvar PrefetchKind;\n(function(PrefetchKind) {\n    PrefetchKind[\"AUTO\"] = \"auto\";\n    PrefetchKind[\"FULL\"] = \"full\";\n    PrefetchKind[\"TEMPORARY\"] = \"temporary\";\n})(PrefetchKind || (PrefetchKind = {}));\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=router-reducer-types.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLXR5cGVzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGLEtBQU1DLENBQUFBLENBU047QUFDQSxTQUFTUyxRQUFRQyxNQUFNLEVBQUVDLEdBQUc7SUFDeEIsSUFBSSxJQUFJQyxRQUFRRCxJQUFJZixPQUFPQyxlQUFlYSxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFYLFNBQVM7SUFDYkcsY0FBYyxTQUFkQTtRQUNJLE9BQU9BO0lBQ1g7SUFDQUMsZ0JBQWdCLFNBQWhCQTtRQUNJLE9BQU9BO0lBQ1g7SUFDQUMsaUJBQWlCLFNBQWpCQTtRQUNJLE9BQU9BO0lBQ1g7SUFDQUMsZ0JBQWdCLFNBQWhCQTtRQUNJLE9BQU9BO0lBQ1g7SUFDQUMscUJBQXFCLFNBQXJCQTtRQUNJLE9BQU9BO0lBQ1g7SUFDQUMsaUJBQWlCLFNBQWpCQTtRQUNJLE9BQU9BO0lBQ1g7SUFDQUMscUJBQXFCLFNBQXJCQTtRQUNJLE9BQU9BO0lBQ1g7SUFDQUMsc0JBQXNCLFNBQXRCQTtRQUNJLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLElBQU1OLGlCQUFpQjtBQUN2QixJQUFNQyxrQkFBa0I7QUFDeEIsSUFBTUMsaUJBQWlCO0FBQ3ZCLElBQU1DLHNCQUFzQjtBQUM1QixJQUFNQyxrQkFBa0I7QUFDeEIsSUFBTUMsc0JBQXNCO0FBQzVCLElBQU1DLHVCQUF1QjtBQUM3QixJQUFJUDtBQUNILFVBQVNBLFlBQVk7SUFDbEJBLFlBQVksQ0FBQyxPQUFPLEdBQUc7SUFDdkJBLFlBQVksQ0FBQyxPQUFPLEdBQUc7SUFDdkJBLFlBQVksQ0FBQyxZQUFZLEdBQUc7QUFDaEMsR0FBR0EsZ0JBQWlCQSxDQUFBQSxlQUFlLENBQUM7QUFFcEMsSUFBSSxDQUFDLE9BQU9ILE9BQVFpQixDQUFBQSxVQUFPLEtBQUssY0FBZSxPQUFPakIsT0FBUWlCLENBQUFBLFVBQU8sS0FBSyxZQUFZakIsT0FBUWlCLENBQUFBLFVBQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2pCLE9BQVFpQixDQUFBQSxVQUFPLENBQUNDLGVBQWUsYUFBYTtJQUNyS3BCLE9BQU9DLGVBQWVDLE9BQVFpQixDQUFBQSxVQUFPLEVBQUUsY0FBYztRQUFFaEIsT0FBTztJQUFLO0lBQ25FSCxPQUFPcUIsT0FBT25CLE9BQVFpQixDQUFBQSxVQUFPLEVBQUVqQjtJQUMvQkUsT0FBT0YsVUFBVUEsT0FBUWlCLENBQUFBLFVBQU87QUFDbEMsRUFFQSxnREFBZ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci10eXBlcy5qcz82NTdkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgUHJlZmV0Y2hLaW5kOiBudWxsLFxuICAgIEFDVElPTl9SRUZSRVNIOiBudWxsLFxuICAgIEFDVElPTl9OQVZJR0FURTogbnVsbCxcbiAgICBBQ1RJT05fUkVTVE9SRTogbnVsbCxcbiAgICBBQ1RJT05fU0VSVkVSX1BBVENIOiBudWxsLFxuICAgIEFDVElPTl9QUkVGRVRDSDogbnVsbCxcbiAgICBBQ1RJT05fRkFTVF9SRUZSRVNIOiBudWxsLFxuICAgIEFDVElPTl9TRVJWRVJfQUNUSU9OOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIFByZWZldGNoS2luZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQcmVmZXRjaEtpbmQ7XG4gICAgfSxcbiAgICBBQ1RJT05fUkVGUkVTSDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBBQ1RJT05fUkVGUkVTSDtcbiAgICB9LFxuICAgIEFDVElPTl9OQVZJR0FURTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBBQ1RJT05fTkFWSUdBVEU7XG4gICAgfSxcbiAgICBBQ1RJT05fUkVTVE9SRTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBBQ1RJT05fUkVTVE9SRTtcbiAgICB9LFxuICAgIEFDVElPTl9TRVJWRVJfUEFUQ0g6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQUNUSU9OX1NFUlZFUl9QQVRDSDtcbiAgICB9LFxuICAgIEFDVElPTl9QUkVGRVRDSDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBBQ1RJT05fUFJFRkVUQ0g7XG4gICAgfSxcbiAgICBBQ1RJT05fRkFTVF9SRUZSRVNIOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFDVElPTl9GQVNUX1JFRlJFU0g7XG4gICAgfSxcbiAgICBBQ1RJT05fU0VSVkVSX0FDVElPTjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBBQ1RJT05fU0VSVkVSX0FDVElPTjtcbiAgICB9XG59KTtcbmNvbnN0IEFDVElPTl9SRUZSRVNIID0gXCJyZWZyZXNoXCI7XG5jb25zdCBBQ1RJT05fTkFWSUdBVEUgPSBcIm5hdmlnYXRlXCI7XG5jb25zdCBBQ1RJT05fUkVTVE9SRSA9IFwicmVzdG9yZVwiO1xuY29uc3QgQUNUSU9OX1NFUlZFUl9QQVRDSCA9IFwic2VydmVyLXBhdGNoXCI7XG5jb25zdCBBQ1RJT05fUFJFRkVUQ0ggPSBcInByZWZldGNoXCI7XG5jb25zdCBBQ1RJT05fRkFTVF9SRUZSRVNIID0gXCJmYXN0LXJlZnJlc2hcIjtcbmNvbnN0IEFDVElPTl9TRVJWRVJfQUNUSU9OID0gXCJzZXJ2ZXItYWN0aW9uXCI7XG52YXIgUHJlZmV0Y2hLaW5kO1xuKGZ1bmN0aW9uKFByZWZldGNoS2luZCkge1xuICAgIFByZWZldGNoS2luZFtcIkFVVE9cIl0gPSBcImF1dG9cIjtcbiAgICBQcmVmZXRjaEtpbmRbXCJGVUxMXCJdID0gXCJmdWxsXCI7XG4gICAgUHJlZmV0Y2hLaW5kW1wiVEVNUE9SQVJZXCJdID0gXCJ0ZW1wb3JhcnlcIjtcbn0pKFByZWZldGNoS2luZCB8fCAoUHJlZmV0Y2hLaW5kID0ge30pKTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLXJlZHVjZXItdHlwZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiUHJlZmV0Y2hLaW5kIiwiQUNUSU9OX1JFRlJFU0giLCJBQ1RJT05fTkFWSUdBVEUiLCJBQ1RJT05fUkVTVE9SRSIsIkFDVElPTl9TRVJWRVJfUEFUQ0giLCJBQ1RJT05fUFJFRkVUQ0giLCJBQ1RJT05fRkFTVF9SRUZSRVNIIiwiQUNUSU9OX1NFUlZFUl9BQ1RJT04iLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/get-domain-locale.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/client/get-domain-locale.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getDomainLocale\", ({\n    enumerable: true,\n    get: function get() {\n        return getDomainLocale;\n    }\n}));\nvar basePath =  false || \"\";\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (false) { var finalLocale, proto, domain, target, detectDomainLocale, normalizeLocalePath; } else {\n        return false;\n    }\n}\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=get-domain-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9nZXQtZG9tYWluLWxvY2FsZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsbURBQWtEO0lBQzlDSSxZQUFZO0lBQ1pDLEtBQUssU0FBTEE7UUFDSSxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsSUFBTUMsV0FBV0MsTUFBa0NFLElBQUk7QUFDdkQsU0FBU0osZ0JBQWdCSyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxhQUFhO0lBQ3pELElBQUlOLEtBQStCTyxFQUFFLG9GQVdwQyxNQUFNO1FBQ0gsT0FBTztJQUNYO0FBQ0o7QUFFQSxJQUFJLENBQUMsT0FBT2IsT0FBUXlCLENBQUFBLFVBQU8sS0FBSyxjQUFlLE9BQU96QixPQUFReUIsQ0FBQUEsVUFBTyxLQUFLLFlBQVl6QixPQUFReUIsQ0FBQUEsVUFBTyxLQUFLLElBQUksS0FBTSxPQUFPekIsT0FBUXlCLENBQUFBLFVBQU8sQ0FBQ0MsZUFBZSxhQUFhO0lBQ3JLNUIsT0FBT0MsZUFBZUMsT0FBUXlCLENBQUFBLFVBQU8sRUFBRSxjQUFjO1FBQUV4QixPQUFPO0lBQUs7SUFDbkVILE9BQU82QixPQUFPM0IsT0FBUXlCLENBQUFBLFVBQU8sRUFBRXpCO0lBQy9CNEIsT0FBTzVCLFVBQVVBLE9BQVF5QixDQUFBQSxVQUFPO0FBQ2xDLEVBRUEsNkNBQTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2dldC1kb21haW4tbG9jYWxlLmpzPzVjMjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXREb21haW5Mb2NhbGVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldERvbWFpbkxvY2FsZTtcbiAgICB9XG59KTtcbmNvbnN0IGJhc2VQYXRoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCB8fCBcIlwiO1xuZnVuY3Rpb24gZ2V0RG9tYWluTG9jYWxlKHBhdGgsIGxvY2FsZSwgbG9jYWxlcywgZG9tYWluTG9jYWxlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZUxvY2FsZVBhdGggPSByZXF1aXJlKFwiLi9ub3JtYWxpemUtbG9jYWxlLXBhdGhcIikubm9ybWFsaXplTG9jYWxlUGF0aDtcbiAgICAgICAgY29uc3QgZGV0ZWN0RG9tYWluTG9jYWxlID0gcmVxdWlyZShcIi4vZGV0ZWN0LWRvbWFpbi1sb2NhbGVcIikuZGV0ZWN0RG9tYWluTG9jYWxlO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBsb2NhbGUgfHwgbm9ybWFsaXplTG9jYWxlUGF0aChwYXRoLCBsb2NhbGVzKS5kZXRlY3RlZExvY2FsZTtcbiAgICAgICAgY29uc3QgZG9tYWluID0gZGV0ZWN0RG9tYWluTG9jYWxlKGRvbWFpbkxvY2FsZXMsIHVuZGVmaW5lZCwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgY29uc3QgcHJvdG8gPSBcImh0dHBcIiArIChkb21haW4uaHR0cCA/IFwiXCIgOiBcInNcIikgKyBcIjovL1wiO1xuICAgICAgICAgICAgY29uc3QgZmluYWxMb2NhbGUgPSB0YXJnZXQgPT09IGRvbWFpbi5kZWZhdWx0TG9jYWxlID8gXCJcIiA6IFwiL1wiICsgdGFyZ2V0O1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyBwcm90byArIGRvbWFpbi5kb21haW4gKyBiYXNlUGF0aCArIGZpbmFsTG9jYWxlICsgcGF0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LWRvbWFpbi1sb2NhbGUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImdldERvbWFpbkxvY2FsZSIsImJhc2VQYXRoIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9ST1VURVJfQkFTRVBBVEgiLCJwYXRoIiwibG9jYWxlIiwibG9jYWxlcyIsImRvbWFpbkxvY2FsZXMiLCJfX05FWFRfSTE4Tl9TVVBQT1JUIiwibm9ybWFsaXplTG9jYWxlUGF0aCIsInJlcXVpcmUiLCJkZXRlY3REb21haW5Mb2NhbGUiLCJ0YXJnZXQiLCJkZXRlY3RlZExvY2FsZSIsImRvbWFpbiIsInVuZGVmaW5lZCIsInByb3RvIiwiaHR0cCIsImZpbmFsTG9jYWxlIiwiZGVmYXVsdExvY2FsZSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/get-domain-locale.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/image.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/image.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"./node_modules/@swc/helpers/esm/_object_spread.js\");\nvar _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"./node_modules/@swc/helpers/esm/_object_spread_props.js\");\nvar _object_without_properties = __webpack_require__(/*! @swc/helpers/_/_object_without_properties */ \"./node_modules/@swc/helpers/esm/_object_without_properties.js\");\nvar _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"./node_modules/@swc/helpers/esm/_sliced_to_array.js\");\nvar _to_consumable_array = __webpack_require__(/*! @swc/helpers/_/_to_consumable_array */ \"./node_modules/@swc/helpers/esm/_to_consumable_array.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function get() {\n        return _default;\n    }\n}));\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nvar _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar _head = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\"));\nvar _imageblursvg = __webpack_require__(/*! ../shared/lib/image-blur-svg */ \"./node_modules/next/dist/shared/lib/image-blur-svg.js\");\nvar _imageconfig = __webpack_require__(/*! ../shared/lib/image-config */ \"./node_modules/next/dist/shared/lib/image-config.js\");\nvar _imageconfigcontext = __webpack_require__(/*! ../shared/lib/image-config-context */ \"./node_modules/next/dist/shared/lib/image-config-context.js\");\nvar _warnonce = __webpack_require__(/*! ../shared/lib/utils/warn-once */ \"./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nvar _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"./node_modules/next/dist/shared/lib/image-loader.js\"));\nvar configEnv = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[]};\nvar allImgs = new Map();\nvar perfObserver;\nif (false) {}\nvar VALID_LOADING_VALUES = [\n    \"lazy\",\n    \"eager\",\n    undefined\n];\nfunction isStaticRequire(src) {\n    return src[\"default\"] !== undefined;\n}\nfunction isStaticImageData(src) {\n    return src.src !== undefined;\n}\nfunction isStaticImport(src) {\n    return typeof src === \"object\" && (isStaticRequire(src) || isStaticImageData(src));\n}\nfunction getWidths(param, width, sizes) {\n    var deviceSizes = param.deviceSizes, allSizes = param.allSizes;\n    if (sizes) {\n        // Find all the \"vw\" percent sizes used in the sizes prop\n        var viewportWidthRe = /(^|\\s)(1?\\d?\\d)vw/g;\n        var percentSizes = [];\n        for(var match; match = viewportWidthRe.exec(sizes); match){\n            percentSizes.push(parseInt(match[2]));\n        }\n        if (percentSizes.length) {\n            var _Math;\n            var smallestRatio = (_Math = Math).min.apply(_Math, _to_consumable_array._(percentSizes)) * 0.01;\n            return {\n                widths: allSizes.filter(function(s) {\n                    return s >= deviceSizes[0] * smallestRatio;\n                }),\n                kind: \"w\"\n            };\n        }\n        return {\n            widths: allSizes,\n            kind: \"w\"\n        };\n    }\n    if (typeof width !== \"number\") {\n        return {\n            widths: deviceSizes,\n            kind: \"w\"\n        };\n    }\n    var widths = _to_consumable_array._(new Set(// > are actually 3x in the green color, but only 1.5x in the red and\n    // > blue colors. Showing a 3x resolution image in the app vs a 2x\n    // > resolution image will be visually the same, though the 3x image\n    // > takes significantly more data. Even true 3x resolution screens are\n    // > wasteful as the human eye cannot see that level of detail without\n    // > something like a magnifying glass.\n    // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\n    [\n        width,\n        width * 2 /*, width * 3*/ \n    ].map(function(w) {\n        return allSizes.find(function(p) {\n            return p >= w;\n        }) || allSizes[allSizes.length - 1];\n    })));\n    return {\n        widths: widths,\n        kind: \"x\"\n    };\n}\nfunction generateImgAttrs(param) {\n    var config = param.config, src = param.src, unoptimized = param.unoptimized, width = param.width, quality = param.quality, sizes = param.sizes, loader = param.loader;\n    if (unoptimized) {\n        return {\n            src: src,\n            srcSet: undefined,\n            sizes: undefined\n        };\n    }\n    var _getWidths = getWidths(config, width, sizes), widths = _getWidths.widths, kind = _getWidths.kind;\n    var last = widths.length - 1;\n    return {\n        sizes: !sizes && kind === \"w\" ? \"100vw\" : sizes,\n        srcSet: widths.map(function(w, i) {\n            return loader({\n                config: config,\n                src: src,\n                quality: quality,\n                width: w\n            }) + \" \" + (kind === \"w\" ? w : i + 1) + kind;\n        }).join(\", \"),\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        src: loader({\n            config: config,\n            src: src,\n            quality: quality,\n            width: widths[last]\n        })\n    };\n}\nfunction getInt(x) {\n    if (typeof x === \"undefined\") {\n        return x;\n    }\n    if (typeof x === \"number\") {\n        return Number.isFinite(x) ? x : NaN;\n    }\n    if (typeof x === \"string\" && /^[0-9]+$/.test(x)) {\n        return parseInt(x, 10);\n    }\n    return NaN;\n}\n// See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\nfunction handleLoading(img, src, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized) {\n    if (!img || img[\"data-loaded-src\"] === src) {\n        return;\n    }\n    img[\"data-loaded-src\"] = src;\n    var p = \"decode\" in img ? img.decode() : Promise.resolve();\n    p[\"catch\"](function() {}).then(function() {\n        if (!img.parentElement || !img.isConnected) {\n            // Exit early in case of race condition:\n            // - onload() is called\n            // - decode() is called but incomplete\n            // - unmount is called\n            // - decode() completes\n            return;\n        }\n        if (placeholder === \"blur\") {\n            setBlurComplete(true);\n        }\n        if (onLoadRef == null ? void 0 : onLoadRef.current) {\n            // Since we don't have the SyntheticEvent here,\n            // we must create one with the same shape.\n            // See https://reactjs.org/docs/events.html\n            var event = new Event(\"load\");\n            Object.defineProperty(event, \"target\", {\n                writable: false,\n                value: img\n            });\n            var prevented = false;\n            var stopped = false;\n            onLoadRef.current(_object_spread_props._(_object_spread._({}, event), {\n                nativeEvent: event,\n                currentTarget: img,\n                target: img,\n                isDefaultPrevented: function() {\n                    return prevented;\n                },\n                isPropagationStopped: function() {\n                    return stopped;\n                },\n                persist: function() {},\n                preventDefault: function() {\n                    prevented = true;\n                    event.preventDefault();\n                },\n                stopPropagation: function() {\n                    stopped = true;\n                    event.stopPropagation();\n                }\n            }));\n        }\n        if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {\n            onLoadingCompleteRef.current(img);\n        }\n        if (true) {\n            if (img.getAttribute(\"data-nimg\") === \"fill\") {\n                if (!unoptimized && (!img.getAttribute(\"sizes\") || img.getAttribute(\"sizes\") === \"100vw\")) {\n                    var widthViewportRatio = img.getBoundingClientRect().width / window.innerWidth;\n                    if (widthViewportRatio < 0.6) {\n                        (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has \"fill\" but is missing \"sizes\" prop. Please add it to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                    }\n                }\n                if (img.parentElement) {\n                    var position = window.getComputedStyle(img.parentElement).position;\n                    var valid = [\n                        \"absolute\",\n                        \"fixed\",\n                        \"relative\"\n                    ];\n                    if (!valid.includes(position)) {\n                        (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has \"fill\" and parent element with invalid \"position\". Provided \"' + position + '\" should be one of ' + valid.map(String).join(\",\") + \".\");\n                    }\n                }\n                if (img.height === 0) {\n                    (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has \"fill\" and a height value of 0. This is likely because the parent element of the image has not been styled to have a set height.');\n                }\n            }\n            var heightModified = img.height.toString() !== img.getAttribute(\"height\");\n            var widthModified = img.width.toString() !== img.getAttribute(\"width\");\n            if (heightModified && !widthModified || !heightModified && widthModified) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles \\'width: \"auto\"\\' or \\'height: \"auto\"\\' to maintain the aspect ratio.');\n            }\n        }\n    });\n}\nfunction getDynamicProps(fetchPriority) {\n    var _react_version_split = _sliced_to_array._(_react.version.split(\".\"), 2), majorStr = _react_version_split[0], minorStr = _react_version_split[1];\n    var major = parseInt(majorStr, 10);\n    var minor = parseInt(minorStr, 10);\n    if (major > 18 || major === 18 && minor >= 3) {\n        // In React 18.3.0 or newer, we must use camelCase\n        // prop to avoid \"Warning: Invalid DOM property\".\n        // See https://github.com/facebook/react/pull/25927\n        return {\n            fetchPriority: fetchPriority\n        };\n    }\n    // In React 18.2.0 or older, we must use lowercase prop\n    // to avoid \"Warning: Invalid DOM property\".\n    return {\n        fetchpriority: fetchPriority\n    };\n}\nvar ImageElement = /*#__PURE__*/ (0, _react.forwardRef)(function(param, forwardedRef) {\n    var imgAttributes = param.imgAttributes, heightInt = param.heightInt, widthInt = param.widthInt, qualityInt = param.qualityInt, className = param.className, imgStyle = param.imgStyle, blurStyle = param.blurStyle, isLazy = param.isLazy, fetchPriority = param.fetchPriority, fill = param.fill, placeholder = param.placeholder, loading = param.loading, srcString = param.srcString, config = param.config, unoptimized = param.unoptimized, loader = param.loader, onLoadRef = param.onLoadRef, onLoadingCompleteRef = param.onLoadingCompleteRef, setBlurComplete = param.setBlurComplete, setShowAltText = param.setShowAltText, onLoad = param.onLoad, onError = param.onError, rest = _object_without_properties._(param, [\n        \"imgAttributes\",\n        \"heightInt\",\n        \"widthInt\",\n        \"qualityInt\",\n        \"className\",\n        \"imgStyle\",\n        \"blurStyle\",\n        \"isLazy\",\n        \"fetchPriority\",\n        \"fill\",\n        \"placeholder\",\n        \"loading\",\n        \"srcString\",\n        \"config\",\n        \"unoptimized\",\n        \"loader\",\n        \"onLoadRef\",\n        \"onLoadingCompleteRef\",\n        \"setBlurComplete\",\n        \"setShowAltText\",\n        \"onLoad\",\n        \"onError\"\n    ]);\n    loading = isLazy ? \"lazy\" : loading;\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"img\", _object_spread_props._(_object_spread._(_object_spread_props._(_object_spread._({}, rest, getDynamicProps(fetchPriority)), {\n        loading: loading,\n        width: widthInt,\n        height: heightInt,\n        decoding: \"async\",\n        \"data-nimg\": fill ? \"fill\" : \"1\",\n        className: className,\n        style: _object_spread._({}, imgStyle, blurStyle)\n    }), imgAttributes), {\n        ref: (0, _react.useCallback)(function(img) {\n            if (forwardedRef) {\n                if (typeof forwardedRef === \"function\") forwardedRef(img);\n                else if (typeof forwardedRef === \"object\") {\n                    // @ts-ignore - .current is read only it's usually assigned by react internally\n                    forwardedRef.current = img;\n                }\n            }\n            if (!img) {\n                return;\n            }\n            if (onError) {\n                // If the image has an error before react hydrates, then the error is lost.\n                // The workaround is to wait until the image is mounted which is after hydration,\n                // then we set the src again to trigger the error handler (if there was an error).\n                // eslint-disable-next-line no-self-assign\n                img.src = img.src;\n            }\n            if (true) {\n                if (!srcString) {\n                    console.error('Image is missing required \"src\" property:', img);\n                }\n                if (img.getAttribute(\"alt\") === null) {\n                    console.error('Image is missing required \"alt\" property. Please add Alternative Text to describe the image for screen readers and search engines.');\n                }\n            }\n            if (img.complete) {\n                handleLoading(img, srcString, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized);\n            }\n        }, [\n            srcString,\n            placeholder,\n            onLoadRef,\n            onLoadingCompleteRef,\n            setBlurComplete,\n            onError,\n            unoptimized,\n            forwardedRef\n        ]),\n        onLoad: function(event) {\n            var img = event.currentTarget;\n            handleLoading(img, srcString, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized);\n        },\n        onError: function(event) {\n            // if the real image fails to load, this will ensure \"alt\" is visible\n            setShowAltText(true);\n            if (placeholder === \"blur\") {\n                // If the real image fails to load, this will still remove the placeholder.\n                setBlurComplete(true);\n            }\n            if (onError) {\n                onError(event);\n            }\n        }\n    }));\n});\n_c = ImageElement;\nvar Image = /*#__PURE__*/ (0, _react.forwardRef)(function(param, forwardedRef) {\n    var src = param.src, sizes = param.sizes, _param_unoptimized = param.unoptimized, unoptimized = _param_unoptimized === void 0 ? false : _param_unoptimized, _param_priority = param.priority, priority = _param_priority === void 0 ? false : _param_priority, loading = param.loading, className = param.className, quality = param.quality, width = param.width, height = param.height, fill = param.fill, style = param.style, onLoad = param.onLoad, onLoadingComplete = param.onLoadingComplete, _param_placeholder = param.placeholder, placeholder = _param_placeholder === void 0 ? \"empty\" : _param_placeholder, blurDataURL = param.blurDataURL, fetchPriority = param.fetchPriority, layout = param.layout, objectFit = param.objectFit, objectPosition = param.objectPosition, lazyBoundary = param.lazyBoundary, lazyRoot = param.lazyRoot, all = _object_without_properties._(param, [\n        \"src\",\n        \"sizes\",\n        \"unoptimized\",\n        \"priority\",\n        \"loading\",\n        \"className\",\n        \"quality\",\n        \"width\",\n        \"height\",\n        \"fill\",\n        \"style\",\n        \"onLoad\",\n        \"onLoadingComplete\",\n        \"placeholder\",\n        \"blurDataURL\",\n        \"fetchPriority\",\n        \"layout\",\n        \"objectFit\",\n        \"objectPosition\",\n        \"lazyBoundary\",\n        \"lazyRoot\"\n    ]);\n    var configContext = (0, _react.useContext)(_imageconfigcontext.ImageConfigContext);\n    var config = (0, _react.useMemo)(function() {\n        var c = configEnv || configContext || _imageconfig.imageConfigDefault;\n        var allSizes = _to_consumable_array._(c.deviceSizes).concat(_to_consumable_array._(c.imageSizes)).sort(function(a, b) {\n            return a - b;\n        });\n        var deviceSizes = c.deviceSizes.sort(function(a, b) {\n            return a - b;\n        });\n        return _object_spread_props._(_object_spread._({}, c), {\n            allSizes: allSizes,\n            deviceSizes: deviceSizes\n        });\n    }, [\n        configContext\n    ]);\n    var rest = all;\n    var loader = rest.loader || _imageloader[\"default\"];\n    // Remove property so it's not spread on <img> element\n    delete rest.loader;\n    // This special value indicates that the user\n    // didn't define a \"loader\" prop or \"loader\" config.\n    var isDefaultLoader = \"__next_img_default\" in loader;\n    if (isDefaultLoader) {\n        if (config.loader === \"custom\") {\n            throw new Error('Image with src \"' + src + '\" is missing \"loader\" prop.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader\");\n        }\n    } else {\n        // The user defined a \"loader\" prop or config.\n        // Since the config object is internal only, we\n        // must not pass it to the user-defined \"loader\".\n        var customImageLoader = loader;\n        var _tmp;\n        _tmp = function(obj) {\n            var _ = obj.config, opts = _object_without_properties._(obj, [\n                \"config\"\n            ]);\n            return customImageLoader(opts);\n        }, loader = _tmp, _tmp;\n    }\n    if (layout) {\n        if (layout === \"fill\") {\n            fill = true;\n        }\n        var layoutToStyle = {\n            intrinsic: {\n                maxWidth: \"100%\",\n                height: \"auto\"\n            },\n            responsive: {\n                width: \"100%\",\n                height: \"auto\"\n            }\n        };\n        var layoutToSizes = {\n            responsive: \"100vw\",\n            fill: \"100vw\"\n        };\n        var layoutStyle = layoutToStyle[layout];\n        if (layoutStyle) {\n            style = _object_spread._({}, style, layoutStyle);\n        }\n        var layoutSizes = layoutToSizes[layout];\n        if (layoutSizes && !sizes) {\n            sizes = layoutSizes;\n        }\n    }\n    var staticSrc = \"\";\n    var widthInt = getInt(width);\n    var heightInt = getInt(height);\n    var blurWidth;\n    var blurHeight;\n    if (isStaticImport(src)) {\n        var staticImageData = isStaticRequire(src) ? src[\"default\"] : src;\n        if (!staticImageData.src) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received \" + JSON.stringify(staticImageData));\n        }\n        if (!staticImageData.height || !staticImageData.width) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received \" + JSON.stringify(staticImageData));\n        }\n        blurWidth = staticImageData.blurWidth;\n        blurHeight = staticImageData.blurHeight;\n        blurDataURL = blurDataURL || staticImageData.blurDataURL;\n        staticSrc = staticImageData.src;\n        if (!fill) {\n            if (!widthInt && !heightInt) {\n                widthInt = staticImageData.width;\n                heightInt = staticImageData.height;\n            } else if (widthInt && !heightInt) {\n                var ratio = widthInt / staticImageData.width;\n                heightInt = Math.round(staticImageData.height * ratio);\n            } else if (!widthInt && heightInt) {\n                var ratio1 = heightInt / staticImageData.height;\n                widthInt = Math.round(staticImageData.width * ratio1);\n            }\n        }\n    }\n    src = typeof src === \"string\" ? src : staticSrc;\n    var isLazy = !priority && (loading === \"lazy\" || typeof loading === \"undefined\");\n    if (!src || src.startsWith(\"data:\") || src.startsWith(\"blob:\")) {\n        // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n        unoptimized = true;\n        isLazy = false;\n    }\n    if (config.unoptimized) {\n        unoptimized = true;\n    }\n    if (isDefaultLoader && src.endsWith(\".svg\") && !config.dangerouslyAllowSVG) {\n        // Special case to make svg serve as-is to avoid proxying\n        // through the built-in Image Optimization API.\n        unoptimized = true;\n    }\n    if (priority) {\n        fetchPriority = \"high\";\n    }\n    var _ref = _sliced_to_array._((0, _react.useState)(false), 2), blurComplete = _ref[0], setBlurComplete = _ref[1];\n    var _ref1 = _sliced_to_array._((0, _react.useState)(false), 2), showAltText = _ref1[0], setShowAltText = _ref1[1];\n    var qualityInt = getInt(quality);\n    if (true) {\n        if (config.output === \"export\" && isDefaultLoader && !unoptimized) {\n            throw new Error(\"Image Optimization using the default loader is not compatible with `{ output: 'export' }`.\\n  Possible solutions:\\n    - Remove `{ output: 'export' }` and run \\\"next start\\\" to run server mode including the Image Optimization API.\\n    - Configure `{ images: { unoptimized: true } }` in `next.config.js` to disable the Image Optimization API.\\n  Read more: https://nextjs.org/docs/messages/export-image-api\");\n        }\n        if (!src) {\n            // React doesn't show the stack trace and there's\n            // no `src` to help identify which image, so we\n            // instead console.error(ref) during mount.\n            unoptimized = true;\n        } else {\n            if (fill) {\n                if (width) {\n                    throw new Error('Image with src \"' + src + '\" has both \"width\" and \"fill\" properties. Only one should be used.');\n                }\n                if (height) {\n                    throw new Error('Image with src \"' + src + '\" has both \"height\" and \"fill\" properties. Only one should be used.');\n                }\n                if ((style == null ? void 0 : style.position) && style.position !== \"absolute\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.position\" properties. Images with \"fill\" always use position absolute - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.width) && style.width !== \"100%\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.width\" properties. Images with \"fill\" always use width 100% - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.height) && style.height !== \"100%\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.height\" properties. Images with \"fill\" always use height 100% - it cannot be modified.');\n                }\n            } else {\n                if (typeof widthInt === \"undefined\") {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"width\" property.');\n                } else if (isNaN(widthInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"width\" property. Expected a numeric value in pixels but received \"' + width + '\".');\n                }\n                if (typeof heightInt === \"undefined\") {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"height\" property.');\n                } else if (isNaN(heightInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"height\" property. Expected a numeric value in pixels but received \"' + height + '\".');\n                }\n            }\n        }\n        if (!VALID_LOADING_VALUES.includes(loading)) {\n            throw new Error('Image with src \"' + src + '\" has invalid \"loading\" property. Provided \"' + loading + '\" should be one of ' + VALID_LOADING_VALUES.map(String).join(\",\") + \".\");\n        }\n        if (priority && loading === \"lazy\") {\n            throw new Error('Image with src \"' + src + '\" has both \"priority\" and \"loading=\\'lazy\\'\" properties. Only one should be used.');\n        }\n        if (placeholder === \"blur\") {\n            if (widthInt && heightInt && widthInt * heightInt < 1600) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is smaller than 40x40. Consider removing the \"placeholder=\\'blur\\'\" property to improve performance.');\n            }\n            if (!blurDataURL) {\n                var VALID_BLUR_EXT = [\n                    \"jpeg\",\n                    \"png\",\n                    \"webp\",\n                    \"avif\"\n                ] // should match next-image-loader\n                ;\n                throw new Error('Image with src \"' + src + '\" has \"placeholder=\\'blur\\'\" property but is missing the \"blurDataURL\" property.\\n          Possible solutions:\\n            - Add a \"blurDataURL\" property, the contents should be a small Data URL to represent the image\\n            - Change the \"src\" property to a static import with one of the supported file types: ' + VALID_BLUR_EXT.join(\",\") + '\\n            - Remove the \"placeholder\" property, effectively no blur effect\\n          Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url');\n            }\n        }\n        if (\"ref\" in rest) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using unsupported \"ref\" property. Consider using the \"onLoadingComplete\" property instead.');\n        }\n        if (!unoptimized && loader !== _imageloader[\"default\"]) {\n            var urlStr = loader({\n                config: config,\n                src: src,\n                width: widthInt || 400,\n                quality: qualityInt || 75\n            });\n            var url;\n            try {\n                url = new URL(urlStr);\n            } catch (err) {}\n            if (urlStr === src || url && url.pathname === src && !url.search) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has a \"loader\" property that does not implement width. Please implement it or use the \"unoptimized\" property instead.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width\");\n            }\n        }\n        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n        try {\n            for(var _iterator = Object.entries({\n                layout: layout,\n                objectFit: objectFit,\n                objectPosition: objectPosition,\n                lazyBoundary: lazyBoundary,\n                lazyRoot: lazyRoot\n            })[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                var _step_value = _sliced_to_array._(_step.value, 2), legacyKey = _step_value[0], legacyValue = _step_value[1];\n                if (legacyValue) {\n                    (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has legacy prop \"' + legacyKey + '\". Did you forget to run the codemod?' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-upgrade-to-13\");\n                }\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally{\n            try {\n                if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                    _iterator[\"return\"]();\n                }\n            } finally{\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n        if ( true && !perfObserver && window.PerformanceObserver) {\n            perfObserver = new PerformanceObserver(function(entryList) {\n                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n                try {\n                    for(var _iterator = entryList.getEntries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                        var entry = _step.value;\n                        var _entry_element;\n                        // @ts-ignore - missing \"LargestContentfulPaint\" class with \"element\" prop\n                        var imgSrc = (entry == null ? void 0 : (_entry_element = entry.element) == null ? void 0 : _entry_element.src) || \"\";\n                        var lcpImage = allImgs.get(imgSrc);\n                        if (lcpImage && !lcpImage.priority && lcpImage.placeholder !== \"blur\" && !lcpImage.src.startsWith(\"data:\") && !lcpImage.src.startsWith(\"blob:\")) {\n                            // https://web.dev/lcp/#measure-lcp-in-javascript\n                            (0, _warnonce.warnOnce)('Image with src \"' + lcpImage.src + '\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.' + \"\\nRead more: https://nextjs.org/docs/api-reference/next/image#priority\");\n                        }\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally{\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                            _iterator[\"return\"]();\n                        }\n                    } finally{\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n            });\n            try {\n                perfObserver.observe({\n                    type: \"largest-contentful-paint\",\n                    buffered: true\n                });\n            } catch (err) {\n                // Log error but don't crash the app\n                console.error(err);\n            }\n        }\n    }\n    var imgStyle = Object.assign(fill ? {\n        position: \"absolute\",\n        height: \"100%\",\n        width: \"100%\",\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n        objectFit: objectFit,\n        objectPosition: objectPosition\n    } : {}, showAltText ? {} : {\n        color: \"transparent\"\n    }, style);\n    var blurStyle = placeholder === \"blur\" && blurDataURL && !blurComplete ? {\n        backgroundSize: imgStyle.objectFit || \"cover\",\n        backgroundPosition: imgStyle.objectPosition || \"50% 50%\",\n        backgroundRepeat: \"no-repeat\",\n        backgroundImage: 'url(\"data:image/svg+xml;charset=utf-8,' + (0, _imageblursvg.getImageBlurSvg)({\n            widthInt: widthInt,\n            heightInt: heightInt,\n            blurWidth: blurWidth,\n            blurHeight: blurHeight,\n            blurDataURL: blurDataURL,\n            objectFit: imgStyle.objectFit\n        }) + '\")'\n    } : {};\n    if (true) {\n        if (blurStyle.backgroundImage && (blurDataURL == null ? void 0 : blurDataURL.startsWith(\"/\"))) {\n            // During `next dev`, we don't want to generate blur placeholders with webpack\n            // because it can delay starting the dev server. Instead, `next-image-loader.js`\n            // will inline a special url to lazily generate the blur placeholder at request time.\n            blurStyle.backgroundImage = 'url(\"' + blurDataURL + '\")';\n        }\n    }\n    var imgAttributes = generateImgAttrs({\n        config: config,\n        src: src,\n        unoptimized: unoptimized,\n        width: widthInt,\n        quality: qualityInt,\n        sizes: sizes,\n        loader: loader\n    });\n    var srcString = src;\n    if (true) {\n        if (true) {\n            var fullUrl;\n            try {\n                fullUrl = new URL(imgAttributes.src);\n            } catch (e) {\n                fullUrl = new URL(imgAttributes.src, window.location.href);\n            }\n            allImgs.set(fullUrl.href, {\n                src: src,\n                priority: priority,\n                placeholder: placeholder\n            });\n        }\n    }\n    var onLoadRef = (0, _react.useRef)(onLoad);\n    (0, _react.useEffect)(function() {\n        onLoadRef.current = onLoad;\n    }, [\n        onLoad\n    ]);\n    var onLoadingCompleteRef = (0, _react.useRef)(onLoadingComplete);\n    (0, _react.useEffect)(function() {\n        onLoadingCompleteRef.current = onLoadingComplete;\n    }, [\n        onLoadingComplete\n    ]);\n    var imgElementArgs = _object_spread._({\n        isLazy: isLazy,\n        imgAttributes: imgAttributes,\n        heightInt: heightInt,\n        widthInt: widthInt,\n        qualityInt: qualityInt,\n        className: className,\n        imgStyle: imgStyle,\n        blurStyle: blurStyle,\n        loading: loading,\n        config: config,\n        fetchPriority: fetchPriority,\n        fill: fill,\n        unoptimized: unoptimized,\n        placeholder: placeholder,\n        loader: loader,\n        srcString: srcString,\n        onLoadRef: onLoadRef,\n        onLoadingCompleteRef: onLoadingCompleteRef,\n        setBlurComplete: setBlurComplete,\n        setShowAltText: setShowAltText\n    }, rest);\n    return /*#__PURE__*/ _react[\"default\"].createElement(_react[\"default\"].Fragment, null, /*#__PURE__*/ _react[\"default\"].createElement(ImageElement, _object_spread_props._(_object_spread._({}, imgElementArgs), {\n        ref: forwardedRef\n    })), priority ? // for browsers that do not support `imagesrcset`, and in those cases\n    // it would likely cause the incorrect image to be preloaded.\n    //\n    // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n    /*#__PURE__*/ _react[\"default\"].createElement(_head[\"default\"], null, /*#__PURE__*/ _react[\"default\"].createElement(\"link\", _object_spread._({\n        key: \"__nimg-\" + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes,\n        rel: \"preload\",\n        as: \"image\",\n        href: imgAttributes.srcSet ? undefined : imgAttributes.src,\n        imageSrcSet: imgAttributes.srcSet,\n        imageSizes: imgAttributes.sizes,\n        crossOrigin: rest.crossOrigin,\n        referrerPolicy: rest.referrerPolicy\n    }, getDynamicProps(fetchPriority)))) : null);\n});\nvar _default = Image;\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=image.js.map\nvar _c;\n$RefreshReg$(_c, \"ImageElement\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbWFnZS5qcy5qcyIsIm1hcHBpbmdzIjoicURBQ2E7Ozs7Ozs7OztBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsMkNBQTBDO0lBQ3RDSSxZQUFZO0lBQ1pDLEtBQUssU0FBTEE7UUFDSSxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsSUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQyw0R0FBeUM7QUFDbEYsSUFBTUMsNEJBQTRCRCxtQkFBT0EsQ0FBQyw4R0FBMEM7QUFDcEYsSUFBTUUsU0FBUyxXQUFXLEdBQUdELDBCQUEwQkUsRUFBRUgsbUJBQU9BLENBQUMsNENBQU87QUFDeEUsSUFBTUksUUFBUSxXQUFXLEdBQUdMLHlCQUF5QkksRUFBRUgsbUJBQU9BLENBQUMsdUVBQW9CO0FBQ25GLElBQU1LLGdCQUFnQkwsbUJBQU9BLENBQUMsMkZBQThCO0FBQzVELElBQU1NLGVBQWVOLG1CQUFPQSxDQUFDLHVGQUE0QjtBQUN6RCxJQUFNTyxzQkFBc0JQLG1CQUFPQSxDQUFDLHVHQUFvQztBQUN4RSxJQUFNUSxZQUFZUixtQkFBT0EsQ0FBQyw2RkFBK0I7QUFDekQsSUFBTVMsZUFBZSxXQUFXLEdBQUdWLHlCQUF5QkksRUFBRUgsbUJBQU9BLENBQUMsOEZBQW1DO0FBRXpHLElBQU1VLFlBQVlDLDBOQUE2QkU7QUFDL0MsSUFBTUMsVUFBVSxJQUFJQztBQUNwQixJQUFJQztBQUNKLElBQUksS0FBNkIsRUFBRSxFQUVsQztBQUNELElBQU1HLHVCQUF1QjtJQUN6QjtJQUNBO0lBQ0FDO0NBQ0g7QUFDRCxTQUFTQyxnQkFBZ0JDLEdBQUc7SUFDeEIsT0FBT0EsR0FBSUMsQ0FBQUEsVUFBTyxLQUFLSDtBQUMzQjtBQUNBLFNBQVNJLGtCQUFrQkYsR0FBRztJQUMxQixPQUFPQSxJQUFJQSxRQUFRRjtBQUN2QjtBQUNBLFNBQVNLLGVBQWVILEdBQUc7SUFDdkIsT0FBTyxPQUFP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QUssSUFBSSxLQUFNLE9BQU83QixPQUFRNkIsQ0FBQUEsVUFBTyxDQUFDdU4sZUFBZSxhQUFhO0lBQ3JLdFAsT0FBT0MsZUFBZUMsT0FBUTZCLENBQUFBLFVBQU8sRUFBRSxjQUFjO1FBQUU1QixPQUFPO0lBQUs7SUFDbkVILE9BQU80TixPQUFPMU4sT0FBUTZCLENBQUFBLFVBQU8sRUFBRTdCO0lBQy9CcVAsT0FBT3JQLFVBQVVBLE9BQVE2QixDQUFBQSxVQUFPO0FBQ2xDLEVBRUEsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2ltYWdlLmpzPzgyZjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9kZWZhdWx0O1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdFwiKTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZFwiKTtcbmNvbnN0IF9yZWFjdCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5fKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBfaGVhZCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4uL3NoYXJlZC9saWIvaGVhZFwiKSk7XG5jb25zdCBfaW1hZ2VibHVyc3ZnID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvaW1hZ2UtYmx1ci1zdmdcIik7XG5jb25zdCBfaW1hZ2Vjb25maWcgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9pbWFnZS1jb25maWdcIik7XG5jb25zdCBfaW1hZ2Vjb25maWdjb250ZXh0ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnLWNvbnRleHRcIik7XG5jb25zdCBfd2Fybm9uY2UgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi91dGlscy93YXJuLW9uY2VcIik7XG5jb25zdCBfaW1hZ2Vsb2FkZXIgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCJuZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXJcIikpO1xuXG5jb25zdCBjb25maWdFbnYgPSBwcm9jZXNzLmVudi5fX05FWFRfSU1BR0VfT1BUUztcbmNvbnN0IGFsbEltZ3MgPSBuZXcgTWFwKCk7XG5sZXQgcGVyZk9ic2VydmVyO1xuaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBnbG9iYWxUaGlzLl9fTkVYVF9JTUFHRV9JTVBPUlRFRCA9IHRydWU7XG59XG5jb25zdCBWQUxJRF9MT0FESU5HX1ZBTFVFUyA9IFtcbiAgICBcImxhenlcIixcbiAgICBcImVhZ2VyXCIsXG4gICAgdW5kZWZpbmVkXG5dO1xuZnVuY3Rpb24gaXNTdGF0aWNSZXF1aXJlKHNyYykge1xuICAgIHJldHVybiBzcmMuZGVmYXVsdCAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNTdGF0aWNJbWFnZURhdGEoc3JjKSB7XG4gICAgcmV0dXJuIHNyYy5zcmMgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzU3RhdGljSW1wb3J0KHNyYykge1xuICAgIHJldHVybiB0eXBlb2Ygc3JjID09PSBcIm9iamVjdFwiICYmIChpc1N0YXRpY1JlcXVpcmUoc3JjKSB8fCBpc1N0YXRpY0ltYWdlRGF0YShzcmMpKTtcbn1cbmZ1bmN0aW9uIGdldFdpZHRocyhwYXJhbSwgd2lkdGgsIHNpemVzKSB7XG4gICAgbGV0IHsgZGV2aWNlU2l6ZXMgLCBhbGxTaXplcyAgfSA9IHBhcmFtO1xuICAgIGlmIChzaXplcykge1xuICAgICAgICAvLyBGaW5kIGFsbCB0aGUgXCJ2d1wiIHBlcmNlbnQgc2l6ZXMgdXNlZCBpbiB0aGUgc2l6ZXMgcHJvcFxuICAgICAgICBjb25zdCB2aWV3cG9ydFdpZHRoUmUgPSAvKF58XFxzKSgxP1xcZD9cXGQpdncvZztcbiAgICAgICAgY29uc3QgcGVyY2VudFNpemVzID0gW107XG4gICAgICAgIGZvcihsZXQgbWF0Y2g7IG1hdGNoID0gdmlld3BvcnRXaWR0aFJlLmV4ZWMoc2l6ZXMpOyBtYXRjaCl7XG4gICAgICAgICAgICBwZXJjZW50U2l6ZXMucHVzaChwYXJzZUludChtYXRjaFsyXSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwZXJjZW50U2l6ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBzbWFsbGVzdFJhdGlvID0gTWF0aC5taW4oLi4ucGVyY2VudFNpemVzKSAqIDAuMDE7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoczogYWxsU2l6ZXMuZmlsdGVyKChzKT0+cyA+PSBkZXZpY2VTaXplc1swXSAqIHNtYWxsZXN0UmF0aW8pLFxuICAgICAgICAgICAgICAgIGtpbmQ6IFwid1wiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aHM6IGFsbFNpemVzLFxuICAgICAgICAgICAga2luZDogXCJ3XCJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGhzOiBkZXZpY2VTaXplcyxcbiAgICAgICAgICAgIGtpbmQ6IFwid1wiXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHdpZHRocyA9IFtcbiAgICAgICAgLi4ubmV3IFNldCgvLyA+IFRoaXMgbWVhbnMgdGhhdCBtb3N0IE9MRUQgc2NyZWVucyB0aGF0IHNheSB0aGV5IGFyZSAzeCByZXNvbHV0aW9uLFxuICAgICAgICAvLyA+IGFyZSBhY3R1YWxseSAzeCBpbiB0aGUgZ3JlZW4gY29sb3IsIGJ1dCBvbmx5IDEuNXggaW4gdGhlIHJlZCBhbmRcbiAgICAgICAgLy8gPiBibHVlIGNvbG9ycy4gU2hvd2luZyBhIDN4IHJlc29sdXRpb24gaW1hZ2UgaW4gdGhlIGFwcCB2cyBhIDJ4XG4gICAgICAgIC8vID4gcmVzb2x1dGlvbiBpbWFnZSB3aWxsIGJlIHZpc3VhbGx5IHRoZSBzYW1lLCB0aG91Z2ggdGhlIDN4IGltYWdlXG4gICAgICAgIC8vID4gdGFrZXMgc2lnbmlmaWNhbnRseSBtb3JlIGRhdGEuIEV2ZW4gdHJ1ZSAzeCByZXNvbHV0aW9uIHNjcmVlbnMgYXJlXG4gICAgICAgIC8vID4gd2FzdGVmdWwgYXMgdGhlIGh1bWFuIGV5ZSBjYW5ub3Qgc2VlIHRoYXQgbGV2ZWwgb2YgZGV0YWlsIHdpdGhvdXRcbiAgICAgICAgLy8gPiBzb21ldGhpbmcgbGlrZSBhIG1hZ25pZnlpbmcgZ2xhc3MuXG4gICAgICAgIC8vIGh0dHBzOi8vYmxvZy50d2l0dGVyLmNvbS9lbmdpbmVlcmluZy9lbl91cy90b3BpY3MvaW5mcmFzdHJ1Y3R1cmUvMjAxOS9jYXBwaW5nLWltYWdlLWZpZGVsaXR5LW9uLXVsdHJhLWhpZ2gtcmVzb2x1dGlvbi1kZXZpY2VzLmh0bWxcbiAgICAgICAgW1xuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICB3aWR0aCAqIDIgLyosIHdpZHRoICogMyovIFxuICAgICAgICBdLm1hcCgodyk9PmFsbFNpemVzLmZpbmQoKHApPT5wID49IHcpIHx8IGFsbFNpemVzW2FsbFNpemVzLmxlbmd0aCAtIDFdKSlcbiAgICBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRocyxcbiAgICAgICAga2luZDogXCJ4XCJcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVJbWdBdHRycyhwYXJhbSkge1xuICAgIGxldCB7IGNvbmZpZyAsIHNyYyAsIHVub3B0aW1pemVkICwgd2lkdGggLCBxdWFsaXR5ICwgc2l6ZXMgLCBsb2FkZXIgIH0gPSBwYXJhbTtcbiAgICBpZiAodW5vcHRpbWl6ZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgIHNyY1NldDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2l6ZXM6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB7IHdpZHRocyAsIGtpbmQgIH0gPSBnZXRXaWR0aHMoY29uZmlnLCB3aWR0aCwgc2l6ZXMpO1xuICAgIGNvbnN0IGxhc3QgPSB3aWR0aHMubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzaXplczogIXNpemVzICYmIGtpbmQgPT09IFwid1wiID8gXCIxMDB2d1wiIDogc2l6ZXMsXG4gICAgICAgIHNyY1NldDogd2lkdGhzLm1hcCgodywgaSk9PmxvYWRlcih7XG4gICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgICBxdWFsaXR5LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3XG4gICAgICAgICAgICB9KSArIFwiIFwiICsgKGtpbmQgPT09IFwid1wiID8gdyA6IGkgKyAxKSArIGtpbmQpLmpvaW4oXCIsIFwiKSxcbiAgICAgICAgLy8gSXQncyBpbnRlbmRlZCB0byBrZWVwIGBzcmNgIHRoZSBsYXN0IGF0dHJpYnV0ZSBiZWNhdXNlIFJlYWN0IHVwZGF0ZXNcbiAgICAgICAgLy8gYXR0cmlidXRlcyBpbiBvcmRlci4gSWYgd2Uga2VlcCBgc3JjYCB0aGUgZmlyc3Qgb25lLCBTYWZhcmkgd2lsbFxuICAgICAgICAvLyBpbW1lZGlhdGVseSBzdGFydCB0byBmZXRjaCBgc3JjYCwgYmVmb3JlIGBzaXplc2AgYW5kIGBzcmNTZXRgIGFyZSBldmVuXG4gICAgICAgIC8vIHVwZGF0ZWQgYnkgUmVhY3QuIFRoYXQgY2F1c2VzIG11bHRpcGxlIHVubmVjZXNzYXJ5IHJlcXVlc3RzIGlmIGBzcmNTZXRgXG4gICAgICAgIC8vIGFuZCBgc2l6ZXNgIGFyZSBkZWZpbmVkLlxuICAgICAgICAvLyBUaGlzIGJ1ZyBjYW5ub3QgYmUgcmVwcm9kdWNlZCBpbiBDaHJvbWUgb3IgRmlyZWZveC5cbiAgICAgICAgc3JjOiBsb2FkZXIoe1xuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgcXVhbGl0eSxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aHNbbGFzdF1cbiAgICAgICAgfSlcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0SW50KHgpIHtcbiAgICBpZiAodHlwZW9mIHggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKHgpID8geCA6IE5hTjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB4ID09PSBcInN0cmluZ1wiICYmIC9eWzAtOV0rJC8udGVzdCh4KSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoeCwgMTApO1xuICAgIH1cbiAgICByZXR1cm4gTmFOO1xufVxuLy8gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8zOTc3NzgzMy8yNjY1MzUgZm9yIHdoeSB3ZSB1c2UgdGhpcyByZWZcbi8vIGhhbmRsZXIgaW5zdGVhZCBvZiB0aGUgaW1nJ3Mgb25Mb2FkIGF0dHJpYnV0ZS5cbmZ1bmN0aW9uIGhhbmRsZUxvYWRpbmcoaW1nLCBzcmMsIHBsYWNlaG9sZGVyLCBvbkxvYWRSZWYsIG9uTG9hZGluZ0NvbXBsZXRlUmVmLCBzZXRCbHVyQ29tcGxldGUsIHVub3B0aW1pemVkKSB7XG4gICAgaWYgKCFpbWcgfHwgaW1nW1wiZGF0YS1sb2FkZWQtc3JjXCJdID09PSBzcmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbWdbXCJkYXRhLWxvYWRlZC1zcmNcIl0gPSBzcmM7XG4gICAgY29uc3QgcCA9IFwiZGVjb2RlXCIgaW4gaW1nID8gaW1nLmRlY29kZSgpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgcC5jYXRjaCgoKT0+e30pLnRoZW4oKCk9PntcbiAgICAgICAgaWYgKCFpbWcucGFyZW50RWxlbWVudCB8fCAhaW1nLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICAvLyBFeGl0IGVhcmx5IGluIGNhc2Ugb2YgcmFjZSBjb25kaXRpb246XG4gICAgICAgICAgICAvLyAtIG9ubG9hZCgpIGlzIGNhbGxlZFxuICAgICAgICAgICAgLy8gLSBkZWNvZGUoKSBpcyBjYWxsZWQgYnV0IGluY29tcGxldGVcbiAgICAgICAgICAgIC8vIC0gdW5tb3VudCBpcyBjYWxsZWRcbiAgICAgICAgICAgIC8vIC0gZGVjb2RlKCkgY29tcGxldGVzXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyID09PSBcImJsdXJcIikge1xuICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkxvYWRSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IG9uTG9hZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCBoYXZlIHRoZSBTeW50aGV0aWNFdmVudCBoZXJlLFxuICAgICAgICAgICAgLy8gd2UgbXVzdCBjcmVhdGUgb25lIHdpdGggdGhlIHNhbWUgc2hhcGUuXG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2V2ZW50cy5odG1sXG4gICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudChcImxvYWRcIik7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXZlbnQsIFwidGFyZ2V0XCIsIHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGltZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgcHJldmVudGVkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgb25Mb2FkUmVmLmN1cnJlbnQoe1xuICAgICAgICAgICAgICAgIC4uLmV2ZW50LFxuICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiBpbWcsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBpbWcsXG4gICAgICAgICAgICAgICAgaXNEZWZhdWx0UHJldmVudGVkOiAoKT0+cHJldmVudGVkLFxuICAgICAgICAgICAgICAgIGlzUHJvcGFnYXRpb25TdG9wcGVkOiAoKT0+c3RvcHBlZCxcbiAgICAgICAgICAgICAgICBwZXJzaXN0OiAoKT0+e30sXG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6ICgpPT57XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246ICgpPT57XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Mb2FkaW5nQ29tcGxldGVSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IG9uTG9hZGluZ0NvbXBsZXRlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmLmN1cnJlbnQoaW1nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAoaW1nLmdldEF0dHJpYnV0ZShcImRhdGEtbmltZ1wiKSA9PT0gXCJmaWxsXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXVub3B0aW1pemVkICYmICghaW1nLmdldEF0dHJpYnV0ZShcInNpemVzXCIpIHx8IGltZy5nZXRBdHRyaWJ1dGUoXCJzaXplc1wiKSA9PT0gXCIxMDB2d1wiKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgd2lkdGhWaWV3cG9ydFJhdGlvID0gaW1nLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC8gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aWR0aFZpZXdwb3J0UmF0aW8gPCAwLjYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaGFzIFwiZmlsbFwiIGJ1dCBpcyBtaXNzaW5nIFwic2l6ZXNcIiBwcm9wLiBQbGVhc2UgYWRkIGl0IHRvIGltcHJvdmUgcGFnZSBwZXJmb3JtYW5jZS4gUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvaW1hZ2Ujc2l6ZXMnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW1nLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBwb3NpdGlvbiAgfSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGltZy5wYXJlbnRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcImFic29sdXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImZpeGVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInJlbGF0aXZlXCJcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWxpZC5pbmNsdWRlcyhwb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaGFzIFwiZmlsbFwiIGFuZCBwYXJlbnQgZWxlbWVudCB3aXRoIGludmFsaWQgXCJwb3NpdGlvblwiLiBQcm92aWRlZCBcIicgKyBwb3NpdGlvbiArICdcIiBzaG91bGQgYmUgb25lIG9mICcgKyB2YWxpZC5tYXAoU3RyaW5nKS5qb2luKFwiLFwiKSArIFwiLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW1nLmhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgX3dhcm5vbmNlLndhcm5PbmNlKSgnSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBcImZpbGxcIiBhbmQgYSBoZWlnaHQgdmFsdWUgb2YgMC4gVGhpcyBpcyBsaWtlbHkgYmVjYXVzZSB0aGUgcGFyZW50IGVsZW1lbnQgb2YgdGhlIGltYWdlIGhhcyBub3QgYmVlbiBzdHlsZWQgdG8gaGF2ZSBhIHNldCBoZWlnaHQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVpZ2h0TW9kaWZpZWQgPSBpbWcuaGVpZ2h0LnRvU3RyaW5nKCkgIT09IGltZy5nZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIik7XG4gICAgICAgICAgICBjb25zdCB3aWR0aE1vZGlmaWVkID0gaW1nLndpZHRoLnRvU3RyaW5nKCkgIT09IGltZy5nZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiKTtcbiAgICAgICAgICAgIGlmIChoZWlnaHRNb2RpZmllZCAmJiAhd2lkdGhNb2RpZmllZCB8fCAhaGVpZ2h0TW9kaWZpZWQgJiYgd2lkdGhNb2RpZmllZCkge1xuICAgICAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaGFzIGVpdGhlciB3aWR0aCBvciBoZWlnaHQgbW9kaWZpZWQsIGJ1dCBub3QgdGhlIG90aGVyLiBJZiB5b3UgdXNlIENTUyB0byBjaGFuZ2UgdGhlIHNpemUgb2YgeW91ciBpbWFnZSwgYWxzbyBpbmNsdWRlIHRoZSBzdHlsZXMgXFwnd2lkdGg6IFwiYXV0b1wiXFwnIG9yIFxcJ2hlaWdodDogXCJhdXRvXCJcXCcgdG8gbWFpbnRhaW4gdGhlIGFzcGVjdCByYXRpby4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0RHluYW1pY1Byb3BzKGZldGNoUHJpb3JpdHkpIHtcbiAgICBjb25zdCBbbWFqb3JTdHIsIG1pbm9yU3RyXSA9IF9yZWFjdC52ZXJzaW9uLnNwbGl0KFwiLlwiKTtcbiAgICBjb25zdCBtYWpvciA9IHBhcnNlSW50KG1ham9yU3RyLCAxMCk7XG4gICAgY29uc3QgbWlub3IgPSBwYXJzZUludChtaW5vclN0ciwgMTApO1xuICAgIGlmIChtYWpvciA+IDE4IHx8IG1ham9yID09PSAxOCAmJiBtaW5vciA+PSAzKSB7XG4gICAgICAgIC8vIEluIFJlYWN0IDE4LjMuMCBvciBuZXdlciwgd2UgbXVzdCB1c2UgY2FtZWxDYXNlXG4gICAgICAgIC8vIHByb3AgdG8gYXZvaWQgXCJXYXJuaW5nOiBJbnZhbGlkIERPTSBwcm9wZXJ0eVwiLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjU5MjdcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZldGNoUHJpb3JpdHlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gSW4gUmVhY3QgMTguMi4wIG9yIG9sZGVyLCB3ZSBtdXN0IHVzZSBsb3dlcmNhc2UgcHJvcFxuICAgIC8vIHRvIGF2b2lkIFwiV2FybmluZzogSW52YWxpZCBET00gcHJvcGVydHlcIi5cbiAgICByZXR1cm4ge1xuICAgICAgICBmZXRjaHByaW9yaXR5OiBmZXRjaFByaW9yaXR5XG4gICAgfTtcbn1cbmNvbnN0IEltYWdlRWxlbWVudCA9IC8qI19fUFVSRV9fKi8gKDAsIF9yZWFjdC5mb3J3YXJkUmVmKSgocGFyYW0sIGZvcndhcmRlZFJlZik9PntcbiAgICBsZXQgeyBpbWdBdHRyaWJ1dGVzICwgaGVpZ2h0SW50ICwgd2lkdGhJbnQgLCBxdWFsaXR5SW50ICwgY2xhc3NOYW1lICwgaW1nU3R5bGUgLCBibHVyU3R5bGUgLCBpc0xhenkgLCBmZXRjaFByaW9yaXR5ICwgZmlsbCAsIHBsYWNlaG9sZGVyICwgbG9hZGluZyAsIHNyY1N0cmluZyAsIGNvbmZpZyAsIHVub3B0aW1pemVkICwgbG9hZGVyICwgb25Mb2FkUmVmICwgb25Mb2FkaW5nQ29tcGxldGVSZWYgLCBzZXRCbHVyQ29tcGxldGUgLCBzZXRTaG93QWx0VGV4dCAsIG9uTG9hZCAsIG9uRXJyb3IgLCAuLi5yZXN0IH0gPSBwYXJhbTtcbiAgICBsb2FkaW5nID0gaXNMYXp5ID8gXCJsYXp5XCIgOiBsb2FkaW5nO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIiwge1xuICAgICAgICAuLi5yZXN0LFxuICAgICAgICAuLi5nZXREeW5hbWljUHJvcHMoZmV0Y2hQcmlvcml0eSksXG4gICAgICAgIGxvYWRpbmc6IGxvYWRpbmcsXG4gICAgICAgIHdpZHRoOiB3aWR0aEludCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRJbnQsXG4gICAgICAgIGRlY29kaW5nOiBcImFzeW5jXCIsXG4gICAgICAgIFwiZGF0YS1uaW1nXCI6IGZpbGwgPyBcImZpbGxcIiA6IFwiMVwiLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIC4uLmltZ1N0eWxlLFxuICAgICAgICAgICAgLi4uYmx1clN0eWxlXG4gICAgICAgIH0sXG4gICAgICAgIC4uLmltZ0F0dHJpYnV0ZXMsXG4gICAgICAgIHJlZjogKDAsIF9yZWFjdC51c2VDYWxsYmFjaykoKGltZyk9PntcbiAgICAgICAgICAgIGlmIChmb3J3YXJkZWRSZWYpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZvcndhcmRlZFJlZiA9PT0gXCJmdW5jdGlvblwiKSBmb3J3YXJkZWRSZWYoaW1nKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZm9yd2FyZGVkUmVmID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSAuY3VycmVudCBpcyByZWFkIG9ubHkgaXQncyB1c3VhbGx5IGFzc2lnbmVkIGJ5IHJlYWN0IGludGVybmFsbHlcbiAgICAgICAgICAgICAgICAgICAgZm9yd2FyZGVkUmVmLmN1cnJlbnQgPSBpbWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpbWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBpbWFnZSBoYXMgYW4gZXJyb3IgYmVmb3JlIHJlYWN0IGh5ZHJhdGVzLCB0aGVuIHRoZSBlcnJvciBpcyBsb3N0LlxuICAgICAgICAgICAgICAgIC8vIFRoZSB3b3JrYXJvdW5kIGlzIHRvIHdhaXQgdW50aWwgdGhlIGltYWdlIGlzIG1vdW50ZWQgd2hpY2ggaXMgYWZ0ZXIgaHlkcmF0aW9uLFxuICAgICAgICAgICAgICAgIC8vIHRoZW4gd2Ugc2V0IHRoZSBzcmMgYWdhaW4gdG8gdHJpZ2dlciB0aGUgZXJyb3IgaGFuZGxlciAoaWYgdGhlcmUgd2FzIGFuIGVycm9yKS5cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICAgICAgICAgICAgICBpbWcuc3JjID0gaW1nLnNyYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNyY1N0cmluZykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbWFnZSBpcyBtaXNzaW5nIHJlcXVpcmVkIFwic3JjXCIgcHJvcGVydHk6JywgaW1nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGltZy5nZXRBdHRyaWJ1dGUoXCJhbHRcIikgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignSW1hZ2UgaXMgbWlzc2luZyByZXF1aXJlZCBcImFsdFwiIHByb3BlcnR5LiBQbGVhc2UgYWRkIEFsdGVybmF0aXZlIFRleHQgdG8gZGVzY3JpYmUgdGhlIGltYWdlIGZvciBzY3JlZW4gcmVhZGVycyBhbmQgc2VhcmNoIGVuZ2luZXMuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGltZy5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUxvYWRpbmcoaW1nLCBzcmNTdHJpbmcsIHBsYWNlaG9sZGVyLCBvbkxvYWRSZWYsIG9uTG9hZGluZ0NvbXBsZXRlUmVmLCBzZXRCbHVyQ29tcGxldGUsIHVub3B0aW1pemVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW1xuICAgICAgICAgICAgc3JjU3RyaW5nLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICAgICAgICBvbkxvYWRSZWYsXG4gICAgICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZixcbiAgICAgICAgICAgIHNldEJsdXJDb21wbGV0ZSxcbiAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICB1bm9wdGltaXplZCxcbiAgICAgICAgICAgIGZvcndhcmRlZFJlZlxuICAgICAgICBdKSxcbiAgICAgICAgb25Mb2FkOiAoZXZlbnQpPT57XG4gICAgICAgICAgICBjb25zdCBpbWcgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgaGFuZGxlTG9hZGluZyhpbWcsIHNyY1N0cmluZywgcGxhY2Vob2xkZXIsIG9uTG9hZFJlZiwgb25Mb2FkaW5nQ29tcGxldGVSZWYsIHNldEJsdXJDb21wbGV0ZSwgdW5vcHRpbWl6ZWQpO1xuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yOiAoZXZlbnQpPT57XG4gICAgICAgICAgICAvLyBpZiB0aGUgcmVhbCBpbWFnZSBmYWlscyB0byBsb2FkLCB0aGlzIHdpbGwgZW5zdXJlIFwiYWx0XCIgaXMgdmlzaWJsZVxuICAgICAgICAgICAgc2V0U2hvd0FsdFRleHQodHJ1ZSk7XG4gICAgICAgICAgICBpZiAocGxhY2Vob2xkZXIgPT09IFwiYmx1clwiKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlYWwgaW1hZ2UgZmFpbHMgdG8gbG9hZCwgdGhpcyB3aWxsIHN0aWxsIHJlbW92ZSB0aGUgcGxhY2Vob2xkZXIuXG4gICAgICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG5jb25zdCBJbWFnZSA9IC8qI19fUFVSRV9fKi8gKDAsIF9yZWFjdC5mb3J3YXJkUmVmKSgocGFyYW0sIGZvcndhcmRlZFJlZik9PntcbiAgICBsZXQgeyBzcmMgLCBzaXplcyAsIHVub3B0aW1pemVkID1mYWxzZSAsIHByaW9yaXR5ID1mYWxzZSAsIGxvYWRpbmcgLCBjbGFzc05hbWUgLCBxdWFsaXR5ICwgd2lkdGggLCBoZWlnaHQgLCBmaWxsICwgc3R5bGUgLCBvbkxvYWQgLCBvbkxvYWRpbmdDb21wbGV0ZSAsIHBsYWNlaG9sZGVyID1cImVtcHR5XCIgLCBibHVyRGF0YVVSTCAsIGZldGNoUHJpb3JpdHkgLCBsYXlvdXQgLCBvYmplY3RGaXQgLCBvYmplY3RQb3NpdGlvbiAsIGxhenlCb3VuZGFyeSAsIGxhenlSb290ICwgLi4uYWxsIH0gPSBwYXJhbTtcbiAgICBjb25zdCBjb25maWdDb250ZXh0ID0gKDAsIF9yZWFjdC51c2VDb250ZXh0KShfaW1hZ2Vjb25maWdjb250ZXh0LkltYWdlQ29uZmlnQ29udGV4dCk7XG4gICAgY29uc3QgY29uZmlnID0gKDAsIF9yZWFjdC51c2VNZW1vKSgoKT0+e1xuICAgICAgICBjb25zdCBjID0gY29uZmlnRW52IHx8IGNvbmZpZ0NvbnRleHQgfHwgX2ltYWdlY29uZmlnLmltYWdlQ29uZmlnRGVmYXVsdDtcbiAgICAgICAgY29uc3QgYWxsU2l6ZXMgPSBbXG4gICAgICAgICAgICAuLi5jLmRldmljZVNpemVzLFxuICAgICAgICAgICAgLi4uYy5pbWFnZVNpemVzXG4gICAgICAgIF0uc29ydCgoYSwgYik9PmEgLSBiKTtcbiAgICAgICAgY29uc3QgZGV2aWNlU2l6ZXMgPSBjLmRldmljZVNpemVzLnNvcnQoKGEsIGIpPT5hIC0gYik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jLFxuICAgICAgICAgICAgYWxsU2l6ZXMsXG4gICAgICAgICAgICBkZXZpY2VTaXplc1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgY29uZmlnQ29udGV4dFxuICAgIF0pO1xuICAgIGxldCByZXN0ID0gYWxsO1xuICAgIGxldCBsb2FkZXIgPSByZXN0LmxvYWRlciB8fCBfaW1hZ2Vsb2FkZXIuZGVmYXVsdDtcbiAgICAvLyBSZW1vdmUgcHJvcGVydHkgc28gaXQncyBub3Qgc3ByZWFkIG9uIDxpbWc+IGVsZW1lbnRcbiAgICBkZWxldGUgcmVzdC5sb2FkZXI7XG4gICAgLy8gVGhpcyBzcGVjaWFsIHZhbHVlIGluZGljYXRlcyB0aGF0IHRoZSB1c2VyXG4gICAgLy8gZGlkbid0IGRlZmluZSBhIFwibG9hZGVyXCIgcHJvcCBvciBcImxvYWRlclwiIGNvbmZpZy5cbiAgICBjb25zdCBpc0RlZmF1bHRMb2FkZXIgPSBcIl9fbmV4dF9pbWdfZGVmYXVsdFwiIGluIGxvYWRlcjtcbiAgICBpZiAoaXNEZWZhdWx0TG9hZGVyKSB7XG4gICAgICAgIGlmIChjb25maWcubG9hZGVyID09PSBcImN1c3RvbVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBpcyBtaXNzaW5nIFwibG9hZGVyXCIgcHJvcC4nICsgXCJcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtaW1hZ2UtbWlzc2luZy1sb2FkZXJcIik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgdXNlciBkZWZpbmVkIGEgXCJsb2FkZXJcIiBwcm9wIG9yIGNvbmZpZy5cbiAgICAgICAgLy8gU2luY2UgdGhlIGNvbmZpZyBvYmplY3QgaXMgaW50ZXJuYWwgb25seSwgd2VcbiAgICAgICAgLy8gbXVzdCBub3QgcGFzcyBpdCB0byB0aGUgdXNlci1kZWZpbmVkIFwibG9hZGVyXCIuXG4gICAgICAgIGNvbnN0IGN1c3RvbUltYWdlTG9hZGVyID0gbG9hZGVyO1xuICAgICAgICBsb2FkZXIgPSAob2JqKT0+e1xuICAgICAgICAgICAgY29uc3QgeyBjb25maWc6IF8gLCAuLi5vcHRzIH0gPSBvYmo7XG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tSW1hZ2VMb2FkZXIob3B0cyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChsYXlvdXQpIHtcbiAgICAgICAgaWYgKGxheW91dCA9PT0gXCJmaWxsXCIpIHtcbiAgICAgICAgICAgIGZpbGwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxheW91dFRvU3R5bGUgPSB7XG4gICAgICAgICAgICBpbnRyaW5zaWM6IHtcbiAgICAgICAgICAgICAgICBtYXhXaWR0aDogXCIxMDAlXCIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBcImF1dG9cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc3BvbnNpdmU6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBcImF1dG9cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBsYXlvdXRUb1NpemVzID0ge1xuICAgICAgICAgICAgcmVzcG9uc2l2ZTogXCIxMDB2d1wiLFxuICAgICAgICAgICAgZmlsbDogXCIxMDB2d1wiXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGxheW91dFN0eWxlID0gbGF5b3V0VG9TdHlsZVtsYXlvdXRdO1xuICAgICAgICBpZiAobGF5b3V0U3R5bGUpIHtcbiAgICAgICAgICAgIHN0eWxlID0ge1xuICAgICAgICAgICAgICAgIC4uLnN0eWxlLFxuICAgICAgICAgICAgICAgIC4uLmxheW91dFN0eWxlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxheW91dFNpemVzID0gbGF5b3V0VG9TaXplc1tsYXlvdXRdO1xuICAgICAgICBpZiAobGF5b3V0U2l6ZXMgJiYgIXNpemVzKSB7XG4gICAgICAgICAgICBzaXplcyA9IGxheW91dFNpemVzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBzdGF0aWNTcmMgPSBcIlwiO1xuICAgIGxldCB3aWR0aEludCA9IGdldEludCh3aWR0aCk7XG4gICAgbGV0IGhlaWdodEludCA9IGdldEludChoZWlnaHQpO1xuICAgIGxldCBibHVyV2lkdGg7XG4gICAgbGV0IGJsdXJIZWlnaHQ7XG4gICAgaWYgKGlzU3RhdGljSW1wb3J0KHNyYykpIHtcbiAgICAgICAgY29uc3Qgc3RhdGljSW1hZ2VEYXRhID0gaXNTdGF0aWNSZXF1aXJlKHNyYykgPyBzcmMuZGVmYXVsdCA6IHNyYztcbiAgICAgICAgaWYgKCFzdGF0aWNJbWFnZURhdGEuc3JjKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbiBvYmplY3Qgc2hvdWxkIG9ubHkgYmUgcGFzc2VkIHRvIHRoZSBpbWFnZSBjb21wb25lbnQgc3JjIHBhcmFtZXRlciBpZiBpdCBjb21lcyBmcm9tIGEgc3RhdGljIGltYWdlIGltcG9ydC4gSXQgbXVzdCBpbmNsdWRlIHNyYy4gUmVjZWl2ZWQgXCIgKyBKU09OLnN0cmluZ2lmeShzdGF0aWNJbWFnZURhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0YXRpY0ltYWdlRGF0YS5oZWlnaHQgfHwgIXN0YXRpY0ltYWdlRGF0YS53aWR0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW4gb2JqZWN0IHNob3VsZCBvbmx5IGJlIHBhc3NlZCB0byB0aGUgaW1hZ2UgY29tcG9uZW50IHNyYyBwYXJhbWV0ZXIgaWYgaXQgY29tZXMgZnJvbSBhIHN0YXRpYyBpbWFnZSBpbXBvcnQuIEl0IG11c3QgaW5jbHVkZSBoZWlnaHQgYW5kIHdpZHRoLiBSZWNlaXZlZCBcIiArIEpTT04uc3RyaW5naWZ5KHN0YXRpY0ltYWdlRGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGJsdXJXaWR0aCA9IHN0YXRpY0ltYWdlRGF0YS5ibHVyV2lkdGg7XG4gICAgICAgIGJsdXJIZWlnaHQgPSBzdGF0aWNJbWFnZURhdGEuYmx1ckhlaWdodDtcbiAgICAgICAgYmx1ckRhdGFVUkwgPSBibHVyRGF0YVVSTCB8fCBzdGF0aWNJbWFnZURhdGEuYmx1ckRhdGFVUkw7XG4gICAgICAgIHN0YXRpY1NyYyA9IHN0YXRpY0ltYWdlRGF0YS5zcmM7XG4gICAgICAgIGlmICghZmlsbCkge1xuICAgICAgICAgICAgaWYgKCF3aWR0aEludCAmJiAhaGVpZ2h0SW50KSB7XG4gICAgICAgICAgICAgICAgd2lkdGhJbnQgPSBzdGF0aWNJbWFnZURhdGEud2lkdGg7XG4gICAgICAgICAgICAgICAgaGVpZ2h0SW50ID0gc3RhdGljSW1hZ2VEYXRhLmhlaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod2lkdGhJbnQgJiYgIWhlaWdodEludCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhdGlvID0gd2lkdGhJbnQgLyBzdGF0aWNJbWFnZURhdGEud2lkdGg7XG4gICAgICAgICAgICAgICAgaGVpZ2h0SW50ID0gTWF0aC5yb3VuZChzdGF0aWNJbWFnZURhdGEuaGVpZ2h0ICogcmF0aW8pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghd2lkdGhJbnQgJiYgaGVpZ2h0SW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF0aW8gPSBoZWlnaHRJbnQgLyBzdGF0aWNJbWFnZURhdGEuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHdpZHRoSW50ID0gTWF0aC5yb3VuZChzdGF0aWNJbWFnZURhdGEud2lkdGggKiByYXRpbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3JjID0gdHlwZW9mIHNyYyA9PT0gXCJzdHJpbmdcIiA/IHNyYyA6IHN0YXRpY1NyYztcbiAgICBsZXQgaXNMYXp5ID0gIXByaW9yaXR5ICYmIChsb2FkaW5nID09PSBcImxhenlcIiB8fCB0eXBlb2YgbG9hZGluZyA9PT0gXCJ1bmRlZmluZWRcIik7XG4gICAgaWYgKCFzcmMgfHwgc3JjLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSB8fCBzcmMuc3RhcnRzV2l0aChcImJsb2I6XCIpKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvQmFzaWNzX29mX0hUVFAvRGF0YV9VUklzXG4gICAgICAgIHVub3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgaXNMYXp5ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChjb25maWcudW5vcHRpbWl6ZWQpIHtcbiAgICAgICAgdW5vcHRpbWl6ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNEZWZhdWx0TG9hZGVyICYmIHNyYy5lbmRzV2l0aChcIi5zdmdcIikgJiYgIWNvbmZpZy5kYW5nZXJvdXNseUFsbG93U1ZHKSB7XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZSB0byBtYWtlIHN2ZyBzZXJ2ZSBhcy1pcyB0byBhdm9pZCBwcm94eWluZ1xuICAgICAgICAvLyB0aHJvdWdoIHRoZSBidWlsdC1pbiBJbWFnZSBPcHRpbWl6YXRpb24gQVBJLlxuICAgICAgICB1bm9wdGltaXplZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChwcmlvcml0eSkge1xuICAgICAgICBmZXRjaFByaW9yaXR5ID0gXCJoaWdoXCI7XG4gICAgfVxuICAgIGNvbnN0IFtibHVyQ29tcGxldGUsIHNldEJsdXJDb21wbGV0ZV0gPSAoMCwgX3JlYWN0LnVzZVN0YXRlKShmYWxzZSk7XG4gICAgY29uc3QgW3Nob3dBbHRUZXh0LCBzZXRTaG93QWx0VGV4dF0gPSAoMCwgX3JlYWN0LnVzZVN0YXRlKShmYWxzZSk7XG4gICAgY29uc3QgcXVhbGl0eUludCA9IGdldEludChxdWFsaXR5KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGlmIChjb25maWcub3V0cHV0ID09PSBcImV4cG9ydFwiICYmIGlzRGVmYXVsdExvYWRlciAmJiAhdW5vcHRpbWl6ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkltYWdlIE9wdGltaXphdGlvbiB1c2luZyB0aGUgZGVmYXVsdCBsb2FkZXIgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBgeyBvdXRwdXQ6ICdleHBvcnQnIH1gLlxcbiAgUG9zc2libGUgc29sdXRpb25zOlxcbiAgICAtIFJlbW92ZSBgeyBvdXRwdXQ6ICdleHBvcnQnIH1gIGFuZCBydW4gXFxcIm5leHQgc3RhcnRcXFwiIHRvIHJ1biBzZXJ2ZXIgbW9kZSBpbmNsdWRpbmcgdGhlIEltYWdlIE9wdGltaXphdGlvbiBBUEkuXFxuICAgIC0gQ29uZmlndXJlIGB7IGltYWdlczogeyB1bm9wdGltaXplZDogdHJ1ZSB9IH1gIGluIGBuZXh0LmNvbmZpZy5qc2AgdG8gZGlzYWJsZSB0aGUgSW1hZ2UgT3B0aW1pemF0aW9uIEFQSS5cXG4gIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZXhwb3J0LWltYWdlLWFwaVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNyYykge1xuICAgICAgICAgICAgLy8gUmVhY3QgZG9lc24ndCBzaG93IHRoZSBzdGFjayB0cmFjZSBhbmQgdGhlcmUnc1xuICAgICAgICAgICAgLy8gbm8gYHNyY2AgdG8gaGVscCBpZGVudGlmeSB3aGljaCBpbWFnZSwgc28gd2VcbiAgICAgICAgICAgIC8vIGluc3RlYWQgY29uc29sZS5lcnJvcihyZWYpIGR1cmluZyBtb3VudC5cbiAgICAgICAgICAgIHVub3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBib3RoIFwid2lkdGhcIiBhbmQgXCJmaWxsXCIgcHJvcGVydGllcy4gT25seSBvbmUgc2hvdWxkIGJlIHVzZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaGFzIGJvdGggXCJoZWlnaHRcIiBhbmQgXCJmaWxsXCIgcHJvcGVydGllcy4gT25seSBvbmUgc2hvdWxkIGJlIHVzZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoc3R5bGUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0eWxlLnBvc2l0aW9uKSAmJiBzdHlsZS5wb3NpdGlvbiAhPT0gXCJhYnNvbHV0ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBib3RoIFwiZmlsbFwiIGFuZCBcInN0eWxlLnBvc2l0aW9uXCIgcHJvcGVydGllcy4gSW1hZ2VzIHdpdGggXCJmaWxsXCIgYWx3YXlzIHVzZSBwb3NpdGlvbiBhYnNvbHV0ZSAtIGl0IGNhbm5vdCBiZSBtb2RpZmllZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChzdHlsZSA9PSBudWxsID8gdm9pZCAwIDogc3R5bGUud2lkdGgpICYmIHN0eWxlLndpZHRoICE9PSBcIjEwMCVcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBoYXMgYm90aCBcImZpbGxcIiBhbmQgXCJzdHlsZS53aWR0aFwiIHByb3BlcnRpZXMuIEltYWdlcyB3aXRoIFwiZmlsbFwiIGFsd2F5cyB1c2Ugd2lkdGggMTAwJSAtIGl0IGNhbm5vdCBiZSBtb2RpZmllZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChzdHlsZSA9PSBudWxsID8gdm9pZCAwIDogc3R5bGUuaGVpZ2h0KSAmJiBzdHlsZS5oZWlnaHQgIT09IFwiMTAwJVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBib3RoIFwiZmlsbFwiIGFuZCBcInN0eWxlLmhlaWdodFwiIHByb3BlcnRpZXMuIEltYWdlcyB3aXRoIFwiZmlsbFwiIGFsd2F5cyB1c2UgaGVpZ2h0IDEwMCUgLSBpdCBjYW5ub3QgYmUgbW9kaWZpZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpZHRoSW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGlzIG1pc3NpbmcgcmVxdWlyZWQgXCJ3aWR0aFwiIHByb3BlcnR5LicpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOYU4od2lkdGhJbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBpbnZhbGlkIFwid2lkdGhcIiBwcm9wZXJ0eS4gRXhwZWN0ZWQgYSBudW1lcmljIHZhbHVlIGluIHBpeGVscyBidXQgcmVjZWl2ZWQgXCInICsgd2lkdGggKyAnXCIuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0SW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGlzIG1pc3NpbmcgcmVxdWlyZWQgXCJoZWlnaHRcIiBwcm9wZXJ0eS4nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKGhlaWdodEludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaGFzIGludmFsaWQgXCJoZWlnaHRcIiBwcm9wZXJ0eS4gRXhwZWN0ZWQgYSBudW1lcmljIHZhbHVlIGluIHBpeGVscyBidXQgcmVjZWl2ZWQgXCInICsgaGVpZ2h0ICsgJ1wiLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIVZBTElEX0xPQURJTkdfVkFMVUVTLmluY2x1ZGVzKGxvYWRpbmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBoYXMgaW52YWxpZCBcImxvYWRpbmdcIiBwcm9wZXJ0eS4gUHJvdmlkZWQgXCInICsgbG9hZGluZyArICdcIiBzaG91bGQgYmUgb25lIG9mICcgKyBWQUxJRF9MT0FESU5HX1ZBTFVFUy5tYXAoU3RyaW5nKS5qb2luKFwiLFwiKSArIFwiLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJpb3JpdHkgJiYgbG9hZGluZyA9PT0gXCJsYXp5XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBib3RoIFwicHJpb3JpdHlcIiBhbmQgXCJsb2FkaW5nPVxcJ2xhenlcXCdcIiBwcm9wZXJ0aWVzLiBPbmx5IG9uZSBzaG91bGQgYmUgdXNlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGxhY2Vob2xkZXIgPT09IFwiYmx1clwiKSB7XG4gICAgICAgICAgICBpZiAod2lkdGhJbnQgJiYgaGVpZ2h0SW50ICYmIHdpZHRoSW50ICogaGVpZ2h0SW50IDwgMTYwMCkge1xuICAgICAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaXMgc21hbGxlciB0aGFuIDQweDQwLiBDb25zaWRlciByZW1vdmluZyB0aGUgXCJwbGFjZWhvbGRlcj1cXCdibHVyXFwnXCIgcHJvcGVydHkgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYmx1ckRhdGFVUkwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBWQUxJRF9CTFVSX0VYVCA9IFtcbiAgICAgICAgICAgICAgICAgICAgXCJqcGVnXCIsXG4gICAgICAgICAgICAgICAgICAgIFwicG5nXCIsXG4gICAgICAgICAgICAgICAgICAgIFwid2VicFwiLFxuICAgICAgICAgICAgICAgICAgICBcImF2aWZcIlxuICAgICAgICAgICAgICAgIF0gLy8gc2hvdWxkIG1hdGNoIG5leHQtaW1hZ2UtbG9hZGVyXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBcInBsYWNlaG9sZGVyPVxcJ2JsdXJcXCdcIiBwcm9wZXJ0eSBidXQgaXMgbWlzc2luZyB0aGUgXCJibHVyRGF0YVVSTFwiIHByb3BlcnR5LlxcbiAgICAgICAgICBQb3NzaWJsZSBzb2x1dGlvbnM6XFxuICAgICAgICAgICAgLSBBZGQgYSBcImJsdXJEYXRhVVJMXCIgcHJvcGVydHksIHRoZSBjb250ZW50cyBzaG91bGQgYmUgYSBzbWFsbCBEYXRhIFVSTCB0byByZXByZXNlbnQgdGhlIGltYWdlXFxuICAgICAgICAgICAgLSBDaGFuZ2UgdGhlIFwic3JjXCIgcHJvcGVydHkgdG8gYSBzdGF0aWMgaW1wb3J0IHdpdGggb25lIG9mIHRoZSBzdXBwb3J0ZWQgZmlsZSB0eXBlczogJyArIFZBTElEX0JMVVJfRVhULmpvaW4oXCIsXCIpICsgJ1xcbiAgICAgICAgICAgIC0gUmVtb3ZlIHRoZSBcInBsYWNlaG9sZGVyXCIgcHJvcGVydHksIGVmZmVjdGl2ZWx5IG5vIGJsdXIgZWZmZWN0XFxuICAgICAgICAgIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvcGxhY2Vob2xkZXItYmx1ci1kYXRhLXVybCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChcInJlZlwiIGluIHJlc3QpIHtcbiAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaXMgdXNpbmcgdW5zdXBwb3J0ZWQgXCJyZWZcIiBwcm9wZXJ0eS4gQ29uc2lkZXIgdXNpbmcgdGhlIFwib25Mb2FkaW5nQ29tcGxldGVcIiBwcm9wZXJ0eSBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdW5vcHRpbWl6ZWQgJiYgbG9hZGVyICE9PSBfaW1hZ2Vsb2FkZXIuZGVmYXVsdCkge1xuICAgICAgICAgICAgY29uc3QgdXJsU3RyID0gbG9hZGVyKHtcbiAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aEludCB8fCA0MDAsXG4gICAgICAgICAgICAgICAgcXVhbGl0eTogcXVhbGl0eUludCB8fCA3NVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgdXJsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB1cmwgPSBuZXcgVVJMKHVybFN0cik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICBpZiAodXJsU3RyID09PSBzcmMgfHwgdXJsICYmIHVybC5wYXRobmFtZSA9PT0gc3JjICYmICF1cmwuc2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBoYXMgYSBcImxvYWRlclwiIHByb3BlcnR5IHRoYXQgZG9lcyBub3QgaW1wbGVtZW50IHdpZHRoLiBQbGVhc2UgaW1wbGVtZW50IGl0IG9yIHVzZSB0aGUgXCJ1bm9wdGltaXplZFwiIHByb3BlcnR5IGluc3RlYWQuJyArIFwiXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLW1pc3NpbmctbG9hZGVyLXdpZHRoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2xlZ2FjeUtleSwgbGVnYWN5VmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHtcbiAgICAgICAgICAgIGxheW91dCxcbiAgICAgICAgICAgIG9iamVjdEZpdCxcbiAgICAgICAgICAgIG9iamVjdFBvc2l0aW9uLFxuICAgICAgICAgICAgbGF6eUJvdW5kYXJ5LFxuICAgICAgICAgICAgbGF6eVJvb3RcbiAgICAgICAgfSkpe1xuICAgICAgICAgICAgaWYgKGxlZ2FjeVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBoYXMgbGVnYWN5IHByb3AgXCInICsgbGVnYWN5S2V5ICsgJ1wiLiBEaWQgeW91IGZvcmdldCB0byBydW4gdGhlIGNvZGVtb2Q/JyArIFwiXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLXVwZ3JhZGUtdG8tMTNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgIXBlcmZPYnNlcnZlciAmJiB3aW5kb3cuUGVyZm9ybWFuY2VPYnNlcnZlcikge1xuICAgICAgICAgICAgcGVyZk9ic2VydmVyID0gbmV3IFBlcmZvcm1hbmNlT2JzZXJ2ZXIoKGVudHJ5TGlzdCk9PntcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJ5TGlzdC5nZXRFbnRyaWVzKCkpe1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2VudHJ5X2VsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSBtaXNzaW5nIFwiTGFyZ2VzdENvbnRlbnRmdWxQYWludFwiIGNsYXNzIHdpdGggXCJlbGVtZW50XCIgcHJvcFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWdTcmMgPSAoZW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IChfZW50cnlfZWxlbWVudCA9IGVudHJ5LmVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZW50cnlfZWxlbWVudC5zcmMpIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxjcEltYWdlID0gYWxsSW1ncy5nZXQoaW1nU3JjKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxjcEltYWdlICYmICFsY3BJbWFnZS5wcmlvcml0eSAmJiBsY3BJbWFnZS5wbGFjZWhvbGRlciAhPT0gXCJibHVyXCIgJiYgIWxjcEltYWdlLnNyYy5zdGFydHNXaXRoKFwiZGF0YTpcIikgJiYgIWxjcEltYWdlLnNyYy5zdGFydHNXaXRoKFwiYmxvYjpcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vd2ViLmRldi9sY3AvI21lYXN1cmUtbGNwLWluLWphdmFzY3JpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBsY3BJbWFnZS5zcmMgKyAnXCIgd2FzIGRldGVjdGVkIGFzIHRoZSBMYXJnZXN0IENvbnRlbnRmdWwgUGFpbnQgKExDUCkuIFBsZWFzZSBhZGQgdGhlIFwicHJpb3JpdHlcIiBwcm9wZXJ0eSBpZiB0aGlzIGltYWdlIGlzIGFib3ZlIHRoZSBmb2xkLicgKyBcIlxcblJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI3ByaW9yaXR5XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBlcmZPYnNlcnZlci5vYnNlcnZlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJsYXJnZXN0LWNvbnRlbnRmdWwtcGFpbnRcIixcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyZWQ6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIExvZyBlcnJvciBidXQgZG9uJ3QgY3Jhc2ggdGhlIGFwcFxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbWdTdHlsZSA9IE9iamVjdC5hc3NpZ24oZmlsbCA/IHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIG9iamVjdEZpdCxcbiAgICAgICAgb2JqZWN0UG9zaXRpb25cbiAgICB9IDoge30sIHNob3dBbHRUZXh0ID8ge30gOiB7XG4gICAgICAgIGNvbG9yOiBcInRyYW5zcGFyZW50XCJcbiAgICB9LCBzdHlsZSk7XG4gICAgY29uc3QgYmx1clN0eWxlID0gcGxhY2Vob2xkZXIgPT09IFwiYmx1clwiICYmIGJsdXJEYXRhVVJMICYmICFibHVyQ29tcGxldGUgPyB7XG4gICAgICAgIGJhY2tncm91bmRTaXplOiBpbWdTdHlsZS5vYmplY3RGaXQgfHwgXCJjb3ZlclwiLFxuICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246IGltZ1N0eWxlLm9iamVjdFBvc2l0aW9uIHx8IFwiNTAlIDUwJVwiLFxuICAgICAgICBiYWNrZ3JvdW5kUmVwZWF0OiBcIm5vLXJlcGVhdFwiLFxuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6ICd1cmwoXCJkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGYtOCwnICsgKDAsIF9pbWFnZWJsdXJzdmcuZ2V0SW1hZ2VCbHVyU3ZnKSh7XG4gICAgICAgICAgICB3aWR0aEludCxcbiAgICAgICAgICAgIGhlaWdodEludCxcbiAgICAgICAgICAgIGJsdXJXaWR0aCxcbiAgICAgICAgICAgIGJsdXJIZWlnaHQsXG4gICAgICAgICAgICBibHVyRGF0YVVSTCxcbiAgICAgICAgICAgIG9iamVjdEZpdDogaW1nU3R5bGUub2JqZWN0Rml0XG4gICAgICAgIH0pICsgJ1wiKSdcbiAgICB9IDoge307XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgaWYgKGJsdXJTdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgJiYgKGJsdXJEYXRhVVJMID09IG51bGwgPyB2b2lkIDAgOiBibHVyRGF0YVVSTC5zdGFydHNXaXRoKFwiL1wiKSkpIHtcbiAgICAgICAgICAgIC8vIER1cmluZyBgbmV4dCBkZXZgLCB3ZSBkb24ndCB3YW50IHRvIGdlbmVyYXRlIGJsdXIgcGxhY2Vob2xkZXJzIHdpdGggd2VicGFja1xuICAgICAgICAgICAgLy8gYmVjYXVzZSBpdCBjYW4gZGVsYXkgc3RhcnRpbmcgdGhlIGRldiBzZXJ2ZXIuIEluc3RlYWQsIGBuZXh0LWltYWdlLWxvYWRlci5qc2BcbiAgICAgICAgICAgIC8vIHdpbGwgaW5saW5lIGEgc3BlY2lhbCB1cmwgdG8gbGF6aWx5IGdlbmVyYXRlIHRoZSBibHVyIHBsYWNlaG9sZGVyIGF0IHJlcXVlc3QgdGltZS5cbiAgICAgICAgICAgIGJsdXJTdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSAndXJsKFwiJyArIGJsdXJEYXRhVVJMICsgJ1wiKSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW1nQXR0cmlidXRlcyA9IGdlbmVyYXRlSW1nQXR0cnMoe1xuICAgICAgICBjb25maWcsXG4gICAgICAgIHNyYyxcbiAgICAgICAgdW5vcHRpbWl6ZWQsXG4gICAgICAgIHdpZHRoOiB3aWR0aEludCxcbiAgICAgICAgcXVhbGl0eTogcXVhbGl0eUludCxcbiAgICAgICAgc2l6ZXMsXG4gICAgICAgIGxvYWRlclxuICAgIH0pO1xuICAgIGxldCBzcmNTdHJpbmcgPSBzcmM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbGV0IGZ1bGxVcmw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZ1bGxVcmwgPSBuZXcgVVJMKGltZ0F0dHJpYnV0ZXMuc3JjKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBmdWxsVXJsID0gbmV3IFVSTChpbWdBdHRyaWJ1dGVzLnNyYywgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWxsSW1ncy5zZXQoZnVsbFVybC5ocmVmLCB7XG4gICAgICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgICAgIHByaW9yaXR5LFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvbkxvYWRSZWYgPSAoMCwgX3JlYWN0LnVzZVJlZikob25Mb2FkKTtcbiAgICAoMCwgX3JlYWN0LnVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgb25Mb2FkUmVmLmN1cnJlbnQgPSBvbkxvYWQ7XG4gICAgfSwgW1xuICAgICAgICBvbkxvYWRcbiAgICBdKTtcbiAgICBjb25zdCBvbkxvYWRpbmdDb21wbGV0ZVJlZiA9ICgwLCBfcmVhY3QudXNlUmVmKShvbkxvYWRpbmdDb21wbGV0ZSk7XG4gICAgKDAsIF9yZWFjdC51c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmLmN1cnJlbnQgPSBvbkxvYWRpbmdDb21wbGV0ZTtcbiAgICB9LCBbXG4gICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlXG4gICAgXSk7XG4gICAgY29uc3QgaW1nRWxlbWVudEFyZ3MgPSB7XG4gICAgICAgIGlzTGF6eSxcbiAgICAgICAgaW1nQXR0cmlidXRlcyxcbiAgICAgICAgaGVpZ2h0SW50LFxuICAgICAgICB3aWR0aEludCxcbiAgICAgICAgcXVhbGl0eUludCxcbiAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICBpbWdTdHlsZSxcbiAgICAgICAgYmx1clN0eWxlLFxuICAgICAgICBsb2FkaW5nLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIGZldGNoUHJpb3JpdHksXG4gICAgICAgIGZpbGwsXG4gICAgICAgIHVub3B0aW1pemVkLFxuICAgICAgICBwbGFjZWhvbGRlcixcbiAgICAgICAgbG9hZGVyLFxuICAgICAgICBzcmNTdHJpbmcsXG4gICAgICAgIG9uTG9hZFJlZixcbiAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYsXG4gICAgICAgIHNldEJsdXJDb21wbGV0ZSxcbiAgICAgICAgc2V0U2hvd0FsdFRleHQsXG4gICAgICAgIC4uLnJlc3RcbiAgICB9O1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChJbWFnZUVsZW1lbnQsIHtcbiAgICAgICAgLi4uaW1nRWxlbWVudEFyZ3MsXG4gICAgICAgIHJlZjogZm9yd2FyZGVkUmVmXG4gICAgfSksIHByaW9yaXR5ID8gLy8gTm90ZSBob3cgd2Ugb21pdCB0aGUgYGhyZWZgIGF0dHJpYnV0ZSwgYXMgaXQgd291bGQgb25seSBiZSByZWxldmFudFxuICAgIC8vIGZvciBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IGBpbWFnZXNyY3NldGAsIGFuZCBpbiB0aG9zZSBjYXNlc1xuICAgIC8vIGl0IHdvdWxkIGxpa2VseSBjYXVzZSB0aGUgaW5jb3JyZWN0IGltYWdlIHRvIGJlIHByZWxvYWRlZC5cbiAgICAvL1xuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI2F0dHItbGluay1pbWFnZXNyY3NldFxuICAgIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfaGVhZC5kZWZhdWx0LCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIsIHtcbiAgICAgICAga2V5OiBcIl9fbmltZy1cIiArIGltZ0F0dHJpYnV0ZXMuc3JjICsgaW1nQXR0cmlidXRlcy5zcmNTZXQgKyBpbWdBdHRyaWJ1dGVzLnNpemVzLFxuICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgICAgICBhczogXCJpbWFnZVwiLFxuICAgICAgICBocmVmOiBpbWdBdHRyaWJ1dGVzLnNyY1NldCA/IHVuZGVmaW5lZCA6IGltZ0F0dHJpYnV0ZXMuc3JjLFxuICAgICAgICBpbWFnZVNyY1NldDogaW1nQXR0cmlidXRlcy5zcmNTZXQsXG4gICAgICAgIGltYWdlU2l6ZXM6IGltZ0F0dHJpYnV0ZXMuc2l6ZXMsXG4gICAgICAgIGNyb3NzT3JpZ2luOiByZXN0LmNyb3NzT3JpZ2luLFxuICAgICAgICByZWZlcnJlclBvbGljeTogcmVzdC5yZWZlcnJlclBvbGljeSxcbiAgICAgICAgLi4uZ2V0RHluYW1pY1Byb3BzKGZldGNoUHJpb3JpdHkpXG4gICAgfSkpIDogbnVsbCk7XG59KTtcbmNvbnN0IF9kZWZhdWx0ID0gSW1hZ2U7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJfZGVmYXVsdCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwiX3JlYWN0IiwiXyIsIl9oZWFkIiwiX2ltYWdlYmx1cnN2ZyIsIl9pbWFnZWNvbmZpZyIsIl9pbWFnZWNvbmZpZ2NvbnRleHQiLCJfd2Fybm9uY2UiLCJfaW1hZ2Vsb2FkZXIiLCJjb25maWdFbnYiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0lNQUdFX09QVFMiLCJhbGxJbWdzIiwiTWFwIiwicGVyZk9ic2VydmVyIiwiZ2xvYmFsVGhpcyIsIl9fTkVYVF9JTUFHRV9JTVBPUlRFRCIsIlZBTElEX0xPQURJTkdfVkFMVUVTIiwidW5kZWZpbmVkIiwiaXNTdGF0aWNSZXF1aXJlIiwic3JjIiwiZGVmYXVsdCIsImlzU3RhdGljSW1hZ2VEYXRhIiwiaXNTdGF0aWNJbXBvcnQiLCJnZXRXaWR0aHMiLCJwYXJhbSIsIndpZHRoIiwic2l6ZXMiLCJkZXZpY2VTaXplcyIsImFsbFNpemVzIiwidmlld3BvcnRXaWR0aFJlIiwicGVyY2VudFNpemVzIiwibWF0Y2giLCJleGVjIiwicHVzaCIsInBhcnNlSW50IiwibGVuZ3RoIiwiTWF0aCIsInNtYWxsZXN0UmF0aW8iLCJtaW4iLCJ3aWR0aHMiLCJmaWx0ZXIiLCJzIiwia2luZCIsIlNldCIsIm1hcCIsInciLCJmaW5kIiwicCIsImdlbmVyYXRlSW1nQXR0cnMiLCJjb25maWciLCJ1bm9wdGltaXplZCIsInF1YWxpdHkiLCJsb2FkZXIiLCJzcmNTZXQiLCJsYXN0IiwiaSIsImpvaW4iLCJnZXRJbnQiLCJ4IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJOYU4iLCJ0ZXN0IiwiaGFuZGxlTG9hZGluZyIsImltZyIsInBsYWNlaG9sZGVyIiwib25Mb2FkUmVmIiwib25Mb2FkaW5nQ29tcGxldGVSZWYiLCJzZXRCbHVyQ29tcGxldGUiLCJkZWNvZGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNhdGNoIiwidGhlbiIsInBhcmVudEVsZW1lbnQiLCJpc0Nvbm5lY3RlZCIsImN1cnJlbnQiLCJldmVudCIsIkV2ZW50Iiwid3JpdGFibGUiLCJwcmV2ZW50ZWQiLCJzdG9wcGVkIiwibmF0aXZlRXZlbnQiLCJjdXJyZW50VGFyZ2V0IiwidGFyZ2V0IiwiaXNEZWZhdWx0UHJldmVudGVkIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJwZXJzaXN0IiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJnZXRBdHRyaWJ1dGUiLCJ3aWR0aFZpZXdwb3J0UmF0aW8iLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwid2Fybk9uY2UiLCJwb3NpdGlvbiIsImdldENvbXB1dGVkU3R5bGUiLCJ2YWxpZCIsImluY2x1ZGVzIiwiU3RyaW5nIiwiaGVpZ2h0IiwiaGVpZ2h0TW9kaWZpZWQiLCJ0b1N0cmluZyIsIndpZHRoTW9kaWZpZWQiLCJnZXREeW5hbWljUHJvcHMiLCJmZXRjaFByaW9yaXR5IiwidmVyc2lvbiIsInNwbGl0IiwibWFqb3JTdHIiLCJtaW5vclN0ciIsIm1ham9yIiwibWlub3IiLCJmZXRjaHByaW9yaXR5IiwiSW1hZ2VFbGVtZW50IiwiZm9yd2FyZFJlZiIsImZvcndhcmRlZFJlZiIsImltZ0F0dHJpYnV0ZXMiLCJoZWlnaHRJbnQiLCJ3aWR0aEludCIsInF1YWxpdHlJbnQiLCJjbGFzc05hbWUiLCJpbWdTdHlsZSIsImJsdXJTdHlsZSIsImlzTGF6eSIsImZpbGwiLCJsb2FkaW5nIiwic3JjU3RyaW5nIiwic2V0U2hvd0FsdFRleHQiLCJvbkxvYWQiLCJvbkVycm9yIiwicmVzdCIsImNyZWF0ZUVsZW1lbnQiLCJkZWNvZGluZyIsInN0eWxlIiwicmVmIiwidXNlQ2FsbGJhY2siLCJjb25zb2xlIiwiZXJyb3IiLCJjb21wbGV0ZSIsIkltYWdlIiwicHJpb3JpdHkiLCJvbkxvYWRpbmdDb21wbGV0ZSIsImJsdXJEYXRhVVJMIiwibGF5b3V0Iiwib2JqZWN0Rml0Iiwib2JqZWN0UG9zaXRpb24iLCJsYXp5Qm91bmRhcnkiLCJsYXp5Um9vdCIsImFsbCIsImNvbmZpZ0NvbnRleHQiLCJ1c2VDb250ZXh0IiwiSW1hZ2VDb25maWdDb250ZXh0IiwidXNlTWVtbyIsImMiLCJpbWFnZUNvbmZpZ0RlZmF1bHQiLCJpbWFnZVNpemVzIiwic29ydCIsImEiLCJiIiwiaXNEZWZhdWx0TG9hZGVyIiwiRXJyb3IiLCJjdXN0b21JbWFnZUxvYWRlciIsIm9iaiIsIm9wdHMiLCJsYXlvdXRUb1N0eWxlIiwiaW50cmluc2ljIiwibWF4V2lkdGgiLCJyZXNwb25zaXZlIiwibGF5b3V0VG9TaXplcyIsImxheW91dFN0eWxlIiwibGF5b3V0U2l6ZXMiLCJzdGF0aWNTcmMiLCJibHVyV2lkdGgiLCJibHVySGVpZ2h0Iiwic3RhdGljSW1hZ2VEYXRhIiwiSlNPTiIsInN0cmluZ2lmeSIsInJhdGlvIiwicm91bmQiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJkYW5nZXJvdXNseUFsbG93U1ZHIiwidXNlU3RhdGUiLCJibHVyQ29tcGxldGUiLCJzaG93QWx0VGV4dCIsIm91dHB1dCIsImlzTmFOIiwiVkFMSURfQkxVUl9FWFQiLCJ1cmxTdHIiLCJ1cmwiLCJVUkwiLCJlcnIiLCJwYXRobmFtZSIsInNlYXJjaCIsImVudHJpZXMiLCJsZWdhY3lLZXkiLCJsZWdhY3lWYWx1ZSIsIlBlcmZvcm1hbmNlT2JzZXJ2ZXIiLCJlbnRyeUxpc3QiLCJnZXRFbnRyaWVzIiwiZW50cnkiLCJfZW50cnlfZWxlbWVudCIsImltZ1NyYyIsImVsZW1lbnQiLCJsY3BJbWFnZSIsIm9ic2VydmUiLCJ0eXBlIiwiYnVmZmVyZWQiLCJhc3NpZ24iLCJsZWZ0IiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJjb2xvciIsImJhY2tncm91bmRTaXplIiwiYmFja2dyb3VuZFBvc2l0aW9uIiwiYmFja2dyb3VuZFJlcGVhdCIsImJhY2tncm91bmRJbWFnZSIsImdldEltYWdlQmx1clN2ZyIsImZ1bGxVcmwiLCJlIiwibG9jYXRpb24iLCJocmVmIiwic2V0IiwidXNlUmVmIiwidXNlRWZmZWN0IiwiaW1nRWxlbWVudEFyZ3MiLCJGcmFnbWVudCIsImtleSIsInJlbCIsImFzIiwiaW1hZ2VTcmNTZXQiLCJjcm9zc09yaWdpbiIsInJlZmVycmVyUG9saWN5IiwiX19lc01vZHVsZSIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/image.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"./node_modules/@swc/helpers/esm/_object_spread.js\");\nvar _object_without_properties = __webpack_require__(/*! @swc/helpers/_/_object_without_properties */ \"./node_modules/@swc/helpers/esm/_object_without_properties.js\");\nvar _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"./node_modules/@swc/helpers/esm/_sliced_to_array.js\");\nvar _type_of = __webpack_require__(/*! @swc/helpers/_/_type_of */ \"./node_modules/@swc/helpers/esm/_type_of.js\");\nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function get() {\n        return _default;\n    }\n}));\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar _resolvehref = __webpack_require__(/*! ../shared/lib/router/utils/resolve-href */ \"./node_modules/next/dist/shared/lib/router/utils/resolve-href.js\");\nvar _islocalurl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ \"./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nvar _formaturl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nvar _utils = __webpack_require__(/*! ../shared/lib/utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nvar _addlocale = __webpack_require__(/*! ./add-locale */ \"./node_modules/next/dist/client/add-locale.js\");\nvar _routercontext = __webpack_require__(/*! ../shared/lib/router-context */ \"./node_modules/next/dist/shared/lib/router-context.js\");\nvar _approutercontext = __webpack_require__(/*! ../shared/lib/app-router-context */ \"./node_modules/next/dist/shared/lib/app-router-context.js\");\nvar _useintersection = __webpack_require__(/*! ./use-intersection */ \"./node_modules/next/dist/client/use-intersection.js\");\nvar _getdomainlocale = __webpack_require__(/*! ./get-domain-locale */ \"./node_modules/next/dist/client/get-domain-locale.js\");\nvar _addbasepath = __webpack_require__(/*! ./add-base-path */ \"./node_modules/next/dist/client/add-base-path.js\");\nvar _routerreducertypes = __webpack_require__(/*! ./components/router-reducer/router-reducer-types */ \"./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nvar prefetched = new Set();\nfunction prefetch(router, href, as, options, appOptions, isAppRouter) {\n    if (false) {}\n    // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    if (!isAppRouter && !(0, _islocalurl.isLocalURL)(href)) {\n        return;\n    }\n    // We should only dedupe requests when experimental.optimisticClientCache is\n    // disabled.\n    if (!options.bypassPrefetchedCheck) {\n        var locale = typeof options.locale !== \"undefined\" ? options.locale : \"locale\" in router ? router.locale : undefined;\n        var prefetchedKey = href + \"%\" + as + \"%\" + locale;\n        // If we've already fetched the key, then don't prefetch it again!\n        if (prefetched.has(prefetchedKey)) {\n            return;\n        }\n        // Mark this URL as prefetched.\n        prefetched.add(prefetchedKey);\n    }\n    var prefetchPromise = isAppRouter ? router.prefetch(href, appOptions) : router.prefetch(href, as, options);\n    // Prefetch the JSON page if asked (only in the client)\n    // We need to handle a prefetch error here since we may be\n    // loading with priority which can reject but we don't\n    // want to force navigation since this is only a prefetch\n    Promise.resolve(prefetchPromise)[\"catch\"](function(err) {\n        if (true) {\n            // rethrow to show invalid URL errors\n            throw err;\n        }\n    });\n}\nfunction isModifiedEvent(event) {\n    var eventTarget = event.currentTarget;\n    var target = eventTarget.getAttribute(\"target\");\n    return target && target !== \"_self\" || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download\n    event.nativeEvent && event.nativeEvent.which === 2;\n}\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter, prefetchEnabled) {\n    var nodeName = e.currentTarget.nodeName;\n    // anchors inside an svg have a lowercase nodeName\n    var isAnchorNodeName = nodeName.toUpperCase() === \"A\";\n    if (isAnchorNodeName && (isModifiedEvent(e) || // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    !isAppRouter && !(0, _islocalurl.isLocalURL)(href))) {\n        // ignore click for browsers default behavior\n        return;\n    }\n    e.preventDefault();\n    var navigate = function() {\n        // If the router is an NextRouter instance it will have `beforePopState`\n        if (\"beforePopState\" in router) {\n            router[replace ? \"replace\" : \"push\"](href, as, {\n                shallow: shallow,\n                locale: locale,\n                scroll: scroll\n            });\n        } else {\n            router[replace ? \"replace\" : \"push\"](as || href, {\n                forceOptimisticNavigation: !prefetchEnabled\n            });\n        }\n    };\n    if (isAppRouter) {\n        _react[\"default\"].startTransition(navigate);\n    } else {\n        navigate();\n    }\n}\nfunction formatStringOrUrl(urlObjOrString) {\n    if (typeof urlObjOrString === \"string\") {\n        return urlObjOrString;\n    }\n    return (0, _formaturl.formatUrl)(urlObjOrString);\n}\nvar _s1;\n/**\n * React Component that enables client-side transitions between routes.\n */ var Link = /*#__PURE__*/ _s(_react[\"default\"].forwardRef((_s1 = _s(function LinkComponent(props, forwardedRef) {\n    _s();\n    var children;\n    var hrefProp = props.href, asProp = props.as, childrenProp = props.children, tmp = props.prefetch, prefetchProp = tmp === void 0 ? null : tmp, passHref = props.passHref, replace = props.replace, shallow = props.shallow, scroll = props.scroll, locale = props.locale, onClick = props.onClick, onMouseEnterProp = props.onMouseEnter, onTouchStartProp = props.onTouchStart, _props_legacyBehavior = props.legacyBehavior, legacyBehavior = _props_legacyBehavior === void 0 ? true === false : _props_legacyBehavior, restProps = _object_without_properties._(props, [\n        \"href\",\n        \"as\",\n        \"children\",\n        \"prefetch\",\n        \"passHref\",\n        \"replace\",\n        \"shallow\",\n        \"scroll\",\n        \"locale\",\n        \"onClick\",\n        \"onMouseEnter\",\n        \"onTouchStart\",\n        \"legacyBehavior\"\n    ]);\n    children = childrenProp;\n    if (legacyBehavior && (typeof children === \"string\" || typeof children === \"number\")) {\n        children = /*#__PURE__*/ _react[\"default\"].createElement(\"a\", null, children);\n    }\n    var prefetchEnabled = prefetchProp !== false;\n    /**\n     * The possible states for prefetch are:\n     * - null: this is the default \"auto\" mode, where we will prefetch partially if the link is in the viewport\n     * - true: we will prefetch if the link is visible and prefetch the full page, not just partially\n     * - false: we will not prefetch if in the viewport at all\n     */ var appPrefetchKind = prefetchProp === null ? _routerreducertypes.PrefetchKind.AUTO : _routerreducertypes.PrefetchKind.FULL;\n    var pagesRouter = _react[\"default\"].useContext(_routercontext.RouterContext);\n    var appRouter = _react[\"default\"].useContext(_approutercontext.AppRouterContext);\n    var router = pagesRouter != null ? pagesRouter : appRouter;\n    // We're in the app directory if there is no pages router.\n    var isAppRouter = !pagesRouter;\n    if (true) {\n        var createPropError = function createPropError(args) {\n            return new Error(\"Failed prop type: The prop `\" + args.key + \"` expects a \" + args.expected + \" in `<Link>`, but got `\" + args.actual + \"` instead.\" + ( true ? \"\\nOpen your browser's console to view the Component stack trace.\" : 0));\n        };\n        // TypeScript trick for type-guarding:\n        var requiredPropsGuard = {\n            href: true\n        };\n        var requiredProps = Object.keys(requiredPropsGuard);\n        requiredProps.forEach(function(key) {\n            if (key === \"href\") {\n                if (props[key] == null || typeof props[key] !== \"string\" && typeof props[key] !== \"object\") {\n                    throw createPropError({\n                        key: key,\n                        expected: \"`string` or `object`\",\n                        actual: props[key] === null ? \"null\" : _type_of._(props[key])\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                var _ = key;\n            }\n        });\n        // TypeScript trick for type-guarding:\n        var optionalPropsGuard = {\n            as: true,\n            replace: true,\n            scroll: true,\n            shallow: true,\n            passHref: true,\n            prefetch: true,\n            locale: true,\n            onClick: true,\n            onMouseEnter: true,\n            onTouchStart: true,\n            legacyBehavior: true\n        };\n        var optionalProps = Object.keys(optionalPropsGuard);\n        optionalProps.forEach(function(key) {\n            var valType = _type_of._(props[key]);\n            if (key === \"as\") {\n                if (props[key] && valType !== \"string\" && valType !== \"object\") {\n                    throw createPropError({\n                        key: key,\n                        expected: \"`string` or `object`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"locale\") {\n                if (props[key] && valType !== \"string\") {\n                    throw createPropError({\n                        key: key,\n                        expected: \"`string`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"onClick\" || key === \"onMouseEnter\" || key === \"onTouchStart\") {\n                if (props[key] && valType !== \"function\") {\n                    throw createPropError({\n                        key: key,\n                        expected: \"`function`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"replace\" || key === \"scroll\" || key === \"shallow\" || key === \"passHref\" || key === \"prefetch\" || key === \"legacyBehavior\") {\n                if (props[key] != null && valType !== \"boolean\") {\n                    throw createPropError({\n                        key: key,\n                        expected: \"`boolean`\",\n                        actual: valType\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                var _ = key;\n            }\n        });\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        var hasWarned = _react[\"default\"].useRef(false);\n        if (props.prefetch && !hasWarned.current && !isAppRouter) {\n            hasWarned.current = true;\n            console.warn(\"Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated\");\n        }\n    }\n    if (true) {\n        if (isAppRouter && !asProp) {\n            var href;\n            if (typeof hrefProp === \"string\") {\n                href = hrefProp;\n            } else if (typeof hrefProp === \"object\" && typeof hrefProp.pathname === \"string\") {\n                href = hrefProp.pathname;\n            }\n            if (href) {\n                var hasDynamicSegment = href.split(\"/\").some(function(segment) {\n                    return segment.startsWith(\"[\") && segment.endsWith(\"]\");\n                });\n                if (hasDynamicSegment) {\n                    throw new Error(\"Dynamic href `\" + href + \"` found in <Link> while using the `/app` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href\");\n                }\n            }\n        }\n    }\n    var _react_default_useMemo = _react[\"default\"].useMemo(function() {\n        if (!pagesRouter) {\n            var resolvedHref = formatStringOrUrl(hrefProp);\n            return {\n                href: resolvedHref,\n                as: asProp ? formatStringOrUrl(asProp) : resolvedHref\n            };\n        }\n        var _ref = _sliced_to_array._((0, _resolvehref.resolveHref)(pagesRouter, hrefProp, true), 2), resolvedHref1 = _ref[0], resolvedAs = _ref[1];\n        return {\n            href: resolvedHref1,\n            as: asProp ? (0, _resolvehref.resolveHref)(pagesRouter, asProp) : resolvedAs || resolvedHref1\n        };\n    }, [\n        pagesRouter,\n        hrefProp,\n        asProp\n    ]), href1 = _react_default_useMemo.href, as = _react_default_useMemo.as;\n    var previousHref = _react[\"default\"].useRef(href1);\n    var previousAs = _react[\"default\"].useRef(as);\n    // This will return the first child, if multiple are provided it will throw an error\n    var child;\n    if (legacyBehavior) {\n        if (true) {\n            if (onClick) {\n                console.warn('\"onClick\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link');\n            }\n            if (onMouseEnterProp) {\n                console.warn('\"onMouseEnter\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link');\n            }\n            try {\n                child = _react[\"default\"].Children.only(children);\n            } catch (err) {\n                if (!children) {\n                    throw new Error(\"No children were passed to <Link> with `href` of `\" + hrefProp + \"` but one child is required https://nextjs.org/docs/messages/link-no-children\");\n                }\n                throw new Error(\"Multiple children were passed to <Link> with `href` of `\" + hrefProp + \"` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children\" + ( true ? \" \\nOpen your browser's console to view the Component stack trace.\" : 0));\n            }\n        } else {}\n    } else {\n        if (true) {\n            if ((children == null ? void 0 : children.type) === \"a\") {\n                throw new Error(\"Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor\");\n            }\n        }\n    }\n    var childRef = legacyBehavior ? child && typeof child === \"object\" && child.ref : forwardedRef;\n    var _ref = _sliced_to_array._((0, _useintersection.useIntersection)({\n        rootMargin: \"200px\"\n    }), 3), setIntersectionRef = _ref[0], isVisible = _ref[1], resetVisible = _ref[2];\n    var setRef = _react[\"default\"].useCallback(function(el) {\n        // Before the link getting observed, check if visible state need to be reset\n        if (previousAs.current !== as || previousHref.current !== href1) {\n            resetVisible();\n            previousAs.current = as;\n            previousHref.current = href1;\n        }\n        setIntersectionRef(el);\n        if (childRef) {\n            if (typeof childRef === \"function\") childRef(el);\n            else if (typeof childRef === \"object\") {\n                childRef.current = el;\n            }\n        }\n    }, [\n        as,\n        childRef,\n        href1,\n        resetVisible,\n        setIntersectionRef\n    ]);\n    // Prefetch the URL if we haven't already and it's visible.\n    _react[\"default\"].useEffect(function() {\n        // in dev, we only prefetch on hover to avoid wasting resources as the prefetch will trigger compiling the page.\n        if (true) {\n            return;\n        }\n        if (!router) {\n            return;\n        }\n        // If we don't need to prefetch the URL, don't do prefetch.\n        if (!isVisible || !prefetchEnabled) {\n            return;\n        }\n        // Prefetch the URL.\n        prefetch(router, href1, as, {\n            locale: locale\n        }, {\n            kind: appPrefetchKind\n        }, isAppRouter);\n    }, [\n        as,\n        href1,\n        isVisible,\n        locale,\n        prefetchEnabled,\n        pagesRouter == null ? void 0 : pagesRouter.locale,\n        router,\n        isAppRouter,\n        appPrefetchKind\n    ]);\n    var childProps = {\n        ref: setRef,\n        onClick: function(e) {\n            if (true) {\n                if (!e) {\n                    throw new Error('Component rendered inside next/link has to pass click event to \"onClick\" prop.');\n                }\n            }\n            if (!legacyBehavior && typeof onClick === \"function\") {\n                onClick(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onClick === \"function\") {\n                child.props.onClick(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (e.defaultPrevented) {\n                return;\n            }\n            linkClicked(e, router, href1, as, replace, shallow, scroll, locale, isAppRouter, prefetchEnabled);\n        },\n        onMouseEnter: function(e) {\n            if (!legacyBehavior && typeof onMouseEnterProp === \"function\") {\n                onMouseEnterProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === \"function\") {\n                child.props.onMouseEnter(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled && isAppRouter) {\n                return;\n            }\n            prefetch(router, href1, as, {\n                locale: locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, {\n                kind: appPrefetchKind\n            }, isAppRouter);\n        },\n        onTouchStart: function(e) {\n            if (!legacyBehavior && typeof onTouchStartProp === \"function\") {\n                onTouchStartProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onTouchStart === \"function\") {\n                child.props.onTouchStart(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled && isAppRouter) {\n                return;\n            }\n            prefetch(router, href1, as, {\n                locale: locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, {\n                kind: appPrefetchKind\n            }, isAppRouter);\n        }\n    };\n    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n    // defined, we specify the current 'href', so that repetition is not needed by the user.\n    // If the url is absolute, we can bypass the logic to prepend the domain and locale.\n    if ((0, _utils.isAbsoluteUrl)(as)) {\n        childProps.href = as;\n    } else if (!legacyBehavior || passHref || child.type === \"a\" && !(\"href\" in child.props)) {\n        var curLocale = typeof locale !== \"undefined\" ? locale : pagesRouter == null ? void 0 : pagesRouter.locale;\n        // we only render domain locales if we are currently on a domain locale\n        // so that locale links are still visitable in development/preview envs\n        var localeDomain = (pagesRouter == null ? void 0 : pagesRouter.isLocaleDomain) && (0, _getdomainlocale.getDomainLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.locales, pagesRouter == null ? void 0 : pagesRouter.domainLocales);\n        childProps.href = localeDomain || (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.defaultLocale));\n    }\n    return legacyBehavior ? /*#__PURE__*/ _react[\"default\"].cloneElement(child, childProps) : /*#__PURE__*/ _react[\"default\"].createElement(\"a\", _object_spread._({}, restProps, childProps), children);\n}, \"iGdYZW22TllPihoUFJYL0qIKigo=\"), _c = _s1, _s1)), \"iGdYZW22TllPihoUFJYL0qIKigo=\");\n_c1 = Link;\nvar _default = Link;\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=link.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Link$_react.default.forwardRef\");\n$RefreshReg$(_c1, \"Link\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9saW5rLmpzLmpzIiwibWFwcGluZ3MiOiJxREFDYTs7Ozs7Ozs7O0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCwyQ0FBMEM7SUFDdENJLFlBQVk7SUFDWkMsS0FBSyxTQUFMQTtRQUNJLE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixJQUFNQywyQkFBMkJDLG1CQUFPQSxDQUFDLDRHQUF5QztBQUNsRixJQUFNQyxTQUFTLFdBQVcsR0FBR0YseUJBQXlCRyxFQUFFRixtQkFBT0EsQ0FBQyw0Q0FBTztBQUN2RSxJQUFNRyxlQUFlSCxtQkFBT0EsQ0FBQyxpSEFBeUM7QUFDdEUsSUFBTUksY0FBY0osbUJBQU9BLENBQUMsaUhBQXlDO0FBQ3JFLElBQU1LLGFBQWFMLG1CQUFPQSxDQUFDLDZHQUF1QztBQUNsRSxJQUFNTSxTQUFTTixtQkFBT0EsQ0FBQyx5RUFBcUI7QUFDNUMsSUFBTU8sYUFBYVAsbUJBQU9BLENBQUMsbUVBQWM7QUFDekMsSUFBTVEsaUJBQWlCUixtQkFBT0EsQ0FBQywyRkFBOEI7QUFDN0QsSUFBTVMsb0JBQW9CVCxtQkFBT0EsQ0FBQyxtR0FBa0M7QUFDcEUsSUFBTVUsbUJBQW1CVixtQkFBT0EsQ0FBQywrRUFBb0I7QUFDckQsSUFBTVcsbUJBQW1CWCxtQkFBT0EsQ0FBQyxpRkFBcUI7QUFDdEQsSUFBTVksZUFBZVosbUJBQU9BLENBQUMseUVBQWlCO0FBQzlDLElBQU1hLHNCQUFzQmIsbUJBQU9BLENBQUMsMklBQWtEO0FBRXRGLElBQU1jLGFBQWEsSUFBSUM7QUFDdkIsU0FBU0MsU0FBU0MsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEVBQUUsRUFBRUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLFdBQVc7SUFDaEUsSUFBSSxLQUE2QixFQUFFLEVBRWxDO0lBQ0QsZ0pBQWdKO0lBQ2hKLElBQUksQ0FBQ0EsZUFBZSxDQUFDLENBQUMsR0FBR2xCLFlB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Q2xDLEVBRUEsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2xpbmsuanM/ZTRmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVmYXVsdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2RlZmF1bHQ7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgX3Jlc29sdmVocmVmID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3Jlc29sdmUtaHJlZlwiKTtcbmNvbnN0IF9pc2xvY2FsdXJsID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2lzLWxvY2FsLXVybFwiKTtcbmNvbnN0IF9mb3JtYXR1cmwgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybFwiKTtcbmNvbnN0IF91dGlscyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3V0aWxzXCIpO1xuY29uc3QgX2FkZGxvY2FsZSA9IHJlcXVpcmUoXCIuL2FkZC1sb2NhbGVcIik7XG5jb25zdCBfcm91dGVyY29udGV4dCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci1jb250ZXh0XCIpO1xuY29uc3QgX2FwcHJvdXRlcmNvbnRleHQgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHRcIik7XG5jb25zdCBfdXNlaW50ZXJzZWN0aW9uID0gcmVxdWlyZShcIi4vdXNlLWludGVyc2VjdGlvblwiKTtcbmNvbnN0IF9nZXRkb21haW5sb2NhbGUgPSByZXF1aXJlKFwiLi9nZXQtZG9tYWluLWxvY2FsZVwiKTtcbmNvbnN0IF9hZGRiYXNlcGF0aCA9IHJlcXVpcmUoXCIuL2FkZC1iYXNlLXBhdGhcIik7XG5jb25zdCBfcm91dGVycmVkdWNlcnR5cGVzID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci10eXBlc1wiKTtcblxuY29uc3QgcHJlZmV0Y2hlZCA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIG9wdGlvbnMsIGFwcE9wdGlvbnMsIGlzQXBwUm91dGVyKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBhcHAtcm91dGVyIHN1cHBvcnRzIGV4dGVybmFsIHVybHMgb3V0IG9mIHRoZSBib3ggc28gaXQgc2hvdWxkbid0IHNob3J0LWNpcmN1aXQgaGVyZSBhcyBzdXBwb3J0IGZvciBlLmcuIGByZXBsYWNlYCBpcyBhZGRlZCBpbiB0aGUgYXBwLXJvdXRlci5cbiAgICBpZiAoIWlzQXBwUm91dGVyICYmICEoMCwgX2lzbG9jYWx1cmwuaXNMb2NhbFVSTCkoaHJlZikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBXZSBzaG91bGQgb25seSBkZWR1cGUgcmVxdWVzdHMgd2hlbiBleHBlcmltZW50YWwub3B0aW1pc3RpY0NsaWVudENhY2hlIGlzXG4gICAgLy8gZGlzYWJsZWQuXG4gICAgaWYgKCFvcHRpb25zLmJ5cGFzc1ByZWZldGNoZWRDaGVjaykge1xuICAgICAgICBjb25zdCBsb2NhbGUgPSAvLyBMZXQgdGhlIGxpbmsncyBsb2NhbGUgcHJvcCBvdmVycmlkZSB0aGUgZGVmYXVsdCByb3V0ZXIgbG9jYWxlLlxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgIT09IFwidW5kZWZpbmVkXCIgPyBvcHRpb25zLmxvY2FsZSA6IFwibG9jYWxlXCIgaW4gcm91dGVyID8gcm91dGVyLmxvY2FsZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgcHJlZmV0Y2hlZEtleSA9IGhyZWYgKyBcIiVcIiArIGFzICsgXCIlXCIgKyBsb2NhbGU7XG4gICAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZmV0Y2hlZCB0aGUga2V5LCB0aGVuIGRvbid0IHByZWZldGNoIGl0IGFnYWluIVxuICAgICAgICBpZiAocHJlZmV0Y2hlZC5oYXMocHJlZmV0Y2hlZEtleSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXJrIHRoaXMgVVJMIGFzIHByZWZldGNoZWQuXG4gICAgICAgIHByZWZldGNoZWQuYWRkKHByZWZldGNoZWRLZXkpO1xuICAgIH1cbiAgICBjb25zdCBwcmVmZXRjaFByb21pc2UgPSBpc0FwcFJvdXRlciA/IHJvdXRlci5wcmVmZXRjaChocmVmLCBhcHBPcHRpb25zKSA6IHJvdXRlci5wcmVmZXRjaChocmVmLCBhcywgb3B0aW9ucyk7XG4gICAgLy8gUHJlZmV0Y2ggdGhlIEpTT04gcGFnZSBpZiBhc2tlZCAob25seSBpbiB0aGUgY2xpZW50KVxuICAgIC8vIFdlIG5lZWQgdG8gaGFuZGxlIGEgcHJlZmV0Y2ggZXJyb3IgaGVyZSBzaW5jZSB3ZSBtYXkgYmVcbiAgICAvLyBsb2FkaW5nIHdpdGggcHJpb3JpdHkgd2hpY2ggY2FuIHJlamVjdCBidXQgd2UgZG9uJ3RcbiAgICAvLyB3YW50IHRvIGZvcmNlIG5hdmlnYXRpb24gc2luY2UgdGhpcyBpcyBvbmx5IGEgcHJlZmV0Y2hcbiAgICBQcm9taXNlLnJlc29sdmUocHJlZmV0Y2hQcm9taXNlKS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAvLyByZXRocm93IHRvIHNob3cgaW52YWxpZCBVUkwgZXJyb3JzXG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudCkge1xuICAgIGNvbnN0IGV2ZW50VGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIik7XG4gICAgcmV0dXJuIHRhcmdldCAmJiB0YXJnZXQgIT09IFwiX3NlbGZcIiB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IC8vIHRyaWdnZXJzIHJlc291cmNlIGRvd25sb2FkXG4gICAgZXZlbnQubmF0aXZlRXZlbnQgJiYgZXZlbnQubmF0aXZlRXZlbnQud2hpY2ggPT09IDI7XG59XG5mdW5jdGlvbiBsaW5rQ2xpY2tlZChlLCByb3V0ZXIsIGhyZWYsIGFzLCByZXBsYWNlLCBzaGFsbG93LCBzY3JvbGwsIGxvY2FsZSwgaXNBcHBSb3V0ZXIsIHByZWZldGNoRW5hYmxlZCkge1xuICAgIGNvbnN0IHsgbm9kZU5hbWUgIH0gPSBlLmN1cnJlbnRUYXJnZXQ7XG4gICAgLy8gYW5jaG9ycyBpbnNpZGUgYW4gc3ZnIGhhdmUgYSBsb3dlcmNhc2Ugbm9kZU5hbWVcbiAgICBjb25zdCBpc0FuY2hvck5vZGVOYW1lID0gbm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gXCJBXCI7XG4gICAgaWYgKGlzQW5jaG9yTm9kZU5hbWUgJiYgKGlzTW9kaWZpZWRFdmVudChlKSB8fCAvLyBhcHAtcm91dGVyIHN1cHBvcnRzIGV4dGVybmFsIHVybHMgb3V0IG9mIHRoZSBib3ggc28gaXQgc2hvdWxkbid0IHNob3J0LWNpcmN1aXQgaGVyZSBhcyBzdXBwb3J0IGZvciBlLmcuIGByZXBsYWNlYCBpcyBhZGRlZCBpbiB0aGUgYXBwLXJvdXRlci5cbiAgICAhaXNBcHBSb3V0ZXIgJiYgISgwLCBfaXNsb2NhbHVybC5pc0xvY2FsVVJMKShocmVmKSkpIHtcbiAgICAgICAgLy8gaWdub3JlIGNsaWNrIGZvciBicm93c2Vy4oCZcyBkZWZhdWx0IGJlaGF2aW9yXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IG5hdmlnYXRlID0gKCk9PntcbiAgICAgICAgLy8gSWYgdGhlIHJvdXRlciBpcyBhbiBOZXh0Um91dGVyIGluc3RhbmNlIGl0IHdpbGwgaGF2ZSBgYmVmb3JlUG9wU3RhdGVgXG4gICAgICAgIGlmIChcImJlZm9yZVBvcFN0YXRlXCIgaW4gcm91dGVyKSB7XG4gICAgICAgICAgICByb3V0ZXJbcmVwbGFjZSA/IFwicmVwbGFjZVwiIDogXCJwdXNoXCJdKGhyZWYsIGFzLCB7XG4gICAgICAgICAgICAgICAgc2hhbGxvdyxcbiAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgc2Nyb2xsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvdXRlcltyZXBsYWNlID8gXCJyZXBsYWNlXCIgOiBcInB1c2hcIl0oYXMgfHwgaHJlZiwge1xuICAgICAgICAgICAgICAgIGZvcmNlT3B0aW1pc3RpY05hdmlnYXRpb246ICFwcmVmZXRjaEVuYWJsZWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNBcHBSb3V0ZXIpIHtcbiAgICAgICAgX3JlYWN0LmRlZmF1bHQuc3RhcnRUcmFuc2l0aW9uKG5hdmlnYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBuYXZpZ2F0ZSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZvcm1hdFN0cmluZ09yVXJsKHVybE9iak9yU3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiB1cmxPYmpPclN0cmluZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdXJsT2JqT3JTdHJpbmc7XG4gICAgfVxuICAgIHJldHVybiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRVcmwpKHVybE9iak9yU3RyaW5nKTtcbn1cbi8qKlxuICogUmVhY3QgQ29tcG9uZW50IHRoYXQgZW5hYmxlcyBjbGllbnQtc2lkZSB0cmFuc2l0aW9ucyBiZXR3ZWVuIHJvdXRlcy5cbiAqLyBjb25zdCBMaW5rID0gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIExpbmtDb21wb25lbnQocHJvcHMsIGZvcndhcmRlZFJlZikge1xuICAgIGxldCBjaGlsZHJlbjtcbiAgICBjb25zdCB7IGhyZWY6IGhyZWZQcm9wICwgYXM6IGFzUHJvcCAsIGNoaWxkcmVuOiBjaGlsZHJlblByb3AgLCBwcmVmZXRjaDogcHJlZmV0Y2hQcm9wID0gbnVsbCAsIHBhc3NIcmVmICwgcmVwbGFjZSAsIHNoYWxsb3cgLCBzY3JvbGwgLCBsb2NhbGUgLCBvbkNsaWNrICwgb25Nb3VzZUVudGVyOiBvbk1vdXNlRW50ZXJQcm9wICwgb25Ub3VjaFN0YXJ0OiBvblRvdWNoU3RhcnRQcm9wICwgLy8gQHRzLWV4cGVjdC1lcnJvciB0aGlzIGlzIGlubGluZWQgYXMgYSBsaXRlcmFsIGJvb2xlYW4gbm90IGEgc3RyaW5nXG4gICAgbGVnYWN5QmVoYXZpb3IgPXByb2Nlc3MuZW52Ll9fTkVYVF9ORVdfTElOS19CRUhBVklPUiA9PT0gZmFsc2UgLCAuLi5yZXN0UHJvcHMgfSA9IHByb3BzO1xuICAgIGNoaWxkcmVuID0gY2hpbGRyZW5Qcm9wO1xuICAgIGlmIChsZWdhY3lCZWhhdmlvciAmJiAodHlwZW9mIGNoaWxkcmVuID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJudW1iZXJcIikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIG51bGwsIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgY29uc3QgcHJlZmV0Y2hFbmFibGVkID0gcHJlZmV0Y2hQcm9wICE9PSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBUaGUgcG9zc2libGUgc3RhdGVzIGZvciBwcmVmZXRjaCBhcmU6XG4gICAgICogLSBudWxsOiB0aGlzIGlzIHRoZSBkZWZhdWx0IFwiYXV0b1wiIG1vZGUsIHdoZXJlIHdlIHdpbGwgcHJlZmV0Y2ggcGFydGlhbGx5IGlmIHRoZSBsaW5rIGlzIGluIHRoZSB2aWV3cG9ydFxuICAgICAqIC0gdHJ1ZTogd2Ugd2lsbCBwcmVmZXRjaCBpZiB0aGUgbGluayBpcyB2aXNpYmxlIGFuZCBwcmVmZXRjaCB0aGUgZnVsbCBwYWdlLCBub3QganVzdCBwYXJ0aWFsbHlcbiAgICAgKiAtIGZhbHNlOiB3ZSB3aWxsIG5vdCBwcmVmZXRjaCBpZiBpbiB0aGUgdmlld3BvcnQgYXQgYWxsXG4gICAgICovIGNvbnN0IGFwcFByZWZldGNoS2luZCA9IHByZWZldGNoUHJvcCA9PT0gbnVsbCA/IF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hLaW5kLkFVVE8gOiBfcm91dGVycmVkdWNlcnR5cGVzLlByZWZldGNoS2luZC5GVUxMO1xuICAgIGNvbnN0IHBhZ2VzUm91dGVyID0gX3JlYWN0LmRlZmF1bHQudXNlQ29udGV4dChfcm91dGVyY29udGV4dC5Sb3V0ZXJDb250ZXh0KTtcbiAgICBjb25zdCBhcHBSb3V0ZXIgPSBfcmVhY3QuZGVmYXVsdC51c2VDb250ZXh0KF9hcHByb3V0ZXJjb250ZXh0LkFwcFJvdXRlckNvbnRleHQpO1xuICAgIGNvbnN0IHJvdXRlciA9IHBhZ2VzUm91dGVyICE9IG51bGwgPyBwYWdlc1JvdXRlciA6IGFwcFJvdXRlcjtcbiAgICAvLyBXZSdyZSBpbiB0aGUgYXBwIGRpcmVjdG9yeSBpZiB0aGVyZSBpcyBubyBwYWdlcyByb3V0ZXIuXG4gICAgY29uc3QgaXNBcHBSb3V0ZXIgPSAhcGFnZXNSb3V0ZXI7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBmdW5jdGlvbiBjcmVhdGVQcm9wRXJyb3IoYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcIkZhaWxlZCBwcm9wIHR5cGU6IFRoZSBwcm9wIGBcIiArIGFyZ3Mua2V5ICsgXCJgIGV4cGVjdHMgYSBcIiArIGFyZ3MuZXhwZWN0ZWQgKyBcIiBpbiBgPExpbms+YCwgYnV0IGdvdCBgXCIgKyBhcmdzLmFjdHVhbCArIFwiYCBpbnN0ZWFkLlwiICsgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyBcIlxcbk9wZW4geW91ciBicm93c2VyJ3MgY29uc29sZSB0byB2aWV3IHRoZSBDb21wb25lbnQgc3RhY2sgdHJhY2UuXCIgOiBcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgY29uc3QgcmVxdWlyZWRQcm9wc0d1YXJkID0ge1xuICAgICAgICAgICAgaHJlZjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXF1aXJlZFByb3BzID0gT2JqZWN0LmtleXMocmVxdWlyZWRQcm9wc0d1YXJkKTtcbiAgICAgICAgcmVxdWlyZWRQcm9wcy5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcImhyZWZcIikge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldID09IG51bGwgfHwgdHlwZW9mIHByb3BzW2tleV0gIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHByb3BzW2tleV0gIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcImBzdHJpbmdgIG9yIGBvYmplY3RgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHByb3BzW2tleV0gPT09IG51bGwgPyBcIm51bGxcIiA6IHR5cGVvZiBwcm9wc1trZXldXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgICAgICAgY29uc3QgXyA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIGNvbnN0IG9wdGlvbmFsUHJvcHNHdWFyZCA9IHtcbiAgICAgICAgICAgIGFzOiB0cnVlLFxuICAgICAgICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgICAgIHNjcm9sbDogdHJ1ZSxcbiAgICAgICAgICAgIHNoYWxsb3c6IHRydWUsXG4gICAgICAgICAgICBwYXNzSHJlZjogdHJ1ZSxcbiAgICAgICAgICAgIHByZWZldGNoOiB0cnVlLFxuICAgICAgICAgICAgbG9jYWxlOiB0cnVlLFxuICAgICAgICAgICAgb25DbGljazogdHJ1ZSxcbiAgICAgICAgICAgIG9uTW91c2VFbnRlcjogdHJ1ZSxcbiAgICAgICAgICAgIG9uVG91Y2hTdGFydDogdHJ1ZSxcbiAgICAgICAgICAgIGxlZ2FjeUJlaGF2aW9yOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9wdGlvbmFsUHJvcHMgPSBPYmplY3Qua2V5cyhvcHRpb25hbFByb3BzR3VhcmQpO1xuICAgICAgICBvcHRpb25hbFByb3BzLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgIGNvbnN0IHZhbFR5cGUgPSB0eXBlb2YgcHJvcHNba2V5XTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwiYXNcIikge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldICYmIHZhbFR5cGUgIT09IFwic3RyaW5nXCIgJiYgdmFsVHlwZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiYHN0cmluZ2Agb3IgYG9iamVjdGBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJsb2NhbGVcIikge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldICYmIHZhbFR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcImBzdHJpbmdgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwib25DbGlja1wiIHx8IGtleSA9PT0gXCJvbk1vdXNlRW50ZXJcIiB8fCBrZXkgPT09IFwib25Ub3VjaFN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcImBmdW5jdGlvbmBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJyZXBsYWNlXCIgfHwga2V5ID09PSBcInNjcm9sbFwiIHx8IGtleSA9PT0gXCJzaGFsbG93XCIgfHwga2V5ID09PSBcInBhc3NIcmVmXCIgfHwga2V5ID09PSBcInByZWZldGNoXCIgfHwga2V5ID09PSBcImxlZ2FjeUJlaGF2aW9yXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSAhPSBudWxsICYmIHZhbFR5cGUgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJgYm9vbGVhbmBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgICAgIGNvbnN0IF8gPSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUaGlzIGhvb2sgaXMgaW4gYSBjb25kaXRpb25hbCBidXQgdGhhdCBpcyBvayBiZWNhdXNlIGBwcm9jZXNzLmVudi5OT0RFX0VOVmAgbmV2ZXIgY2hhbmdlc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICAgICAgY29uc3QgaGFzV2FybmVkID0gX3JlYWN0LmRlZmF1bHQudXNlUmVmKGZhbHNlKTtcbiAgICAgICAgaWYgKHByb3BzLnByZWZldGNoICYmICFoYXNXYXJuZWQuY3VycmVudCAmJiAhaXNBcHBSb3V0ZXIpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIk5leHQuanMgYXV0by1wcmVmZXRjaGVzIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gdmlld3BvcnQuIFRoZSBwcmVmZXRjaCBhdHRyaWJ1dGUgaXMgbm8gbG9uZ2VyIG5lZWRlZC4gTW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvcHJlZmV0Y2gtdHJ1ZS1kZXByZWNhdGVkXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKGlzQXBwUm91dGVyICYmICFhc1Byb3ApIHtcbiAgICAgICAgICAgIGxldCBocmVmO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBocmVmUHJvcCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGhyZWYgPSBocmVmUHJvcDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGhyZWZQcm9wID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBocmVmUHJvcC5wYXRobmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGhyZWYgPSBocmVmUHJvcC5wYXRobmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChocmVmKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzRHluYW1pY1NlZ21lbnQgPSBocmVmLnNwbGl0KFwiL1wiKS5zb21lKChzZWdtZW50KT0+c2VnbWVudC5zdGFydHNXaXRoKFwiW1wiKSAmJiBzZWdtZW50LmVuZHNXaXRoKFwiXVwiKSk7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0R5bmFtaWNTZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR5bmFtaWMgaHJlZiBgXCIgKyBocmVmICsgXCJgIGZvdW5kIGluIDxMaW5rPiB3aGlsZSB1c2luZyB0aGUgYC9hcHBgIHJvdXRlciwgdGhpcyBpcyBub3Qgc3VwcG9ydGVkLiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2FwcC1kaXItZHluYW1pYy1ocmVmXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7IGhyZWYgLCBhcyAgfSA9IF9yZWFjdC5kZWZhdWx0LnVzZU1lbW8oKCk9PntcbiAgICAgICAgaWYgKCFwYWdlc1JvdXRlcikge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRIcmVmID0gZm9ybWF0U3RyaW5nT3JVcmwoaHJlZlByb3ApO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBocmVmOiByZXNvbHZlZEhyZWYsXG4gICAgICAgICAgICAgICAgYXM6IGFzUHJvcCA/IGZvcm1hdFN0cmluZ09yVXJsKGFzUHJvcCkgOiByZXNvbHZlZEhyZWZcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3Jlc29sdmVkSHJlZiwgcmVzb2x2ZWRBc10gPSAoMCwgX3Jlc29sdmVocmVmLnJlc29sdmVIcmVmKShwYWdlc1JvdXRlciwgaHJlZlByb3AsIHRydWUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaHJlZjogcmVzb2x2ZWRIcmVmLFxuICAgICAgICAgICAgYXM6IGFzUHJvcCA/ICgwLCBfcmVzb2x2ZWhyZWYucmVzb2x2ZUhyZWYpKHBhZ2VzUm91dGVyLCBhc1Byb3ApIDogcmVzb2x2ZWRBcyB8fCByZXNvbHZlZEhyZWZcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIHBhZ2VzUm91dGVyLFxuICAgICAgICBocmVmUHJvcCxcbiAgICAgICAgYXNQcm9wXG4gICAgXSk7XG4gICAgY29uc3QgcHJldmlvdXNIcmVmID0gX3JlYWN0LmRlZmF1bHQudXNlUmVmKGhyZWYpO1xuICAgIGNvbnN0IHByZXZpb3VzQXMgPSBfcmVhY3QuZGVmYXVsdC51c2VSZWYoYXMpO1xuICAgIC8vIFRoaXMgd2lsbCByZXR1cm4gdGhlIGZpcnN0IGNoaWxkLCBpZiBtdWx0aXBsZSBhcmUgcHJvdmlkZWQgaXQgd2lsbCB0aHJvdyBhbiBlcnJvclxuICAgIGxldCBjaGlsZDtcbiAgICBpZiAobGVnYWN5QmVoYXZpb3IpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdcIm9uQ2xpY2tcIiB3YXMgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIGBocmVmYCBvZiBgJyArIGhyZWZQcm9wICsgJ2AgYnV0IFwibGVnYWN5QmVoYXZpb3JcIiB3YXMgc2V0LiBUaGUgbGVnYWN5IGJlaGF2aW9yIHJlcXVpcmVzIG9uQ2xpY2sgYmUgc2V0IG9uIHRoZSBjaGlsZCBvZiBuZXh0L2xpbmsnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbk1vdXNlRW50ZXJQcm9wKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdcIm9uTW91c2VFbnRlclwiIHdhcyBwYXNzZWQgdG8gPExpbms+IHdpdGggYGhyZWZgIG9mIGAnICsgaHJlZlByb3AgKyAnYCBidXQgXCJsZWdhY3lCZWhhdmlvclwiIHdhcyBzZXQuIFRoZSBsZWdhY3kgYmVoYXZpb3IgcmVxdWlyZXMgb25Nb3VzZUVudGVyIGJlIHNldCBvbiB0aGUgY2hpbGQgb2YgbmV4dC9saW5rJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNoaWxkcmVuIHdlcmUgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIGBocmVmYCBvZiBgXCIgKyBocmVmUHJvcCArIFwiYCBidXQgb25lIGNoaWxkIGlzIHJlcXVpcmVkIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2xpbmstbm8tY2hpbGRyZW5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11bHRpcGxlIGNoaWxkcmVuIHdlcmUgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIGBocmVmYCBvZiBgXCIgKyBocmVmUHJvcCArIFwiYCBidXQgb25seSBvbmUgY2hpbGQgaXMgc3VwcG9ydGVkIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2xpbmstbXVsdGlwbGUtY2hpbGRyZW5cIiArICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gXCIgXFxuT3BlbiB5b3VyIGJyb3dzZXIncyBjb25zb2xlIHRvIHZpZXcgdGhlIENvbXBvbmVudCBzdGFjayB0cmFjZS5cIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkID0gX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICAgICAgaWYgKChjaGlsZHJlbiA9PSBudWxsID8gdm9pZCAwIDogY2hpbGRyZW4udHlwZSkgPT09IFwiYVwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCA8TGluaz4gd2l0aCA8YT4gY2hpbGQuIFBsZWFzZSByZW1vdmUgPGE+IG9yIHVzZSA8TGluayBsZWdhY3lCZWhhdmlvcj4uXFxuTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvaW52YWxpZC1uZXctbGluay13aXRoLWV4dHJhLWFuY2hvclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjaGlsZFJlZiA9IGxlZ2FjeUJlaGF2aW9yID8gY2hpbGQgJiYgdHlwZW9mIGNoaWxkID09PSBcIm9iamVjdFwiICYmIGNoaWxkLnJlZiA6IGZvcndhcmRlZFJlZjtcbiAgICBjb25zdCBbc2V0SW50ZXJzZWN0aW9uUmVmLCBpc1Zpc2libGUsIHJlc2V0VmlzaWJsZV0gPSAoMCwgX3VzZWludGVyc2VjdGlvbi51c2VJbnRlcnNlY3Rpb24pKHtcbiAgICAgICAgcm9vdE1hcmdpbjogXCIyMDBweFwiXG4gICAgfSk7XG4gICAgY29uc3Qgc2V0UmVmID0gX3JlYWN0LmRlZmF1bHQudXNlQ2FsbGJhY2soKGVsKT0+e1xuICAgICAgICAvLyBCZWZvcmUgdGhlIGxpbmsgZ2V0dGluZyBvYnNlcnZlZCwgY2hlY2sgaWYgdmlzaWJsZSBzdGF0ZSBuZWVkIHRvIGJlIHJlc2V0XG4gICAgICAgIGlmIChwcmV2aW91c0FzLmN1cnJlbnQgIT09IGFzIHx8IHByZXZpb3VzSHJlZi5jdXJyZW50ICE9PSBocmVmKSB7XG4gICAgICAgICAgICByZXNldFZpc2libGUoKTtcbiAgICAgICAgICAgIHByZXZpb3VzQXMuY3VycmVudCA9IGFzO1xuICAgICAgICAgICAgcHJldmlvdXNIcmVmLmN1cnJlbnQgPSBocmVmO1xuICAgICAgICB9XG4gICAgICAgIHNldEludGVyc2VjdGlvblJlZihlbCk7XG4gICAgICAgIGlmIChjaGlsZFJlZikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZFJlZiA9PT0gXCJmdW5jdGlvblwiKSBjaGlsZFJlZihlbCk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2hpbGRSZWYgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFJlZi5jdXJyZW50ID0gZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGFzLFxuICAgICAgICBjaGlsZFJlZixcbiAgICAgICAgaHJlZixcbiAgICAgICAgcmVzZXRWaXNpYmxlLFxuICAgICAgICBzZXRJbnRlcnNlY3Rpb25SZWZcbiAgICBdKTtcbiAgICAvLyBQcmVmZXRjaCB0aGUgVVJMIGlmIHdlIGhhdmVuJ3QgYWxyZWFkeSBhbmQgaXQncyB2aXNpYmxlLlxuICAgIF9yZWFjdC5kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAvLyBpbiBkZXYsIHdlIG9ubHkgcHJlZmV0Y2ggb24gaG92ZXIgdG8gYXZvaWQgd2FzdGluZyByZXNvdXJjZXMgYXMgdGhlIHByZWZldGNoIHdpbGwgdHJpZ2dlciBjb21waWxpbmcgdGhlIHBhZ2UuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJvdXRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGRvbid0IG5lZWQgdG8gcHJlZmV0Y2ggdGhlIFVSTCwgZG9uJ3QgZG8gcHJlZmV0Y2guXG4gICAgICAgIGlmICghaXNWaXNpYmxlIHx8ICFwcmVmZXRjaEVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmVmZXRjaCB0aGUgVVJMLlxuICAgICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7XG4gICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAga2luZDogYXBwUHJlZmV0Y2hLaW5kXG4gICAgICAgIH0sIGlzQXBwUm91dGVyKTtcbiAgICB9LCBbXG4gICAgICAgIGFzLFxuICAgICAgICBocmVmLFxuICAgICAgICBpc1Zpc2libGUsXG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgcHJlZmV0Y2hFbmFibGVkLFxuICAgICAgICBwYWdlc1JvdXRlciA9PSBudWxsID8gdm9pZCAwIDogcGFnZXNSb3V0ZXIubG9jYWxlLFxuICAgICAgICByb3V0ZXIsXG4gICAgICAgIGlzQXBwUm91dGVyLFxuICAgICAgICBhcHBQcmVmZXRjaEtpbmRcbiAgICBdKTtcbiAgICBjb25zdCBjaGlsZFByb3BzID0ge1xuICAgICAgICByZWY6IHNldFJlZixcbiAgICAgICAgb25DbGljayAoZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGlmICghZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBvbmVudCByZW5kZXJlZCBpbnNpZGUgbmV4dC9saW5rIGhhcyB0byBwYXNzIGNsaWNrIGV2ZW50IHRvIFwib25DbGlja1wiIHByb3AuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFsZWdhY3lCZWhhdmlvciAmJiB0eXBlb2Ygb25DbGljayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgb25DbGljayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWdhY3lCZWhhdmlvciAmJiBjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25DbGljayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQucHJvcHMub25DbGljayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmtDbGlja2VkKGUsIHJvdXRlciwgaHJlZiwgYXMsIHJlcGxhY2UsIHNoYWxsb3csIHNjcm9sbCwgbG9jYWxlLCBpc0FwcFJvdXRlciwgcHJlZmV0Y2hFbmFibGVkKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Nb3VzZUVudGVyIChlKSB7XG4gICAgICAgICAgICBpZiAoIWxlZ2FjeUJlaGF2aW9yICYmIHR5cGVvZiBvbk1vdXNlRW50ZXJQcm9wID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBvbk1vdXNlRW50ZXJQcm9wKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZ2FjeUJlaGF2aW9yICYmIGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNoaWxkLnByb3BzLm9uTW91c2VFbnRlcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwcmVmZXRjaEVuYWJsZWQgJiYgaXNBcHBSb3V0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7XG4gICAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICAgIHByaW9yaXR5OiB0cnVlLFxuICAgICAgICAgICAgICAgIC8vIEBzZWUge2h0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9kaXNjdXNzaW9ucy80MDI2OD9zb3J0PXRvcCNkaXNjdXNzaW9uY29tbWVudC0zNTcyNjQyfVxuICAgICAgICAgICAgICAgIGJ5cGFzc1ByZWZldGNoZWRDaGVjazogdHJ1ZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtpbmQ6IGFwcFByZWZldGNoS2luZFxuICAgICAgICAgICAgfSwgaXNBcHBSb3V0ZXIpO1xuICAgICAgICB9LFxuICAgICAgICBvblRvdWNoU3RhcnQgKGUpIHtcbiAgICAgICAgICAgIGlmICghbGVnYWN5QmVoYXZpb3IgJiYgdHlwZW9mIG9uVG91Y2hTdGFydFByb3AgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG9uVG91Y2hTdGFydFByb3AoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVnYWN5QmVoYXZpb3IgJiYgY2hpbGQucHJvcHMgJiYgdHlwZW9mIGNoaWxkLnByb3BzLm9uVG91Y2hTdGFydCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQucHJvcHMub25Ub3VjaFN0YXJ0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyb3V0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXByZWZldGNoRW5hYmxlZCAmJiBpc0FwcFJvdXRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIHtcbiAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgcHJpb3JpdHk6IHRydWUsXG4gICAgICAgICAgICAgICAgLy8gQHNlZSB7aHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL2Rpc2N1c3Npb25zLzQwMjY4P3NvcnQ9dG9wI2Rpc2N1c3Npb25jb21tZW50LTM1NzI2NDJ9XG4gICAgICAgICAgICAgICAgYnlwYXNzUHJlZmV0Y2hlZENoZWNrOiB0cnVlXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAga2luZDogYXBwUHJlZmV0Y2hLaW5kXG4gICAgICAgICAgICB9LCBpc0FwcFJvdXRlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIElmIGNoaWxkIGlzIGFuIDxhPiB0YWcgYW5kIGRvZXNuJ3QgaGF2ZSBhIGhyZWYgYXR0cmlidXRlLCBvciBpZiB0aGUgJ3Bhc3NIcmVmJyBwcm9wZXJ0eSBpc1xuICAgIC8vIGRlZmluZWQsIHdlIHNwZWNpZnkgdGhlIGN1cnJlbnQgJ2hyZWYnLCBzbyB0aGF0IHJlcGV0aXRpb24gaXMgbm90IG5lZWRlZCBieSB0aGUgdXNlci5cbiAgICAvLyBJZiB0aGUgdXJsIGlzIGFic29sdXRlLCB3ZSBjYW4gYnlwYXNzIHRoZSBsb2dpYyB0byBwcmVwZW5kIHRoZSBkb21haW4gYW5kIGxvY2FsZS5cbiAgICBpZiAoKDAsIF91dGlscy5pc0Fic29sdXRlVXJsKShhcykpIHtcbiAgICAgICAgY2hpbGRQcm9wcy5ocmVmID0gYXM7XG4gICAgfSBlbHNlIGlmICghbGVnYWN5QmVoYXZpb3IgfHwgcGFzc0hyZWYgfHwgY2hpbGQudHlwZSA9PT0gXCJhXCIgJiYgIShcImhyZWZcIiBpbiBjaGlsZC5wcm9wcykpIHtcbiAgICAgICAgY29uc3QgY3VyTG9jYWxlID0gdHlwZW9mIGxvY2FsZSAhPT0gXCJ1bmRlZmluZWRcIiA/IGxvY2FsZSA6IHBhZ2VzUm91dGVyID09IG51bGwgPyB2b2lkIDAgOiBwYWdlc1JvdXRlci5sb2NhbGU7XG4gICAgICAgIC8vIHdlIG9ubHkgcmVuZGVyIGRvbWFpbiBsb2NhbGVzIGlmIHdlIGFyZSBjdXJyZW50bHkgb24gYSBkb21haW4gbG9jYWxlXG4gICAgICAgIC8vIHNvIHRoYXQgbG9jYWxlIGxpbmtzIGFyZSBzdGlsbCB2aXNpdGFibGUgaW4gZGV2ZWxvcG1lbnQvcHJldmlldyBlbnZzXG4gICAgICAgIGNvbnN0IGxvY2FsZURvbWFpbiA9IChwYWdlc1JvdXRlciA9PSBudWxsID8gdm9pZCAwIDogcGFnZXNSb3V0ZXIuaXNMb2NhbGVEb21haW4pICYmICgwLCBfZ2V0ZG9tYWlubG9jYWxlLmdldERvbWFpbkxvY2FsZSkoYXMsIGN1ckxvY2FsZSwgcGFnZXNSb3V0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHBhZ2VzUm91dGVyLmxvY2FsZXMsIHBhZ2VzUm91dGVyID09IG51bGwgPyB2b2lkIDAgOiBwYWdlc1JvdXRlci5kb21haW5Mb2NhbGVzKTtcbiAgICAgICAgY2hpbGRQcm9wcy5ocmVmID0gbG9jYWxlRG9tYWluIHx8ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkoYXMsIGN1ckxvY2FsZSwgcGFnZXNSb3V0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHBhZ2VzUm91dGVyLmRlZmF1bHRMb2NhbGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZ2FjeUJlaGF2aW9yID8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jbG9uZUVsZW1lbnQoY2hpbGQsIGNoaWxkUHJvcHMpIDogLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7XG4gICAgICAgIC4uLnJlc3RQcm9wcyxcbiAgICAgICAgLi4uY2hpbGRQcm9wc1xuICAgIH0sIGNoaWxkcmVuKTtcbn0pO1xuY29uc3QgX2RlZmF1bHQgPSBMaW5rO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW5rLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJfZGVmYXVsdCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfcmVhY3QiLCJfIiwiX3Jlc29sdmVocmVmIiwiX2lzbG9jYWx1cmwiLCJfZm9ybWF0dXJsIiwiX3V0aWxzIiwiX2FkZGxvY2FsZSIsIl9yb3V0ZXJjb250ZXh0IiwiX2FwcHJvdXRlcmNvbnRleHQiLCJfdXNlaW50ZXJzZWN0aW9uIiwiX2dldGRvbWFpbmxvY2FsZSIsIl9hZGRiYXNlcGF0aCIsIl9yb3V0ZXJyZWR1Y2VydHlwZXMiLCJwcmVmZXRjaGVkIiwiU2V0IiwicHJlZmV0Y2giLCJyb3V0ZXIiLCJocmVmIiwiYXMiLCJvcHRpb25zIiwiYXBwT3B0aW9ucyIsImlzQXBwUm91dGVyIiwiaXNMb2NhbFVSTCIsImJ5cGFzc1ByZWZldGNoZWRDaGVjayIsImxvY2FsZSIsInVuZGVmaW5lZCIsInByZWZldGNoZWRLZXkiLCJoYXMiLCJhZGQiLCJwcmVmZXRjaFByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNhdGNoIiwiZXJyIiwicHJvY2VzcyIsImlzTW9kaWZpZWRFdmVudCIsImV2ZW50IiwiZXZlbnRUYXJnZXQiLCJjdXJyZW50VGFyZ2V0IiwidGFyZ2V0IiwiZ2V0QXR0cmlidXRlIiwibWV0YUtleSIsImN0cmxLZXkiLCJzaGlmdEtleSIsImFsdEtleSIsIm5hdGl2ZUV2ZW50Iiwid2hpY2giLCJsaW5rQ2xpY2tlZCIsImUiLCJyZXBsYWNlIiwic2hhbGxvdyIsInNjcm9sbCIsInByZWZldGNoRW5hYmxlZCIsIm5vZGVOYW1lIiwiaXNBbmNob3JOb2RlTmFtZSIsInRvVXBwZXJDYXNlIiwicHJldmVudERlZmF1bHQiLCJuYXZpZ2F0ZSIsImZvcmNlT3B0aW1pc3RpY05hdmlnYXRpb24iLCJkZWZhdWx0Iiwic3RhcnRUcmFuc2l0aW9uIiwiZm9ybWF0U3RyaW5nT3JVcmwiLCJ1cmxPYmpPclN0cmluZyIsImZvcm1hdFVybCIsIkxpbmsiLCJmb3J3YXJkUmVmIiwiTGlua0NvbXBvbmVudCIsInByb3BzIiwiZm9yd2FyZGVkUmVmIiwiY2hpbGRyZW4iLCJocmVmUHJvcCIsImFzUHJvcCIsImNoaWxkcmVuUHJvcCIsInByZWZldGNoUHJvcCIsInBhc3NIcmVmIiwib25DbGljayIsIm9uTW91c2VFbnRlciIsIm9uTW91c2VFbnRlclByb3AiLCJvblRvdWNoU3RhcnQiLCJvblRvdWNoU3RhcnRQcm9wIiwibGVnYWN5QmVoYXZpb3IiLCJlbnYiLCJfX05FWFRfTkVXX0xJTktfQkVIQVZJT1IiLCJyZXN0UHJvcHMiLCJjcmVhdGVFbGVtZW50IiwiYXBwUHJlZmV0Y2hLaW5kIiwiUHJlZmV0Y2hLaW5kIiwiQVVUTyIsIkZVTEwiLCJwYWdlc1JvdXRlciIsInVzZUNvbnRleHQiLCJSb3V0ZXJDb250ZXh0IiwiYXBwUm91dGVyIiwiQXBwUm91dGVyQ29udGV4dCIsImNyZWF0ZVByb3BFcnJvciIsImFyZ3MiLCJFcnJvciIsImtleSIsImV4cGVjdGVkIiwiYWN0dWFsIiwicmVxdWlyZWRQcm9wc0d1YXJkIiwicmVxdWlyZWRQcm9wcyIsImtleXMiLCJmb3JFYWNoIiwib3B0aW9uYWxQcm9wc0d1YXJkIiwib3B0aW9uYWxQcm9wcyIsInZhbFR5cGUiLCJoYXNXYXJuZWQiLCJ1c2VSZWYiLCJjdXJyZW50IiwiY29uc29sZSIsIndhcm4iLCJwYXRobmFtZSIsImhhc0R5bmFtaWNTZWdtZW50Iiwic3BsaXQiLCJzb21lIiwic2VnbWVudCIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsInVzZU1lbW8iLCJyZXNvbHZlZEhyZWYiLCJyZXNvbHZlSHJlZiIsInJlc29sdmVkQXMiLCJwcmV2aW91c0hyZWYiLCJwcmV2aW91c0FzIiwiY2hpbGQiLCJDaGlsZHJlbiIsIm9ubHkiLCJ0eXBlIiwiY2hpbGRSZWYiLCJyZWYiLCJ1c2VJbnRlcnNlY3Rpb24iLCJyb290TWFyZ2luIiwic2V0SW50ZXJzZWN0aW9uUmVmIiwiaXNWaXNpYmxlIiwicmVzZXRWaXNpYmxlIiwic2V0UmVmIiwidXNlQ2FsbGJhY2siLCJlbCIsInVzZUVmZmVjdCIsImtpbmQiLCJjaGlsZFByb3BzIiwiZGVmYXVsdFByZXZlbnRlZCIsInByaW9yaXR5IiwiaXNBYnNvbHV0ZVVybCIsImN1ckxvY2FsZSIsImxvY2FsZURvbWFpbiIsImlzTG9jYWxlRG9tYWluIiwiZ2V0RG9tYWluTG9jYWxlIiwibG9jYWxlcyIsImRvbWFpbkxvY2FsZXMiLCJhZGRCYXNlUGF0aCIsImFkZExvY2FsZSIsImRlZmF1bHRMb2NhbGUiLCJjbG9uZUVsZW1lbnQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/link.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"./node_modules/@swc/helpers/esm/_sliced_to_array.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useIntersection\", ({\n    enumerable: true,\n    get: function get() {\n        return useIntersection;\n    }\n}));\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar _requestidlecallback = __webpack_require__(/*! ./request-idle-callback */ \"./node_modules/next/dist/client/request-idle-callback.js\");\nvar hasIntersectionObserver = typeof IntersectionObserver === \"function\";\nvar observers = new Map();\nvar idList = [];\nfunction createObserver(options) {\n    var id = {\n        root: options.root || null,\n        margin: options.rootMargin || \"\"\n    };\n    var existing = idList.find(function(obj) {\n        return obj.root === id.root && obj.margin === id.margin;\n    });\n    var instance;\n    if (existing) {\n        instance = observers.get(existing);\n        if (instance) {\n            return instance;\n        }\n    }\n    var elements = new Map();\n    var observer = new IntersectionObserver(function(entries) {\n        entries.forEach(function(entry) {\n            var callback = elements.get(entry.target);\n            var isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    instance = {\n        id: id,\n        observer: observer,\n        elements: elements\n    };\n    idList.push(id);\n    observers.set(id, instance);\n    return instance;\n}\nfunction observe(element, callback, options) {\n    var _createObserver = createObserver(options), id = _createObserver.id, observer = _createObserver.observer, elements = _createObserver.elements;\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements[\"delete\"](element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers[\"delete\"](id);\n            var index = idList.findIndex(function(obj) {\n                return obj.root === id.root && obj.margin === id.margin;\n            });\n            if (index > -1) {\n                idList.splice(index, 1);\n            }\n        }\n    };\n}\nfunction useIntersection(param) {\n    var rootRef = param.rootRef, rootMargin = param.rootMargin, disabled = param.disabled;\n    var isDisabled = disabled || !hasIntersectionObserver;\n    var _ref = _sliced_to_array._((0, _react.useState)(false), 2), visible = _ref[0], setVisible = _ref[1];\n    var elementRef = (0, _react.useRef)(null);\n    var setElement = (0, _react.useCallback)(function(element) {\n        elementRef.current = element;\n    }, []);\n    (0, _react.useEffect)(function() {\n        if (hasIntersectionObserver) {\n            if (isDisabled || visible) return;\n            var element = elementRef.current;\n            if (element && element.tagName) {\n                var unobserve = observe(element, function(isVisible) {\n                    return isVisible && setVisible(isVisible);\n                }, {\n                    root: rootRef == null ? void 0 : rootRef.current,\n                    rootMargin: rootMargin\n                });\n                return unobserve;\n            }\n        } else {\n            if (!visible) {\n                var idleCallback = (0, _requestidlecallback.requestIdleCallback)(function() {\n                    return setVisible(true);\n                });\n                return function() {\n                    return (0, _requestidlecallback.cancelIdleCallback)(idleCallback);\n                };\n            }\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        isDisabled,\n        rootMargin,\n        rootRef,\n        visible,\n        elementRef.current\n    ]);\n    var resetVisible = (0, _react.useCallback)(function() {\n        setVisible(false);\n    }, []);\n    return [\n        setElement,\n        visible,\n        resetVisible\n    ];\n}\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=use-intersection.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC91c2UtaW50ZXJzZWN0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOzs7OztBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsbURBQWtEO0lBQzlDSSxZQUFZO0lBQ1pDLEtBQUssU0FBTEE7UUFDSSxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsSUFBTUMsU0FBU0MsbUJBQU9BLENBQUMsNENBQU87QUFDOUIsSUFBTUMsdUJBQXVCRCxtQkFBT0EsQ0FBQyx5RkFBeUI7QUFDOUQsSUFBTUUsMEJBQTBCLE9BQU9DLHlCQUF5QjtBQUNoRSxJQUFNQyxZQUFZLElBQUlDO0FBQ3RCLElBQU1DLFNBQVMsRUFBRTtBQUNqQixTQUFTQyxlQUFlQyxPQUFPO0lBQzNCLElBQU1DLEtBQUs7UUFDUEMsTUFBTUYsUUFBUUUsUUFBUTtRQUN0QkMsUUFBUUgsUUFBUUksY0FBYztJQUNsQztJQUNBLElBQU1DLFdBQVdQLE9BQU9RLEtBQUssU0FBQ0M7ZUFBTUEsSUFBSUwsU0FBU0QsR0FBR0MsUUFBUUssSUFBSUosV0FBV0YsR0FBR0U7O0lBQzlFLElBQUlLO0lBQ0osSUFBSUgsVUFBVTtRQUNWRyxXQUFXWixVQUFVUCxJQUFJZ0I7UUFDekIsSUFBSUcsVUFBVTtZQUNWLE9BQU9BO1FBQ1g7SUFDSjtJQUNBLElBQU1DLFdBQVcsSUFBSVo7SUFDckIsSUFBTWEsV0FBVyxJQUFJZixxQkFBcUIsU0FBQ2dCO1FBQ3ZDQSxRQUFRQyxRQUFRLFNBQUNDO1lBQ2IsSUFBTUMsV0FBV0wsU0FBU3BCLElBQUl3QixNQUFNRTtZQUNwQyxJQUFNQyxZQUFZSCxNQUFNSSxrQkFBa0JKLE1BQU1LLG9CQUFvQjtZQUNwRSxJQUFJSixZQUFZRSxXQUFXO2dCQUN2QkYsU0FBU0U7WUFDYjtRQUNKO0lBQ0osR0FBR2hCO0lBQ0hRLFdBQVc7UUFDUFAsSUFBQUE7UUFDQVMsVUFBQUE7UUFDQUQsVUFBQUE7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QU87QUFDbEMsRUFFQSw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvdXNlLWludGVyc2VjdGlvbi5qcz9mZDk0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidXNlSW50ZXJzZWN0aW9uXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB1c2VJbnRlcnNlY3Rpb247XG4gICAgfVxufSk7XG5jb25zdCBfcmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG5jb25zdCBfcmVxdWVzdGlkbGVjYWxsYmFjayA9IHJlcXVpcmUoXCIuL3JlcXVlc3QtaWRsZS1jYWxsYmFja1wiKTtcbmNvbnN0IGhhc0ludGVyc2VjdGlvbk9ic2VydmVyID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09PSBcImZ1bmN0aW9uXCI7XG5jb25zdCBvYnNlcnZlcnMgPSBuZXcgTWFwKCk7XG5jb25zdCBpZExpc3QgPSBbXTtcbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmVyKG9wdGlvbnMpIHtcbiAgICBjb25zdCBpZCA9IHtcbiAgICAgICAgcm9vdDogb3B0aW9ucy5yb290IHx8IG51bGwsXG4gICAgICAgIG1hcmdpbjogb3B0aW9ucy5yb290TWFyZ2luIHx8IFwiXCJcbiAgICB9O1xuICAgIGNvbnN0IGV4aXN0aW5nID0gaWRMaXN0LmZpbmQoKG9iaik9Pm9iai5yb290ID09PSBpZC5yb290ICYmIG9iai5tYXJnaW4gPT09IGlkLm1hcmdpbik7XG4gICAgbGV0IGluc3RhbmNlO1xuICAgIGlmIChleGlzdGluZykge1xuICAgICAgICBpbnN0YW5jZSA9IG9ic2VydmVycy5nZXQoZXhpc3RpbmcpO1xuICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcigoZW50cmllcyk9PntcbiAgICAgICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSk9PntcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gZWxlbWVudHMuZ2V0KGVudHJ5LnRhcmdldCk7XG4gICAgICAgICAgICBjb25zdCBpc1Zpc2libGUgPSBlbnRyeS5pc0ludGVyc2VjdGluZyB8fCBlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyA+IDA7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sgJiYgaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soaXNWaXNpYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSwgb3B0aW9ucyk7XG4gICAgaW5zdGFuY2UgPSB7XG4gICAgICAgIGlkLFxuICAgICAgICBvYnNlcnZlcixcbiAgICAgICAgZWxlbWVudHNcbiAgICB9O1xuICAgIGlkTGlzdC5wdXNoKGlkKTtcbiAgICBvYnNlcnZlcnMuc2V0KGlkLCBpbnN0YW5jZSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gb2JzZXJ2ZShlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgaWQgLCBvYnNlcnZlciAsIGVsZW1lbnRzICB9ID0gY3JlYXRlT2JzZXJ2ZXIob3B0aW9ucyk7XG4gICAgZWxlbWVudHMuc2V0KGVsZW1lbnQsIGNhbGxiYWNrKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bm9ic2VydmUoKSB7XG4gICAgICAgIGVsZW1lbnRzLmRlbGV0ZShlbGVtZW50KTtcbiAgICAgICAgb2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpO1xuICAgICAgICAvLyBEZXN0cm95IG9ic2VydmVyIHdoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gd2F0Y2g6XG4gICAgICAgIGlmIChlbGVtZW50cy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBvYnNlcnZlcnMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gaWRMaXN0LmZpbmRJbmRleCgob2JqKT0+b2JqLnJvb3QgPT09IGlkLnJvb3QgJiYgb2JqLm1hcmdpbiA9PT0gaWQubWFyZ2luKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaWRMaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gdXNlSW50ZXJzZWN0aW9uKHBhcmFtKSB7XG4gICAgbGV0IHsgcm9vdFJlZiAsIHJvb3RNYXJnaW4gLCBkaXNhYmxlZCAgfSA9IHBhcmFtO1xuICAgIGNvbnN0IGlzRGlzYWJsZWQgPSBkaXNhYmxlZCB8fCAhaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXI7XG4gICAgY29uc3QgW3Zpc2libGUsIHNldFZpc2libGVdID0gKDAsIF9yZWFjdC51c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGNvbnN0IGVsZW1lbnRSZWYgPSAoMCwgX3JlYWN0LnVzZVJlZikobnVsbCk7XG4gICAgY29uc3Qgc2V0RWxlbWVudCA9ICgwLCBfcmVhY3QudXNlQ2FsbGJhY2spKChlbGVtZW50KT0+e1xuICAgICAgICBlbGVtZW50UmVmLmN1cnJlbnQgPSBlbGVtZW50O1xuICAgIH0sIFtdKTtcbiAgICAoMCwgX3JlYWN0LnVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKGhhc0ludGVyc2VjdGlvbk9ic2VydmVyKSB7XG4gICAgICAgICAgICBpZiAoaXNEaXNhYmxlZCB8fCB2aXNpYmxlKSByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudFJlZi5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC50YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5vYnNlcnZlID0gb2JzZXJ2ZShlbGVtZW50LCAoaXNWaXNpYmxlKT0+aXNWaXNpYmxlICYmIHNldFZpc2libGUoaXNWaXNpYmxlKSwge1xuICAgICAgICAgICAgICAgICAgICByb290OiByb290UmVmID09IG51bGwgPyB2b2lkIDAgOiByb290UmVmLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgIHJvb3RNYXJnaW5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5vYnNlcnZlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF2aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWRsZUNhbGxiYWNrID0gKDAsIF9yZXF1ZXN0aWRsZWNhbGxiYWNrLnJlcXVlc3RJZGxlQ2FsbGJhY2spKCgpPT5zZXRWaXNpYmxlKHRydWUpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCk9PigwLCBfcmVxdWVzdGlkbGVjYWxsYmFjay5jYW5jZWxJZGxlQ2FsbGJhY2spKGlkbGVDYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgfSwgW1xuICAgICAgICBpc0Rpc2FibGVkLFxuICAgICAgICByb290TWFyZ2luLFxuICAgICAgICByb290UmVmLFxuICAgICAgICB2aXNpYmxlLFxuICAgICAgICBlbGVtZW50UmVmLmN1cnJlbnRcbiAgICBdKTtcbiAgICBjb25zdCByZXNldFZpc2libGUgPSAoMCwgX3JlYWN0LnVzZUNhbGxiYWNrKSgoKT0+e1xuICAgICAgICBzZXRWaXNpYmxlKGZhbHNlKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc2V0RWxlbWVudCxcbiAgICAgICAgdmlzaWJsZSxcbiAgICAgICAgcmVzZXRWaXNpYmxlXG4gICAgXTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWludGVyc2VjdGlvbi5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwidXNlSW50ZXJzZWN0aW9uIiwiX3JlYWN0IiwicmVxdWlyZSIsIl9yZXF1ZXN0aWRsZWNhbGxiYWNrIiwiaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsIm9ic2VydmVycyIsIk1hcCIsImlkTGlzdCIsImNyZWF0ZU9ic2VydmVyIiwib3B0aW9ucyIsImlkIiwicm9vdCIsIm1hcmdpbiIsInJvb3RNYXJnaW4iLCJleGlzdGluZyIsImZpbmQiLCJvYmoiLCJpbnN0YW5jZSIsImVsZW1lbnRzIiwib2JzZXJ2ZXIiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImVudHJ5IiwiY2FsbGJhY2siLCJ0YXJnZXQiLCJpc1Zpc2libGUiLCJpc0ludGVyc2VjdGluZyIsImludGVyc2VjdGlvblJhdGlvIiwicHVzaCIsInNldCIsIm9ic2VydmUiLCJlbGVtZW50IiwidW5vYnNlcnZlIiwiZGVsZXRlIiwic2l6ZSIsImRpc2Nvbm5lY3QiLCJpbmRleCIsImZpbmRJbmRleCIsInNwbGljZSIsInBhcmFtIiwicm9vdFJlZiIsImRpc2FibGVkIiwiaXNEaXNhYmxlZCIsInVzZVN0YXRlIiwidmlzaWJsZSIsInNldFZpc2libGUiLCJlbGVtZW50UmVmIiwidXNlUmVmIiwic2V0RWxlbWVudCIsInVzZUNhbGxiYWNrIiwiY3VycmVudCIsInVzZUVmZmVjdCIsInRhZ05hbWUiLCJpZGxlQ2FsbGJhY2siLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwiY2FuY2VsSWRsZUNhbGxiYWNrIiwicmVzZXRWaXNpYmxlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/use-intersection.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/image-blur-svg.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-blur-svg.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * A shared function, used on both client and server, to generate a SVG blur placeholder.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImageBlurSvg\", ({\n    enumerable: true,\n    get: function get() {\n        return getImageBlurSvg;\n    }\n}));\nfunction getImageBlurSvg(param) {\n    var widthInt = param.widthInt, heightInt = param.heightInt, blurWidth = param.blurWidth, blurHeight = param.blurHeight, blurDataURL = param.blurDataURL, objectFit = param.objectFit;\n    var std = blurWidth && blurHeight ? \"1\" : \"20\";\n    var svgWidth = blurWidth || widthInt;\n    var svgHeight = blurHeight || heightInt;\n    var feComponentTransfer = blurDataURL.startsWith(\"data:image/jpeg\") ? \"%3CfeComponentTransfer%3E%3CfeFuncA type='discrete' tableValues='1 1'/%3E%3C/feComponentTransfer%3E%\" : \"\";\n    if (svgWidth && svgHeight) {\n        return \"%3Csvg xmlns='http%3A//www.w3.org/2000/svg' viewBox='0 0 \" + svgWidth + \" \" + svgHeight + \"'%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E\" + feComponentTransfer + \"%3C/filter%3E%3Cimage preserveAspectRatio='none' filter='url(%23b)' x='0' y='0' height='100%25' width='100%25' href='\" + blurDataURL + \"'/%3E%3C/svg%3E\";\n    }\n    var preserveAspectRatio = objectFit === \"contain\" ? \"xMidYMid\" : objectFit === \"cover\" ? \"xMidYMid slice\" : \"none\";\n    return \"%3Csvg xmlns='http%3A//www.w3.org/2000/svg'%3E%3Cimage style='filter:blur(20px)' preserveAspectRatio='\" + preserveAspectRatio + \"' x='0' y='0' height='100%25' width='100%25' href='\" + blurDataURL + \"'/%3E%3C/svg%3E\";\n} //# sourceMappingURL=image-blur-svg.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtYmx1ci1zdmcuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0NBRUMsR0FBZ0I7QUFDakJBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCxtREFBa0Q7SUFDOUNJLFlBQVk7SUFDWkMsS0FBSyxTQUFMQTtRQUNJLE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixTQUFTQSxnQkFBZ0JDLEtBQUs7SUFDMUIsSUFBTUMsV0FBNkVELE1BQTdFQyxVQUFXQyxZQUFrRUYsTUFBbEVFLFdBQVlDLFlBQXNESCxNQUF0REcsV0FBWUMsYUFBMENKLE1BQTFDSSxZQUFhQyxjQUE2QkwsTUFBN0JLLGFBQWNDLFlBQWVOLE1BQWZNO0lBQ3BFLElBQU1DLE1BQU1KLGFBQWFDLGFBQWEsTUFBTTtJQUM1QyxJQUFNSSxXQUFXTCxhQUFhRjtJQUM5QixJQUFNUSxZQUFZTCxjQUFjRjtJQUNoQyxJQUFNUSxzQkFBc0JMLFlBQVlNLFdBQVcscUJBQXFCLHlHQUF5RztJQUNqTCxJQUFJSCxZQUFZQyxXQUFXO1FBQ3ZCLE9BQU8sOERBQThERCxXQUFXLE1BQU1DLFlBQVksK0ZBQStGRixNQUFNLFVBQVVHLHNCQUFzQiwwSEFBMEhMLGNBQWM7SUFDblg7SUFDQSxJQUFNTyxzQkFBc0JOLGNBQWMsWUFBWSxhQUFhQSxjQUFjLFVBQVUsbUJBQW1CO0lBQzlHLE9BQU8sMkdBQTJHTSxzQkFBc0Isd0RBQXdEUCxjQUFjO0FBQ2xOLEVBRUEsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1ibHVyLXN2Zy5qcz85NTcwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSBzaGFyZWQgZnVuY3Rpb24sIHVzZWQgb24gYm90aCBjbGllbnQgYW5kIHNlcnZlciwgdG8gZ2VuZXJhdGUgYSBTVkcgYmx1ciBwbGFjZWhvbGRlci5cbiAqLyBcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEltYWdlQmx1clN2Z1wiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0SW1hZ2VCbHVyU3ZnO1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gZ2V0SW1hZ2VCbHVyU3ZnKHBhcmFtKSB7XG4gICAgbGV0IHsgd2lkdGhJbnQgLCBoZWlnaHRJbnQgLCBibHVyV2lkdGggLCBibHVySGVpZ2h0ICwgYmx1ckRhdGFVUkwgLCBvYmplY3RGaXQgIH0gPSBwYXJhbTtcbiAgICBjb25zdCBzdGQgPSBibHVyV2lkdGggJiYgYmx1ckhlaWdodCA/IFwiMVwiIDogXCIyMFwiO1xuICAgIGNvbnN0IHN2Z1dpZHRoID0gYmx1cldpZHRoIHx8IHdpZHRoSW50O1xuICAgIGNvbnN0IHN2Z0hlaWdodCA9IGJsdXJIZWlnaHQgfHwgaGVpZ2h0SW50O1xuICAgIGNvbnN0IGZlQ29tcG9uZW50VHJhbnNmZXIgPSBibHVyRGF0YVVSTC5zdGFydHNXaXRoKFwiZGF0YTppbWFnZS9qcGVnXCIpID8gXCIlM0NmZUNvbXBvbmVudFRyYW5zZmVyJTNFJTNDZmVGdW5jQSB0eXBlPSdkaXNjcmV0ZScgdGFibGVWYWx1ZXM9JzEgMScvJTNFJTNDL2ZlQ29tcG9uZW50VHJhbnNmZXIlM0UlXCIgOiBcIlwiO1xuICAgIGlmIChzdmdXaWR0aCAmJiBzdmdIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIFwiJTNDc3ZnIHhtbG5zPSdodHRwJTNBLy93d3cudzMub3JnLzIwMDAvc3ZnJyB2aWV3Qm94PScwIDAgXCIgKyBzdmdXaWR0aCArIFwiIFwiICsgc3ZnSGVpZ2h0ICsgXCInJTNFJTNDZmlsdGVyIGlkPSdiJyBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9J3NSR0InJTNFJTNDZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSdcIiArIHN0ZCArIFwiJy8lM0VcIiArIGZlQ29tcG9uZW50VHJhbnNmZXIgKyBcIiUzQy9maWx0ZXIlM0UlM0NpbWFnZSBwcmVzZXJ2ZUFzcGVjdFJhdGlvPSdub25lJyBmaWx0ZXI9J3VybCglMjNiKScgeD0nMCcgeT0nMCcgaGVpZ2h0PScxMDAlMjUnIHdpZHRoPScxMDAlMjUnIGhyZWY9J1wiICsgYmx1ckRhdGFVUkwgKyBcIicvJTNFJTNDL3N2ZyUzRVwiO1xuICAgIH1cbiAgICBjb25zdCBwcmVzZXJ2ZUFzcGVjdFJhdGlvID0gb2JqZWN0Rml0ID09PSBcImNvbnRhaW5cIiA/IFwieE1pZFlNaWRcIiA6IG9iamVjdEZpdCA9PT0gXCJjb3ZlclwiID8gXCJ4TWlkWU1pZCBzbGljZVwiIDogXCJub25lXCI7XG4gICAgcmV0dXJuIFwiJTNDc3ZnIHhtbG5zPSdodHRwJTNBLy93d3cudzMub3JnLzIwMDAvc3ZnJyUzRSUzQ2ltYWdlIHN0eWxlPSdmaWx0ZXI6Ymx1cigyMHB4KScgcHJlc2VydmVBc3BlY3RSYXRpbz0nXCIgKyBwcmVzZXJ2ZUFzcGVjdFJhdGlvICsgXCInIHg9JzAnIHk9JzAnIGhlaWdodD0nMTAwJTI1JyB3aWR0aD0nMTAwJTI1JyBocmVmPSdcIiArIGJsdXJEYXRhVVJMICsgXCInLyUzRSUzQy9zdmclM0VcIjtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UtYmx1ci1zdmcuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImdldEltYWdlQmx1clN2ZyIsInBhcmFtIiwid2lkdGhJbnQiLCJoZWlnaHRJbnQiLCJibHVyV2lkdGgiLCJibHVySGVpZ2h0IiwiYmx1ckRhdGFVUkwiLCJvYmplY3RGaXQiLCJzdGQiLCJzdmdXaWR0aCIsInN2Z0hlaWdodCIsImZlQ29tcG9uZW50VHJhbnNmZXIiLCJzdGFydHNXaXRoIiwicHJlc2VydmVBc3BlY3RSYXRpbyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/image-blur-svg.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/image-loader.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-loader.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function get() {\n        return _default;\n    }\n}));\nfunction defaultLoader(param) {\n    var config = param.config, src = param.src, width = param.width, quality = param.quality;\n    if (true) {\n        var missingValues = [];\n        // these should always be provided but make sure they are\n        if (!src) missingValues.push(\"src\");\n        if (!width) missingValues.push(\"width\");\n        if (missingValues.length > 0) {\n            throw new Error(\"Next Image Optimization requires \" + missingValues.join(\", \") + \" to be provided. Make sure you pass them as props to the `next/image` component. Received: \" + JSON.stringify({\n                src: src,\n                width: width,\n                quality: quality\n            }));\n        }\n        if (src.startsWith(\"//\")) {\n            throw new Error('Failed to parse src \"' + src + '\" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)');\n        }\n        if (!src.startsWith(\"/\") && (config.domains || config.remotePatterns)) {\n            var parsedSrc;\n            try {\n                parsedSrc = new URL(src);\n            } catch (err) {\n                console.error(err);\n                throw new Error('Failed to parse src \"' + src + '\" on `next/image`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)');\n            }\n            if (true) {\n                // We use dynamic require because this should only error in development\n                var hasMatch = (__webpack_require__(/*! ./match-remote-pattern */ \"./node_modules/next/dist/shared/lib/match-remote-pattern.js\").hasMatch);\n                if (!hasMatch(config.domains, config.remotePatterns, parsedSrc)) {\n                    throw new Error(\"Invalid src prop (\" + src + ') on `next/image`, hostname \"' + parsedSrc.hostname + '\" is not configured under images in your `next.config.js`\\n' + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host\");\n                }\n            }\n        }\n    }\n    return config.path + \"?url=\" + encodeURIComponent(src) + \"&w=\" + width + \"&q=\" + (quality || 75);\n}\n// We use this to determine if the import is the default loader\n// or a custom loader defined by the user in next.config.js\ndefaultLoader.__next_img_default = true;\nvar _default = defaultLoader; //# sourceMappingURL=image-loader.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtbG9hZGVyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCwyQ0FBMEM7SUFDdENJLFlBQVk7SUFDWkMsS0FBSyxTQUFMQTtRQUNJLE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixTQUFTQyxjQUFjQyxLQUFLO0lBQ3hCLElBQU1DLFNBQW9DRCxNQUFwQ0MsUUFBU0MsTUFBMkJGLE1BQTNCRSxLQUFNQyxRQUFxQkgsTUFBckJHLE9BQVFDLFVBQWFKLE1BQWJJO0lBQzdCLElBQUlDLElBQXFDLEVBQUU7UUFDdkMsSUFBTUMsZ0JBQWdCLEVBQUU7UUFDeEIseURBQXlEO1FBQ3pELElBQUksQ0FBQ0osS0FBS0ksY0FBY0MsS0FBSztRQUM3QixJQUFJLENBQUNKLE9BQU9HLGNBQWNDLEtBQUs7UUFDL0IsSUFBSUQsY0FBY0UsU0FBUyxHQUFHO1lBQzFCLE1BQU0sSUFBSUMsTUFBTSxzQ0FBc0NILGNBQWNJLEtBQUssUUFBUSxnR0FBZ0dDLEtBQUtDLFVBQVU7Z0JBQzVMVixLQUFBQTtnQkFDQUMsT0FBQUE7Z0JBQ0FDLFNBQUFBO1lBQ0o7UUFDSjtRQUNBLElBQUlGLElBQUlXLFdBQVcsT0FBTztZQUN0QixNQUFNLElBQUlKLE1BQU0sMEJBQTBCUCxNQUFNO1FBQ3BEO1FBQ0EsSUFBSSxDQUFDQSxJQUFJVyxXQUFXLFFBQVNaLENBQUFBLE9BQU9hLFdBQVdiLE9BQU9jLGNBQWEsR0FBSTtZQUNuRSxJQUFJQztZQUNKLElBQUk7Z0JBQ0FBLFlBQVksSUFBSUMsSUFBSWY7WUFDeEIsRUFBRSxPQUFPZ0IsS0FBSztnQkFDVkMsUUFBUUMsTUFBTUY7Z0JBQ2QsTUFBTSxJQUFJVCxNQUFNLDBCQUEwQlAsTUFBTTtZQUNwRDtZQUNBLElBQUlHLElBQytCLEVBQUU7Z0JBQ2pDLHVFQUF1RTtnQkFDdkUsSUFBTSxXQUFnQm1CLDJIQUFORDtnQkFDaEIsSUFBSSxDQUFDQSxTQUFTdEIsT0FBT2EsU0FBU2IsT0FBT2MsZ0JBQWdCQyxZQUFZO29CQUM3RCxNQUFNLElBQUlQLE1BQU0sdUJBQXVCUCxNQUFNLGtDQUFrQ2MsVUFBVVMsV0FBVyxnRUFBZ0U7Z0JBQ3hLO1lBQ0o7UUFDSjtJQUNKO0lBQ0EsT0FBT3hCLE9BQU95QixPQUFPLFVBQVVDLG1CQUFtQnpCLE9BQU8sUUFBUUMsUUFBUSxRQUFTQyxDQUFBQSxXQUFXLEVBQUM7QUFDbEc7QUFDQSwrREFBK0Q7QUFDL0QsMkRBQTJEO0FBQzNETCxjQUFjNkIscUJBQXFCO0FBQ25DLElBQU05QixXQUFXQyxlQUVqQix3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2ltYWdlLWxvYWRlci5qcz9jMGExIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVmYXVsdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2RlZmF1bHQ7XG4gICAgfVxufSk7XG5mdW5jdGlvbiBkZWZhdWx0TG9hZGVyKHBhcmFtKSB7XG4gICAgbGV0IHsgY29uZmlnICwgc3JjICwgd2lkdGggLCBxdWFsaXR5ICB9ID0gcGFyYW07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBjb25zdCBtaXNzaW5nVmFsdWVzID0gW107XG4gICAgICAgIC8vIHRoZXNlIHNob3VsZCBhbHdheXMgYmUgcHJvdmlkZWQgYnV0IG1ha2Ugc3VyZSB0aGV5IGFyZVxuICAgICAgICBpZiAoIXNyYykgbWlzc2luZ1ZhbHVlcy5wdXNoKFwic3JjXCIpO1xuICAgICAgICBpZiAoIXdpZHRoKSBtaXNzaW5nVmFsdWVzLnB1c2goXCJ3aWR0aFwiKTtcbiAgICAgICAgaWYgKG1pc3NpbmdWYWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTmV4dCBJbWFnZSBPcHRpbWl6YXRpb24gcmVxdWlyZXMgXCIgKyBtaXNzaW5nVmFsdWVzLmpvaW4oXCIsIFwiKSArIFwiIHRvIGJlIHByb3ZpZGVkLiBNYWtlIHN1cmUgeW91IHBhc3MgdGhlbSBhcyBwcm9wcyB0byB0aGUgYG5leHQvaW1hZ2VgIGNvbXBvbmVudC4gUmVjZWl2ZWQ6IFwiICsgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICBxdWFsaXR5XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNyYy5zdGFydHNXaXRoKFwiLy9cIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHBhcnNlIHNyYyBcIicgKyBzcmMgKyAnXCIgb24gYG5leHQvaW1hZ2VgLCBwcm90b2NvbC1yZWxhdGl2ZSBVUkwgKC8vKSBtdXN0IGJlIGNoYW5nZWQgdG8gYW4gYWJzb2x1dGUgVVJMIChodHRwOi8vIG9yIGh0dHBzOi8vKScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3JjLnN0YXJ0c1dpdGgoXCIvXCIpICYmIChjb25maWcuZG9tYWlucyB8fCBjb25maWcucmVtb3RlUGF0dGVybnMpKSB7XG4gICAgICAgICAgICBsZXQgcGFyc2VkU3JjO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXJzZWRTcmMgPSBuZXcgVVJMKHNyYyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2Ugc3JjIFwiJyArIHNyYyArICdcIiBvbiBgbmV4dC9pbWFnZWAsIGlmIHVzaW5nIHJlbGF0aXZlIGltYWdlIGl0IG11c3Qgc3RhcnQgd2l0aCBhIGxlYWRpbmcgc2xhc2ggXCIvXCIgb3IgYmUgYW4gYWJzb2x1dGUgVVJMIChodHRwOi8vIG9yIGh0dHBzOi8vKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInRlc3RcIiAmJiAvLyBtaWNyb21hdGNoIGlzbid0IGNvbXBhdGlibGUgd2l0aCBlZGdlIHJ1bnRpbWVcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSAhPT0gXCJlZGdlXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSB1c2UgZHluYW1pYyByZXF1aXJlIGJlY2F1c2UgdGhpcyBzaG91bGQgb25seSBlcnJvciBpbiBkZXZlbG9wbWVudFxuICAgICAgICAgICAgICAgIGNvbnN0IHsgaGFzTWF0Y2ggIH0gPSByZXF1aXJlKFwiLi9tYXRjaC1yZW1vdGUtcGF0dGVyblwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc01hdGNoKGNvbmZpZy5kb21haW5zLCBjb25maWcucmVtb3RlUGF0dGVybnMsIHBhcnNlZFNyYykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzcmMgcHJvcCAoXCIgKyBzcmMgKyAnKSBvbiBgbmV4dC9pbWFnZWAsIGhvc3RuYW1lIFwiJyArIHBhcnNlZFNyYy5ob3N0bmFtZSArICdcIiBpcyBub3QgY29uZmlndXJlZCB1bmRlciBpbWFnZXMgaW4geW91ciBgbmV4dC5jb25maWcuanNgXFxuJyArIFwiU2VlIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1pbWFnZS11bmNvbmZpZ3VyZWQtaG9zdFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZy5wYXRoICsgXCI/dXJsPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHNyYykgKyBcIiZ3PVwiICsgd2lkdGggKyBcIiZxPVwiICsgKHF1YWxpdHkgfHwgNzUpO1xufVxuLy8gV2UgdXNlIHRoaXMgdG8gZGV0ZXJtaW5lIGlmIHRoZSBpbXBvcnQgaXMgdGhlIGRlZmF1bHQgbG9hZGVyXG4vLyBvciBhIGN1c3RvbSBsb2FkZXIgZGVmaW5lZCBieSB0aGUgdXNlciBpbiBuZXh0LmNvbmZpZy5qc1xuZGVmYXVsdExvYWRlci5fX25leHRfaW1nX2RlZmF1bHQgPSB0cnVlO1xuY29uc3QgX2RlZmF1bHQgPSBkZWZhdWx0TG9hZGVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZS1sb2FkZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIl9kZWZhdWx0IiwiZGVmYXVsdExvYWRlciIsInBhcmFtIiwiY29uZmlnIiwic3JjIiwid2lkdGgiLCJxdWFsaXR5IiwicHJvY2VzcyIsIm1pc3NpbmdWYWx1ZXMiLCJwdXNoIiwibGVuZ3RoIiwiRXJyb3IiLCJqb2luIiwiSlNPTiIsInN0cmluZ2lmeSIsInN0YXJ0c1dpdGgiLCJkb21haW5zIiwicmVtb3RlUGF0dGVybnMiLCJwYXJzZWRTcmMiLCJVUkwiLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJlbnYiLCJORVhUX1JVTlRJTUUiLCJoYXNNYXRjaCIsInJlcXVpcmUiLCJob3N0bmFtZSIsInBhdGgiLCJlbmNvZGVVUklDb21wb25lbnQiLCJfX25leHRfaW1nX2RlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/image-loader.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/match-remote-pattern.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/match-remote-pattern.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    matchRemotePattern: function matchRemotePattern1() {\n        return matchRemotePattern;\n    },\n    hasMatch: function hasMatch1() {\n        return hasMatch;\n    }\n});\nvar _micromatch = __webpack_require__(/*! next/dist/compiled/micromatch */ \"./node_modules/next/dist/compiled/micromatch/index.js\");\nfunction matchRemotePattern(pattern, url) {\n    if (pattern.protocol !== undefined) {\n        var actualProto = url.protocol.slice(0, -1);\n        if (pattern.protocol !== actualProto) {\n            return false;\n        }\n    }\n    if (pattern.port !== undefined) {\n        if (pattern.port !== url.port) {\n            return false;\n        }\n    }\n    if (pattern.hostname === undefined) {\n        throw new Error(\"Pattern should define hostname but found\\n\" + JSON.stringify(pattern));\n    } else {\n        if (!(0, _micromatch.makeRe)(pattern.hostname).test(url.hostname)) {\n            return false;\n        }\n    }\n    var _pattern_pathname;\n    if (!(0, _micromatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : \"**\").test(url.pathname)) {\n        return false;\n    }\n    return true;\n}\nfunction hasMatch(domains, remotePatterns, url) {\n    return domains.some(function(domain) {\n        return url.hostname === domain;\n    }) || remotePatterns.some(function(p) {\n        return matchRemotePattern(p, url);\n    });\n} //# sourceMappingURL=match-remote-pattern.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvbWF0Y2gtcmVtb3RlLXBhdHRlcm4uanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FHTjtBQUNBLFNBQVNHLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlULE9BQU9DLGVBQWVPLFFBQVFFLE1BQU07UUFDcERDLFlBQVk7UUFDWkMsS0FBS0gsR0FBRyxDQUFDQyxLQUFLO0lBQ2xCO0FBQ0o7QUFDQUgsUUFBUUwsU0FBUztJQUNiRyxvQkFBb0IsU0FBcEJBO1FBQ0ksT0FBT0E7SUFDWDtJQUNBQyxVQUFVLFNBQVZBO1FBQ0ksT0FBT0E7SUFDWDtBQUNKO0FBQ0EsSUFBTU8sY0FBY0MsbUJBQU9BLENBQUMsNEZBQStCO0FBQzNELFNBQVNULG1CQUFtQlUsT0FBTyxFQUFFQyxHQUFHO0lBQ3BDLElBQUlELFFBQVFFLGFBQWFDLFdBQVc7UUFDaEMsSUFBTUMsY0FBY0gsSUFBSUMsU0FBU0csTUFBTSxHQUFHLENBQUM7UUFDM0MsSUFBSUwsUUFBUUUsYUFBYUUsYUFBYTtZQUNsQyxPQUFPO1FBQ1g7SUFDSjtJQUNBLElBQUlKLFFBQVFNLFNBQVNILFdBQVc7UUFDNUIsSUFBSUgsUUFBUU0sU0FBU0wsSUFBSUssTUFBTTtZQUMzQixPQUFPO1FBQ1g7SUFDSjtJQUNBLElBQUlOLFFBQVFPLGFBQWFKLFdBQVc7UUFDaEMsTUFBTSxJQUFJSyxNQUFNLCtDQUErQ0MsS0FBS0MsVUFBVVY7SUFDbEYsT0FBTztRQUNILElBQUksQ0FBQyxDQUFDLEdBQUdGLFlBQVlhLE1BQUssRUFBR1gsUUFBUU8sVUFBVUssS0FBS1gsSUFBSU0sV0FBVztZQUMvRCxPQUFPO1FBQ1g7SUFDSjtJQUNBLElBQUlNO0lBQ0osSUFBSSxDQUFDLENBQUMsR0FBR2YsWUFBWWEsTUFBSyxFQUFHLENBQUNFLG9CQUFvQmIsUUFBUWMsUUFBTyxLQUFNLE9BQU9ELG9CQUFvQixNQUFNRCxLQUFLWCxJQUFJYSxXQUFXO1FBQ3hILE9BQU87SUFDWDtJQUNBLE9BQU87QUFDWDtBQUNBLFNBQVN2QixTQUFTd0IsT0FBTyxFQUFFQyxjQUFjLEVBQUVmLEdBQUc7SUFDMUMsT0FBT2MsUUFBUUUsS0FBSyxTQUFDQztlQUFTakIsSUFBSU0sYUFBYVc7VUFBV0YsZUFBZUMsS0FBSyxTQUFDRTtlQUFJN0IsbUJBQW1CNkIsR0FBR2xCOztBQUM3RyxFQUVBLGdEQUFnRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvbWF0Y2gtcmVtb3RlLXBhdHRlcm4uanM/MGM5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIG1hdGNoUmVtb3RlUGF0dGVybjogbnVsbCxcbiAgICBoYXNNYXRjaDogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBtYXRjaFJlbW90ZVBhdHRlcm46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbWF0Y2hSZW1vdGVQYXR0ZXJuO1xuICAgIH0sXG4gICAgaGFzTWF0Y2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaGFzTWF0Y2g7XG4gICAgfVxufSk7XG5jb25zdCBfbWljcm9tYXRjaCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvbWljcm9tYXRjaFwiKTtcbmZ1bmN0aW9uIG1hdGNoUmVtb3RlUGF0dGVybihwYXR0ZXJuLCB1cmwpIHtcbiAgICBpZiAocGF0dGVybi5wcm90b2NvbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGFjdHVhbFByb3RvID0gdXJsLnByb3RvY29sLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgaWYgKHBhdHRlcm4ucHJvdG9jb2wgIT09IGFjdHVhbFByb3RvKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhdHRlcm4ucG9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChwYXR0ZXJuLnBvcnQgIT09IHVybC5wb3J0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhdHRlcm4uaG9zdG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXR0ZXJuIHNob3VsZCBkZWZpbmUgaG9zdG5hbWUgYnV0IGZvdW5kXFxuXCIgKyBKU09OLnN0cmluZ2lmeShwYXR0ZXJuKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCEoMCwgX21pY3JvbWF0Y2gubWFrZVJlKShwYXR0ZXJuLmhvc3RuYW1lKS50ZXN0KHVybC5ob3N0bmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgX3BhdHRlcm5fcGF0aG5hbWU7XG4gICAgaWYgKCEoMCwgX21pY3JvbWF0Y2gubWFrZVJlKSgoX3BhdHRlcm5fcGF0aG5hbWUgPSBwYXR0ZXJuLnBhdGhuYW1lKSAhPSBudWxsID8gX3BhdHRlcm5fcGF0aG5hbWUgOiBcIioqXCIpLnRlc3QodXJsLnBhdGhuYW1lKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaGFzTWF0Y2goZG9tYWlucywgcmVtb3RlUGF0dGVybnMsIHVybCkge1xuICAgIHJldHVybiBkb21haW5zLnNvbWUoKGRvbWFpbik9PnVybC5ob3N0bmFtZSA9PT0gZG9tYWluKSB8fCByZW1vdGVQYXR0ZXJucy5zb21lKChwKT0+bWF0Y2hSZW1vdGVQYXR0ZXJuKHAsIHVybCkpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRjaC1yZW1vdGUtcGF0dGVybi5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJtYXRjaFJlbW90ZVBhdHRlcm4iLCJoYXNNYXRjaCIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIl9taWNyb21hdGNoIiwicmVxdWlyZSIsInBhdHRlcm4iLCJ1cmwiLCJwcm90b2NvbCIsInVuZGVmaW5lZCIsImFjdHVhbFByb3RvIiwic2xpY2UiLCJwb3J0IiwiaG9zdG5hbWUiLCJFcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJtYWtlUmUiLCJ0ZXN0IiwiX3BhdHRlcm5fcGF0aG5hbWUiLCJwYXRobmFtZSIsImRvbWFpbnMiLCJyZW1vdGVQYXR0ZXJucyIsInNvbWUiLCJkb21haW4iLCJwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/match-remote-pattern.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/micromatch/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/compiled/micromatch/index.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"../../node_modules/process/browser.js\");\n(()=>{\"use strict\";var e={333:(e,t,r)=>{const n=r(137);const u=r(179);const s=r(13);const o=r(719);const braces=(e,t={})=>{let r=[];if(Array.isArray(e)){for(let n of e){let e=braces.create(n,t);if(Array.isArray(e)){r.push(...e)}else{r.push(e)}}}else{r=[].concat(braces.create(e,t))}if(t&&t.expand===true&&t.nodupes===true){r=[...new Set(r)]}return r};braces.parse=(e,t={})=>o(e,t);braces.stringify=(e,t={})=>{if(typeof e===\"string\"){return n(braces.parse(e,t),t)}return n(e,t)};braces.compile=(e,t={})=>{if(typeof e===\"string\"){e=braces.parse(e,t)}return u(e,t)};braces.expand=(e,t={})=>{if(typeof e===\"string\"){e=braces.parse(e,t)}let r=s(e,t);if(t.noempty===true){r=r.filter(Boolean)}if(t.nodupes===true){r=[...new Set(r)]}return r};braces.create=(e,t={})=>{if(e===\"\"||e.length<3){return[e]}return t.expand!==true?braces.compile(e,t):braces.expand(e,t)};e.exports=braces},179:(e,t,r)=>{const n=r(783);const u=r(617);const compile=(e,t={})=>{let walk=(e,r={})=>{let s=u.isInvalidBrace(r);let o=e.invalid===true&&t.escapeInvalid===true;let i=s===true||o===true;let a=t.escapeInvalid===true?\"\\\\\":\"\";let l=\"\";if(e.isOpen===true){return a+e.value}if(e.isClose===true){return a+e.value}if(e.type===\"open\"){return i?a+e.value:\"(\"}if(e.type===\"close\"){return i?a+e.value:\")\"}if(e.type===\"comma\"){return e.prev.type===\"comma\"?\"\":i?e.value:\"|\"}if(e.value){return e.value}if(e.nodes&&e.ranges>0){let r=u.reduce(e.nodes);let s=n(...r,{...t,wrap:false,toRegex:true});if(s.length!==0){return r.length>1&&s.length>1?`(${s})`:s}}if(e.nodes){for(let t of e.nodes){l+=walk(t,e)}}return l};return walk(e)};e.exports=compile},457:e=>{e.exports={MAX_LENGTH:1024*64,CHAR_0:\"0\",CHAR_9:\"9\",CHAR_UPPERCASE_A:\"A\",CHAR_LOWERCASE_A:\"a\",CHAR_UPPERCASE_Z:\"Z\",CHAR_LOWERCASE_Z:\"z\",CHAR_LEFT_PARENTHESES:\"(\",CHAR_RIGHT_PARENTHESES:\")\",CHAR_ASTERISK:\"*\",CHAR_AMPERSAND:\"&\",CHAR_AT:\"@\",CHAR_BACKSLASH:\"\\\\\",CHAR_BACKTICK:\"`\",CHAR_CARRIAGE_RETURN:\"\\r\",CHAR_CIRCUMFLEX_ACCENT:\"^\",CHAR_COLON:\":\",CHAR_COMMA:\",\",CHAR_DOLLAR:\"$\",CHAR_DOT:\".\",CHAR_DOUBLE_QUOTE:'\"',CHAR_EQUAL:\"=\",CHAR_EXCLAMATION_MARK:\"!\",CHAR_FORM_FEED:\"\\f\",CHAR_FORWARD_SLASH:\"/\",CHAR_HASH:\"#\",CHAR_HYPHEN_MINUS:\"-\",CHAR_LEFT_ANGLE_BRACKET:\"<\",CHAR_LEFT_CURLY_BRACE:\"{\",CHAR_LEFT_SQUARE_BRACKET:\"[\",CHAR_LINE_FEED:\"\\n\",CHAR_NO_BREAK_SPACE:\"\",CHAR_PERCENT:\"%\",CHAR_PLUS:\"+\",CHAR_QUESTION_MARK:\"?\",CHAR_RIGHT_ANGLE_BRACKET:\">\",CHAR_RIGHT_CURLY_BRACE:\"}\",CHAR_RIGHT_SQUARE_BRACKET:\"]\",CHAR_SEMICOLON:\";\",CHAR_SINGLE_QUOTE:\"'\",CHAR_SPACE:\" \",CHAR_TAB:\"\\t\",CHAR_UNDERSCORE:\"_\",CHAR_VERTICAL_LINE:\"|\",CHAR_ZERO_WIDTH_NOBREAK_SPACE:\"\\ufeff\"}},13:(e,t,r)=>{const n=r(783);const u=r(137);const s=r(617);const append=(e=\"\",t=\"\",r=false)=>{let n=[];e=[].concat(e);t=[].concat(t);if(!t.length)return e;if(!e.length){return r?s.flatten(t).map((e=>`{${e}}`)):t}for(let u of e){if(Array.isArray(u)){for(let e of u){n.push(append(e,t,r))}}else{for(let e of t){if(r===true&&typeof e===\"string\")e=`{${e}}`;n.push(Array.isArray(e)?append(u,e,r):u+e)}}}return s.flatten(n)};const expand=(e,t={})=>{let r=t.rangeLimit===void 0?1e3:t.rangeLimit;let walk=(e,o={})=>{e.queue=[];let i=o;let a=o.queue;while(i.type!==\"brace\"&&i.type!==\"root\"&&i.parent){i=i.parent;a=i.queue}if(e.invalid||e.dollar){a.push(append(a.pop(),u(e,t)));return}if(e.type===\"brace\"&&e.invalid!==true&&e.nodes.length===2){a.push(append(a.pop(),[\"{}\"]));return}if(e.nodes&&e.ranges>0){let o=s.reduce(e.nodes);if(s.exceedsLimit(...o,t.step,r)){throw new RangeError(\"expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.\")}let i=n(...o,t);if(i.length===0){i=u(e,t)}a.push(append(a.pop(),i));e.nodes=[];return}let l=s.encloseBrace(e);let c=e.queue;let p=e;while(p.type!==\"brace\"&&p.type!==\"root\"&&p.parent){p=p.parent;c=p.queue}for(let t=0;t<e.nodes.length;t++){let r=e.nodes[t];if(r.type===\"comma\"&&e.type===\"brace\"){if(t===1)c.push(\"\");c.push(\"\");continue}if(r.type===\"close\"){a.push(append(a.pop(),c,l));continue}if(r.value&&r.type!==\"open\"){c.push(append(c.pop(),r.value));continue}if(r.nodes){walk(r,e)}}return c};return s.flatten(walk(e))};e.exports=expand},719:(e,t,r)=>{const n=r(137);const{MAX_LENGTH:u,CHAR_BACKSLASH:s,CHAR_BACKTICK:o,CHAR_COMMA:i,CHAR_DOT:a,CHAR_LEFT_PARENTHESES:l,CHAR_RIGHT_PARENTHESES:c,CHAR_LEFT_CURLY_BRACE:p,CHAR_RIGHT_CURLY_BRACE:f,CHAR_LEFT_SQUARE_BRACKET:A,CHAR_RIGHT_SQUARE_BRACKET:R,CHAR_DOUBLE_QUOTE:_,CHAR_SINGLE_QUOTE:h,CHAR_NO_BREAK_SPACE:g,CHAR_ZERO_WIDTH_NOBREAK_SPACE:E}=r(457);const parse=(e,t={})=>{if(typeof e!==\"string\"){throw new TypeError(\"Expected a string\")}let r=t||{};let C=typeof r.maxLength===\"number\"?Math.min(u,r.maxLength):u;if(e.length>C){throw new SyntaxError(`Input length (${e.length}), exceeds max characters (${C})`)}let y={type:\"root\",input:e,nodes:[]};let d=[y];let x=y;let b=y;let S=0;let H=e.length;let v=0;let $=0;let m;let T={};const advance=()=>e[v++];const push=e=>{if(e.type===\"text\"&&b.type===\"dot\"){b.type=\"text\"}if(b&&b.type===\"text\"&&e.type===\"text\"){b.value+=e.value;return}x.nodes.push(e);e.parent=x;e.prev=b;b=e;return e};push({type:\"bos\"});while(v<H){x=d[d.length-1];m=advance();if(m===E||m===g){continue}if(m===s){push({type:\"text\",value:(t.keepEscaping?m:\"\")+advance()});continue}if(m===R){push({type:\"text\",value:\"\\\\\"+m});continue}if(m===A){S++;let e=true;let t;while(v<H&&(t=advance())){m+=t;if(t===A){S++;continue}if(t===s){m+=advance();continue}if(t===R){S--;if(S===0){break}}}push({type:\"text\",value:m});continue}if(m===l){x=push({type:\"paren\",nodes:[]});d.push(x);push({type:\"text\",value:m});continue}if(m===c){if(x.type!==\"paren\"){push({type:\"text\",value:m});continue}x=d.pop();push({type:\"text\",value:m});x=d[d.length-1];continue}if(m===_||m===h||m===o){let e=m;let r;if(t.keepQuotes!==true){m=\"\"}while(v<H&&(r=advance())){if(r===s){m+=r+advance();continue}if(r===e){if(t.keepQuotes===true)m+=r;break}m+=r}push({type:\"text\",value:m});continue}if(m===p){$++;let e=b.value&&b.value.slice(-1)===\"$\"||x.dollar===true;let t={type:\"brace\",open:true,close:false,dollar:e,depth:$,commas:0,ranges:0,nodes:[]};x=push(t);d.push(x);push({type:\"open\",value:m});continue}if(m===f){if(x.type!==\"brace\"){push({type:\"text\",value:m});continue}let e=\"close\";x=d.pop();x.close=true;push({type:e,value:m});$--;x=d[d.length-1];continue}if(m===i&&$>0){if(x.ranges>0){x.ranges=0;let e=x.nodes.shift();x.nodes=[e,{type:\"text\",value:n(x)}]}push({type:\"comma\",value:m});x.commas++;continue}if(m===a&&$>0&&x.commas===0){let e=x.nodes;if($===0||e.length===0){push({type:\"text\",value:m});continue}if(b.type===\"dot\"){x.range=[];b.value+=m;b.type=\"range\";if(x.nodes.length!==3&&x.nodes.length!==5){x.invalid=true;x.ranges=0;b.type=\"text\";continue}x.ranges++;x.args=[];continue}if(b.type===\"range\"){e.pop();let t=e[e.length-1];t.value+=b.value+m;b=t;x.ranges--;continue}push({type:\"dot\",value:m});continue}push({type:\"text\",value:m})}do{x=d.pop();if(x.type!==\"root\"){x.nodes.forEach((e=>{if(!e.nodes){if(e.type===\"open\")e.isOpen=true;if(e.type===\"close\")e.isClose=true;if(!e.nodes)e.type=\"text\";e.invalid=true}}));let e=d[d.length-1];let t=e.nodes.indexOf(x);e.nodes.splice(t,1,...x.nodes)}}while(d.length>0);push({type:\"eos\"});return y};e.exports=parse},137:(e,t,r)=>{const n=r(617);e.exports=(e,t={})=>{let stringify=(e,r={})=>{let u=t.escapeInvalid&&n.isInvalidBrace(r);let s=e.invalid===true&&t.escapeInvalid===true;let o=\"\";if(e.value){if((u||s)&&n.isOpenOrClose(e)){return\"\\\\\"+e.value}return e.value}if(e.value){return e.value}if(e.nodes){for(let t of e.nodes){o+=stringify(t)}}return o};return stringify(e)}},617:(e,t)=>{t.isInteger=e=>{if(typeof e===\"number\"){return Number.isInteger(e)}if(typeof e===\"string\"&&e.trim()!==\"\"){return Number.isInteger(Number(e))}return false};t.find=(e,t)=>e.nodes.find((e=>e.type===t));t.exceedsLimit=(e,r,n=1,u)=>{if(u===false)return false;if(!t.isInteger(e)||!t.isInteger(r))return false;return(Number(r)-Number(e))/Number(n)>=u};t.escapeNode=(e,t=0,r)=>{let n=e.nodes[t];if(!n)return;if(r&&n.type===r||n.type===\"open\"||n.type===\"close\"){if(n.escaped!==true){n.value=\"\\\\\"+n.value;n.escaped=true}}};t.encloseBrace=e=>{if(e.type!==\"brace\")return false;if(e.commas>>0+e.ranges>>0===0){e.invalid=true;return true}return false};t.isInvalidBrace=e=>{if(e.type!==\"brace\")return false;if(e.invalid===true||e.dollar)return true;if(e.commas>>0+e.ranges>>0===0){e.invalid=true;return true}if(e.open!==true||e.close!==true){e.invalid=true;return true}return false};t.isOpenOrClose=e=>{if(e.type===\"open\"||e.type===\"close\"){return true}return e.open===true||e.close===true};t.reduce=e=>e.reduce(((e,t)=>{if(t.type===\"text\")e.push(t.value);if(t.type===\"range\")t.type=\"text\";return e}),[]);t.flatten=(...e)=>{const t=[];const flat=e=>{for(let r=0;r<e.length;r++){let n=e[r];Array.isArray(n)?flat(n,t):n!==void 0&&t.push(n)}return t};flat(e);return t}},783:(e,t,r)=>{\n/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\nconst n=r(837);const u=r(492);const isObject=e=>e!==null&&typeof e===\"object\"&&!Array.isArray(e);const transform=e=>t=>e===true?Number(t):String(t);const isValidValue=e=>typeof e===\"number\"||typeof e===\"string\"&&e!==\"\";const isNumber=e=>Number.isInteger(+e);const zeros=e=>{let t=`${e}`;let r=-1;if(t[0]===\"-\")t=t.slice(1);if(t===\"0\")return false;while(t[++r]===\"0\");return r>0};const stringify=(e,t,r)=>{if(typeof e===\"string\"||typeof t===\"string\"){return true}return r.stringify===true};const pad=(e,t,r)=>{if(t>0){let r=e[0]===\"-\"?\"-\":\"\";if(r)e=e.slice(1);e=r+e.padStart(r?t-1:t,\"0\")}if(r===false){return String(e)}return e};const toMaxLen=(e,t)=>{let r=e[0]===\"-\"?\"-\":\"\";if(r){e=e.slice(1);t--}while(e.length<t)e=\"0\"+e;return r?\"-\"+e:e};const toSequence=(e,t)=>{e.negatives.sort(((e,t)=>e<t?-1:e>t?1:0));e.positives.sort(((e,t)=>e<t?-1:e>t?1:0));let r=t.capture?\"\":\"?:\";let n=\"\";let u=\"\";let s;if(e.positives.length){n=e.positives.join(\"|\")}if(e.negatives.length){u=`-(${r}${e.negatives.join(\"|\")})`}if(n&&u){s=`${n}|${u}`}else{s=n||u}if(t.wrap){return`(${r}${s})`}return s};const toRange=(e,t,r,n)=>{if(r){return u(e,t,{wrap:false,...n})}let s=String.fromCharCode(e);if(e===t)return s;let o=String.fromCharCode(t);return`[${s}-${o}]`};const toRegex=(e,t,r)=>{if(Array.isArray(e)){let t=r.wrap===true;let n=r.capture?\"\":\"?:\";return t?`(${n}${e.join(\"|\")})`:e.join(\"|\")}return u(e,t,r)};const rangeError=(...e)=>new RangeError(\"Invalid range arguments: \"+n.inspect(...e));const invalidRange=(e,t,r)=>{if(r.strictRanges===true)throw rangeError([e,t]);return[]};const invalidStep=(e,t)=>{if(t.strictRanges===true){throw new TypeError(`Expected step \"${e}\" to be a number`)}return[]};const fillNumbers=(e,t,r=1,n={})=>{let u=Number(e);let s=Number(t);if(!Number.isInteger(u)||!Number.isInteger(s)){if(n.strictRanges===true)throw rangeError([e,t]);return[]}if(u===0)u=0;if(s===0)s=0;let o=u>s;let i=String(e);let a=String(t);let l=String(r);r=Math.max(Math.abs(r),1);let c=zeros(i)||zeros(a)||zeros(l);let p=c?Math.max(i.length,a.length,l.length):0;let f=c===false&&stringify(e,t,n)===false;let A=n.transform||transform(f);if(n.toRegex&&r===1){return toRange(toMaxLen(e,p),toMaxLen(t,p),true,n)}let R={negatives:[],positives:[]};let push=e=>R[e<0?\"negatives\":\"positives\"].push(Math.abs(e));let _=[];let h=0;while(o?u>=s:u<=s){if(n.toRegex===true&&r>1){push(u)}else{_.push(pad(A(u,h),p,f))}u=o?u-r:u+r;h++}if(n.toRegex===true){return r>1?toSequence(R,n):toRegex(_,null,{wrap:false,...n})}return _};const fillLetters=(e,t,r=1,n={})=>{if(!isNumber(e)&&e.length>1||!isNumber(t)&&t.length>1){return invalidRange(e,t,n)}let u=n.transform||(e=>String.fromCharCode(e));let s=`${e}`.charCodeAt(0);let o=`${t}`.charCodeAt(0);let i=s>o;let a=Math.min(s,o);let l=Math.max(s,o);if(n.toRegex&&r===1){return toRange(a,l,false,n)}let c=[];let p=0;while(i?s>=o:s<=o){c.push(u(s,p));s=i?s-r:s+r;p++}if(n.toRegex===true){return toRegex(c,null,{wrap:false,options:n})}return c};const fill=(e,t,r,n={})=>{if(t==null&&isValidValue(e)){return[e]}if(!isValidValue(e)||!isValidValue(t)){return invalidRange(e,t,n)}if(typeof r===\"function\"){return fill(e,t,1,{transform:r})}if(isObject(r)){return fill(e,t,0,r)}let u={...n};if(u.capture===true)u.wrap=true;r=r||u.step||1;if(!isNumber(r)){if(r!=null&&!isObject(r))return invalidStep(r,u);return fill(e,t,1,r)}if(isNumber(e)&&isNumber(t)){return fillNumbers(e,t,r,u)}return fillLetters(e,t,Math.max(Math.abs(r),1),u)};e.exports=fill},357:e=>{\n/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\ne.exports=function(e){if(typeof e===\"number\"){return e-e===0}if(typeof e===\"string\"&&e.trim()!==\"\"){return Number.isFinite?Number.isFinite(+e):isFinite(+e)}return false}},971:(e,t,r)=>{const n=r(837);const u=r(333);const s=r(251);const o=r(513);const isEmptyString=e=>e===\"\"||e===\"./\";const micromatch=(e,t,r)=>{t=[].concat(t);e=[].concat(e);let n=new Set;let u=new Set;let o=new Set;let i=0;let onResult=e=>{o.add(e.output);if(r&&r.onResult){r.onResult(e)}};for(let o=0;o<t.length;o++){let a=s(String(t[o]),{...r,onResult:onResult},true);let l=a.state.negated||a.state.negatedExtglob;if(l)i++;for(let t of e){let e=a(t,true);let r=l?!e.isMatch:e.isMatch;if(!r)continue;if(l){n.add(e.output)}else{n.delete(e.output);u.add(e.output)}}}let a=i===t.length?[...o]:[...u];let l=a.filter((e=>!n.has(e)));if(r&&l.length===0){if(r.failglob===true){throw new Error(`No matches found for \"${t.join(\", \")}\"`)}if(r.nonull===true||r.nullglob===true){return r.unescape?t.map((e=>e.replace(/\\\\/g,\"\"))):t}}return l};micromatch.match=micromatch;micromatch.matcher=(e,t)=>s(e,t);micromatch.isMatch=(e,t,r)=>s(t,r)(e);micromatch.any=micromatch.isMatch;micromatch.not=(e,t,r={})=>{t=[].concat(t).map(String);let n=new Set;let u=[];let onResult=e=>{if(r.onResult)r.onResult(e);u.push(e.output)};let s=micromatch(e,t,{...r,onResult:onResult});for(let e of u){if(!s.includes(e)){n.add(e)}}return[...n]};micromatch.contains=(e,t,r)=>{if(typeof e!==\"string\"){throw new TypeError(`Expected a string: \"${n.inspect(e)}\"`)}if(Array.isArray(t)){return t.some((t=>micromatch.contains(e,t,r)))}if(typeof t===\"string\"){if(isEmptyString(e)||isEmptyString(t)){return false}if(e.includes(t)||e.startsWith(\"./\")&&e.slice(2).includes(t)){return true}}return micromatch.isMatch(e,t,{...r,contains:true})};micromatch.matchKeys=(e,t,r)=>{if(!o.isObject(e)){throw new TypeError(\"Expected the first argument to be an object\")}let n=micromatch(Object.keys(e),t,r);let u={};for(let t of n)u[t]=e[t];return u};micromatch.some=(e,t,r)=>{let n=[].concat(e);for(let e of[].concat(t)){let t=s(String(e),r);if(n.some((e=>t(e)))){return true}}return false};micromatch.every=(e,t,r)=>{let n=[].concat(e);for(let e of[].concat(t)){let t=s(String(e),r);if(!n.every((e=>t(e)))){return false}}return true};micromatch.all=(e,t,r)=>{if(typeof e!==\"string\"){throw new TypeError(`Expected a string: \"${n.inspect(e)}\"`)}return[].concat(t).every((t=>s(t,r)(e)))};micromatch.capture=(e,t,r)=>{let n=o.isWindows(r);let u=s.makeRe(String(e),{...r,capture:true});let i=u.exec(n?o.toPosixSlashes(t):t);if(i){return i.slice(1).map((e=>e===void 0?\"\":e))}};micromatch.makeRe=(...e)=>s.makeRe(...e);micromatch.scan=(...e)=>s.scan(...e);micromatch.parse=(e,t)=>{let r=[];for(let n of[].concat(e||[])){for(let e of u(String(n),t)){r.push(s.parse(e,t))}}return r};micromatch.braces=(e,t)=>{if(typeof e!==\"string\")throw new TypeError(\"Expected a string\");if(t&&t.nobrace===true||!/\\{.*\\}/.test(e)){return[e]}return u(e,t)};micromatch.braceExpand=(e,t)=>{if(typeof e!==\"string\")throw new TypeError(\"Expected a string\");return micromatch.braces(e,{...t,expand:true})};e.exports=micromatch},251:(e,t,r)=>{e.exports=r(683)},356:(e,t,r)=>{const n=r(17);const u=\"\\\\\\\\/\";const s=`[^${u}]`;const o=\"\\\\.\";const i=\"\\\\+\";const a=\"\\\\?\";const l=\"\\\\/\";const c=\"(?=.)\";const p=\"[^/]\";const f=`(?:${l}|$)`;const A=`(?:^|${l})`;const R=`${o}{1,2}${f}`;const _=`(?!${o})`;const h=`(?!${A}${R})`;const g=`(?!${o}{0,1}${f})`;const E=`(?!${R})`;const C=`[^.${l}]`;const y=`${p}*?`;const d={DOT_LITERAL:o,PLUS_LITERAL:i,QMARK_LITERAL:a,SLASH_LITERAL:l,ONE_CHAR:c,QMARK:p,END_ANCHOR:f,DOTS_SLASH:R,NO_DOT:_,NO_DOTS:h,NO_DOT_SLASH:g,NO_DOTS_SLASH:E,QMARK_NO_DOT:C,STAR:y,START_ANCHOR:A};const x={...d,SLASH_LITERAL:`[${u}]`,QMARK:s,STAR:`${s}*?`,DOTS_SLASH:`${o}{1,2}(?:[${u}]|$)`,NO_DOT:`(?!${o})`,NO_DOTS:`(?!(?:^|[${u}])${o}{1,2}(?:[${u}]|$))`,NO_DOT_SLASH:`(?!${o}{0,1}(?:[${u}]|$))`,NO_DOTS_SLASH:`(?!${o}{1,2}(?:[${u}]|$))`,QMARK_NO_DOT:`[^.${u}]`,START_ANCHOR:`(?:^|[${u}])`,END_ANCHOR:`(?:[${u}]|$)`};const b={alnum:\"a-zA-Z0-9\",alpha:\"a-zA-Z\",ascii:\"\\\\x00-\\\\x7F\",blank:\" \\\\t\",cntrl:\"\\\\x00-\\\\x1F\\\\x7F\",digit:\"0-9\",graph:\"\\\\x21-\\\\x7E\",lower:\"a-z\",print:\"\\\\x20-\\\\x7E \",punct:\"\\\\-!\\\"#$%&'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~\",space:\" \\\\t\\\\r\\\\n\\\\v\\\\f\",upper:\"A-Z\",word:\"A-Za-z0-9_\",xdigit:\"A-Fa-f0-9\"};e.exports={MAX_LENGTH:1024*64,POSIX_REGEX_SOURCE:b,REGEX_BACKSLASH:/\\\\(?![*+?^${}(|)[\\]])/g,REGEX_NON_SPECIAL_CHARS:/^[^@![\\].,$*+?^{}()|\\\\/]+/,REGEX_SPECIAL_CHARS:/[-*+?.^${}(|)[\\]]/,REGEX_SPECIAL_CHARS_BACKREF:/(\\\\?)((\\W)(\\3*))/g,REGEX_SPECIAL_CHARS_GLOBAL:/([-*+?.^${}(|)[\\]])/g,REGEX_REMOVE_BACKSLASH:/(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,REPLACEMENTS:{\"***\":\"*\",\"**/**\":\"**\",\"**/**/**\":\"**\"},CHAR_0:48,CHAR_9:57,CHAR_UPPERCASE_A:65,CHAR_LOWERCASE_A:97,CHAR_UPPERCASE_Z:90,CHAR_LOWERCASE_Z:122,CHAR_LEFT_PARENTHESES:40,CHAR_RIGHT_PARENTHESES:41,CHAR_ASTERISK:42,CHAR_AMPERSAND:38,CHAR_AT:64,CHAR_BACKWARD_SLASH:92,CHAR_CARRIAGE_RETURN:13,CHAR_CIRCUMFLEX_ACCENT:94,CHAR_COLON:58,CHAR_COMMA:44,CHAR_DOT:46,CHAR_DOUBLE_QUOTE:34,CHAR_EQUAL:61,CHAR_EXCLAMATION_MARK:33,CHAR_FORM_FEED:12,CHAR_FORWARD_SLASH:47,CHAR_GRAVE_ACCENT:96,CHAR_HASH:35,CHAR_HYPHEN_MINUS:45,CHAR_LEFT_ANGLE_BRACKET:60,CHAR_LEFT_CURLY_BRACE:123,CHAR_LEFT_SQUARE_BRACKET:91,CHAR_LINE_FEED:10,CHAR_NO_BREAK_SPACE:160,CHAR_PERCENT:37,CHAR_PLUS:43,CHAR_QUESTION_MARK:63,CHAR_RIGHT_ANGLE_BRACKET:62,CHAR_RIGHT_CURLY_BRACE:125,CHAR_RIGHT_SQUARE_BRACKET:93,CHAR_SEMICOLON:59,CHAR_SINGLE_QUOTE:39,CHAR_SPACE:32,CHAR_TAB:9,CHAR_UNDERSCORE:95,CHAR_VERTICAL_LINE:124,CHAR_ZERO_WIDTH_NOBREAK_SPACE:65279,SEP:n.sep,extglobChars(e){return{\"!\":{type:\"negate\",open:\"(?:(?!(?:\",close:`))${e.STAR})`},\"?\":{type:\"qmark\",open:\"(?:\",close:\")?\"},\"+\":{type:\"plus\",open:\"(?:\",close:\")+\"},\"*\":{type:\"star\",open:\"(?:\",close:\")*\"},\"@\":{type:\"at\",open:\"(?:\",close:\")\"}}},globChars(e){return e===true?x:d}}},754:(e,t,r)=>{const n=r(356);const u=r(513);const{MAX_LENGTH:s,POSIX_REGEX_SOURCE:o,REGEX_NON_SPECIAL_CHARS:i,REGEX_SPECIAL_CHARS_BACKREF:a,REPLACEMENTS:l}=n;const expandRange=(e,t)=>{if(typeof t.expandRange===\"function\"){return t.expandRange(...e,t)}e.sort();const r=`[${e.join(\"-\")}]`;try{new RegExp(r)}catch(t){return e.map((e=>u.escapeRegex(e))).join(\"..\")}return r};const syntaxError=(e,t)=>`Missing ${e}: \"${t}\" - use \"\\\\\\\\${t}\" to match literal characters`;const parse=(e,t)=>{if(typeof e!==\"string\"){throw new TypeError(\"Expected a string\")}e=l[e]||e;const r={...t};const c=typeof r.maxLength===\"number\"?Math.min(s,r.maxLength):s;let p=e.length;if(p>c){throw new SyntaxError(`Input length: ${p}, exceeds maximum allowed length: ${c}`)}const f={type:\"bos\",value:\"\",output:r.prepend||\"\"};const A=[f];const R=r.capture?\"\":\"?:\";const _=u.isWindows(t);const h=n.globChars(_);const g=n.extglobChars(h);const{DOT_LITERAL:E,PLUS_LITERAL:C,SLASH_LITERAL:y,ONE_CHAR:d,DOTS_SLASH:x,NO_DOT:b,NO_DOT_SLASH:S,NO_DOTS_SLASH:H,QMARK:v,QMARK_NO_DOT:$,STAR:m,START_ANCHOR:T}=h;const globstar=e=>`(${R}(?:(?!${T}${e.dot?x:E}).)*?)`;const L=r.dot?\"\":b;const O=r.dot?v:$;let w=r.bash===true?globstar(r):m;if(r.capture){w=`(${w})`}if(typeof r.noext===\"boolean\"){r.noextglob=r.noext}const N={input:e,index:-1,start:0,dot:r.dot===true,consumed:\"\",output:\"\",prefix:\"\",backtrack:false,negated:false,brackets:0,braces:0,parens:0,quotes:0,globstar:false,tokens:A};e=u.removePrefix(e,N);p=e.length;const k=[];const I=[];const M=[];let P=f;let B;const eos=()=>N.index===p-1;const G=N.peek=(t=1)=>e[N.index+t];const D=N.advance=()=>e[++N.index];const remaining=()=>e.slice(N.index+1);const consume=(e=\"\",t=0)=>{N.consumed+=e;N.index+=t};const append=e=>{N.output+=e.output!=null?e.output:e.value;consume(e.value)};const negate=()=>{let e=1;while(G()===\"!\"&&(G(2)!==\"(\"||G(3)===\"?\")){D();N.start++;e++}if(e%2===0){return false}N.negated=true;N.start++;return true};const increment=e=>{N[e]++;M.push(e)};const decrement=e=>{N[e]--;M.pop()};const push=e=>{if(P.type===\"globstar\"){const t=N.braces>0&&(e.type===\"comma\"||e.type===\"brace\");const r=e.extglob===true||k.length&&(e.type===\"pipe\"||e.type===\"paren\");if(e.type!==\"slash\"&&e.type!==\"paren\"&&!t&&!r){N.output=N.output.slice(0,-P.output.length);P.type=\"star\";P.value=\"*\";P.output=w;N.output+=P.output}}if(k.length&&e.type!==\"paren\"&&!g[e.value]){k[k.length-1].inner+=e.value}if(e.value||e.output)append(e);if(P&&P.type===\"text\"&&e.type===\"text\"){P.value+=e.value;P.output=(P.output||\"\")+e.value;return}e.prev=P;A.push(e);P=e};const extglobOpen=(e,t)=>{const n={...g[t],conditions:1,inner:\"\"};n.prev=P;n.parens=N.parens;n.output=N.output;const u=(r.capture?\"(\":\"\")+n.open;increment(\"parens\");push({type:e,value:t,output:N.output?\"\":d});push({type:\"paren\",extglob:true,value:D(),output:u});k.push(n)};const extglobClose=e=>{let t=e.close+(r.capture?\")\":\"\");if(e.type===\"negate\"){let n=w;if(e.inner&&e.inner.length>1&&e.inner.includes(\"/\")){n=globstar(r)}if(n!==w||eos()||/^\\)+$/.test(remaining())){t=e.close=`)$))${n}`}if(e.prev.type===\"bos\"){N.negatedExtglob=true}}push({type:\"paren\",extglob:true,value:B,output:t});decrement(\"parens\")};if(r.fastpaths!==false&&!/(^[*!]|[/()[\\]{}\"])/.test(e)){let n=false;let s=e.replace(a,((e,t,r,u,s,o)=>{if(u===\"\\\\\"){n=true;return e}if(u===\"?\"){if(t){return t+u+(s?v.repeat(s.length):\"\")}if(o===0){return O+(s?v.repeat(s.length):\"\")}return v.repeat(r.length)}if(u===\".\"){return E.repeat(r.length)}if(u===\"*\"){if(t){return t+u+(s?w:\"\")}return w}return t?e:`\\\\${e}`}));if(n===true){if(r.unescape===true){s=s.replace(/\\\\/g,\"\")}else{s=s.replace(/\\\\+/g,(e=>e.length%2===0?\"\\\\\\\\\":e?\"\\\\\":\"\"))}}if(s===e&&r.contains===true){N.output=e;return N}N.output=u.wrapOutput(s,N,t);return N}while(!eos()){B=D();if(B===\"\\0\"){continue}if(B===\"\\\\\"){const e=G();if(e===\"/\"&&r.bash!==true){continue}if(e===\".\"||e===\";\"){continue}if(!e){B+=\"\\\\\";push({type:\"text\",value:B});continue}const t=/^\\\\+/.exec(remaining());let n=0;if(t&&t[0].length>2){n=t[0].length;N.index+=n;if(n%2!==0){B+=\"\\\\\"}}if(r.unescape===true){B=D()||\"\"}else{B+=D()||\"\"}if(N.brackets===0){push({type:\"text\",value:B});continue}}if(N.brackets>0&&(B!==\"]\"||P.value===\"[\"||P.value===\"[^\")){if(r.posix!==false&&B===\":\"){const e=P.value.slice(1);if(e.includes(\"[\")){P.posix=true;if(e.includes(\":\")){const e=P.value.lastIndexOf(\"[\");const t=P.value.slice(0,e);const r=P.value.slice(e+2);const n=o[r];if(n){P.value=t+n;N.backtrack=true;D();if(!f.output&&A.indexOf(P)===1){f.output=d}continue}}}}if(B===\"[\"&&G()!==\":\"||B===\"-\"&&G()===\"]\"){B=`\\\\${B}`}if(B===\"]\"&&(P.value===\"[\"||P.value===\"[^\")){B=`\\\\${B}`}if(r.posix===true&&B===\"!\"&&P.value===\"[\"){B=\"^\"}P.value+=B;append({value:B});continue}if(N.quotes===1&&B!=='\"'){B=u.escapeRegex(B);P.value+=B;append({value:B});continue}if(B==='\"'){N.quotes=N.quotes===1?0:1;if(r.keepQuotes===true){push({type:\"text\",value:B})}continue}if(B===\"(\"){increment(\"parens\");push({type:\"paren\",value:B});continue}if(B===\")\"){if(N.parens===0&&r.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"(\"))}const e=k[k.length-1];if(e&&N.parens===e.parens+1){extglobClose(k.pop());continue}push({type:\"paren\",value:B,output:N.parens?\")\":\"\\\\)\"});decrement(\"parens\");continue}if(B===\"[\"){if(r.nobracket===true||!remaining().includes(\"]\")){if(r.nobracket!==true&&r.strictBrackets===true){throw new SyntaxError(syntaxError(\"closing\",\"]\"))}B=`\\\\${B}`}else{increment(\"brackets\")}push({type:\"bracket\",value:B});continue}if(B===\"]\"){if(r.nobracket===true||P&&P.type===\"bracket\"&&P.value.length===1){push({type:\"text\",value:B,output:`\\\\${B}`});continue}if(N.brackets===0){if(r.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"[\"))}push({type:\"text\",value:B,output:`\\\\${B}`});continue}decrement(\"brackets\");const e=P.value.slice(1);if(P.posix!==true&&e[0]===\"^\"&&!e.includes(\"/\")){B=`/${B}`}P.value+=B;append({value:B});if(r.literalBrackets===false||u.hasRegexChars(e)){continue}const t=u.escapeRegex(P.value);N.output=N.output.slice(0,-P.value.length);if(r.literalBrackets===true){N.output+=t;P.value=t;continue}P.value=`(${R}${t}|${P.value})`;N.output+=P.value;continue}if(B===\"{\"&&r.nobrace!==true){increment(\"braces\");const e={type:\"brace\",value:B,output:\"(\",outputIndex:N.output.length,tokensIndex:N.tokens.length};I.push(e);push(e);continue}if(B===\"}\"){const e=I[I.length-1];if(r.nobrace===true||!e){push({type:\"text\",value:B,output:B});continue}let t=\")\";if(e.dots===true){const e=A.slice();const n=[];for(let t=e.length-1;t>=0;t--){A.pop();if(e[t].type===\"brace\"){break}if(e[t].type!==\"dots\"){n.unshift(e[t].value)}}t=expandRange(n,r);N.backtrack=true}if(e.comma!==true&&e.dots!==true){const r=N.output.slice(0,e.outputIndex);const n=N.tokens.slice(e.tokensIndex);e.value=e.output=\"\\\\{\";B=t=\"\\\\}\";N.output=r;for(const e of n){N.output+=e.output||e.value}}push({type:\"brace\",value:B,output:t});decrement(\"braces\");I.pop();continue}if(B===\"|\"){if(k.length>0){k[k.length-1].conditions++}push({type:\"text\",value:B});continue}if(B===\",\"){let e=B;const t=I[I.length-1];if(t&&M[M.length-1]===\"braces\"){t.comma=true;e=\"|\"}push({type:\"comma\",value:B,output:e});continue}if(B===\"/\"){if(P.type===\"dot\"&&N.index===N.start+1){N.start=N.index+1;N.consumed=\"\";N.output=\"\";A.pop();P=f;continue}push({type:\"slash\",value:B,output:y});continue}if(B===\".\"){if(N.braces>0&&P.type===\"dot\"){if(P.value===\".\")P.output=E;const e=I[I.length-1];P.type=\"dots\";P.output+=B;P.value+=B;e.dots=true;continue}if(N.braces+N.parens===0&&P.type!==\"bos\"&&P.type!==\"slash\"){push({type:\"text\",value:B,output:E});continue}push({type:\"dot\",value:B,output:E});continue}if(B===\"?\"){const e=P&&P.value===\"(\";if(!e&&r.noextglob!==true&&G()===\"(\"&&G(2)!==\"?\"){extglobOpen(\"qmark\",B);continue}if(P&&P.type===\"paren\"){const e=G();let t=B;if(e===\"<\"&&!u.supportsLookbehinds()){throw new Error(\"Node.js v10 or higher is required for regex lookbehinds\")}if(P.value===\"(\"&&!/[!=<:]/.test(e)||e===\"<\"&&!/<([!=]|\\w+>)/.test(remaining())){t=`\\\\${B}`}push({type:\"text\",value:B,output:t});continue}if(r.dot!==true&&(P.type===\"slash\"||P.type===\"bos\")){push({type:\"qmark\",value:B,output:$});continue}push({type:\"qmark\",value:B,output:v});continue}if(B===\"!\"){if(r.noextglob!==true&&G()===\"(\"){if(G(2)!==\"?\"||!/[!=<:]/.test(G(3))){extglobOpen(\"negate\",B);continue}}if(r.nonegate!==true&&N.index===0){negate();continue}}if(B===\"+\"){if(r.noextglob!==true&&G()===\"(\"&&G(2)!==\"?\"){extglobOpen(\"plus\",B);continue}if(P&&P.value===\"(\"||r.regex===false){push({type:\"plus\",value:B,output:C});continue}if(P&&(P.type===\"bracket\"||P.type===\"paren\"||P.type===\"brace\")||N.parens>0){push({type:\"plus\",value:B});continue}push({type:\"plus\",value:C});continue}if(B===\"@\"){if(r.noextglob!==true&&G()===\"(\"&&G(2)!==\"?\"){push({type:\"at\",extglob:true,value:B,output:\"\"});continue}push({type:\"text\",value:B});continue}if(B!==\"*\"){if(B===\"$\"||B===\"^\"){B=`\\\\${B}`}const e=i.exec(remaining());if(e){B+=e[0];N.index+=e[0].length}push({type:\"text\",value:B});continue}if(P&&(P.type===\"globstar\"||P.star===true)){P.type=\"star\";P.star=true;P.value+=B;P.output=w;N.backtrack=true;N.globstar=true;consume(B);continue}let t=remaining();if(r.noextglob!==true&&/^\\([^?]/.test(t)){extglobOpen(\"star\",B);continue}if(P.type===\"star\"){if(r.noglobstar===true){consume(B);continue}const n=P.prev;const u=n.prev;const s=n.type===\"slash\"||n.type===\"bos\";const o=u&&(u.type===\"star\"||u.type===\"globstar\");if(r.bash===true&&(!s||t[0]&&t[0]!==\"/\")){push({type:\"star\",value:B,output:\"\"});continue}const i=N.braces>0&&(n.type===\"comma\"||n.type===\"brace\");const a=k.length&&(n.type===\"pipe\"||n.type===\"paren\");if(!s&&n.type!==\"paren\"&&!i&&!a){push({type:\"star\",value:B,output:\"\"});continue}while(t.slice(0,3)===\"/**\"){const r=e[N.index+4];if(r&&r!==\"/\"){break}t=t.slice(3);consume(\"/**\",3)}if(n.type===\"bos\"&&eos()){P.type=\"globstar\";P.value+=B;P.output=globstar(r);N.output=P.output;N.globstar=true;consume(B);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&!o&&eos()){N.output=N.output.slice(0,-(n.output+P.output).length);n.output=`(?:${n.output}`;P.type=\"globstar\";P.output=globstar(r)+(r.strictSlashes?\")\":\"|$)\");P.value+=B;N.globstar=true;N.output+=n.output+P.output;consume(B);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&t[0]===\"/\"){const e=t[1]!==void 0?\"|$\":\"\";N.output=N.output.slice(0,-(n.output+P.output).length);n.output=`(?:${n.output}`;P.type=\"globstar\";P.output=`${globstar(r)}${y}|${y}${e})`;P.value+=B;N.output+=n.output+P.output;N.globstar=true;consume(B+D());push({type:\"slash\",value:\"/\",output:\"\"});continue}if(n.type===\"bos\"&&t[0]===\"/\"){P.type=\"globstar\";P.value+=B;P.output=`(?:^|${y}|${globstar(r)}${y})`;N.output=P.output;N.globstar=true;consume(B+D());push({type:\"slash\",value:\"/\",output:\"\"});continue}N.output=N.output.slice(0,-P.output.length);P.type=\"globstar\";P.output=globstar(r);P.value+=B;N.output+=P.output;N.globstar=true;consume(B);continue}const n={type:\"star\",value:B,output:w};if(r.bash===true){n.output=\".*?\";if(P.type===\"bos\"||P.type===\"slash\"){n.output=L+n.output}push(n);continue}if(P&&(P.type===\"bracket\"||P.type===\"paren\")&&r.regex===true){n.output=B;push(n);continue}if(N.index===N.start||P.type===\"slash\"||P.type===\"dot\"){if(P.type===\"dot\"){N.output+=S;P.output+=S}else if(r.dot===true){N.output+=H;P.output+=H}else{N.output+=L;P.output+=L}if(G()!==\"*\"){N.output+=d;P.output+=d}}push(n)}while(N.brackets>0){if(r.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"]\"));N.output=u.escapeLast(N.output,\"[\");decrement(\"brackets\")}while(N.parens>0){if(r.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\")\"));N.output=u.escapeLast(N.output,\"(\");decrement(\"parens\")}while(N.braces>0){if(r.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"}\"));N.output=u.escapeLast(N.output,\"{\");decrement(\"braces\")}if(r.strictSlashes!==true&&(P.type===\"star\"||P.type===\"bracket\")){push({type:\"maybe_slash\",value:\"\",output:`${y}?`})}if(N.backtrack===true){N.output=\"\";for(const e of N.tokens){N.output+=e.output!=null?e.output:e.value;if(e.suffix){N.output+=e.suffix}}}return N};parse.fastpaths=(e,t)=>{const r={...t};const o=typeof r.maxLength===\"number\"?Math.min(s,r.maxLength):s;const i=e.length;if(i>o){throw new SyntaxError(`Input length: ${i}, exceeds maximum allowed length: ${o}`)}e=l[e]||e;const a=u.isWindows(t);const{DOT_LITERAL:c,SLASH_LITERAL:p,ONE_CHAR:f,DOTS_SLASH:A,NO_DOT:R,NO_DOTS:_,NO_DOTS_SLASH:h,STAR:g,START_ANCHOR:E}=n.globChars(a);const C=r.dot?_:R;const y=r.dot?h:R;const d=r.capture?\"\":\"?:\";const x={negated:false,prefix:\"\"};let b=r.bash===true?\".*?\":g;if(r.capture){b=`(${b})`}const globstar=e=>{if(e.noglobstar===true)return b;return`(${d}(?:(?!${E}${e.dot?A:c}).)*?)`};const create=e=>{switch(e){case\"*\":return`${C}${f}${b}`;case\".*\":return`${c}${f}${b}`;case\"*.*\":return`${C}${b}${c}${f}${b}`;case\"*/*\":return`${C}${b}${p}${f}${y}${b}`;case\"**\":return C+globstar(r);case\"**/*\":return`(?:${C}${globstar(r)}${p})?${y}${f}${b}`;case\"**/*.*\":return`(?:${C}${globstar(r)}${p})?${y}${b}${c}${f}${b}`;case\"**/.*\":return`(?:${C}${globstar(r)}${p})?${c}${f}${b}`;default:{const t=/^(.*?)\\.(\\w+)$/.exec(e);if(!t)return;const r=create(t[1]);if(!r)return;return r+c+t[2]}}};const S=u.removePrefix(e,x);let H=create(S);if(H&&r.strictSlashes!==true){H+=`${p}?`}return H};e.exports=parse},683:(e,t,r)=>{const n=r(17);const u=r(700);const s=r(754);const o=r(513);const i=r(356);const isObject=e=>e&&typeof e===\"object\"&&!Array.isArray(e);const picomatch=(e,t,r=false)=>{if(Array.isArray(e)){const n=e.map((e=>picomatch(e,t,r)));const arrayMatcher=e=>{for(const t of n){const r=t(e);if(r)return r}return false};return arrayMatcher}const n=isObject(e)&&e.tokens&&e.input;if(e===\"\"||typeof e!==\"string\"&&!n){throw new TypeError(\"Expected pattern to be a non-empty string\")}const u=t||{};const s=o.isWindows(t);const i=n?picomatch.compileRe(e,t):picomatch.makeRe(e,t,false,true);const a=i.state;delete i.state;let isIgnored=()=>false;if(u.ignore){const e={...t,ignore:null,onMatch:null,onResult:null};isIgnored=picomatch(u.ignore,e,r)}const matcher=(r,n=false)=>{const{isMatch:o,match:l,output:c}=picomatch.test(r,i,t,{glob:e,posix:s});const p={glob:e,state:a,regex:i,posix:s,input:r,output:c,match:l,isMatch:o};if(typeof u.onResult===\"function\"){u.onResult(p)}if(o===false){p.isMatch=false;return n?p:false}if(isIgnored(r)){if(typeof u.onIgnore===\"function\"){u.onIgnore(p)}p.isMatch=false;return n?p:false}if(typeof u.onMatch===\"function\"){u.onMatch(p)}return n?p:true};if(r){matcher.state=a}return matcher};picomatch.test=(e,t,r,{glob:n,posix:u}={})=>{if(typeof e!==\"string\"){throw new TypeError(\"Expected input to be a string\")}if(e===\"\"){return{isMatch:false,output:\"\"}}const s=r||{};const i=s.format||(u?o.toPosixSlashes:null);let a=e===n;let l=a&&i?i(e):e;if(a===false){l=i?i(e):e;a=l===n}if(a===false||s.capture===true){if(s.matchBase===true||s.basename===true){a=picomatch.matchBase(e,t,r,u)}else{a=t.exec(l)}}return{isMatch:Boolean(a),match:a,output:l}};picomatch.matchBase=(e,t,r,u=o.isWindows(r))=>{const s=t instanceof RegExp?t:picomatch.makeRe(t,r);return s.test(n.basename(e))};picomatch.isMatch=(e,t,r)=>picomatch(t,r)(e);picomatch.parse=(e,t)=>{if(Array.isArray(e))return e.map((e=>picomatch.parse(e,t)));return s(e,{...t,fastpaths:false})};picomatch.scan=(e,t)=>u(e,t);picomatch.compileRe=(e,t,r=false,n=false)=>{if(r===true){return e.output}const u=t||{};const s=u.contains?\"\":\"^\";const o=u.contains?\"\":\"$\";let i=`${s}(?:${e.output})${o}`;if(e&&e.negated===true){i=`^(?!${i}).*$`}const a=picomatch.toRegex(i,t);if(n===true){a.state=e}return a};picomatch.makeRe=(e,t,r=false,n=false)=>{if(!e||typeof e!==\"string\"){throw new TypeError(\"Expected a non-empty string\")}const u=t||{};let o={negated:false,fastpaths:true};let i=\"\";let a;if(e.startsWith(\"./\")){e=e.slice(2);i=o.prefix=\"./\"}if(u.fastpaths!==false&&(e[0]===\".\"||e[0]===\"*\")){a=s.fastpaths(e,t)}if(a===undefined){o=s(e,t);o.prefix=i+(o.prefix||\"\")}else{o.output=a}return picomatch.compileRe(o,t,r,n)};picomatch.toRegex=(e,t)=>{try{const r=t||{};return new RegExp(e,r.flags||(r.nocase?\"i\":\"\"))}catch(e){if(t&&t.debug===true)throw e;return/$^/}};picomatch.constants=i;e.exports=picomatch},700:(e,t,r)=>{const n=r(513);const{CHAR_ASTERISK:u,CHAR_AT:s,CHAR_BACKWARD_SLASH:o,CHAR_COMMA:i,CHAR_DOT:a,CHAR_EXCLAMATION_MARK:l,CHAR_FORWARD_SLASH:c,CHAR_LEFT_CURLY_BRACE:p,CHAR_LEFT_PARENTHESES:f,CHAR_LEFT_SQUARE_BRACKET:A,CHAR_PLUS:R,CHAR_QUESTION_MARK:_,CHAR_RIGHT_CURLY_BRACE:h,CHAR_RIGHT_PARENTHESES:g,CHAR_RIGHT_SQUARE_BRACKET:E}=r(356);const isPathSeparator=e=>e===c||e===o;const depth=e=>{if(e.isPrefix!==true){e.depth=e.isGlobstar?Infinity:1}};const scan=(e,t)=>{const r=t||{};const C=e.length-1;const y=r.parts===true||r.scanToEnd===true;const d=[];const x=[];const b=[];let S=e;let H=-1;let v=0;let $=0;let m=false;let T=false;let L=false;let O=false;let w=false;let N=false;let k=false;let I=false;let M=false;let P=0;let B;let G;let D={value:\"\",depth:0,isGlob:false};const eos=()=>H>=C;const peek=()=>S.charCodeAt(H+1);const advance=()=>{B=G;return S.charCodeAt(++H)};while(H<C){G=advance();let e;if(G===o){k=D.backslashes=true;G=advance();if(G===p){N=true}continue}if(N===true||G===p){P++;while(eos()!==true&&(G=advance())){if(G===o){k=D.backslashes=true;advance();continue}if(G===p){P++;continue}if(N!==true&&G===a&&(G=advance())===a){m=D.isBrace=true;L=D.isGlob=true;M=true;if(y===true){continue}break}if(N!==true&&G===i){m=D.isBrace=true;L=D.isGlob=true;M=true;if(y===true){continue}break}if(G===h){P--;if(P===0){N=false;m=D.isBrace=true;M=true;break}}}if(y===true){continue}break}if(G===c){d.push(H);x.push(D);D={value:\"\",depth:0,isGlob:false};if(M===true)continue;if(B===a&&H===v+1){v+=2;continue}$=H+1;continue}if(r.noext!==true){const e=G===R||G===s||G===u||G===_||G===l;if(e===true&&peek()===f){L=D.isGlob=true;O=D.isExtglob=true;M=true;if(y===true){while(eos()!==true&&(G=advance())){if(G===o){k=D.backslashes=true;G=advance();continue}if(G===g){L=D.isGlob=true;M=true;break}}continue}break}}if(G===u){if(B===u)w=D.isGlobstar=true;L=D.isGlob=true;M=true;if(y===true){continue}break}if(G===_){L=D.isGlob=true;M=true;if(y===true){continue}break}if(G===A){while(eos()!==true&&(e=advance())){if(e===o){k=D.backslashes=true;advance();continue}if(e===E){T=D.isBracket=true;L=D.isGlob=true;M=true;break}}if(y===true){continue}break}if(r.nonegate!==true&&G===l&&H===v){I=D.negated=true;v++;continue}if(r.noparen!==true&&G===f){L=D.isGlob=true;if(y===true){while(eos()!==true&&(G=advance())){if(G===f){k=D.backslashes=true;G=advance();continue}if(G===g){M=true;break}}continue}break}if(L===true){M=true;if(y===true){continue}break}}if(r.noext===true){O=false;L=false}let U=S;let K=\"\";let F=\"\";if(v>0){K=S.slice(0,v);S=S.slice(v);$-=v}if(U&&L===true&&$>0){U=S.slice(0,$);F=S.slice($)}else if(L===true){U=\"\";F=S}else{U=S}if(U&&U!==\"\"&&U!==\"/\"&&U!==S){if(isPathSeparator(U.charCodeAt(U.length-1))){U=U.slice(0,-1)}}if(r.unescape===true){if(F)F=n.removeBackslashes(F);if(U&&k===true){U=n.removeBackslashes(U)}}const Q={prefix:K,input:e,start:v,base:U,glob:F,isBrace:m,isBracket:T,isGlob:L,isExtglob:O,isGlobstar:w,negated:I};if(r.tokens===true){Q.maxDepth=0;if(!isPathSeparator(G)){x.push(D)}Q.tokens=x}if(r.parts===true||r.tokens===true){let t;for(let n=0;n<d.length;n++){const u=t?t+1:v;const s=d[n];const o=e.slice(u,s);if(r.tokens){if(n===0&&v!==0){x[n].isPrefix=true;x[n].value=K}else{x[n].value=o}depth(x[n]);Q.maxDepth+=x[n].depth}if(n!==0||o!==\"\"){b.push(o)}t=s}if(t&&t+1<e.length){const n=e.slice(t+1);b.push(n);if(r.tokens){x[x.length-1].value=n;depth(x[x.length-1]);Q.maxDepth+=x[x.length-1].depth}}Q.slashes=d;Q.parts=b}return Q};e.exports=scan},513:(e,t,r)=>{const n=r(17);const u=process.platform===\"win32\";const{REGEX_BACKSLASH:s,REGEX_REMOVE_BACKSLASH:o,REGEX_SPECIAL_CHARS:i,REGEX_SPECIAL_CHARS_GLOBAL:a}=r(356);t.isObject=e=>e!==null&&typeof e===\"object\"&&!Array.isArray(e);t.hasRegexChars=e=>i.test(e);t.isRegexChar=e=>e.length===1&&t.hasRegexChars(e);t.escapeRegex=e=>e.replace(a,\"\\\\$1\");t.toPosixSlashes=e=>e.replace(s,\"/\");t.removeBackslashes=e=>e.replace(o,(e=>e===\"\\\\\"?\"\":e));t.supportsLookbehinds=()=>{const e=process.version.slice(1).split(\".\").map(Number);if(e.length===3&&e[0]>=9||e[0]===8&&e[1]>=10){return true}return false};t.isWindows=e=>{if(e&&typeof e.windows===\"boolean\"){return e.windows}return u===true||n.sep===\"\\\\\"};t.escapeLast=(e,r,n)=>{const u=e.lastIndexOf(r,n);if(u===-1)return e;if(e[u-1]===\"\\\\\")return t.escapeLast(e,r,u-1);return`${e.slice(0,u)}\\\\${e.slice(u)}`};t.removePrefix=(e,t={})=>{let r=e;if(r.startsWith(\"./\")){r=r.slice(2);t.prefix=\"./\"}return r};t.wrapOutput=(e,t={},r={})=>{const n=r.contains?\"\":\"^\";const u=r.contains?\"\":\"$\";let s=`${n}(?:${e})${u}`;if(t.negated===true){s=`(?:^(?!${s}).*$)`}return s}},492:(e,t,r)=>{\n/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\nconst n=r(357);const toRegexRange=(e,t,r)=>{if(n(e)===false){throw new TypeError(\"toRegexRange: expected the first argument to be a number\")}if(t===void 0||e===t){return String(e)}if(n(t)===false){throw new TypeError(\"toRegexRange: expected the second argument to be a number.\")}let u={relaxZeros:true,...r};if(typeof u.strictZeros===\"boolean\"){u.relaxZeros=u.strictZeros===false}let s=String(u.relaxZeros);let o=String(u.shorthand);let i=String(u.capture);let a=String(u.wrap);let l=e+\":\"+t+\"=\"+s+o+i+a;if(toRegexRange.cache.hasOwnProperty(l)){return toRegexRange.cache[l].result}let c=Math.min(e,t);let p=Math.max(e,t);if(Math.abs(c-p)===1){let r=e+\"|\"+t;if(u.capture){return`(${r})`}if(u.wrap===false){return r}return`(?:${r})`}let f=hasPadding(e)||hasPadding(t);let A={min:e,max:t,a:c,b:p};let R=[];let _=[];if(f){A.isPadded=f;A.maxLen=String(A.max).length}if(c<0){let e=p<0?Math.abs(p):1;_=splitToPatterns(e,Math.abs(c),A,u);c=A.a=0}if(p>=0){R=splitToPatterns(c,p,A,u)}A.negatives=_;A.positives=R;A.result=collatePatterns(_,R,u);if(u.capture===true){A.result=`(${A.result})`}else if(u.wrap!==false&&R.length+_.length>1){A.result=`(?:${A.result})`}toRegexRange.cache[l]=A;return A.result};function collatePatterns(e,t,r){let n=filterPatterns(e,t,\"-\",false,r)||[];let u=filterPatterns(t,e,\"\",false,r)||[];let s=filterPatterns(e,t,\"-?\",true,r)||[];let o=n.concat(s).concat(u);return o.join(\"|\")}function splitToRanges(e,t){let r=1;let n=1;let u=countNines(e,r);let s=new Set([t]);while(e<=u&&u<=t){s.add(u);r+=1;u=countNines(e,r)}u=countZeros(t+1,n)-1;while(e<u&&u<=t){s.add(u);n+=1;u=countZeros(t+1,n)-1}s=[...s];s.sort(compare);return s}function rangeToPattern(e,t,r){if(e===t){return{pattern:e,count:[],digits:0}}let n=zip(e,t);let u=n.length;let s=\"\";let o=0;for(let e=0;e<u;e++){let[t,u]=n[e];if(t===u){s+=t}else if(t!==\"0\"||u!==\"9\"){s+=toCharacterClass(t,u,r)}else{o++}}if(o){s+=r.shorthand===true?\"\\\\d\":\"[0-9]\"}return{pattern:s,count:[o],digits:u}}function splitToPatterns(e,t,r,n){let u=splitToRanges(e,t);let s=[];let o=e;let i;for(let e=0;e<u.length;e++){let t=u[e];let a=rangeToPattern(String(o),String(t),n);let l=\"\";if(!r.isPadded&&i&&i.pattern===a.pattern){if(i.count.length>1){i.count.pop()}i.count.push(a.count[0]);i.string=i.pattern+toQuantifier(i.count);o=t+1;continue}if(r.isPadded){l=padZeros(t,r,n)}a.string=l+a.pattern+toQuantifier(a.count);s.push(a);o=t+1;i=a}return s}function filterPatterns(e,t,r,n,u){let s=[];for(let u of e){let{string:e}=u;if(!n&&!contains(t,\"string\",e)){s.push(r+e)}if(n&&contains(t,\"string\",e)){s.push(r+e)}}return s}function zip(e,t){let r=[];for(let n=0;n<e.length;n++)r.push([e[n],t[n]]);return r}function compare(e,t){return e>t?1:t>e?-1:0}function contains(e,t,r){return e.some((e=>e[t]===r))}function countNines(e,t){return Number(String(e).slice(0,-t)+\"9\".repeat(t))}function countZeros(e,t){return e-e%Math.pow(10,t)}function toQuantifier(e){let[t=0,r=\"\"]=e;if(r||t>1){return`{${t+(r?\",\"+r:\"\")}}`}return\"\"}function toCharacterClass(e,t,r){return`[${e}${t-e===1?\"\":\"-\"}${t}]`}function hasPadding(e){return/^-?(0+)\\d/.test(e)}function padZeros(e,t,r){if(!t.isPadded){return e}let n=Math.abs(t.maxLen-String(e).length);let u=r.relaxZeros!==false;switch(n){case 0:return\"\";case 1:return u?\"0?\":\"0\";case 2:return u?\"0{0,2}\":\"00\";default:{return u?`0{0,${n}}`:`0{${n}}`}}}toRegexRange.cache={};toRegexRange.clearCache=()=>toRegexRange.cache={};e.exports=toRegexRange},17:e=>{e.exports=__webpack_require__(/*! path */ \"./node_modules/next/dist/compiled/path-browserify/index.js\")},837:e=>{e.exports=__webpack_require__(/*! util */ \"../../node_modules/util/util.js\")}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var u=t[r]={exports:{}};var s=true;try{e[r](u,u.exports,__nccwpck_require__);s=false}finally{if(s)delete t[r]}return u.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(971);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pY3JvbWF0Y2gvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7QUFBQSxNQUFNLGFBQWEsT0FBTyxjQUFjLGVBQWUsZUFBZSxjQUFjLGVBQWUsb0JBQW9CLElBQUksU0FBUyxxQkFBcUIsZ0JBQWdCLHlCQUF5QixxQkFBcUIsYUFBYSxLQUFLLFlBQVksS0FBSyxnQ0FBZ0MseUNBQXlDLGtCQUFrQixVQUFVLG9CQUFvQixVQUFVLHdCQUF3QixJQUFJLHdCQUF3Qiw4QkFBOEIsZUFBZSxzQkFBc0IsSUFBSSx3QkFBd0Isb0JBQW9CLGVBQWUscUJBQXFCLElBQUksd0JBQXdCLG9CQUFvQixhQUFhLHFCQUFxQixvQkFBb0IscUJBQXFCLGtCQUFrQixVQUFVLHFCQUFxQixJQUFJLHVCQUF1QixVQUFVLCtEQUErRCxpQkFBaUIsZUFBZSxlQUFlLGVBQWUscUJBQXFCLElBQUksZ0JBQWdCLElBQUksMEJBQTBCLCtDQUErQyx5QkFBeUIscUNBQXFDLFNBQVMsb0JBQW9CLGlCQUFpQixxQkFBcUIsaUJBQWlCLG9CQUFvQix1QkFBdUIscUJBQXFCLHVCQUF1QixxQkFBcUIsOENBQThDLFlBQVksZUFBZSx3QkFBd0Isd0JBQXdCLGNBQWMsNkJBQTZCLEVBQUUsaUJBQWlCLGtDQUFrQyxFQUFFLE1BQU0sWUFBWSxzQkFBc0IsY0FBYyxVQUFVLGdCQUFnQixrQkFBa0IsU0FBUyxXQUFXLDJqQkFBMmpCLHVMQUF1TCxpREFBaUQsd0lBQXdJLGNBQWMsZUFBZSxlQUFlLGVBQWUsbUNBQW1DLFNBQVMsZUFBZSxlQUFlLHNCQUFzQixjQUFjLGdDQUFnQyxFQUFFLEdBQUcsTUFBTSxnQkFBZ0IscUJBQXFCLGdCQUFnQix1QkFBdUIsS0FBSyxnQkFBZ0IscUNBQXFDLEVBQUUsR0FBRyxFQUFFLDZDQUE2QyxxQkFBcUIsb0JBQW9CLElBQUksNkNBQTZDLGdCQUFnQixJQUFJLFdBQVcsUUFBUSxjQUFjLG1EQUFtRCxXQUFXLFVBQVUsd0JBQXdCLCtCQUErQixPQUFPLDJEQUEyRCwwQkFBMEIsS0FBSyxPQUFPLHdCQUF3Qix3QkFBd0Isa0NBQWtDLDRIQUE0SCxnQkFBZ0IsaUJBQWlCLFNBQVMsMEJBQTBCLFdBQVcsT0FBTyx3QkFBd0IsY0FBYyxRQUFRLG1EQUFtRCxXQUFXLFVBQVUsWUFBWSxpQkFBaUIsS0FBSyxpQkFBaUIsdUNBQXVDLG9CQUFvQixXQUFXLFNBQVMscUJBQXFCLDRCQUE0QixTQUFTLDZCQUE2QixnQ0FBZ0MsU0FBUyxZQUFZLFdBQVcsVUFBVSwyQkFBMkIsaUJBQWlCLGVBQWUsZUFBZSxNQUFNLDZUQUE2VCxRQUFRLG1CQUFtQixJQUFJLHdCQUF3Qix5Q0FBeUMsWUFBWSw4REFBOEQsZUFBZSx1Q0FBdUMsU0FBUyw2QkFBNkIsRUFBRSxJQUFJLE9BQU8sOEJBQThCLFVBQVUsUUFBUSxRQUFRLFFBQVEsZUFBZSxRQUFRLFFBQVEsTUFBTSxTQUFTLHlCQUF5QixlQUFlLG9DQUFvQyxjQUFjLHdDQUF3QyxpQkFBaUIsT0FBTyxnQkFBZ0IsV0FBVyxTQUFTLElBQUksVUFBVSxNQUFNLFdBQVcsRUFBRSxXQUFXLGdCQUFnQixZQUFZLGlCQUFpQixTQUFTLFVBQVUsTUFBTSxrREFBa0QsRUFBRSxTQUFTLFVBQVUsTUFBTSx5QkFBeUIsRUFBRSxTQUFTLFVBQVUsSUFBSSxXQUFXLE1BQU0sMEJBQTBCLEtBQUssVUFBVSxJQUFJLFNBQVMsVUFBVSxhQUFhLFNBQVMsVUFBVSxJQUFJLFVBQVUsUUFBUSxNQUFNLG9CQUFvQixFQUFFLFNBQVMsVUFBVSxRQUFRLHNCQUFzQixFQUFFLFVBQVUsTUFBTSxvQkFBb0IsRUFBRSxTQUFTLFVBQVUscUJBQXFCLE1BQU0sb0JBQW9CLEVBQUUsU0FBUyxVQUFVLE1BQU0sb0JBQW9CLEVBQUUsZ0JBQWdCLFNBQVMsd0JBQXdCLFFBQVEsTUFBTSx3QkFBd0IsS0FBSywwQkFBMEIsVUFBVSxlQUFlLFNBQVMsVUFBVSw0QkFBNEIsTUFBTSxLQUFLLE1BQU0sb0JBQW9CLEVBQUUsU0FBUyxVQUFVLElBQUksd0RBQXdELE9BQU8sZ0ZBQWdGLFVBQVUsVUFBVSxNQUFNLG9CQUFvQixFQUFFLFNBQVMsVUFBVSxxQkFBcUIsTUFBTSxvQkFBb0IsRUFBRSxTQUFTLGNBQWMsVUFBVSxhQUFhLE1BQU0sZUFBZSxFQUFFLElBQUksZ0JBQWdCLFNBQVMsZUFBZSxlQUFlLFdBQVcsc0JBQXNCLFlBQVksdUJBQXVCLEVBQUUsTUFBTSxxQkFBcUIsRUFBRSxXQUFXLFNBQVMsNkJBQTZCLGNBQWMsd0JBQXdCLE1BQU0sb0JBQW9CLEVBQUUsU0FBUyxtQkFBbUIsV0FBVyxXQUFXLGVBQWUsMkNBQTJDLGVBQWUsV0FBVyxjQUFjLFNBQVMsV0FBVyxVQUFVLFNBQVMscUJBQXFCLFFBQVEsb0JBQW9CLG1CQUFtQixJQUFJLFdBQVcsU0FBUyxNQUFNLG1CQUFtQixFQUFFLFNBQVMsTUFBTSxvQkFBb0IsRUFBRSxHQUFHLFVBQVUsb0JBQW9CLHFCQUFxQixhQUFhLGlDQUFpQyxtQ0FBbUMsMEJBQTBCLGdCQUFnQixHQUFHLG9CQUFvQix5QkFBeUIsZ0NBQWdDLGtCQUFrQixNQUFNLFdBQVcsRUFBRSxVQUFVLGdCQUFnQixlQUFlLGVBQWUsaUJBQWlCLElBQUkscUJBQXFCLElBQUksMkNBQTJDLCtDQUErQyxTQUFTLFlBQVksK0JBQStCLG1CQUFtQixlQUFlLFlBQVksZUFBZSxZQUFZLHNCQUFzQixpQkFBaUIsVUFBVSxxQkFBcUIsYUFBYSxnQkFBZ0Isd0JBQXdCLDJCQUEyQix1Q0FBdUMsbUNBQW1DLGNBQWMsNENBQTRDLDZCQUE2QiwwQkFBMEIsaURBQWlELDBDQUEwQyx5QkFBeUIsaUJBQWlCLGFBQWEscURBQXFELHFCQUFxQixxQkFBcUIsa0JBQWtCLG1CQUFtQixpQ0FBaUMsZ0NBQWdDLGVBQWUsWUFBWSxjQUFjLHFCQUFxQixpQ0FBaUMsMENBQTBDLGdDQUFnQyxlQUFlLFlBQVksa0NBQWtDLGVBQWUsWUFBWSxjQUFjLG9CQUFvQixzQ0FBc0MsWUFBWSxzQ0FBc0MsOEJBQThCLG1DQUFtQyxrQ0FBa0MsU0FBUyxNQUFNLG1CQUFtQixXQUFXLGVBQWUsWUFBWSxXQUFXLEtBQUssV0FBVyxpREFBaUQsVUFBVSxRQUFRLFVBQVU7QUFDeGpSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZSxtRUFBbUUsbURBQW1ELHVFQUF1RSx1Q0FBdUMsZ0JBQWdCLFNBQVMsRUFBRSxFQUFFLFNBQVMsMkJBQTJCLHdCQUF3QixvQkFBb0IsWUFBWSwwQkFBMEIsNkNBQTZDLFlBQVksMkJBQTJCLG9CQUFvQixRQUFRLHdCQUF3QixrQkFBa0IsNEJBQTRCLGNBQWMsaUJBQWlCLFVBQVUsdUJBQXVCLHdCQUF3QixNQUFNLGFBQWEsSUFBSSx5QkFBeUIsa0JBQWtCLHlCQUF5QiwwQ0FBMEMsMENBQTBDLHdCQUF3QixTQUFTLFNBQVMsTUFBTSx1QkFBdUIsd0JBQXdCLHVCQUF1QixPQUFPLEVBQUUsRUFBRSxzQkFBc0IsR0FBRyxTQUFTLEtBQUssRUFBRSxHQUFHLEVBQUUsRUFBRSxLQUFLLE9BQU8sV0FBVyxVQUFVLEVBQUUsRUFBRSxFQUFFLEdBQUcsVUFBVSwwQkFBMEIsTUFBTSxjQUFjLGdCQUFnQixFQUFFLDZCQUE2QixrQkFBa0IsNkJBQTZCLFVBQVUsRUFBRSxHQUFHLEVBQUUsSUFBSSx3QkFBd0IscUJBQXFCLG9CQUFvQix3QkFBd0IsYUFBYSxFQUFFLEVBQUUsWUFBWSxlQUFlLGlCQUFpQixxRkFBcUYsNkJBQTZCLGlEQUFpRCxVQUFVLDBCQUEwQiwwQkFBMEIsc0NBQXNDLEVBQUUsbUJBQW1CLFVBQVUsK0JBQStCLElBQUksZ0JBQWdCLGdCQUFnQiwrQ0FBK0MsaURBQWlELFNBQVMsYUFBYSxhQUFhLFVBQVUsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsMEJBQTBCLG1DQUFtQywrQ0FBK0MsMENBQTBDLGdDQUFnQyxxQkFBcUIsbURBQW1ELE9BQU8sMkJBQTJCLDZEQUE2RCxTQUFTLFFBQVEsbUJBQW1CLDBCQUEwQixRQUFRLEtBQUssd0JBQXdCLFlBQVksSUFBSSxxQkFBcUIsMkNBQTJDLGdCQUFnQixFQUFFLFVBQVUsK0JBQStCLElBQUksdURBQXVELDJCQUEyQiwrQ0FBK0MsU0FBUyxFQUFFLGdCQUFnQixTQUFTLEVBQUUsZ0JBQWdCLFVBQVUsb0JBQW9CLG9CQUFvQixxQkFBcUIsNEJBQTRCLFNBQVMsUUFBUSxtQkFBbUIsZUFBZSxZQUFZLElBQUkscUJBQXFCLHVCQUF1QixxQkFBcUIsRUFBRSxVQUFVLHNCQUFzQixJQUFJLDZCQUE2QixVQUFVLHVDQUF1QywyQkFBMkIsMEJBQTBCLG1CQUFtQixZQUFZLEVBQUUsZ0JBQWdCLHFCQUFxQixPQUFPLE1BQU0sZ0NBQWdDLGVBQWUsaUJBQWlCLGlEQUFpRCxxQkFBcUIsNkJBQTZCLDRCQUE0QixtREFBbUQsZUFBZTtBQUM5M0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QixlQUFlLHVDQUF1Qyx3REFBd0QsY0FBYyxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsd0NBQXdDLDJCQUEyQixlQUFlLGVBQWUsY0FBYyxjQUFjLGNBQWMsUUFBUSxpQkFBaUIsZ0JBQWdCLGtCQUFrQixnQkFBZ0IsWUFBWSxXQUFXLEtBQUssc0JBQXNCLHVCQUF1QixPQUFPLDhDQUE4QyxTQUFTLGdCQUFnQixnQkFBZ0IsNkJBQTZCLGVBQWUsTUFBTSxnQkFBZ0IsS0FBSyxtQkFBbUIsa0JBQWtCLGlDQUFpQywrQkFBK0Isb0JBQW9CLHNCQUFzQix5Q0FBeUMsYUFBYSxJQUFJLHVDQUF1QyxxREFBcUQsVUFBVSw0QkFBNEIsaUNBQWlDLHNDQUFzQyxrQ0FBa0Msd0JBQXdCLElBQUksMkJBQTJCLGNBQWMsU0FBUyxpQkFBaUIsNEJBQTRCLGtCQUFrQixzQkFBc0IsdUJBQXVCLEVBQUUsZ0JBQWdCLG1CQUFtQixVQUFVLGNBQWMsOEJBQThCLHdCQUF3QiwyQ0FBMkMsYUFBYSxJQUFJLHFCQUFxQiwrQ0FBK0Msd0JBQXdCLHVDQUF1QyxhQUFhLDhEQUE4RCxhQUFhLCtCQUErQixtQkFBbUIsR0FBRywrQkFBK0IsbUJBQW1CLG1FQUFtRSxxQ0FBcUMsU0FBUyx5QkFBeUIsVUFBVSwwQkFBMEIsbUJBQW1CLDBCQUEwQixxQkFBcUIsc0JBQXNCLGFBQWEsY0FBYywyQkFBMkIsbUJBQW1CLDBCQUEwQixxQkFBcUIsd0JBQXdCLGNBQWMsYUFBYSx5QkFBeUIsd0JBQXdCLDJDQUEyQyxhQUFhLElBQUksMENBQTBDLDZCQUE2QixxQkFBcUIsMEJBQTBCLGtCQUFrQixFQUFFLHNDQUFzQyxNQUFNLDhDQUE4Qyx5Q0FBeUMscUNBQXFDLHlCQUF5QixTQUFTLDhCQUE4Qiw2QkFBNkIsc0JBQXNCLFVBQVUsMEJBQTBCLGdFQUFnRSw0QkFBNEIsSUFBSSxXQUFXLFVBQVUsZUFBZSwrQkFBK0IsZ0VBQWdFLDRCQUE0QixpQkFBaUIsR0FBRyxxQkFBcUIsZUFBZSxpQkFBaUIsZUFBZSxjQUFjLGdCQUFnQixhQUFhLEVBQUUsR0FBRyxjQUFjLGNBQWMsY0FBYyxjQUFjLGdCQUFnQixlQUFlLGNBQWMsRUFBRSxLQUFLLGdCQUFnQixFQUFFLEdBQUcsV0FBVyxHQUFHLElBQUksRUFBRSxFQUFFLEVBQUUsY0FBYyxFQUFFLEdBQUcsY0FBYyxFQUFFLEVBQUUsRUFBRSxHQUFHLGNBQWMsR0FBRyxJQUFJLEVBQUUsRUFBRSxHQUFHLGNBQWMsRUFBRSxHQUFHLGNBQWMsRUFBRSxHQUFHLFdBQVcsRUFBRSxJQUFJLFNBQVMsa01BQWtNLFNBQVMsdUJBQXVCLEVBQUUsbUJBQW1CLEVBQUUsa0JBQWtCLEdBQUcsSUFBSSxNQUFNLEVBQUUsbUJBQW1CLEVBQUUsdUJBQXVCLEVBQUUsSUFBSSxHQUFHLElBQUksTUFBTSxFQUFFLDBCQUEwQixHQUFHLElBQUksTUFBTSxFQUFFLDJCQUEyQixHQUFHLElBQUksTUFBTSxFQUFFLDBCQUEwQixFQUFFLHlCQUF5QixFQUFFLHNCQUFzQixFQUFFLE9BQU8sU0FBUyx5TEFBeUwsYUFBYSxFQUFFLDhFQUE4RSxXQUFXLHNFQUFzRSxxREFBcUQseUNBQXlDLGdHQUFnRyw0RUFBNEUsdUNBQXVDLDYzQkFBNjNCLE9BQU8sS0FBSywwQ0FBMEMsT0FBTyxHQUFHLE1BQU0sbUNBQW1DLE1BQU0sa0NBQWtDLE1BQU0sa0NBQWtDLE1BQU0saUNBQWlDLGNBQWMsc0JBQXNCLGVBQWUsZUFBZSxlQUFlLE1BQU0seUdBQXlHLEdBQUcsMEJBQTBCLHNDQUFzQyw2QkFBNkIsU0FBUyxZQUFZLFlBQVksR0FBRyxJQUFJLGNBQWMsU0FBUywrQ0FBK0MsVUFBVSxvQ0FBb0MsRUFBRSxLQUFLLEVBQUUsZUFBZSxFQUFFLCtCQUErQixvQkFBb0Isd0JBQXdCLHlDQUF5QyxVQUFVLFNBQVMsTUFBTSxnRUFBZ0UsZUFBZSxRQUFRLHVDQUF1QyxFQUFFLG9DQUFvQyxFQUFFLEdBQUcsU0FBUywwQ0FBMEMsWUFBWSwwQkFBMEIsdUJBQXVCLHVCQUF1QiwwQkFBMEIsTUFBTSwwSkFBMEosR0FBRyxzQkFBc0IsRUFBRSxRQUFRLEVBQUUsRUFBRSxVQUFVLFFBQVEsbUJBQW1CLGtCQUFrQixrQ0FBa0MsY0FBYyxNQUFNLEVBQUUsR0FBRywrQkFBK0Isb0JBQW9CLFNBQVMsdUtBQXVLLHNCQUFzQixXQUFXLFdBQVcsV0FBVyxXQUFXLFFBQVEsTUFBTSw0QkFBNEIsbUNBQW1DLG1DQUFtQyx1Q0FBdUMsMkJBQTJCLGNBQWMsWUFBWSxpQkFBaUIsMENBQTBDLGtCQUFrQixrQkFBa0IsUUFBUSwyQ0FBMkMsSUFBSSxVQUFVLElBQUksWUFBWSxhQUFhLGVBQWUsVUFBVSxhQUFhLG9CQUFvQixPQUFPLFdBQVcsb0JBQW9CLE9BQU8sU0FBUyxlQUFlLHdCQUF3Qix5REFBeUQsd0VBQXdFLCtDQUErQyw0Q0FBNEMsY0FBYyxZQUFZLFdBQVcsb0JBQW9CLDRDQUE0Qyw2QkFBNkIsK0JBQStCLHdDQUF3QyxpQkFBaUIsZ0NBQWdDLE9BQU8sU0FBUyxVQUFVLEtBQUssMEJBQTBCLFNBQVMsK0JBQStCLFNBQVMsa0JBQWtCLGtCQUFrQixrQ0FBa0Msb0JBQW9CLE1BQU0sb0NBQW9DLEVBQUUsTUFBTSw2Q0FBNkMsRUFBRSxXQUFXLHVCQUF1QixpQ0FBaUMsc0JBQXNCLFFBQVEscURBQXFELGNBQWMsNENBQTRDLGlCQUFpQixFQUFFLEVBQUUsd0JBQXdCLHVCQUF1QixNQUFNLDJDQUEyQyxFQUFFLHFCQUFxQiwwQ0FBMEMsY0FBYyxZQUFZLG1DQUFtQyxhQUFhLE9BQU8sU0FBUyxZQUFZLE1BQU0scUNBQXFDLFVBQVUsbUNBQW1DLDBCQUEwQixZQUFZLDBCQUEwQixZQUFZLE1BQU0sb0JBQW9CLFNBQVMsZ0JBQWdCLEVBQUUsRUFBRSxHQUFHLGFBQWEsc0JBQXNCLHNCQUFzQixLQUFLLDBEQUEwRCw2QkFBNkIsV0FBVyxTQUFTLDZCQUE2QixTQUFTLGNBQWMsTUFBTSxhQUFhLFNBQVMsYUFBYSxZQUFZLDJCQUEyQixTQUFTLGtCQUFrQixHQUFHLFNBQVMsT0FBTyxRQUFRLE1BQU0sb0JBQW9CLEVBQUUsU0FBUyxpQ0FBaUMsUUFBUSxxQkFBcUIsY0FBYyxXQUFXLFlBQVksU0FBUyxzQkFBc0IsVUFBVSxLQUFLLFdBQVcsbUJBQW1CLE1BQU0sb0JBQW9CLEVBQUUsVUFBVSwyREFBMkQsNkJBQTZCLHlCQUF5QixvQkFBb0IsYUFBYSxvQkFBb0IsaUNBQWlDLDJCQUEyQiwyQkFBMkIsYUFBYSxNQUFNLFlBQVksaUJBQWlCLElBQUksZ0NBQWdDLFdBQVcsWUFBWSwyQ0FBMkMsT0FBTyxFQUFFLEVBQUUsNkNBQTZDLE9BQU8sRUFBRSxFQUFFLDJDQUEyQyxNQUFNLFdBQVcsUUFBUSxRQUFRLEVBQUUsU0FBUywwQkFBMEIsbUJBQW1CLFdBQVcsUUFBUSxRQUFRLEVBQUUsU0FBUyxZQUFZLDBCQUEwQix3QkFBd0IsTUFBTSxvQkFBb0IsRUFBRSxTQUFTLFlBQVksb0JBQW9CLE1BQU0scUJBQXFCLEVBQUUsU0FBUyxZQUFZLDBDQUEwQyxrREFBa0Qsc0JBQXNCLDZCQUE2QixzQkFBc0IsU0FBUyxNQUFNLCtDQUErQyxFQUFFLG9CQUFvQixTQUFTLFlBQVksbURBQW1ELGdEQUFnRCxrREFBa0QsT0FBTyxFQUFFLEVBQUUsS0FBSyxzQkFBc0IsTUFBTSx1QkFBdUIsRUFBRSxTQUFTLFlBQVksa0VBQWtFLE1BQU0sZ0NBQWdDLEVBQUUsRUFBRSxFQUFFLFNBQVMsbUJBQW1CLDRCQUE0QixrREFBa0QsTUFBTSxnQ0FBZ0MsRUFBRSxFQUFFLEVBQUUsU0FBUyxzQkFBc0IseUJBQXlCLGlEQUFpRCxNQUFNLEVBQUUsRUFBRSxXQUFXLFFBQVEsUUFBUSxFQUFFLGtEQUFrRCxTQUFTLCtCQUErQiwyQ0FBMkMsNkJBQTZCLFlBQVksVUFBVSxTQUFTLFlBQVksRUFBRSxFQUFFLEVBQUUsR0FBRyxRQUFRLEdBQUcsa0JBQWtCLFNBQVMsU0FBUyxxQkFBcUIsb0JBQW9CLFNBQVMseUZBQXlGLFVBQVUsUUFBUSxTQUFTLFNBQVMsR0FBRyxzQkFBc0IseUJBQXlCLE1BQU0sNkJBQTZCLEVBQUUsU0FBUyxVQUFVLGtCQUFrQixrQkFBa0IsV0FBVyxxQkFBcUIsS0FBSyxLQUFLLFFBQVEsd0JBQXdCLE1BQU0sdUJBQXVCLHVCQUF1QixtQkFBbUIsaUJBQWlCLGtDQUFrQyx3Q0FBd0Msc0NBQXNDLHFCQUFxQixFQUFFLFFBQVEsRUFBRSxXQUFXLGtCQUFrQiw2QkFBNkIsTUFBTSw4QkFBOEIsRUFBRSxvQkFBb0IsUUFBUSxTQUFTLFlBQVksZUFBZSwyQkFBMkIsTUFBTSxvQkFBb0IsRUFBRSxTQUFTLFlBQVksUUFBUSxzQkFBc0IsZ0NBQWdDLGFBQWEsTUFBTSxNQUFNLDhCQUE4QixFQUFFLFNBQVMsWUFBWSx3Q0FBd0Msa0JBQWtCLGNBQWMsWUFBWSxRQUFRLElBQUksU0FBUyxNQUFNLDhCQUE4QixFQUFFLFNBQVMsWUFBWSwrQkFBK0IsNEJBQTRCLHNCQUFzQixjQUFjLFlBQVksV0FBVyxZQUFZLFNBQVMsNERBQTRELE1BQU0sNkJBQTZCLEVBQUUsU0FBUyxNQUFNLDRCQUE0QixFQUFFLFNBQVMsWUFBWSx5QkFBeUIsa0RBQWtELHVCQUF1QixTQUFTLHdCQUF3QixZQUFZLFFBQVEsc0NBQXNDLDJFQUEyRSxpRkFBaUYsT0FBTyxFQUFFLEVBQUUsTUFBTSw2QkFBNkIsRUFBRSxTQUFTLHFEQUFxRCxNQUFNLDhCQUE4QixFQUFFLFNBQVMsTUFBTSw4QkFBOEIsRUFBRSxTQUFTLFlBQVksa0NBQWtDLHFDQUFxQyx3QkFBd0IsVUFBVSxtQ0FBbUMsU0FBUyxVQUFVLFlBQVksOENBQThDLHNCQUFzQixTQUFTLHNDQUFzQyxNQUFNLDZCQUE2QixFQUFFLFNBQVMsNEVBQTRFLE1BQU0sb0JBQW9CLEVBQUUsU0FBUyxNQUFNLG9CQUFvQixFQUFFLFNBQVMsWUFBWSw4Q0FBOEMsTUFBTSx5Q0FBeUMsRUFBRSxTQUFTLE1BQU0sb0JBQW9CLEVBQUUsU0FBUyxZQUFZLHFCQUFxQixPQUFPLEVBQUUsRUFBRSw0QkFBNEIsTUFBTSxRQUFRLHFCQUFxQixNQUFNLG9CQUFvQixFQUFFLFNBQVMsNENBQTRDLGNBQWMsWUFBWSxXQUFXLFdBQVcsaUJBQWlCLGdCQUFnQixXQUFXLFNBQVMsa0JBQWtCLDBDQUEwQyxzQkFBc0IsU0FBUyxvQkFBb0Isd0JBQXdCLFdBQVcsU0FBUyxlQUFlLGVBQWUseUNBQXlDLGtEQUFrRCwwQ0FBMEMsTUFBTSw4QkFBOEIsRUFBRSxTQUFTLHlEQUF5RCxzREFBc0QsaUNBQWlDLE1BQU0sOEJBQThCLEVBQUUsU0FBUyw0QkFBNEIscUJBQXFCLGVBQWUsTUFBTSxhQUFhLGlCQUFpQiwwQkFBMEIsa0JBQWtCLFdBQVcscUJBQXFCLGtCQUFrQixnQkFBZ0IsV0FBVyxTQUFTLHFEQUFxRCx1REFBdUQsZUFBZSxTQUFTLEVBQUUsa0JBQWtCLGlEQUFpRCxXQUFXLGdCQUFnQiw0QkFBNEIsV0FBVyxTQUFTLHNEQUFzRCw4QkFBOEIsdURBQXVELGVBQWUsU0FBUyxFQUFFLGtCQUFrQixZQUFZLFlBQVksRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsR0FBRyxXQUFXLDRCQUE0QixnQkFBZ0IsZUFBZSxNQUFNLGlDQUFpQyxFQUFFLFNBQVMsK0JBQStCLGtCQUFrQixXQUFXLGlCQUFpQixFQUFFLEdBQUcsWUFBWSxFQUFFLEVBQUUsR0FBRyxrQkFBa0IsZ0JBQWdCLGVBQWUsTUFBTSxpQ0FBaUMsRUFBRSxTQUFTLDRDQUE0QyxrQkFBa0IscUJBQXFCLFdBQVcsbUJBQW1CLGdCQUFnQixXQUFXLFNBQVMsU0FBUyw4QkFBOEIsa0JBQWtCLGVBQWUscUNBQXFDLG9CQUFvQixRQUFRLFNBQVMsOERBQThELFdBQVcsUUFBUSxTQUFTLHdEQUF3RCxtQkFBbUIsWUFBWSxZQUFZLHNCQUFzQixZQUFZLFlBQVksS0FBSyxZQUFZLFlBQVksY0FBYyxZQUFZLGFBQWEsUUFBUSxvQkFBb0IsNkVBQTZFLG9DQUFvQyxzQkFBc0Isa0JBQWtCLDZFQUE2RSxvQ0FBb0Msb0JBQW9CLGtCQUFrQix5RUFBeUUsSUFBSSxpQ0FBaUMsR0FBRyxvQkFBb0Isa0VBQWtFLE1BQU0sc0NBQXNDLEVBQUUsR0FBRyxFQUFFLHVCQUF1QixZQUFZLHlCQUF5QiwwQ0FBMEMsYUFBYSxxQkFBcUIsVUFBVSx3QkFBd0IsU0FBUyxNQUFNLGdFQUFnRSxpQkFBaUIsUUFBUSx1Q0FBdUMsRUFBRSxvQ0FBb0MsRUFBRSxHQUFHLFVBQVUsdUJBQXVCLE1BQU0sK0dBQStHLGdCQUFnQixrQkFBa0Isa0JBQWtCLDBCQUEwQixTQUFTLHlCQUF5Qiw0QkFBNEIsY0FBYyxNQUFNLEVBQUUsR0FBRyxtQkFBbUIsZ0NBQWdDLFVBQVUsRUFBRSxRQUFRLEVBQUUsRUFBRSxVQUFVLFNBQVMsaUJBQWlCLFVBQVUsaUJBQWlCLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLGtCQUFrQixFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxtQkFBbUIsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxtQkFBbUIsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsOEJBQThCLHVCQUF1QixFQUFFLEVBQUUsWUFBWSxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSx5QkFBeUIsRUFBRSxFQUFFLFlBQVksRUFBRSxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSx3QkFBd0IsRUFBRSxFQUFFLFlBQVksRUFBRSxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsU0FBUyxpQ0FBaUMsYUFBYSxxQkFBcUIsYUFBYSxtQkFBbUIsNEJBQTRCLGdCQUFnQiw4QkFBOEIsTUFBTSxFQUFFLEdBQUcsVUFBVSxnQkFBZ0IsZUFBZSxjQUFjLGVBQWUsZUFBZSxlQUFlLGVBQWUsNERBQTRELGdDQUFnQyxxQkFBcUIscUNBQXFDLHVCQUF1QixrQkFBa0IsYUFBYSxjQUFjLGNBQWMsb0JBQW9CLHVDQUF1QyxvQ0FBb0MsaUVBQWlFLGNBQWMsdUJBQXVCLG9FQUFvRSxnQkFBZ0IsZUFBZSx3QkFBd0IsYUFBYSxTQUFTLDZDQUE2QyxrQ0FBa0MsNEJBQTRCLE1BQU0sMkJBQTJCLHVCQUF1QixlQUFlLEVBQUUsU0FBUyxtRUFBbUUsbUNBQW1DLGNBQWMsY0FBYyxnQkFBZ0IsaUJBQWlCLGlCQUFpQixtQ0FBbUMsY0FBYyxnQkFBZ0IsaUJBQWlCLGtDQUFrQyxhQUFhLGlCQUFpQixNQUFNLGdCQUFnQixnQkFBZ0IsdUJBQXVCLGVBQWUsR0FBRyxJQUFJLHdCQUF3QixxREFBcUQsV0FBVyxPQUFPLHlCQUF5QixjQUFjLDRDQUE0QyxZQUFZLGtCQUFrQixjQUFjLFdBQVcsUUFBUSxnQ0FBZ0MsMENBQTBDLCtCQUErQixLQUFLLGFBQWEsT0FBTyxzQ0FBc0MsK0NBQStDLG9EQUFvRCw4QkFBOEIsNkNBQTZDLHdCQUF3Qiw0REFBNEQsWUFBWSxxQkFBcUIsR0FBRyw2QkFBNkIsNENBQTRDLGFBQWEsZ0JBQWdCLGNBQWMsMEJBQTBCLDBCQUEwQixTQUFTLEVBQUUsS0FBSyxTQUFTLEdBQUcsRUFBRSxFQUFFLHdCQUF3QixTQUFTLEVBQUUsTUFBTSwrQkFBK0IsYUFBYSxVQUFVLFVBQVUseUNBQXlDLDRCQUE0QixtREFBbUQsY0FBYyxPQUFPLDhCQUE4QixTQUFTLE1BQU0sdUJBQXVCLGFBQWEsZ0JBQWdCLGtEQUFrRCxtQkFBbUIsa0JBQWtCLFNBQVMsMEJBQTBCLEtBQUssV0FBVyxxQ0FBcUMsMEJBQTBCLElBQUksY0FBYyxnREFBZ0QsU0FBUyw2QkFBNkIsYUFBYSxzQkFBc0Isb0JBQW9CLGVBQWUsZUFBZSxNQUFNLCtTQUErUyxRQUFRLHNDQUFzQyxnQkFBZ0Isc0JBQXNCLGtDQUFrQyxtQkFBbUIsY0FBYyxtQkFBbUIsMkNBQTJDLFdBQVcsV0FBVyxXQUFXLFFBQVEsU0FBUyxRQUFRLFFBQVEsWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksUUFBUSxNQUFNLE1BQU0sT0FBTywrQkFBK0IsbUJBQW1CLGlDQUFpQyxtQkFBbUIsSUFBSSwwQkFBMEIsV0FBVyxZQUFZLE1BQU0sVUFBVSxxQkFBcUIsWUFBWSxVQUFVLE9BQU8sU0FBUyxvQkFBb0IsSUFBSSxtQ0FBbUMsVUFBVSxxQkFBcUIsVUFBVSxTQUFTLFVBQVUsSUFBSSxTQUFTLHVDQUF1QyxpQkFBaUIsZ0JBQWdCLE9BQU8sYUFBYSxTQUFTLE1BQU0sb0JBQW9CLGlCQUFpQixnQkFBZ0IsT0FBTyxhQUFhLFNBQVMsTUFBTSxVQUFVLElBQUksVUFBVSxRQUFRLGlCQUFpQixPQUFPLFFBQVEsYUFBYSxTQUFTLE1BQU0sVUFBVSxVQUFVLFVBQVUsR0FBRywrQkFBK0IscUJBQXFCLG1CQUFtQixLQUFLLFNBQVMsTUFBTSxTQUFTLG1CQUFtQiwwQ0FBMEMseUJBQXlCLGdCQUFnQixtQkFBbUIsT0FBTyxhQUFhLG1DQUFtQyxVQUFVLHFCQUFxQixZQUFZLFNBQVMsVUFBVSxnQkFBZ0IsT0FBTyxPQUFPLFNBQVMsT0FBTyxVQUFVLDZCQUE2QixnQkFBZ0IsT0FBTyxhQUFhLFNBQVMsTUFBTSxVQUFVLGdCQUFnQixPQUFPLGFBQWEsU0FBUyxNQUFNLFVBQVUsbUNBQW1DLFVBQVUscUJBQXFCLFVBQVUsU0FBUyxVQUFVLG1CQUFtQixnQkFBZ0IsT0FBTyxPQUFPLGFBQWEsU0FBUyxNQUFNLG9DQUFvQyxpQkFBaUIsSUFBSSxTQUFTLDRCQUE0QixnQkFBZ0IsYUFBYSxtQ0FBbUMsVUFBVSxxQkFBcUIsWUFBWSxTQUFTLFVBQVUsT0FBTyxPQUFPLFNBQVMsTUFBTSxhQUFhLE9BQU8sYUFBYSxTQUFTLE9BQU8sbUJBQW1CLFFBQVEsUUFBUSxRQUFRLFNBQVMsU0FBUyxRQUFRLGVBQWUsYUFBYSxLQUFLLHFCQUFxQixlQUFlLGFBQWEsa0JBQWtCLEtBQUssSUFBSSxLQUFLLElBQUksOEJBQThCLDhDQUE4QyxpQkFBaUIsc0JBQXNCLDhCQUE4QixnQkFBZ0IsMEJBQTBCLFNBQVMsMEdBQTBHLG9CQUFvQixhQUFhLHdCQUF3QixVQUFVLFdBQVcsb0NBQW9DLE1BQU0sWUFBWSxXQUFXLEtBQUssZ0JBQWdCLGFBQWEscUJBQXFCLGFBQWEsaUJBQWlCLG1CQUFtQixhQUFhLEtBQUssYUFBYSxZQUFZLHVCQUF1QixrQkFBa0IsVUFBVSxJQUFJLG9CQUFvQixxQkFBcUIsVUFBVSxhQUFhLHNCQUFzQixxQkFBcUIsaUNBQWlDLFlBQVksVUFBVSxVQUFVLGVBQWUsZUFBZSxjQUFjLFFBQVEsT0FBTyxvQkFBb0IsTUFBTSw4RkFBOEYsUUFBUSwrREFBK0QsNkJBQTZCLGtEQUFrRCxxQ0FBcUMscUNBQXFDLHVEQUF1RCwyQkFBMkIsUUFBUSxPQUFPLHlDQUF5Qyw4Q0FBOEMsWUFBWSxjQUFjLGdCQUFnQixvQ0FBb0MsaUJBQWlCLCtCQUErQix1QkFBdUIsMkJBQTJCLG1CQUFtQiw4Q0FBOEMsU0FBUyxhQUFhLElBQUksV0FBVyxHQUFHLHNCQUFzQixJQUFJLFFBQVEsdUJBQXVCLGFBQWEsY0FBYyxVQUFVLG9CQUFvQixLQUFLLElBQUksMEJBQTBCLDBCQUEwQixTQUFTLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxFQUFFLHFCQUFxQixZQUFZLEVBQUUsT0FBTyxVQUFVO0FBQ3A1ekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2QkFBNkIsaUJBQWlCLGdGQUFnRixzQkFBc0IsaUJBQWlCLGlCQUFpQixrRkFBa0YsT0FBTyxzQkFBc0IscUNBQXFDLG1DQUFtQywyQkFBMkIsMEJBQTBCLHdCQUF3QixxQkFBcUIsMEJBQTBCLHlDQUF5QyxvQ0FBb0Msb0JBQW9CLG9CQUFvQixzQkFBc0IsY0FBYyxjQUFjLFVBQVUsRUFBRSxHQUFHLG1CQUFtQixTQUFTLFlBQVksRUFBRSxHQUFHLG1DQUFtQyxPQUFPLHFCQUFxQixTQUFTLFNBQVMsTUFBTSxhQUFhLDhCQUE4QixRQUFRLHdCQUF3QixxQ0FBcUMsUUFBUSxTQUFTLDJCQUEyQixjQUFjLGNBQWMsZ0NBQWdDLHFCQUFxQixhQUFhLFNBQVMsR0FBRyw2Q0FBNkMsZUFBZSxTQUFTLEdBQUcsd0JBQXdCLGlCQUFpQixnQ0FBZ0MsMENBQTBDLHlDQUF5QywwQ0FBMEMsNEJBQTRCLG1CQUFtQiw0QkFBNEIsUUFBUSxRQUFRLHNCQUFzQixtQkFBbUIsa0JBQWtCLFNBQVMsS0FBSyxrQkFBa0Isc0JBQXNCLGlCQUFpQixTQUFTLEtBQUssc0JBQXNCLFNBQVMsZ0JBQWdCLFNBQVMsK0JBQStCLFVBQVUsT0FBTyw2QkFBNkIsZUFBZSxlQUFlLFNBQVMsUUFBUSxZQUFZLElBQUksS0FBSyxjQUFjLFVBQVUsS0FBSywwQkFBMEIsMkJBQTJCLEtBQUssS0FBSyxNQUFNLG9DQUFvQyxPQUFPLDhCQUE4QixrQ0FBa0MseUJBQXlCLFNBQVMsUUFBUSxNQUFNLFlBQVksV0FBVyxLQUFLLFdBQVcsNENBQTRDLFNBQVMsMENBQTBDLHFCQUFxQixjQUFjLHlCQUF5Qix5Q0FBeUMsTUFBTSxTQUFTLGVBQWUsa0JBQWtCLDJDQUEyQyxVQUFVLE1BQU0sSUFBSSxTQUFTLG1DQUFtQyxTQUFTLGdCQUFnQixJQUFJLFNBQVMsR0FBRyxnQ0FBZ0MsWUFBWSw4QkFBOEIsYUFBYSxTQUFTLGtCQUFrQixTQUFTLFlBQVksV0FBVyx3QkFBd0IsU0FBUyxzQkFBc0Isc0JBQXNCLHlCQUF5Qiw2QkFBNkIseUJBQXlCLG1EQUFtRCx5QkFBeUIsMEJBQTBCLHlCQUF5QixnQkFBZ0IsV0FBVyxRQUFRLEVBQUUsZ0JBQWdCLEVBQUUsU0FBUyxpQ0FBaUMsVUFBVSxFQUFFLEVBQUUsZUFBZSxFQUFFLEVBQUUsR0FBRyx1QkFBdUIsMEJBQTBCLHlCQUF5QixnQkFBZ0IsU0FBUywwQ0FBMEMsMkJBQTJCLFVBQVUsZ0JBQWdCLHlCQUF5QixtQkFBbUIsSUFBSSxPQUFPLFNBQVMsWUFBWSxJQUFJLEdBQUcsS0FBSyxFQUFFLEdBQUcsSUFBSSxzQkFBc0Isa0RBQWtELHVCQUF1QixRQUFRLFVBQVUsbUJBQU8sQ0FBQyx3RUFBTSxFQUFFLFNBQVMsVUFBVSxtQkFBTyxDQUFDLDZDQUFNLElBQUksU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pY3JvbWF0Y2gvaW5kZXguanM/M2NlZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgZT17MzMzOihlLHQscik9Pntjb25zdCBuPXIoMTM3KTtjb25zdCB1PXIoMTc5KTtjb25zdCBzPXIoMTMpO2NvbnN0IG89cig3MTkpO2NvbnN0IGJyYWNlcz0oZSx0PXt9KT0+e2xldCByPVtdO2lmKEFycmF5LmlzQXJyYXkoZSkpe2ZvcihsZXQgbiBvZiBlKXtsZXQgZT1icmFjZXMuY3JlYXRlKG4sdCk7aWYoQXJyYXkuaXNBcnJheShlKSl7ci5wdXNoKC4uLmUpfWVsc2V7ci5wdXNoKGUpfX19ZWxzZXtyPVtdLmNvbmNhdChicmFjZXMuY3JlYXRlKGUsdCkpfWlmKHQmJnQuZXhwYW5kPT09dHJ1ZSYmdC5ub2R1cGVzPT09dHJ1ZSl7cj1bLi4ubmV3IFNldChyKV19cmV0dXJuIHJ9O2JyYWNlcy5wYXJzZT0oZSx0PXt9KT0+byhlLHQpO2JyYWNlcy5zdHJpbmdpZnk9KGUsdD17fSk9PntpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe3JldHVybiBuKGJyYWNlcy5wYXJzZShlLHQpLHQpfXJldHVybiBuKGUsdCl9O2JyYWNlcy5jb21waWxlPShlLHQ9e30pPT57aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtlPWJyYWNlcy5wYXJzZShlLHQpfXJldHVybiB1KGUsdCl9O2JyYWNlcy5leHBhbmQ9KGUsdD17fSk9PntpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe2U9YnJhY2VzLnBhcnNlKGUsdCl9bGV0IHI9cyhlLHQpO2lmKHQubm9lbXB0eT09PXRydWUpe3I9ci5maWx0ZXIoQm9vbGVhbil9aWYodC5ub2R1cGVzPT09dHJ1ZSl7cj1bLi4ubmV3IFNldChyKV19cmV0dXJuIHJ9O2JyYWNlcy5jcmVhdGU9KGUsdD17fSk9PntpZihlPT09XCJcInx8ZS5sZW5ndGg8Myl7cmV0dXJuW2VdfXJldHVybiB0LmV4cGFuZCE9PXRydWU/YnJhY2VzLmNvbXBpbGUoZSx0KTpicmFjZXMuZXhwYW5kKGUsdCl9O2UuZXhwb3J0cz1icmFjZXN9LDE3OTooZSx0LHIpPT57Y29uc3Qgbj1yKDc4Myk7Y29uc3QgdT1yKDYxNyk7Y29uc3QgY29tcGlsZT0oZSx0PXt9KT0+e2xldCB3YWxrPShlLHI9e30pPT57bGV0IHM9dS5pc0ludmFsaWRCcmFjZShyKTtsZXQgbz1lLmludmFsaWQ9PT10cnVlJiZ0LmVzY2FwZUludmFsaWQ9PT10cnVlO2xldCBpPXM9PT10cnVlfHxvPT09dHJ1ZTtsZXQgYT10LmVzY2FwZUludmFsaWQ9PT10cnVlP1wiXFxcXFwiOlwiXCI7bGV0IGw9XCJcIjtpZihlLmlzT3Blbj09PXRydWUpe3JldHVybiBhK2UudmFsdWV9aWYoZS5pc0Nsb3NlPT09dHJ1ZSl7cmV0dXJuIGErZS52YWx1ZX1pZihlLnR5cGU9PT1cIm9wZW5cIil7cmV0dXJuIGk/YStlLnZhbHVlOlwiKFwifWlmKGUudHlwZT09PVwiY2xvc2VcIil7cmV0dXJuIGk/YStlLnZhbHVlOlwiKVwifWlmKGUudHlwZT09PVwiY29tbWFcIil7cmV0dXJuIGUucHJldi50eXBlPT09XCJjb21tYVwiP1wiXCI6aT9lLnZhbHVlOlwifFwifWlmKGUudmFsdWUpe3JldHVybiBlLnZhbHVlfWlmKGUubm9kZXMmJmUucmFuZ2VzPjApe2xldCByPXUucmVkdWNlKGUubm9kZXMpO2xldCBzPW4oLi4ucix7Li4udCx3cmFwOmZhbHNlLHRvUmVnZXg6dHJ1ZX0pO2lmKHMubGVuZ3RoIT09MCl7cmV0dXJuIHIubGVuZ3RoPjEmJnMubGVuZ3RoPjE/YCgke3N9KWA6c319aWYoZS5ub2Rlcyl7Zm9yKGxldCB0IG9mIGUubm9kZXMpe2wrPXdhbGsodCxlKX19cmV0dXJuIGx9O3JldHVybiB3YWxrKGUpfTtlLmV4cG9ydHM9Y29tcGlsZX0sNDU3OmU9PntlLmV4cG9ydHM9e01BWF9MRU5HVEg6MTAyNCo2NCxDSEFSXzA6XCIwXCIsQ0hBUl85OlwiOVwiLENIQVJfVVBQRVJDQVNFX0E6XCJBXCIsQ0hBUl9MT1dFUkNBU0VfQTpcImFcIixDSEFSX1VQUEVSQ0FTRV9aOlwiWlwiLENIQVJfTE9XRVJDQVNFX1o6XCJ6XCIsQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOlwiKFwiLENIQVJfUklHSFRfUEFSRU5USEVTRVM6XCIpXCIsQ0hBUl9BU1RFUklTSzpcIipcIixDSEFSX0FNUEVSU0FORDpcIiZcIixDSEFSX0FUOlwiQFwiLENIQVJfQkFDS1NMQVNIOlwiXFxcXFwiLENIQVJfQkFDS1RJQ0s6XCJgXCIsQ0hBUl9DQVJSSUFHRV9SRVRVUk46XCJcXHJcIixDSEFSX0NJUkNVTUZMRVhfQUNDRU5UOlwiXlwiLENIQVJfQ09MT046XCI6XCIsQ0hBUl9DT01NQTpcIixcIixDSEFSX0RPTExBUjpcIiRcIixDSEFSX0RPVDpcIi5cIixDSEFSX0RPVUJMRV9RVU9URTonXCInLENIQVJfRVFVQUw6XCI9XCIsQ0hBUl9FWENMQU1BVElPTl9NQVJLOlwiIVwiLENIQVJfRk9STV9GRUVEOlwiXFxmXCIsQ0hBUl9GT1JXQVJEX1NMQVNIOlwiL1wiLENIQVJfSEFTSDpcIiNcIixDSEFSX0hZUEhFTl9NSU5VUzpcIi1cIixDSEFSX0xFRlRfQU5HTEVfQlJBQ0tFVDpcIjxcIixDSEFSX0xFRlRfQ1VSTFlfQlJBQ0U6XCJ7XCIsQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUOlwiW1wiLENIQVJfTElORV9GRUVEOlwiXFxuXCIsQ0hBUl9OT19CUkVBS19TUEFDRTpcIsKgXCIsQ0hBUl9QRVJDRU5UOlwiJVwiLENIQVJfUExVUzpcIitcIixDSEFSX1FVRVNUSU9OX01BUks6XCI/XCIsQ0hBUl9SSUdIVF9BTkdMRV9CUkFDS0VUOlwiPlwiLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6XCJ9XCIsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDpcIl1cIixDSEFSX1NFTUlDT0xPTjpcIjtcIixDSEFSX1NJTkdMRV9RVU9URTpcIidcIixDSEFSX1NQQUNFOlwiIFwiLENIQVJfVEFCOlwiXFx0XCIsQ0hBUl9VTkRFUlNDT1JFOlwiX1wiLENIQVJfVkVSVElDQUxfTElORTpcInxcIixDSEFSX1pFUk9fV0lEVEhfTk9CUkVBS19TUEFDRTpcIlxcdWZlZmZcIn19LDEzOihlLHQscik9Pntjb25zdCBuPXIoNzgzKTtjb25zdCB1PXIoMTM3KTtjb25zdCBzPXIoNjE3KTtjb25zdCBhcHBlbmQ9KGU9XCJcIix0PVwiXCIscj1mYWxzZSk9PntsZXQgbj1bXTtlPVtdLmNvbmNhdChlKTt0PVtdLmNvbmNhdCh0KTtpZighdC5sZW5ndGgpcmV0dXJuIGU7aWYoIWUubGVuZ3RoKXtyZXR1cm4gcj9zLmZsYXR0ZW4odCkubWFwKChlPT5geyR7ZX19YCkpOnR9Zm9yKGxldCB1IG9mIGUpe2lmKEFycmF5LmlzQXJyYXkodSkpe2ZvcihsZXQgZSBvZiB1KXtuLnB1c2goYXBwZW5kKGUsdCxyKSl9fWVsc2V7Zm9yKGxldCBlIG9mIHQpe2lmKHI9PT10cnVlJiZ0eXBlb2YgZT09PVwic3RyaW5nXCIpZT1geyR7ZX19YDtuLnB1c2goQXJyYXkuaXNBcnJheShlKT9hcHBlbmQodSxlLHIpOnUrZSl9fX1yZXR1cm4gcy5mbGF0dGVuKG4pfTtjb25zdCBleHBhbmQ9KGUsdD17fSk9PntsZXQgcj10LnJhbmdlTGltaXQ9PT12b2lkIDA/MWUzOnQucmFuZ2VMaW1pdDtsZXQgd2Fsaz0oZSxvPXt9KT0+e2UucXVldWU9W107bGV0IGk9bztsZXQgYT1vLnF1ZXVlO3doaWxlKGkudHlwZSE9PVwiYnJhY2VcIiYmaS50eXBlIT09XCJyb290XCImJmkucGFyZW50KXtpPWkucGFyZW50O2E9aS5xdWV1ZX1pZihlLmludmFsaWR8fGUuZG9sbGFyKXthLnB1c2goYXBwZW5kKGEucG9wKCksdShlLHQpKSk7cmV0dXJufWlmKGUudHlwZT09PVwiYnJhY2VcIiYmZS5pbnZhbGlkIT09dHJ1ZSYmZS5ub2Rlcy5sZW5ndGg9PT0yKXthLnB1c2goYXBwZW5kKGEucG9wKCksW1wie31cIl0pKTtyZXR1cm59aWYoZS5ub2RlcyYmZS5yYW5nZXM+MCl7bGV0IG89cy5yZWR1Y2UoZS5ub2Rlcyk7aWYocy5leGNlZWRzTGltaXQoLi4ubyx0LnN0ZXAscikpe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiZXhwYW5kZWQgYXJyYXkgbGVuZ3RoIGV4Y2VlZHMgcmFuZ2UgbGltaXQuIFVzZSBvcHRpb25zLnJhbmdlTGltaXQgdG8gaW5jcmVhc2Ugb3IgZGlzYWJsZSB0aGUgbGltaXQuXCIpfWxldCBpPW4oLi4ubyx0KTtpZihpLmxlbmd0aD09PTApe2k9dShlLHQpfWEucHVzaChhcHBlbmQoYS5wb3AoKSxpKSk7ZS5ub2Rlcz1bXTtyZXR1cm59bGV0IGw9cy5lbmNsb3NlQnJhY2UoZSk7bGV0IGM9ZS5xdWV1ZTtsZXQgcD1lO3doaWxlKHAudHlwZSE9PVwiYnJhY2VcIiYmcC50eXBlIT09XCJyb290XCImJnAucGFyZW50KXtwPXAucGFyZW50O2M9cC5xdWV1ZX1mb3IobGV0IHQ9MDt0PGUubm9kZXMubGVuZ3RoO3QrKyl7bGV0IHI9ZS5ub2Rlc1t0XTtpZihyLnR5cGU9PT1cImNvbW1hXCImJmUudHlwZT09PVwiYnJhY2VcIil7aWYodD09PTEpYy5wdXNoKFwiXCIpO2MucHVzaChcIlwiKTtjb250aW51ZX1pZihyLnR5cGU9PT1cImNsb3NlXCIpe2EucHVzaChhcHBlbmQoYS5wb3AoKSxjLGwpKTtjb250aW51ZX1pZihyLnZhbHVlJiZyLnR5cGUhPT1cIm9wZW5cIil7Yy5wdXNoKGFwcGVuZChjLnBvcCgpLHIudmFsdWUpKTtjb250aW51ZX1pZihyLm5vZGVzKXt3YWxrKHIsZSl9fXJldHVybiBjfTtyZXR1cm4gcy5mbGF0dGVuKHdhbGsoZSkpfTtlLmV4cG9ydHM9ZXhwYW5kfSw3MTk6KGUsdCxyKT0+e2NvbnN0IG49cigxMzcpO2NvbnN0e01BWF9MRU5HVEg6dSxDSEFSX0JBQ0tTTEFTSDpzLENIQVJfQkFDS1RJQ0s6byxDSEFSX0NPTU1BOmksQ0hBUl9ET1Q6YSxDSEFSX0xFRlRfUEFSRU5USEVTRVM6bCxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOmMsQ0hBUl9MRUZUX0NVUkxZX0JSQUNFOnAsQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRTpmLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDpBLENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQ6UixDSEFSX0RPVUJMRV9RVU9URTpfLENIQVJfU0lOR0xFX1FVT1RFOmgsQ0hBUl9OT19CUkVBS19TUEFDRTpnLENIQVJfWkVST19XSURUSF9OT0JSRUFLX1NQQUNFOkV9PXIoNDU3KTtjb25zdCBwYXJzZT0oZSx0PXt9KT0+e2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgc3RyaW5nXCIpfWxldCByPXR8fHt9O2xldCBDPXR5cGVvZiByLm1heExlbmd0aD09PVwibnVtYmVyXCI/TWF0aC5taW4odSxyLm1heExlbmd0aCk6dTtpZihlLmxlbmd0aD5DKXt0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aCAoJHtlLmxlbmd0aH0pLCBleGNlZWRzIG1heCBjaGFyYWN0ZXJzICgke0N9KWApfWxldCB5PXt0eXBlOlwicm9vdFwiLGlucHV0OmUsbm9kZXM6W119O2xldCBkPVt5XTtsZXQgeD15O2xldCBiPXk7bGV0IFM9MDtsZXQgSD1lLmxlbmd0aDtsZXQgdj0wO2xldCAkPTA7bGV0IG07bGV0IFQ9e307Y29uc3QgYWR2YW5jZT0oKT0+ZVt2KytdO2NvbnN0IHB1c2g9ZT0+e2lmKGUudHlwZT09PVwidGV4dFwiJiZiLnR5cGU9PT1cImRvdFwiKXtiLnR5cGU9XCJ0ZXh0XCJ9aWYoYiYmYi50eXBlPT09XCJ0ZXh0XCImJmUudHlwZT09PVwidGV4dFwiKXtiLnZhbHVlKz1lLnZhbHVlO3JldHVybn14Lm5vZGVzLnB1c2goZSk7ZS5wYXJlbnQ9eDtlLnByZXY9YjtiPWU7cmV0dXJuIGV9O3B1c2goe3R5cGU6XCJib3NcIn0pO3doaWxlKHY8SCl7eD1kW2QubGVuZ3RoLTFdO209YWR2YW5jZSgpO2lmKG09PT1FfHxtPT09Zyl7Y29udGludWV9aWYobT09PXMpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6KHQua2VlcEVzY2FwaW5nP206XCJcIikrYWR2YW5jZSgpfSk7Y29udGludWV9aWYobT09PVIpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6XCJcXFxcXCIrbX0pO2NvbnRpbnVlfWlmKG09PT1BKXtTKys7bGV0IGU9dHJ1ZTtsZXQgdDt3aGlsZSh2PEgmJih0PWFkdmFuY2UoKSkpe20rPXQ7aWYodD09PUEpe1MrKztjb250aW51ZX1pZih0PT09cyl7bSs9YWR2YW5jZSgpO2NvbnRpbnVlfWlmKHQ9PT1SKXtTLS07aWYoUz09PTApe2JyZWFrfX19cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYobT09PWwpe3g9cHVzaCh7dHlwZTpcInBhcmVuXCIsbm9kZXM6W119KTtkLnB1c2goeCk7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYobT09PWMpe2lmKHgudHlwZSE9PVwicGFyZW5cIil7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9eD1kLnBvcCgpO3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6bX0pO3g9ZFtkLmxlbmd0aC0xXTtjb250aW51ZX1pZihtPT09X3x8bT09PWh8fG09PT1vKXtsZXQgZT1tO2xldCByO2lmKHQua2VlcFF1b3RlcyE9PXRydWUpe209XCJcIn13aGlsZSh2PEgmJihyPWFkdmFuY2UoKSkpe2lmKHI9PT1zKXttKz1yK2FkdmFuY2UoKTtjb250aW51ZX1pZihyPT09ZSl7aWYodC5rZWVwUXVvdGVzPT09dHJ1ZSltKz1yO2JyZWFrfW0rPXJ9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYobT09PXApeyQrKztsZXQgZT1iLnZhbHVlJiZiLnZhbHVlLnNsaWNlKC0xKT09PVwiJFwifHx4LmRvbGxhcj09PXRydWU7bGV0IHQ9e3R5cGU6XCJicmFjZVwiLG9wZW46dHJ1ZSxjbG9zZTpmYWxzZSxkb2xsYXI6ZSxkZXB0aDokLGNvbW1hczowLHJhbmdlczowLG5vZGVzOltdfTt4PXB1c2godCk7ZC5wdXNoKHgpO3B1c2goe3R5cGU6XCJvcGVuXCIsdmFsdWU6bX0pO2NvbnRpbnVlfWlmKG09PT1mKXtpZih4LnR5cGUhPT1cImJyYWNlXCIpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6bX0pO2NvbnRpbnVlfWxldCBlPVwiY2xvc2VcIjt4PWQucG9wKCk7eC5jbG9zZT10cnVlO3B1c2goe3R5cGU6ZSx2YWx1ZTptfSk7JC0tO3g9ZFtkLmxlbmd0aC0xXTtjb250aW51ZX1pZihtPT09aSYmJD4wKXtpZih4LnJhbmdlcz4wKXt4LnJhbmdlcz0wO2xldCBlPXgubm9kZXMuc2hpZnQoKTt4Lm5vZGVzPVtlLHt0eXBlOlwidGV4dFwiLHZhbHVlOm4oeCl9XX1wdXNoKHt0eXBlOlwiY29tbWFcIix2YWx1ZTptfSk7eC5jb21tYXMrKztjb250aW51ZX1pZihtPT09YSYmJD4wJiZ4LmNvbW1hcz09PTApe2xldCBlPXgubm9kZXM7aWYoJD09PTB8fGUubGVuZ3RoPT09MCl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYoYi50eXBlPT09XCJkb3RcIil7eC5yYW5nZT1bXTtiLnZhbHVlKz1tO2IudHlwZT1cInJhbmdlXCI7aWYoeC5ub2Rlcy5sZW5ndGghPT0zJiZ4Lm5vZGVzLmxlbmd0aCE9PTUpe3guaW52YWxpZD10cnVlO3gucmFuZ2VzPTA7Yi50eXBlPVwidGV4dFwiO2NvbnRpbnVlfXgucmFuZ2VzKys7eC5hcmdzPVtdO2NvbnRpbnVlfWlmKGIudHlwZT09PVwicmFuZ2VcIil7ZS5wb3AoKTtsZXQgdD1lW2UubGVuZ3RoLTFdO3QudmFsdWUrPWIudmFsdWUrbTtiPXQ7eC5yYW5nZXMtLTtjb250aW51ZX1wdXNoKHt0eXBlOlwiZG90XCIsdmFsdWU6bX0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6bX0pfWRve3g9ZC5wb3AoKTtpZih4LnR5cGUhPT1cInJvb3RcIil7eC5ub2Rlcy5mb3JFYWNoKChlPT57aWYoIWUubm9kZXMpe2lmKGUudHlwZT09PVwib3BlblwiKWUuaXNPcGVuPXRydWU7aWYoZS50eXBlPT09XCJjbG9zZVwiKWUuaXNDbG9zZT10cnVlO2lmKCFlLm5vZGVzKWUudHlwZT1cInRleHRcIjtlLmludmFsaWQ9dHJ1ZX19KSk7bGV0IGU9ZFtkLmxlbmd0aC0xXTtsZXQgdD1lLm5vZGVzLmluZGV4T2YoeCk7ZS5ub2Rlcy5zcGxpY2UodCwxLC4uLngubm9kZXMpfX13aGlsZShkLmxlbmd0aD4wKTtwdXNoKHt0eXBlOlwiZW9zXCJ9KTtyZXR1cm4geX07ZS5leHBvcnRzPXBhcnNlfSwxMzc6KGUsdCxyKT0+e2NvbnN0IG49cig2MTcpO2UuZXhwb3J0cz0oZSx0PXt9KT0+e2xldCBzdHJpbmdpZnk9KGUscj17fSk9PntsZXQgdT10LmVzY2FwZUludmFsaWQmJm4uaXNJbnZhbGlkQnJhY2Uocik7bGV0IHM9ZS5pbnZhbGlkPT09dHJ1ZSYmdC5lc2NhcGVJbnZhbGlkPT09dHJ1ZTtsZXQgbz1cIlwiO2lmKGUudmFsdWUpe2lmKCh1fHxzKSYmbi5pc09wZW5PckNsb3NlKGUpKXtyZXR1cm5cIlxcXFxcIitlLnZhbHVlfXJldHVybiBlLnZhbHVlfWlmKGUudmFsdWUpe3JldHVybiBlLnZhbHVlfWlmKGUubm9kZXMpe2ZvcihsZXQgdCBvZiBlLm5vZGVzKXtvKz1zdHJpbmdpZnkodCl9fXJldHVybiBvfTtyZXR1cm4gc3RyaW5naWZ5KGUpfX0sNjE3OihlLHQpPT57dC5pc0ludGVnZXI9ZT0+e2lmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7cmV0dXJuIE51bWJlci5pc0ludGVnZXIoZSl9aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiJiZlLnRyaW0oKSE9PVwiXCIpe3JldHVybiBOdW1iZXIuaXNJbnRlZ2VyKE51bWJlcihlKSl9cmV0dXJuIGZhbHNlfTt0LmZpbmQ9KGUsdCk9PmUubm9kZXMuZmluZCgoZT0+ZS50eXBlPT09dCkpO3QuZXhjZWVkc0xpbWl0PShlLHIsbj0xLHUpPT57aWYodT09PWZhbHNlKXJldHVybiBmYWxzZTtpZighdC5pc0ludGVnZXIoZSl8fCF0LmlzSW50ZWdlcihyKSlyZXR1cm4gZmFsc2U7cmV0dXJuKE51bWJlcihyKS1OdW1iZXIoZSkpL051bWJlcihuKT49dX07dC5lc2NhcGVOb2RlPShlLHQ9MCxyKT0+e2xldCBuPWUubm9kZXNbdF07aWYoIW4pcmV0dXJuO2lmKHImJm4udHlwZT09PXJ8fG4udHlwZT09PVwib3BlblwifHxuLnR5cGU9PT1cImNsb3NlXCIpe2lmKG4uZXNjYXBlZCE9PXRydWUpe24udmFsdWU9XCJcXFxcXCIrbi52YWx1ZTtuLmVzY2FwZWQ9dHJ1ZX19fTt0LmVuY2xvc2VCcmFjZT1lPT57aWYoZS50eXBlIT09XCJicmFjZVwiKXJldHVybiBmYWxzZTtpZihlLmNvbW1hcz4+MCtlLnJhbmdlcz4+MD09PTApe2UuaW52YWxpZD10cnVlO3JldHVybiB0cnVlfXJldHVybiBmYWxzZX07dC5pc0ludmFsaWRCcmFjZT1lPT57aWYoZS50eXBlIT09XCJicmFjZVwiKXJldHVybiBmYWxzZTtpZihlLmludmFsaWQ9PT10cnVlfHxlLmRvbGxhcilyZXR1cm4gdHJ1ZTtpZihlLmNvbW1hcz4+MCtlLnJhbmdlcz4+MD09PTApe2UuaW52YWxpZD10cnVlO3JldHVybiB0cnVlfWlmKGUub3BlbiE9PXRydWV8fGUuY2xvc2UhPT10cnVlKXtlLmludmFsaWQ9dHJ1ZTtyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2V9O3QuaXNPcGVuT3JDbG9zZT1lPT57aWYoZS50eXBlPT09XCJvcGVuXCJ8fGUudHlwZT09PVwiY2xvc2VcIil7cmV0dXJuIHRydWV9cmV0dXJuIGUub3Blbj09PXRydWV8fGUuY2xvc2U9PT10cnVlfTt0LnJlZHVjZT1lPT5lLnJlZHVjZSgoKGUsdCk9PntpZih0LnR5cGU9PT1cInRleHRcIillLnB1c2godC52YWx1ZSk7aWYodC50eXBlPT09XCJyYW5nZVwiKXQudHlwZT1cInRleHRcIjtyZXR1cm4gZX0pLFtdKTt0LmZsYXR0ZW49KC4uLmUpPT57Y29uc3QgdD1bXTtjb25zdCBmbGF0PWU9Pntmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKyl7bGV0IG49ZVtyXTtBcnJheS5pc0FycmF5KG4pP2ZsYXQobix0KTpuIT09dm9pZCAwJiZ0LnB1c2gobil9cmV0dXJuIHR9O2ZsYXQoZSk7cmV0dXJuIHR9fSw3ODM6KGUsdCxyKT0+e1xuLyohXG4gKiBmaWxsLXJhbmdlIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9maWxsLXJhbmdlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuY29uc3Qgbj1yKDgzNyk7Y29uc3QgdT1yKDQ5Mik7Y29uc3QgaXNPYmplY3Q9ZT0+ZSE9PW51bGwmJnR5cGVvZiBlPT09XCJvYmplY3RcIiYmIUFycmF5LmlzQXJyYXkoZSk7Y29uc3QgdHJhbnNmb3JtPWU9PnQ9PmU9PT10cnVlP051bWJlcih0KTpTdHJpbmcodCk7Y29uc3QgaXNWYWxpZFZhbHVlPWU9PnR5cGVvZiBlPT09XCJudW1iZXJcInx8dHlwZW9mIGU9PT1cInN0cmluZ1wiJiZlIT09XCJcIjtjb25zdCBpc051bWJlcj1lPT5OdW1iZXIuaXNJbnRlZ2VyKCtlKTtjb25zdCB6ZXJvcz1lPT57bGV0IHQ9YCR7ZX1gO2xldCByPS0xO2lmKHRbMF09PT1cIi1cIil0PXQuc2xpY2UoMSk7aWYodD09PVwiMFwiKXJldHVybiBmYWxzZTt3aGlsZSh0Wysrcl09PT1cIjBcIik7cmV0dXJuIHI+MH07Y29uc3Qgc3RyaW5naWZ5PShlLHQscik9PntpZih0eXBlb2YgZT09PVwic3RyaW5nXCJ8fHR5cGVvZiB0PT09XCJzdHJpbmdcIil7cmV0dXJuIHRydWV9cmV0dXJuIHIuc3RyaW5naWZ5PT09dHJ1ZX07Y29uc3QgcGFkPShlLHQscik9PntpZih0PjApe2xldCByPWVbMF09PT1cIi1cIj9cIi1cIjpcIlwiO2lmKHIpZT1lLnNsaWNlKDEpO2U9citlLnBhZFN0YXJ0KHI/dC0xOnQsXCIwXCIpfWlmKHI9PT1mYWxzZSl7cmV0dXJuIFN0cmluZyhlKX1yZXR1cm4gZX07Y29uc3QgdG9NYXhMZW49KGUsdCk9PntsZXQgcj1lWzBdPT09XCItXCI/XCItXCI6XCJcIjtpZihyKXtlPWUuc2xpY2UoMSk7dC0tfXdoaWxlKGUubGVuZ3RoPHQpZT1cIjBcIitlO3JldHVybiByP1wiLVwiK2U6ZX07Y29uc3QgdG9TZXF1ZW5jZT0oZSx0KT0+e2UubmVnYXRpdmVzLnNvcnQoKChlLHQpPT5lPHQ/LTE6ZT50PzE6MCkpO2UucG9zaXRpdmVzLnNvcnQoKChlLHQpPT5lPHQ/LTE6ZT50PzE6MCkpO2xldCByPXQuY2FwdHVyZT9cIlwiOlwiPzpcIjtsZXQgbj1cIlwiO2xldCB1PVwiXCI7bGV0IHM7aWYoZS5wb3NpdGl2ZXMubGVuZ3RoKXtuPWUucG9zaXRpdmVzLmpvaW4oXCJ8XCIpfWlmKGUubmVnYXRpdmVzLmxlbmd0aCl7dT1gLSgke3J9JHtlLm5lZ2F0aXZlcy5qb2luKFwifFwiKX0pYH1pZihuJiZ1KXtzPWAke259fCR7dX1gfWVsc2V7cz1ufHx1fWlmKHQud3JhcCl7cmV0dXJuYCgke3J9JHtzfSlgfXJldHVybiBzfTtjb25zdCB0b1JhbmdlPShlLHQscixuKT0+e2lmKHIpe3JldHVybiB1KGUsdCx7d3JhcDpmYWxzZSwuLi5ufSl9bGV0IHM9U3RyaW5nLmZyb21DaGFyQ29kZShlKTtpZihlPT09dClyZXR1cm4gcztsZXQgbz1TdHJpbmcuZnJvbUNoYXJDb2RlKHQpO3JldHVybmBbJHtzfS0ke299XWB9O2NvbnN0IHRvUmVnZXg9KGUsdCxyKT0+e2lmKEFycmF5LmlzQXJyYXkoZSkpe2xldCB0PXIud3JhcD09PXRydWU7bGV0IG49ci5jYXB0dXJlP1wiXCI6XCI/OlwiO3JldHVybiB0P2AoJHtufSR7ZS5qb2luKFwifFwiKX0pYDplLmpvaW4oXCJ8XCIpfXJldHVybiB1KGUsdCxyKX07Y29uc3QgcmFuZ2VFcnJvcj0oLi4uZSk9Pm5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCByYW5nZSBhcmd1bWVudHM6IFwiK24uaW5zcGVjdCguLi5lKSk7Y29uc3QgaW52YWxpZFJhbmdlPShlLHQscik9PntpZihyLnN0cmljdFJhbmdlcz09PXRydWUpdGhyb3cgcmFuZ2VFcnJvcihbZSx0XSk7cmV0dXJuW119O2NvbnN0IGludmFsaWRTdGVwPShlLHQpPT57aWYodC5zdHJpY3RSYW5nZXM9PT10cnVlKXt0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBzdGVwIFwiJHtlfVwiIHRvIGJlIGEgbnVtYmVyYCl9cmV0dXJuW119O2NvbnN0IGZpbGxOdW1iZXJzPShlLHQscj0xLG49e30pPT57bGV0IHU9TnVtYmVyKGUpO2xldCBzPU51bWJlcih0KTtpZighTnVtYmVyLmlzSW50ZWdlcih1KXx8IU51bWJlci5pc0ludGVnZXIocykpe2lmKG4uc3RyaWN0UmFuZ2VzPT09dHJ1ZSl0aHJvdyByYW5nZUVycm9yKFtlLHRdKTtyZXR1cm5bXX1pZih1PT09MCl1PTA7aWYocz09PTApcz0wO2xldCBvPXU+cztsZXQgaT1TdHJpbmcoZSk7bGV0IGE9U3RyaW5nKHQpO2xldCBsPVN0cmluZyhyKTtyPU1hdGgubWF4KE1hdGguYWJzKHIpLDEpO2xldCBjPXplcm9zKGkpfHx6ZXJvcyhhKXx8emVyb3MobCk7bGV0IHA9Yz9NYXRoLm1heChpLmxlbmd0aCxhLmxlbmd0aCxsLmxlbmd0aCk6MDtsZXQgZj1jPT09ZmFsc2UmJnN0cmluZ2lmeShlLHQsbik9PT1mYWxzZTtsZXQgQT1uLnRyYW5zZm9ybXx8dHJhbnNmb3JtKGYpO2lmKG4udG9SZWdleCYmcj09PTEpe3JldHVybiB0b1JhbmdlKHRvTWF4TGVuKGUscCksdG9NYXhMZW4odCxwKSx0cnVlLG4pfWxldCBSPXtuZWdhdGl2ZXM6W10scG9zaXRpdmVzOltdfTtsZXQgcHVzaD1lPT5SW2U8MD9cIm5lZ2F0aXZlc1wiOlwicG9zaXRpdmVzXCJdLnB1c2goTWF0aC5hYnMoZSkpO2xldCBfPVtdO2xldCBoPTA7d2hpbGUobz91Pj1zOnU8PXMpe2lmKG4udG9SZWdleD09PXRydWUmJnI+MSl7cHVzaCh1KX1lbHNle18ucHVzaChwYWQoQSh1LGgpLHAsZikpfXU9bz91LXI6dStyO2grK31pZihuLnRvUmVnZXg9PT10cnVlKXtyZXR1cm4gcj4xP3RvU2VxdWVuY2UoUixuKTp0b1JlZ2V4KF8sbnVsbCx7d3JhcDpmYWxzZSwuLi5ufSl9cmV0dXJuIF99O2NvbnN0IGZpbGxMZXR0ZXJzPShlLHQscj0xLG49e30pPT57aWYoIWlzTnVtYmVyKGUpJiZlLmxlbmd0aD4xfHwhaXNOdW1iZXIodCkmJnQubGVuZ3RoPjEpe3JldHVybiBpbnZhbGlkUmFuZ2UoZSx0LG4pfWxldCB1PW4udHJhbnNmb3JtfHwoZT0+U3RyaW5nLmZyb21DaGFyQ29kZShlKSk7bGV0IHM9YCR7ZX1gLmNoYXJDb2RlQXQoMCk7bGV0IG89YCR7dH1gLmNoYXJDb2RlQXQoMCk7bGV0IGk9cz5vO2xldCBhPU1hdGgubWluKHMsbyk7bGV0IGw9TWF0aC5tYXgocyxvKTtpZihuLnRvUmVnZXgmJnI9PT0xKXtyZXR1cm4gdG9SYW5nZShhLGwsZmFsc2Usbil9bGV0IGM9W107bGV0IHA9MDt3aGlsZShpP3M+PW86czw9byl7Yy5wdXNoKHUocyxwKSk7cz1pP3MtcjpzK3I7cCsrfWlmKG4udG9SZWdleD09PXRydWUpe3JldHVybiB0b1JlZ2V4KGMsbnVsbCx7d3JhcDpmYWxzZSxvcHRpb25zOm59KX1yZXR1cm4gY307Y29uc3QgZmlsbD0oZSx0LHIsbj17fSk9PntpZih0PT1udWxsJiZpc1ZhbGlkVmFsdWUoZSkpe3JldHVybltlXX1pZighaXNWYWxpZFZhbHVlKGUpfHwhaXNWYWxpZFZhbHVlKHQpKXtyZXR1cm4gaW52YWxpZFJhbmdlKGUsdCxuKX1pZih0eXBlb2Ygcj09PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZpbGwoZSx0LDEse3RyYW5zZm9ybTpyfSl9aWYoaXNPYmplY3Qocikpe3JldHVybiBmaWxsKGUsdCwwLHIpfWxldCB1PXsuLi5ufTtpZih1LmNhcHR1cmU9PT10cnVlKXUud3JhcD10cnVlO3I9cnx8dS5zdGVwfHwxO2lmKCFpc051bWJlcihyKSl7aWYociE9bnVsbCYmIWlzT2JqZWN0KHIpKXJldHVybiBpbnZhbGlkU3RlcChyLHUpO3JldHVybiBmaWxsKGUsdCwxLHIpfWlmKGlzTnVtYmVyKGUpJiZpc051bWJlcih0KSl7cmV0dXJuIGZpbGxOdW1iZXJzKGUsdCxyLHUpfXJldHVybiBmaWxsTGV0dGVycyhlLHQsTWF0aC5tYXgoTWF0aC5hYnMociksMSksdSl9O2UuZXhwb3J0cz1maWxsfSwzNTc6ZT0+e1xuLyohXG4gKiBpcy1udW1iZXIgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLW51bWJlcj5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmUuZXhwb3J0cz1mdW5jdGlvbihlKXtpZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe3JldHVybiBlLWU9PT0wfWlmKHR5cGVvZiBlPT09XCJzdHJpbmdcIiYmZS50cmltKCkhPT1cIlwiKXtyZXR1cm4gTnVtYmVyLmlzRmluaXRlP051bWJlci5pc0Zpbml0ZSgrZSk6aXNGaW5pdGUoK2UpfXJldHVybiBmYWxzZX19LDk3MTooZSx0LHIpPT57Y29uc3Qgbj1yKDgzNyk7Y29uc3QgdT1yKDMzMyk7Y29uc3Qgcz1yKDI1MSk7Y29uc3Qgbz1yKDUxMyk7Y29uc3QgaXNFbXB0eVN0cmluZz1lPT5lPT09XCJcInx8ZT09PVwiLi9cIjtjb25zdCBtaWNyb21hdGNoPShlLHQscik9Pnt0PVtdLmNvbmNhdCh0KTtlPVtdLmNvbmNhdChlKTtsZXQgbj1uZXcgU2V0O2xldCB1PW5ldyBTZXQ7bGV0IG89bmV3IFNldDtsZXQgaT0wO2xldCBvblJlc3VsdD1lPT57by5hZGQoZS5vdXRwdXQpO2lmKHImJnIub25SZXN1bHQpe3Iub25SZXN1bHQoZSl9fTtmb3IobGV0IG89MDtvPHQubGVuZ3RoO28rKyl7bGV0IGE9cyhTdHJpbmcodFtvXSksey4uLnIsb25SZXN1bHQ6b25SZXN1bHR9LHRydWUpO2xldCBsPWEuc3RhdGUubmVnYXRlZHx8YS5zdGF0ZS5uZWdhdGVkRXh0Z2xvYjtpZihsKWkrKztmb3IobGV0IHQgb2YgZSl7bGV0IGU9YSh0LHRydWUpO2xldCByPWw/IWUuaXNNYXRjaDplLmlzTWF0Y2g7aWYoIXIpY29udGludWU7aWYobCl7bi5hZGQoZS5vdXRwdXQpfWVsc2V7bi5kZWxldGUoZS5vdXRwdXQpO3UuYWRkKGUub3V0cHV0KX19fWxldCBhPWk9PT10Lmxlbmd0aD9bLi4ub106Wy4uLnVdO2xldCBsPWEuZmlsdGVyKChlPT4hbi5oYXMoZSkpKTtpZihyJiZsLmxlbmd0aD09PTApe2lmKHIuZmFpbGdsb2I9PT10cnVlKXt0aHJvdyBuZXcgRXJyb3IoYE5vIG1hdGNoZXMgZm91bmQgZm9yIFwiJHt0LmpvaW4oXCIsIFwiKX1cImApfWlmKHIubm9udWxsPT09dHJ1ZXx8ci5udWxsZ2xvYj09PXRydWUpe3JldHVybiByLnVuZXNjYXBlP3QubWFwKChlPT5lLnJlcGxhY2UoL1xcXFwvZyxcIlwiKSkpOnR9fXJldHVybiBsfTttaWNyb21hdGNoLm1hdGNoPW1pY3JvbWF0Y2g7bWljcm9tYXRjaC5tYXRjaGVyPShlLHQpPT5zKGUsdCk7bWljcm9tYXRjaC5pc01hdGNoPShlLHQscik9PnModCxyKShlKTttaWNyb21hdGNoLmFueT1taWNyb21hdGNoLmlzTWF0Y2g7bWljcm9tYXRjaC5ub3Q9KGUsdCxyPXt9KT0+e3Q9W10uY29uY2F0KHQpLm1hcChTdHJpbmcpO2xldCBuPW5ldyBTZXQ7bGV0IHU9W107bGV0IG9uUmVzdWx0PWU9PntpZihyLm9uUmVzdWx0KXIub25SZXN1bHQoZSk7dS5wdXNoKGUub3V0cHV0KX07bGV0IHM9bWljcm9tYXRjaChlLHQsey4uLnIsb25SZXN1bHQ6b25SZXN1bHR9KTtmb3IobGV0IGUgb2YgdSl7aWYoIXMuaW5jbHVkZXMoZSkpe24uYWRkKGUpfX1yZXR1cm5bLi4ubl19O21pY3JvbWF0Y2guY29udGFpbnM9KGUsdCxyKT0+e2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgYSBzdHJpbmc6IFwiJHtuLmluc3BlY3QoZSl9XCJgKX1pZihBcnJheS5pc0FycmF5KHQpKXtyZXR1cm4gdC5zb21lKCh0PT5taWNyb21hdGNoLmNvbnRhaW5zKGUsdCxyKSkpfWlmKHR5cGVvZiB0PT09XCJzdHJpbmdcIil7aWYoaXNFbXB0eVN0cmluZyhlKXx8aXNFbXB0eVN0cmluZyh0KSl7cmV0dXJuIGZhbHNlfWlmKGUuaW5jbHVkZXModCl8fGUuc3RhcnRzV2l0aChcIi4vXCIpJiZlLnNsaWNlKDIpLmluY2x1ZGVzKHQpKXtyZXR1cm4gdHJ1ZX19cmV0dXJuIG1pY3JvbWF0Y2guaXNNYXRjaChlLHQsey4uLnIsY29udGFpbnM6dHJ1ZX0pfTttaWNyb21hdGNoLm1hdGNoS2V5cz0oZSx0LHIpPT57aWYoIW8uaXNPYmplY3QoZSkpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0XCIpfWxldCBuPW1pY3JvbWF0Y2goT2JqZWN0LmtleXMoZSksdCxyKTtsZXQgdT17fTtmb3IobGV0IHQgb2Ygbil1W3RdPWVbdF07cmV0dXJuIHV9O21pY3JvbWF0Y2guc29tZT0oZSx0LHIpPT57bGV0IG49W10uY29uY2F0KGUpO2ZvcihsZXQgZSBvZltdLmNvbmNhdCh0KSl7bGV0IHQ9cyhTdHJpbmcoZSkscik7aWYobi5zb21lKChlPT50KGUpKSkpe3JldHVybiB0cnVlfX1yZXR1cm4gZmFsc2V9O21pY3JvbWF0Y2guZXZlcnk9KGUsdCxyKT0+e2xldCBuPVtdLmNvbmNhdChlKTtmb3IobGV0IGUgb2ZbXS5jb25jYXQodCkpe2xldCB0PXMoU3RyaW5nKGUpLHIpO2lmKCFuLmV2ZXJ5KChlPT50KGUpKSkpe3JldHVybiBmYWxzZX19cmV0dXJuIHRydWV9O21pY3JvbWF0Y2guYWxsPShlLHQscik9PntpZih0eXBlb2YgZSE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGEgc3RyaW5nOiBcIiR7bi5pbnNwZWN0KGUpfVwiYCl9cmV0dXJuW10uY29uY2F0KHQpLmV2ZXJ5KCh0PT5zKHQscikoZSkpKX07bWljcm9tYXRjaC5jYXB0dXJlPShlLHQscik9PntsZXQgbj1vLmlzV2luZG93cyhyKTtsZXQgdT1zLm1ha2VSZShTdHJpbmcoZSksey4uLnIsY2FwdHVyZTp0cnVlfSk7bGV0IGk9dS5leGVjKG4/by50b1Bvc2l4U2xhc2hlcyh0KTp0KTtpZihpKXtyZXR1cm4gaS5zbGljZSgxKS5tYXAoKGU9PmU9PT12b2lkIDA/XCJcIjplKSl9fTttaWNyb21hdGNoLm1ha2VSZT0oLi4uZSk9PnMubWFrZVJlKC4uLmUpO21pY3JvbWF0Y2guc2Nhbj0oLi4uZSk9PnMuc2NhbiguLi5lKTttaWNyb21hdGNoLnBhcnNlPShlLHQpPT57bGV0IHI9W107Zm9yKGxldCBuIG9mW10uY29uY2F0KGV8fFtdKSl7Zm9yKGxldCBlIG9mIHUoU3RyaW5nKG4pLHQpKXtyLnB1c2gocy5wYXJzZShlLHQpKX19cmV0dXJuIHJ9O21pY3JvbWF0Y2guYnJhY2VzPShlLHQpPT57aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKTtpZih0JiZ0Lm5vYnJhY2U9PT10cnVlfHwhL1xcey4qXFx9Ly50ZXN0KGUpKXtyZXR1cm5bZV19cmV0dXJuIHUoZSx0KX07bWljcm9tYXRjaC5icmFjZUV4cGFuZD0oZSx0KT0+e2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYSBzdHJpbmdcIik7cmV0dXJuIG1pY3JvbWF0Y2guYnJhY2VzKGUsey4uLnQsZXhwYW5kOnRydWV9KX07ZS5leHBvcnRzPW1pY3JvbWF0Y2h9LDI1MTooZSx0LHIpPT57ZS5leHBvcnRzPXIoNjgzKX0sMzU2OihlLHQscik9Pntjb25zdCBuPXIoMTcpO2NvbnN0IHU9XCJcXFxcXFxcXC9cIjtjb25zdCBzPWBbXiR7dX1dYDtjb25zdCBvPVwiXFxcXC5cIjtjb25zdCBpPVwiXFxcXCtcIjtjb25zdCBhPVwiXFxcXD9cIjtjb25zdCBsPVwiXFxcXC9cIjtjb25zdCBjPVwiKD89LilcIjtjb25zdCBwPVwiW14vXVwiO2NvbnN0IGY9YCg/OiR7bH18JClgO2NvbnN0IEE9YCg/Ol58JHtsfSlgO2NvbnN0IFI9YCR7b317MSwyfSR7Zn1gO2NvbnN0IF89YCg/ISR7b30pYDtjb25zdCBoPWAoPyEke0F9JHtSfSlgO2NvbnN0IGc9YCg/ISR7b317MCwxfSR7Zn0pYDtjb25zdCBFPWAoPyEke1J9KWA7Y29uc3QgQz1gW14uJHtsfV1gO2NvbnN0IHk9YCR7cH0qP2A7Y29uc3QgZD17RE9UX0xJVEVSQUw6byxQTFVTX0xJVEVSQUw6aSxRTUFSS19MSVRFUkFMOmEsU0xBU0hfTElURVJBTDpsLE9ORV9DSEFSOmMsUU1BUks6cCxFTkRfQU5DSE9SOmYsRE9UU19TTEFTSDpSLE5PX0RPVDpfLE5PX0RPVFM6aCxOT19ET1RfU0xBU0g6ZyxOT19ET1RTX1NMQVNIOkUsUU1BUktfTk9fRE9UOkMsU1RBUjp5LFNUQVJUX0FOQ0hPUjpBfTtjb25zdCB4PXsuLi5kLFNMQVNIX0xJVEVSQUw6YFske3V9XWAsUU1BUks6cyxTVEFSOmAke3N9Kj9gLERPVFNfU0xBU0g6YCR7b317MSwyfSg/Olske3V9XXwkKWAsTk9fRE9UOmAoPyEke299KWAsTk9fRE9UUzpgKD8hKD86XnxbJHt1fV0pJHtvfXsxLDJ9KD86WyR7dX1dfCQpKWAsTk9fRE9UX1NMQVNIOmAoPyEke299ezAsMX0oPzpbJHt1fV18JCkpYCxOT19ET1RTX1NMQVNIOmAoPyEke299ezEsMn0oPzpbJHt1fV18JCkpYCxRTUFSS19OT19ET1Q6YFteLiR7dX1dYCxTVEFSVF9BTkNIT1I6YCg/Ol58WyR7dX1dKWAsRU5EX0FOQ0hPUjpgKD86WyR7dX1dfCQpYH07Y29uc3QgYj17YWxudW06XCJhLXpBLVowLTlcIixhbHBoYTpcImEtekEtWlwiLGFzY2lpOlwiXFxcXHgwMC1cXFxceDdGXCIsYmxhbms6XCIgXFxcXHRcIixjbnRybDpcIlxcXFx4MDAtXFxcXHgxRlxcXFx4N0ZcIixkaWdpdDpcIjAtOVwiLGdyYXBoOlwiXFxcXHgyMS1cXFxceDdFXCIsbG93ZXI6XCJhLXpcIixwcmludDpcIlxcXFx4MjAtXFxcXHg3RSBcIixwdW5jdDpcIlxcXFwtIVxcXCIjJCUmJygpXFxcXCorLC4vOjs8PT4/QFtcXFxcXV5fYHt8fX5cIixzcGFjZTpcIiBcXFxcdFxcXFxyXFxcXG5cXFxcdlxcXFxmXCIsdXBwZXI6XCJBLVpcIix3b3JkOlwiQS1aYS16MC05X1wiLHhkaWdpdDpcIkEtRmEtZjAtOVwifTtlLmV4cG9ydHM9e01BWF9MRU5HVEg6MTAyNCo2NCxQT1NJWF9SRUdFWF9TT1VSQ0U6YixSRUdFWF9CQUNLU0xBU0g6L1xcXFwoPyFbKis/XiR7fSh8KVtcXF1dKS9nLFJFR0VYX05PTl9TUEVDSUFMX0NIQVJTOi9eW15AIVtcXF0uLCQqKz9ee30oKXxcXFxcL10rLyxSRUdFWF9TUEVDSUFMX0NIQVJTOi9bLSorPy5eJHt9KHwpW1xcXV0vLFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRjovKFxcXFw/KSgoXFxXKShcXDMqKSkvZyxSRUdFWF9TUEVDSUFMX0NIQVJTX0dMT0JBTDovKFstKis/Ll4ke30ofClbXFxdXSkvZyxSRUdFWF9SRU1PVkVfQkFDS1NMQVNIOi8oPzpcXFsuKj9bXlxcXFxdXFxdfFxcXFwoPz0uKSkvZyxSRVBMQUNFTUVOVFM6e1wiKioqXCI6XCIqXCIsXCIqKi8qKlwiOlwiKipcIixcIioqLyoqLyoqXCI6XCIqKlwifSxDSEFSXzA6NDgsQ0hBUl85OjU3LENIQVJfVVBQRVJDQVNFX0E6NjUsQ0hBUl9MT1dFUkNBU0VfQTo5NyxDSEFSX1VQUEVSQ0FTRV9aOjkwLENIQVJfTE9XRVJDQVNFX1o6MTIyLENIQVJfTEVGVF9QQVJFTlRIRVNFUzo0MCxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOjQxLENIQVJfQVNURVJJU0s6NDIsQ0hBUl9BTVBFUlNBTkQ6MzgsQ0hBUl9BVDo2NCxDSEFSX0JBQ0tXQVJEX1NMQVNIOjkyLENIQVJfQ0FSUklBR0VfUkVUVVJOOjEzLENIQVJfQ0lSQ1VNRkxFWF9BQ0NFTlQ6OTQsQ0hBUl9DT0xPTjo1OCxDSEFSX0NPTU1BOjQ0LENIQVJfRE9UOjQ2LENIQVJfRE9VQkxFX1FVT1RFOjM0LENIQVJfRVFVQUw6NjEsQ0hBUl9FWENMQU1BVElPTl9NQVJLOjMzLENIQVJfRk9STV9GRUVEOjEyLENIQVJfRk9SV0FSRF9TTEFTSDo0NyxDSEFSX0dSQVZFX0FDQ0VOVDo5NixDSEFSX0hBU0g6MzUsQ0hBUl9IWVBIRU5fTUlOVVM6NDUsQ0hBUl9MRUZUX0FOR0xFX0JSQUNLRVQ6NjAsQ0hBUl9MRUZUX0NVUkxZX0JSQUNFOjEyMyxDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQ6OTEsQ0hBUl9MSU5FX0ZFRUQ6MTAsQ0hBUl9OT19CUkVBS19TUEFDRToxNjAsQ0hBUl9QRVJDRU5UOjM3LENIQVJfUExVUzo0MyxDSEFSX1FVRVNUSU9OX01BUks6NjMsQ0hBUl9SSUdIVF9BTkdMRV9CUkFDS0VUOjYyLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6MTI1LENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQ6OTMsQ0hBUl9TRU1JQ09MT046NTksQ0hBUl9TSU5HTEVfUVVPVEU6MzksQ0hBUl9TUEFDRTozMixDSEFSX1RBQjo5LENIQVJfVU5ERVJTQ09SRTo5NSxDSEFSX1ZFUlRJQ0FMX0xJTkU6MTI0LENIQVJfWkVST19XSURUSF9OT0JSRUFLX1NQQUNFOjY1Mjc5LFNFUDpuLnNlcCxleHRnbG9iQ2hhcnMoZSl7cmV0dXJue1wiIVwiOnt0eXBlOlwibmVnYXRlXCIsb3BlbjpcIig/Oig/ISg/OlwiLGNsb3NlOmApKSR7ZS5TVEFSfSlgfSxcIj9cIjp7dHlwZTpcInFtYXJrXCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKT9cIn0sXCIrXCI6e3R5cGU6XCJwbHVzXCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKStcIn0sXCIqXCI6e3R5cGU6XCJzdGFyXCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKSpcIn0sXCJAXCI6e3R5cGU6XCJhdFwiLG9wZW46XCIoPzpcIixjbG9zZTpcIilcIn19fSxnbG9iQ2hhcnMoZSl7cmV0dXJuIGU9PT10cnVlP3g6ZH19fSw3NTQ6KGUsdCxyKT0+e2NvbnN0IG49cigzNTYpO2NvbnN0IHU9cig1MTMpO2NvbnN0e01BWF9MRU5HVEg6cyxQT1NJWF9SRUdFWF9TT1VSQ0U6byxSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUzppLFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRjphLFJFUExBQ0VNRU5UUzpsfT1uO2NvbnN0IGV4cGFuZFJhbmdlPShlLHQpPT57aWYodHlwZW9mIHQuZXhwYW5kUmFuZ2U9PT1cImZ1bmN0aW9uXCIpe3JldHVybiB0LmV4cGFuZFJhbmdlKC4uLmUsdCl9ZS5zb3J0KCk7Y29uc3Qgcj1gWyR7ZS5qb2luKFwiLVwiKX1dYDt0cnl7bmV3IFJlZ0V4cChyKX1jYXRjaCh0KXtyZXR1cm4gZS5tYXAoKGU9PnUuZXNjYXBlUmVnZXgoZSkpKS5qb2luKFwiLi5cIil9cmV0dXJuIHJ9O2NvbnN0IHN5bnRheEVycm9yPShlLHQpPT5gTWlzc2luZyAke2V9OiBcIiR7dH1cIiAtIHVzZSBcIlxcXFxcXFxcJHt0fVwiIHRvIG1hdGNoIGxpdGVyYWwgY2hhcmFjdGVyc2A7Y29uc3QgcGFyc2U9KGUsdCk9PntpZih0eXBlb2YgZSE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKX1lPWxbZV18fGU7Y29uc3Qgcj17Li4udH07Y29uc3QgYz10eXBlb2Ygci5tYXhMZW5ndGg9PT1cIm51bWJlclwiP01hdGgubWluKHMsci5tYXhMZW5ndGgpOnM7bGV0IHA9ZS5sZW5ndGg7aWYocD5jKXt0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aDogJHtwfSwgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoOiAke2N9YCl9Y29uc3QgZj17dHlwZTpcImJvc1wiLHZhbHVlOlwiXCIsb3V0cHV0OnIucHJlcGVuZHx8XCJcIn07Y29uc3QgQT1bZl07Y29uc3QgUj1yLmNhcHR1cmU/XCJcIjpcIj86XCI7Y29uc3QgXz11LmlzV2luZG93cyh0KTtjb25zdCBoPW4uZ2xvYkNoYXJzKF8pO2NvbnN0IGc9bi5leHRnbG9iQ2hhcnMoaCk7Y29uc3R7RE9UX0xJVEVSQUw6RSxQTFVTX0xJVEVSQUw6QyxTTEFTSF9MSVRFUkFMOnksT05FX0NIQVI6ZCxET1RTX1NMQVNIOngsTk9fRE9UOmIsTk9fRE9UX1NMQVNIOlMsTk9fRE9UU19TTEFTSDpILFFNQVJLOnYsUU1BUktfTk9fRE9UOiQsU1RBUjptLFNUQVJUX0FOQ0hPUjpUfT1oO2NvbnN0IGdsb2JzdGFyPWU9PmAoJHtSfSg/Oig/ISR7VH0ke2UuZG90P3g6RX0pLikqPylgO2NvbnN0IEw9ci5kb3Q/XCJcIjpiO2NvbnN0IE89ci5kb3Q/djokO2xldCB3PXIuYmFzaD09PXRydWU/Z2xvYnN0YXIocik6bTtpZihyLmNhcHR1cmUpe3c9YCgke3d9KWB9aWYodHlwZW9mIHIubm9leHQ9PT1cImJvb2xlYW5cIil7ci5ub2V4dGdsb2I9ci5ub2V4dH1jb25zdCBOPXtpbnB1dDplLGluZGV4Oi0xLHN0YXJ0OjAsZG90OnIuZG90PT09dHJ1ZSxjb25zdW1lZDpcIlwiLG91dHB1dDpcIlwiLHByZWZpeDpcIlwiLGJhY2t0cmFjazpmYWxzZSxuZWdhdGVkOmZhbHNlLGJyYWNrZXRzOjAsYnJhY2VzOjAscGFyZW5zOjAscXVvdGVzOjAsZ2xvYnN0YXI6ZmFsc2UsdG9rZW5zOkF9O2U9dS5yZW1vdmVQcmVmaXgoZSxOKTtwPWUubGVuZ3RoO2NvbnN0IGs9W107Y29uc3QgST1bXTtjb25zdCBNPVtdO2xldCBQPWY7bGV0IEI7Y29uc3QgZW9zPSgpPT5OLmluZGV4PT09cC0xO2NvbnN0IEc9Ti5wZWVrPSh0PTEpPT5lW04uaW5kZXgrdF07Y29uc3QgRD1OLmFkdmFuY2U9KCk9PmVbKytOLmluZGV4XTtjb25zdCByZW1haW5pbmc9KCk9PmUuc2xpY2UoTi5pbmRleCsxKTtjb25zdCBjb25zdW1lPShlPVwiXCIsdD0wKT0+e04uY29uc3VtZWQrPWU7Ti5pbmRleCs9dH07Y29uc3QgYXBwZW5kPWU9PntOLm91dHB1dCs9ZS5vdXRwdXQhPW51bGw/ZS5vdXRwdXQ6ZS52YWx1ZTtjb25zdW1lKGUudmFsdWUpfTtjb25zdCBuZWdhdGU9KCk9PntsZXQgZT0xO3doaWxlKEcoKT09PVwiIVwiJiYoRygyKSE9PVwiKFwifHxHKDMpPT09XCI/XCIpKXtEKCk7Ti5zdGFydCsrO2UrK31pZihlJTI9PT0wKXtyZXR1cm4gZmFsc2V9Ti5uZWdhdGVkPXRydWU7Ti5zdGFydCsrO3JldHVybiB0cnVlfTtjb25zdCBpbmNyZW1lbnQ9ZT0+e05bZV0rKztNLnB1c2goZSl9O2NvbnN0IGRlY3JlbWVudD1lPT57TltlXS0tO00ucG9wKCl9O2NvbnN0IHB1c2g9ZT0+e2lmKFAudHlwZT09PVwiZ2xvYnN0YXJcIil7Y29uc3QgdD1OLmJyYWNlcz4wJiYoZS50eXBlPT09XCJjb21tYVwifHxlLnR5cGU9PT1cImJyYWNlXCIpO2NvbnN0IHI9ZS5leHRnbG9iPT09dHJ1ZXx8ay5sZW5ndGgmJihlLnR5cGU9PT1cInBpcGVcInx8ZS50eXBlPT09XCJwYXJlblwiKTtpZihlLnR5cGUhPT1cInNsYXNoXCImJmUudHlwZSE9PVwicGFyZW5cIiYmIXQmJiFyKXtOLm91dHB1dD1OLm91dHB1dC5zbGljZSgwLC1QLm91dHB1dC5sZW5ndGgpO1AudHlwZT1cInN0YXJcIjtQLnZhbHVlPVwiKlwiO1Aub3V0cHV0PXc7Ti5vdXRwdXQrPVAub3V0cHV0fX1pZihrLmxlbmd0aCYmZS50eXBlIT09XCJwYXJlblwiJiYhZ1tlLnZhbHVlXSl7a1trLmxlbmd0aC0xXS5pbm5lcis9ZS52YWx1ZX1pZihlLnZhbHVlfHxlLm91dHB1dClhcHBlbmQoZSk7aWYoUCYmUC50eXBlPT09XCJ0ZXh0XCImJmUudHlwZT09PVwidGV4dFwiKXtQLnZhbHVlKz1lLnZhbHVlO1Aub3V0cHV0PShQLm91dHB1dHx8XCJcIikrZS52YWx1ZTtyZXR1cm59ZS5wcmV2PVA7QS5wdXNoKGUpO1A9ZX07Y29uc3QgZXh0Z2xvYk9wZW49KGUsdCk9Pntjb25zdCBuPXsuLi5nW3RdLGNvbmRpdGlvbnM6MSxpbm5lcjpcIlwifTtuLnByZXY9UDtuLnBhcmVucz1OLnBhcmVucztuLm91dHB1dD1OLm91dHB1dDtjb25zdCB1PShyLmNhcHR1cmU/XCIoXCI6XCJcIikrbi5vcGVuO2luY3JlbWVudChcInBhcmVuc1wiKTtwdXNoKHt0eXBlOmUsdmFsdWU6dCxvdXRwdXQ6Ti5vdXRwdXQ/XCJcIjpkfSk7cHVzaCh7dHlwZTpcInBhcmVuXCIsZXh0Z2xvYjp0cnVlLHZhbHVlOkQoKSxvdXRwdXQ6dX0pO2sucHVzaChuKX07Y29uc3QgZXh0Z2xvYkNsb3NlPWU9PntsZXQgdD1lLmNsb3NlKyhyLmNhcHR1cmU/XCIpXCI6XCJcIik7aWYoZS50eXBlPT09XCJuZWdhdGVcIil7bGV0IG49dztpZihlLmlubmVyJiZlLmlubmVyLmxlbmd0aD4xJiZlLmlubmVyLmluY2x1ZGVzKFwiL1wiKSl7bj1nbG9ic3RhcihyKX1pZihuIT09d3x8ZW9zKCl8fC9eXFwpKyQvLnRlc3QocmVtYWluaW5nKCkpKXt0PWUuY2xvc2U9YCkkKSkke259YH1pZihlLnByZXYudHlwZT09PVwiYm9zXCIpe04ubmVnYXRlZEV4dGdsb2I9dHJ1ZX19cHVzaCh7dHlwZTpcInBhcmVuXCIsZXh0Z2xvYjp0cnVlLHZhbHVlOkIsb3V0cHV0OnR9KTtkZWNyZW1lbnQoXCJwYXJlbnNcIil9O2lmKHIuZmFzdHBhdGhzIT09ZmFsc2UmJiEvKF5bKiFdfFsvKClbXFxde31cIl0pLy50ZXN0KGUpKXtsZXQgbj1mYWxzZTtsZXQgcz1lLnJlcGxhY2UoYSwoKGUsdCxyLHUscyxvKT0+e2lmKHU9PT1cIlxcXFxcIil7bj10cnVlO3JldHVybiBlfWlmKHU9PT1cIj9cIil7aWYodCl7cmV0dXJuIHQrdSsocz92LnJlcGVhdChzLmxlbmd0aCk6XCJcIil9aWYobz09PTApe3JldHVybiBPKyhzP3YucmVwZWF0KHMubGVuZ3RoKTpcIlwiKX1yZXR1cm4gdi5yZXBlYXQoci5sZW5ndGgpfWlmKHU9PT1cIi5cIil7cmV0dXJuIEUucmVwZWF0KHIubGVuZ3RoKX1pZih1PT09XCIqXCIpe2lmKHQpe3JldHVybiB0K3UrKHM/dzpcIlwiKX1yZXR1cm4gd31yZXR1cm4gdD9lOmBcXFxcJHtlfWB9KSk7aWYobj09PXRydWUpe2lmKHIudW5lc2NhcGU9PT10cnVlKXtzPXMucmVwbGFjZSgvXFxcXC9nLFwiXCIpfWVsc2V7cz1zLnJlcGxhY2UoL1xcXFwrL2csKGU9PmUubGVuZ3RoJTI9PT0wP1wiXFxcXFxcXFxcIjplP1wiXFxcXFwiOlwiXCIpKX19aWYocz09PWUmJnIuY29udGFpbnM9PT10cnVlKXtOLm91dHB1dD1lO3JldHVybiBOfU4ub3V0cHV0PXUud3JhcE91dHB1dChzLE4sdCk7cmV0dXJuIE59d2hpbGUoIWVvcygpKXtCPUQoKTtpZihCPT09XCJcXDBcIil7Y29udGludWV9aWYoQj09PVwiXFxcXFwiKXtjb25zdCBlPUcoKTtpZihlPT09XCIvXCImJnIuYmFzaCE9PXRydWUpe2NvbnRpbnVlfWlmKGU9PT1cIi5cInx8ZT09PVwiO1wiKXtjb250aW51ZX1pZighZSl7Qis9XCJcXFxcXCI7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCfSk7Y29udGludWV9Y29uc3QgdD0vXlxcXFwrLy5leGVjKHJlbWFpbmluZygpKTtsZXQgbj0wO2lmKHQmJnRbMF0ubGVuZ3RoPjIpe249dFswXS5sZW5ndGg7Ti5pbmRleCs9bjtpZihuJTIhPT0wKXtCKz1cIlxcXFxcIn19aWYoci51bmVzY2FwZT09PXRydWUpe0I9RCgpfHxcIlwifWVsc2V7Qis9RCgpfHxcIlwifWlmKE4uYnJhY2tldHM9PT0wKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkJ9KTtjb250aW51ZX19aWYoTi5icmFja2V0cz4wJiYoQiE9PVwiXVwifHxQLnZhbHVlPT09XCJbXCJ8fFAudmFsdWU9PT1cIlteXCIpKXtpZihyLnBvc2l4IT09ZmFsc2UmJkI9PT1cIjpcIil7Y29uc3QgZT1QLnZhbHVlLnNsaWNlKDEpO2lmKGUuaW5jbHVkZXMoXCJbXCIpKXtQLnBvc2l4PXRydWU7aWYoZS5pbmNsdWRlcyhcIjpcIikpe2NvbnN0IGU9UC52YWx1ZS5sYXN0SW5kZXhPZihcIltcIik7Y29uc3QgdD1QLnZhbHVlLnNsaWNlKDAsZSk7Y29uc3Qgcj1QLnZhbHVlLnNsaWNlKGUrMik7Y29uc3Qgbj1vW3JdO2lmKG4pe1AudmFsdWU9dCtuO04uYmFja3RyYWNrPXRydWU7RCgpO2lmKCFmLm91dHB1dCYmQS5pbmRleE9mKFApPT09MSl7Zi5vdXRwdXQ9ZH1jb250aW51ZX19fX1pZihCPT09XCJbXCImJkcoKSE9PVwiOlwifHxCPT09XCItXCImJkcoKT09PVwiXVwiKXtCPWBcXFxcJHtCfWB9aWYoQj09PVwiXVwiJiYoUC52YWx1ZT09PVwiW1wifHxQLnZhbHVlPT09XCJbXlwiKSl7Qj1gXFxcXCR7Qn1gfWlmKHIucG9zaXg9PT10cnVlJiZCPT09XCIhXCImJlAudmFsdWU9PT1cIltcIil7Qj1cIl5cIn1QLnZhbHVlKz1CO2FwcGVuZCh7dmFsdWU6Qn0pO2NvbnRpbnVlfWlmKE4ucXVvdGVzPT09MSYmQiE9PSdcIicpe0I9dS5lc2NhcGVSZWdleChCKTtQLnZhbHVlKz1CO2FwcGVuZCh7dmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEI9PT0nXCInKXtOLnF1b3Rlcz1OLnF1b3Rlcz09PTE/MDoxO2lmKHIua2VlcFF1b3Rlcz09PXRydWUpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6Qn0pfWNvbnRpbnVlfWlmKEI9PT1cIihcIil7aW5jcmVtZW50KFwicGFyZW5zXCIpO3B1c2goe3R5cGU6XCJwYXJlblwiLHZhbHVlOkJ9KTtjb250aW51ZX1pZihCPT09XCIpXCIpe2lmKE4ucGFyZW5zPT09MCYmci5zdHJpY3RCcmFja2V0cz09PXRydWUpe3Rocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcIm9wZW5pbmdcIixcIihcIikpfWNvbnN0IGU9a1trLmxlbmd0aC0xXTtpZihlJiZOLnBhcmVucz09PWUucGFyZW5zKzEpe2V4dGdsb2JDbG9zZShrLnBvcCgpKTtjb250aW51ZX1wdXNoKHt0eXBlOlwicGFyZW5cIix2YWx1ZTpCLG91dHB1dDpOLnBhcmVucz9cIilcIjpcIlxcXFwpXCJ9KTtkZWNyZW1lbnQoXCJwYXJlbnNcIik7Y29udGludWV9aWYoQj09PVwiW1wiKXtpZihyLm5vYnJhY2tldD09PXRydWV8fCFyZW1haW5pbmcoKS5pbmNsdWRlcyhcIl1cIikpe2lmKHIubm9icmFja2V0IT09dHJ1ZSYmci5zdHJpY3RCcmFja2V0cz09PXRydWUpe3Rocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcImNsb3NpbmdcIixcIl1cIikpfUI9YFxcXFwke0J9YH1lbHNle2luY3JlbWVudChcImJyYWNrZXRzXCIpfXB1c2goe3R5cGU6XCJicmFja2V0XCIsdmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEI9PT1cIl1cIil7aWYoci5ub2JyYWNrZXQ9PT10cnVlfHxQJiZQLnR5cGU9PT1cImJyYWNrZXRcIiYmUC52YWx1ZS5sZW5ndGg9PT0xKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkIsb3V0cHV0OmBcXFxcJHtCfWB9KTtjb250aW51ZX1pZihOLmJyYWNrZXRzPT09MCl7aWYoci5zdHJpY3RCcmFja2V0cz09PXRydWUpe3Rocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcIm9wZW5pbmdcIixcIltcIikpfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6QixvdXRwdXQ6YFxcXFwke0J9YH0pO2NvbnRpbnVlfWRlY3JlbWVudChcImJyYWNrZXRzXCIpO2NvbnN0IGU9UC52YWx1ZS5zbGljZSgxKTtpZihQLnBvc2l4IT09dHJ1ZSYmZVswXT09PVwiXlwiJiYhZS5pbmNsdWRlcyhcIi9cIikpe0I9YC8ke0J9YH1QLnZhbHVlKz1CO2FwcGVuZCh7dmFsdWU6Qn0pO2lmKHIubGl0ZXJhbEJyYWNrZXRzPT09ZmFsc2V8fHUuaGFzUmVnZXhDaGFycyhlKSl7Y29udGludWV9Y29uc3QgdD11LmVzY2FwZVJlZ2V4KFAudmFsdWUpO04ub3V0cHV0PU4ub3V0cHV0LnNsaWNlKDAsLVAudmFsdWUubGVuZ3RoKTtpZihyLmxpdGVyYWxCcmFja2V0cz09PXRydWUpe04ub3V0cHV0Kz10O1AudmFsdWU9dDtjb250aW51ZX1QLnZhbHVlPWAoJHtSfSR7dH18JHtQLnZhbHVlfSlgO04ub3V0cHV0Kz1QLnZhbHVlO2NvbnRpbnVlfWlmKEI9PT1cIntcIiYmci5ub2JyYWNlIT09dHJ1ZSl7aW5jcmVtZW50KFwiYnJhY2VzXCIpO2NvbnN0IGU9e3R5cGU6XCJicmFjZVwiLHZhbHVlOkIsb3V0cHV0OlwiKFwiLG91dHB1dEluZGV4Ok4ub3V0cHV0Lmxlbmd0aCx0b2tlbnNJbmRleDpOLnRva2Vucy5sZW5ndGh9O0kucHVzaChlKTtwdXNoKGUpO2NvbnRpbnVlfWlmKEI9PT1cIn1cIil7Y29uc3QgZT1JW0kubGVuZ3RoLTFdO2lmKHIubm9icmFjZT09PXRydWV8fCFlKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkIsb3V0cHV0OkJ9KTtjb250aW51ZX1sZXQgdD1cIilcIjtpZihlLmRvdHM9PT10cnVlKXtjb25zdCBlPUEuc2xpY2UoKTtjb25zdCBuPVtdO2ZvcihsZXQgdD1lLmxlbmd0aC0xO3Q+PTA7dC0tKXtBLnBvcCgpO2lmKGVbdF0udHlwZT09PVwiYnJhY2VcIil7YnJlYWt9aWYoZVt0XS50eXBlIT09XCJkb3RzXCIpe24udW5zaGlmdChlW3RdLnZhbHVlKX19dD1leHBhbmRSYW5nZShuLHIpO04uYmFja3RyYWNrPXRydWV9aWYoZS5jb21tYSE9PXRydWUmJmUuZG90cyE9PXRydWUpe2NvbnN0IHI9Ti5vdXRwdXQuc2xpY2UoMCxlLm91dHB1dEluZGV4KTtjb25zdCBuPU4udG9rZW5zLnNsaWNlKGUudG9rZW5zSW5kZXgpO2UudmFsdWU9ZS5vdXRwdXQ9XCJcXFxce1wiO0I9dD1cIlxcXFx9XCI7Ti5vdXRwdXQ9cjtmb3IoY29uc3QgZSBvZiBuKXtOLm91dHB1dCs9ZS5vdXRwdXR8fGUudmFsdWV9fXB1c2goe3R5cGU6XCJicmFjZVwiLHZhbHVlOkIsb3V0cHV0OnR9KTtkZWNyZW1lbnQoXCJicmFjZXNcIik7SS5wb3AoKTtjb250aW51ZX1pZihCPT09XCJ8XCIpe2lmKGsubGVuZ3RoPjApe2tbay5sZW5ndGgtMV0uY29uZGl0aW9ucysrfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEI9PT1cIixcIil7bGV0IGU9Qjtjb25zdCB0PUlbSS5sZW5ndGgtMV07aWYodCYmTVtNLmxlbmd0aC0xXT09PVwiYnJhY2VzXCIpe3QuY29tbWE9dHJ1ZTtlPVwifFwifXB1c2goe3R5cGU6XCJjb21tYVwiLHZhbHVlOkIsb3V0cHV0OmV9KTtjb250aW51ZX1pZihCPT09XCIvXCIpe2lmKFAudHlwZT09PVwiZG90XCImJk4uaW5kZXg9PT1OLnN0YXJ0KzEpe04uc3RhcnQ9Ti5pbmRleCsxO04uY29uc3VtZWQ9XCJcIjtOLm91dHB1dD1cIlwiO0EucG9wKCk7UD1mO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJzbGFzaFwiLHZhbHVlOkIsb3V0cHV0Onl9KTtjb250aW51ZX1pZihCPT09XCIuXCIpe2lmKE4uYnJhY2VzPjAmJlAudHlwZT09PVwiZG90XCIpe2lmKFAudmFsdWU9PT1cIi5cIilQLm91dHB1dD1FO2NvbnN0IGU9SVtJLmxlbmd0aC0xXTtQLnR5cGU9XCJkb3RzXCI7UC5vdXRwdXQrPUI7UC52YWx1ZSs9QjtlLmRvdHM9dHJ1ZTtjb250aW51ZX1pZihOLmJyYWNlcytOLnBhcmVucz09PTAmJlAudHlwZSE9PVwiYm9zXCImJlAudHlwZSE9PVwic2xhc2hcIil7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCLG91dHB1dDpFfSk7Y29udGludWV9cHVzaCh7dHlwZTpcImRvdFwiLHZhbHVlOkIsb3V0cHV0OkV9KTtjb250aW51ZX1pZihCPT09XCI/XCIpe2NvbnN0IGU9UCYmUC52YWx1ZT09PVwiKFwiO2lmKCFlJiZyLm5vZXh0Z2xvYiE9PXRydWUmJkcoKT09PVwiKFwiJiZHKDIpIT09XCI/XCIpe2V4dGdsb2JPcGVuKFwicW1hcmtcIixCKTtjb250aW51ZX1pZihQJiZQLnR5cGU9PT1cInBhcmVuXCIpe2NvbnN0IGU9RygpO2xldCB0PUI7aWYoZT09PVwiPFwiJiYhdS5zdXBwb3J0c0xvb2tiZWhpbmRzKCkpe3Rocm93IG5ldyBFcnJvcihcIk5vZGUuanMgdjEwIG9yIGhpZ2hlciBpcyByZXF1aXJlZCBmb3IgcmVnZXggbG9va2JlaGluZHNcIil9aWYoUC52YWx1ZT09PVwiKFwiJiYhL1shPTw6XS8udGVzdChlKXx8ZT09PVwiPFwiJiYhLzwoWyE9XXxcXHcrPikvLnRlc3QocmVtYWluaW5nKCkpKXt0PWBcXFxcJHtCfWB9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCLG91dHB1dDp0fSk7Y29udGludWV9aWYoci5kb3QhPT10cnVlJiYoUC50eXBlPT09XCJzbGFzaFwifHxQLnR5cGU9PT1cImJvc1wiKSl7cHVzaCh7dHlwZTpcInFtYXJrXCIsdmFsdWU6QixvdXRwdXQ6JH0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJxbWFya1wiLHZhbHVlOkIsb3V0cHV0OnZ9KTtjb250aW51ZX1pZihCPT09XCIhXCIpe2lmKHIubm9leHRnbG9iIT09dHJ1ZSYmRygpPT09XCIoXCIpe2lmKEcoMikhPT1cIj9cInx8IS9bIT08Ol0vLnRlc3QoRygzKSkpe2V4dGdsb2JPcGVuKFwibmVnYXRlXCIsQik7Y29udGludWV9fWlmKHIubm9uZWdhdGUhPT10cnVlJiZOLmluZGV4PT09MCl7bmVnYXRlKCk7Y29udGludWV9fWlmKEI9PT1cIitcIil7aWYoci5ub2V4dGdsb2IhPT10cnVlJiZHKCk9PT1cIihcIiYmRygyKSE9PVwiP1wiKXtleHRnbG9iT3BlbihcInBsdXNcIixCKTtjb250aW51ZX1pZihQJiZQLnZhbHVlPT09XCIoXCJ8fHIucmVnZXg9PT1mYWxzZSl7cHVzaCh7dHlwZTpcInBsdXNcIix2YWx1ZTpCLG91dHB1dDpDfSk7Y29udGludWV9aWYoUCYmKFAudHlwZT09PVwiYnJhY2tldFwifHxQLnR5cGU9PT1cInBhcmVuXCJ8fFAudHlwZT09PVwiYnJhY2VcIil8fE4ucGFyZW5zPjApe3B1c2goe3R5cGU6XCJwbHVzXCIsdmFsdWU6Qn0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJwbHVzXCIsdmFsdWU6Q30pO2NvbnRpbnVlfWlmKEI9PT1cIkBcIil7aWYoci5ub2V4dGdsb2IhPT10cnVlJiZHKCk9PT1cIihcIiYmRygyKSE9PVwiP1wiKXtwdXNoKHt0eXBlOlwiYXRcIixleHRnbG9iOnRydWUsdmFsdWU6QixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEIhPT1cIipcIil7aWYoQj09PVwiJFwifHxCPT09XCJeXCIpe0I9YFxcXFwke0J9YH1jb25zdCBlPWkuZXhlYyhyZW1haW5pbmcoKSk7aWYoZSl7Qis9ZVswXTtOLmluZGV4Kz1lWzBdLmxlbmd0aH1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkJ9KTtjb250aW51ZX1pZihQJiYoUC50eXBlPT09XCJnbG9ic3RhclwifHxQLnN0YXI9PT10cnVlKSl7UC50eXBlPVwic3RhclwiO1Auc3Rhcj10cnVlO1AudmFsdWUrPUI7UC5vdXRwdXQ9dztOLmJhY2t0cmFjaz10cnVlO04uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEIpO2NvbnRpbnVlfWxldCB0PXJlbWFpbmluZygpO2lmKHIubm9leHRnbG9iIT09dHJ1ZSYmL15cXChbXj9dLy50ZXN0KHQpKXtleHRnbG9iT3BlbihcInN0YXJcIixCKTtjb250aW51ZX1pZihQLnR5cGU9PT1cInN0YXJcIil7aWYoci5ub2dsb2JzdGFyPT09dHJ1ZSl7Y29uc3VtZShCKTtjb250aW51ZX1jb25zdCBuPVAucHJldjtjb25zdCB1PW4ucHJldjtjb25zdCBzPW4udHlwZT09PVwic2xhc2hcInx8bi50eXBlPT09XCJib3NcIjtjb25zdCBvPXUmJih1LnR5cGU9PT1cInN0YXJcInx8dS50eXBlPT09XCJnbG9ic3RhclwiKTtpZihyLmJhc2g9PT10cnVlJiYoIXN8fHRbMF0mJnRbMF0hPT1cIi9cIikpe3B1c2goe3R5cGU6XCJzdGFyXCIsdmFsdWU6QixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfWNvbnN0IGk9Ti5icmFjZXM+MCYmKG4udHlwZT09PVwiY29tbWFcInx8bi50eXBlPT09XCJicmFjZVwiKTtjb25zdCBhPWsubGVuZ3RoJiYobi50eXBlPT09XCJwaXBlXCJ8fG4udHlwZT09PVwicGFyZW5cIik7aWYoIXMmJm4udHlwZSE9PVwicGFyZW5cIiYmIWkmJiFhKXtwdXNoKHt0eXBlOlwic3RhclwiLHZhbHVlOkIsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX13aGlsZSh0LnNsaWNlKDAsMyk9PT1cIi8qKlwiKXtjb25zdCByPWVbTi5pbmRleCs0XTtpZihyJiZyIT09XCIvXCIpe2JyZWFrfXQ9dC5zbGljZSgzKTtjb25zdW1lKFwiLyoqXCIsMyl9aWYobi50eXBlPT09XCJib3NcIiYmZW9zKCkpe1AudHlwZT1cImdsb2JzdGFyXCI7UC52YWx1ZSs9QjtQLm91dHB1dD1nbG9ic3RhcihyKTtOLm91dHB1dD1QLm91dHB1dDtOLmdsb2JzdGFyPXRydWU7Y29uc3VtZShCKTtjb250aW51ZX1pZihuLnR5cGU9PT1cInNsYXNoXCImJm4ucHJldi50eXBlIT09XCJib3NcIiYmIW8mJmVvcygpKXtOLm91dHB1dD1OLm91dHB1dC5zbGljZSgwLC0obi5vdXRwdXQrUC5vdXRwdXQpLmxlbmd0aCk7bi5vdXRwdXQ9YCg/OiR7bi5vdXRwdXR9YDtQLnR5cGU9XCJnbG9ic3RhclwiO1Aub3V0cHV0PWdsb2JzdGFyKHIpKyhyLnN0cmljdFNsYXNoZXM/XCIpXCI6XCJ8JClcIik7UC52YWx1ZSs9QjtOLmdsb2JzdGFyPXRydWU7Ti5vdXRwdXQrPW4ub3V0cHV0K1Aub3V0cHV0O2NvbnN1bWUoQik7Y29udGludWV9aWYobi50eXBlPT09XCJzbGFzaFwiJiZuLnByZXYudHlwZSE9PVwiYm9zXCImJnRbMF09PT1cIi9cIil7Y29uc3QgZT10WzFdIT09dm9pZCAwP1wifCRcIjpcIlwiO04ub3V0cHV0PU4ub3V0cHV0LnNsaWNlKDAsLShuLm91dHB1dCtQLm91dHB1dCkubGVuZ3RoKTtuLm91dHB1dD1gKD86JHtuLm91dHB1dH1gO1AudHlwZT1cImdsb2JzdGFyXCI7UC5vdXRwdXQ9YCR7Z2xvYnN0YXIocil9JHt5fXwke3l9JHtlfSlgO1AudmFsdWUrPUI7Ti5vdXRwdXQrPW4ub3V0cHV0K1Aub3V0cHV0O04uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEIrRCgpKTtwdXNoKHt0eXBlOlwic2xhc2hcIix2YWx1ZTpcIi9cIixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfWlmKG4udHlwZT09PVwiYm9zXCImJnRbMF09PT1cIi9cIil7UC50eXBlPVwiZ2xvYnN0YXJcIjtQLnZhbHVlKz1CO1Aub3V0cHV0PWAoPzpefCR7eX18JHtnbG9ic3RhcihyKX0ke3l9KWA7Ti5vdXRwdXQ9UC5vdXRwdXQ7Ti5nbG9ic3Rhcj10cnVlO2NvbnN1bWUoQitEKCkpO3B1c2goe3R5cGU6XCJzbGFzaFwiLHZhbHVlOlwiL1wiLG91dHB1dDpcIlwifSk7Y29udGludWV9Ti5vdXRwdXQ9Ti5vdXRwdXQuc2xpY2UoMCwtUC5vdXRwdXQubGVuZ3RoKTtQLnR5cGU9XCJnbG9ic3RhclwiO1Aub3V0cHV0PWdsb2JzdGFyKHIpO1AudmFsdWUrPUI7Ti5vdXRwdXQrPVAub3V0cHV0O04uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEIpO2NvbnRpbnVlfWNvbnN0IG49e3R5cGU6XCJzdGFyXCIsdmFsdWU6QixvdXRwdXQ6d307aWYoci5iYXNoPT09dHJ1ZSl7bi5vdXRwdXQ9XCIuKj9cIjtpZihQLnR5cGU9PT1cImJvc1wifHxQLnR5cGU9PT1cInNsYXNoXCIpe24ub3V0cHV0PUwrbi5vdXRwdXR9cHVzaChuKTtjb250aW51ZX1pZihQJiYoUC50eXBlPT09XCJicmFja2V0XCJ8fFAudHlwZT09PVwicGFyZW5cIikmJnIucmVnZXg9PT10cnVlKXtuLm91dHB1dD1CO3B1c2gobik7Y29udGludWV9aWYoTi5pbmRleD09PU4uc3RhcnR8fFAudHlwZT09PVwic2xhc2hcInx8UC50eXBlPT09XCJkb3RcIil7aWYoUC50eXBlPT09XCJkb3RcIil7Ti5vdXRwdXQrPVM7UC5vdXRwdXQrPVN9ZWxzZSBpZihyLmRvdD09PXRydWUpe04ub3V0cHV0Kz1IO1Aub3V0cHV0Kz1IfWVsc2V7Ti5vdXRwdXQrPUw7UC5vdXRwdXQrPUx9aWYoRygpIT09XCIqXCIpe04ub3V0cHV0Kz1kO1Aub3V0cHV0Kz1kfX1wdXNoKG4pfXdoaWxlKE4uYnJhY2tldHM+MCl7aWYoci5zdHJpY3RCcmFja2V0cz09PXRydWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwiXVwiKSk7Ti5vdXRwdXQ9dS5lc2NhcGVMYXN0KE4ub3V0cHV0LFwiW1wiKTtkZWNyZW1lbnQoXCJicmFja2V0c1wiKX13aGlsZShOLnBhcmVucz4wKXtpZihyLnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCIpXCIpKTtOLm91dHB1dD11LmVzY2FwZUxhc3QoTi5vdXRwdXQsXCIoXCIpO2RlY3JlbWVudChcInBhcmVuc1wiKX13aGlsZShOLmJyYWNlcz4wKXtpZihyLnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCJ9XCIpKTtOLm91dHB1dD11LmVzY2FwZUxhc3QoTi5vdXRwdXQsXCJ7XCIpO2RlY3JlbWVudChcImJyYWNlc1wiKX1pZihyLnN0cmljdFNsYXNoZXMhPT10cnVlJiYoUC50eXBlPT09XCJzdGFyXCJ8fFAudHlwZT09PVwiYnJhY2tldFwiKSl7cHVzaCh7dHlwZTpcIm1heWJlX3NsYXNoXCIsdmFsdWU6XCJcIixvdXRwdXQ6YCR7eX0/YH0pfWlmKE4uYmFja3RyYWNrPT09dHJ1ZSl7Ti5vdXRwdXQ9XCJcIjtmb3IoY29uc3QgZSBvZiBOLnRva2Vucyl7Ti5vdXRwdXQrPWUub3V0cHV0IT1udWxsP2Uub3V0cHV0OmUudmFsdWU7aWYoZS5zdWZmaXgpe04ub3V0cHV0Kz1lLnN1ZmZpeH19fXJldHVybiBOfTtwYXJzZS5mYXN0cGF0aHM9KGUsdCk9Pntjb25zdCByPXsuLi50fTtjb25zdCBvPXR5cGVvZiByLm1heExlbmd0aD09PVwibnVtYmVyXCI/TWF0aC5taW4ocyxyLm1heExlbmd0aCk6cztjb25zdCBpPWUubGVuZ3RoO2lmKGk+byl7dGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnB1dCBsZW5ndGg6ICR7aX0sIGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIGxlbmd0aDogJHtvfWApfWU9bFtlXXx8ZTtjb25zdCBhPXUuaXNXaW5kb3dzKHQpO2NvbnN0e0RPVF9MSVRFUkFMOmMsU0xBU0hfTElURVJBTDpwLE9ORV9DSEFSOmYsRE9UU19TTEFTSDpBLE5PX0RPVDpSLE5PX0RPVFM6XyxOT19ET1RTX1NMQVNIOmgsU1RBUjpnLFNUQVJUX0FOQ0hPUjpFfT1uLmdsb2JDaGFycyhhKTtjb25zdCBDPXIuZG90P186Ujtjb25zdCB5PXIuZG90P2g6Ujtjb25zdCBkPXIuY2FwdHVyZT9cIlwiOlwiPzpcIjtjb25zdCB4PXtuZWdhdGVkOmZhbHNlLHByZWZpeDpcIlwifTtsZXQgYj1yLmJhc2g9PT10cnVlP1wiLio/XCI6ZztpZihyLmNhcHR1cmUpe2I9YCgke2J9KWB9Y29uc3QgZ2xvYnN0YXI9ZT0+e2lmKGUubm9nbG9ic3Rhcj09PXRydWUpcmV0dXJuIGI7cmV0dXJuYCgke2R9KD86KD8hJHtFfSR7ZS5kb3Q/QTpjfSkuKSo/KWB9O2NvbnN0IGNyZWF0ZT1lPT57c3dpdGNoKGUpe2Nhc2VcIipcIjpyZXR1cm5gJHtDfSR7Zn0ke2J9YDtjYXNlXCIuKlwiOnJldHVybmAke2N9JHtmfSR7Yn1gO2Nhc2VcIiouKlwiOnJldHVybmAke0N9JHtifSR7Y30ke2Z9JHtifWA7Y2FzZVwiKi8qXCI6cmV0dXJuYCR7Q30ke2J9JHtwfSR7Zn0ke3l9JHtifWA7Y2FzZVwiKipcIjpyZXR1cm4gQytnbG9ic3RhcihyKTtjYXNlXCIqKi8qXCI6cmV0dXJuYCg/OiR7Q30ke2dsb2JzdGFyKHIpfSR7cH0pPyR7eX0ke2Z9JHtifWA7Y2FzZVwiKiovKi4qXCI6cmV0dXJuYCg/OiR7Q30ke2dsb2JzdGFyKHIpfSR7cH0pPyR7eX0ke2J9JHtjfSR7Zn0ke2J9YDtjYXNlXCIqKi8uKlwiOnJldHVybmAoPzoke0N9JHtnbG9ic3RhcihyKX0ke3B9KT8ke2N9JHtmfSR7Yn1gO2RlZmF1bHQ6e2NvbnN0IHQ9L14oLio/KVxcLihcXHcrKSQvLmV4ZWMoZSk7aWYoIXQpcmV0dXJuO2NvbnN0IHI9Y3JlYXRlKHRbMV0pO2lmKCFyKXJldHVybjtyZXR1cm4gcitjK3RbMl19fX07Y29uc3QgUz11LnJlbW92ZVByZWZpeChlLHgpO2xldCBIPWNyZWF0ZShTKTtpZihIJiZyLnN0cmljdFNsYXNoZXMhPT10cnVlKXtIKz1gJHtwfT9gfXJldHVybiBIfTtlLmV4cG9ydHM9cGFyc2V9LDY4MzooZSx0LHIpPT57Y29uc3Qgbj1yKDE3KTtjb25zdCB1PXIoNzAwKTtjb25zdCBzPXIoNzU0KTtjb25zdCBvPXIoNTEzKTtjb25zdCBpPXIoMzU2KTtjb25zdCBpc09iamVjdD1lPT5lJiZ0eXBlb2YgZT09PVwib2JqZWN0XCImJiFBcnJheS5pc0FycmF5KGUpO2NvbnN0IHBpY29tYXRjaD0oZSx0LHI9ZmFsc2UpPT57aWYoQXJyYXkuaXNBcnJheShlKSl7Y29uc3Qgbj1lLm1hcCgoZT0+cGljb21hdGNoKGUsdCxyKSkpO2NvbnN0IGFycmF5TWF0Y2hlcj1lPT57Zm9yKGNvbnN0IHQgb2Ygbil7Y29uc3Qgcj10KGUpO2lmKHIpcmV0dXJuIHJ9cmV0dXJuIGZhbHNlfTtyZXR1cm4gYXJyYXlNYXRjaGVyfWNvbnN0IG49aXNPYmplY3QoZSkmJmUudG9rZW5zJiZlLmlucHV0O2lmKGU9PT1cIlwifHx0eXBlb2YgZSE9PVwic3RyaW5nXCImJiFuKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgcGF0dGVybiB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmdcIil9Y29uc3QgdT10fHx7fTtjb25zdCBzPW8uaXNXaW5kb3dzKHQpO2NvbnN0IGk9bj9waWNvbWF0Y2guY29tcGlsZVJlKGUsdCk6cGljb21hdGNoLm1ha2VSZShlLHQsZmFsc2UsdHJ1ZSk7Y29uc3QgYT1pLnN0YXRlO2RlbGV0ZSBpLnN0YXRlO2xldCBpc0lnbm9yZWQ9KCk9PmZhbHNlO2lmKHUuaWdub3JlKXtjb25zdCBlPXsuLi50LGlnbm9yZTpudWxsLG9uTWF0Y2g6bnVsbCxvblJlc3VsdDpudWxsfTtpc0lnbm9yZWQ9cGljb21hdGNoKHUuaWdub3JlLGUscil9Y29uc3QgbWF0Y2hlcj0ocixuPWZhbHNlKT0+e2NvbnN0e2lzTWF0Y2g6byxtYXRjaDpsLG91dHB1dDpjfT1waWNvbWF0Y2gudGVzdChyLGksdCx7Z2xvYjplLHBvc2l4OnN9KTtjb25zdCBwPXtnbG9iOmUsc3RhdGU6YSxyZWdleDppLHBvc2l4OnMsaW5wdXQ6cixvdXRwdXQ6YyxtYXRjaDpsLGlzTWF0Y2g6b307aWYodHlwZW9mIHUub25SZXN1bHQ9PT1cImZ1bmN0aW9uXCIpe3Uub25SZXN1bHQocCl9aWYobz09PWZhbHNlKXtwLmlzTWF0Y2g9ZmFsc2U7cmV0dXJuIG4/cDpmYWxzZX1pZihpc0lnbm9yZWQocikpe2lmKHR5cGVvZiB1Lm9uSWdub3JlPT09XCJmdW5jdGlvblwiKXt1Lm9uSWdub3JlKHApfXAuaXNNYXRjaD1mYWxzZTtyZXR1cm4gbj9wOmZhbHNlfWlmKHR5cGVvZiB1Lm9uTWF0Y2g9PT1cImZ1bmN0aW9uXCIpe3Uub25NYXRjaChwKX1yZXR1cm4gbj9wOnRydWV9O2lmKHIpe21hdGNoZXIuc3RhdGU9YX1yZXR1cm4gbWF0Y2hlcn07cGljb21hdGNoLnRlc3Q9KGUsdCxyLHtnbG9iOm4scG9zaXg6dX09e30pPT57aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgaW5wdXQgdG8gYmUgYSBzdHJpbmdcIil9aWYoZT09PVwiXCIpe3JldHVybntpc01hdGNoOmZhbHNlLG91dHB1dDpcIlwifX1jb25zdCBzPXJ8fHt9O2NvbnN0IGk9cy5mb3JtYXR8fCh1P28udG9Qb3NpeFNsYXNoZXM6bnVsbCk7bGV0IGE9ZT09PW47bGV0IGw9YSYmaT9pKGUpOmU7aWYoYT09PWZhbHNlKXtsPWk/aShlKTplO2E9bD09PW59aWYoYT09PWZhbHNlfHxzLmNhcHR1cmU9PT10cnVlKXtpZihzLm1hdGNoQmFzZT09PXRydWV8fHMuYmFzZW5hbWU9PT10cnVlKXthPXBpY29tYXRjaC5tYXRjaEJhc2UoZSx0LHIsdSl9ZWxzZXthPXQuZXhlYyhsKX19cmV0dXJue2lzTWF0Y2g6Qm9vbGVhbihhKSxtYXRjaDphLG91dHB1dDpsfX07cGljb21hdGNoLm1hdGNoQmFzZT0oZSx0LHIsdT1vLmlzV2luZG93cyhyKSk9Pntjb25zdCBzPXQgaW5zdGFuY2VvZiBSZWdFeHA/dDpwaWNvbWF0Y2gubWFrZVJlKHQscik7cmV0dXJuIHMudGVzdChuLmJhc2VuYW1lKGUpKX07cGljb21hdGNoLmlzTWF0Y2g9KGUsdCxyKT0+cGljb21hdGNoKHQscikoZSk7cGljb21hdGNoLnBhcnNlPShlLHQpPT57aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gZS5tYXAoKGU9PnBpY29tYXRjaC5wYXJzZShlLHQpKSk7cmV0dXJuIHMoZSx7Li4udCxmYXN0cGF0aHM6ZmFsc2V9KX07cGljb21hdGNoLnNjYW49KGUsdCk9PnUoZSx0KTtwaWNvbWF0Y2guY29tcGlsZVJlPShlLHQscj1mYWxzZSxuPWZhbHNlKT0+e2lmKHI9PT10cnVlKXtyZXR1cm4gZS5vdXRwdXR9Y29uc3QgdT10fHx7fTtjb25zdCBzPXUuY29udGFpbnM/XCJcIjpcIl5cIjtjb25zdCBvPXUuY29udGFpbnM/XCJcIjpcIiRcIjtsZXQgaT1gJHtzfSg/OiR7ZS5vdXRwdXR9KSR7b31gO2lmKGUmJmUubmVnYXRlZD09PXRydWUpe2k9YF4oPyEke2l9KS4qJGB9Y29uc3QgYT1waWNvbWF0Y2gudG9SZWdleChpLHQpO2lmKG49PT10cnVlKXthLnN0YXRlPWV9cmV0dXJuIGF9O3BpY29tYXRjaC5tYWtlUmU9KGUsdCxyPWZhbHNlLG49ZmFsc2UpPT57aWYoIWV8fHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgbm9uLWVtcHR5IHN0cmluZ1wiKX1jb25zdCB1PXR8fHt9O2xldCBvPXtuZWdhdGVkOmZhbHNlLGZhc3RwYXRoczp0cnVlfTtsZXQgaT1cIlwiO2xldCBhO2lmKGUuc3RhcnRzV2l0aChcIi4vXCIpKXtlPWUuc2xpY2UoMik7aT1vLnByZWZpeD1cIi4vXCJ9aWYodS5mYXN0cGF0aHMhPT1mYWxzZSYmKGVbMF09PT1cIi5cInx8ZVswXT09PVwiKlwiKSl7YT1zLmZhc3RwYXRocyhlLHQpfWlmKGE9PT11bmRlZmluZWQpe289cyhlLHQpO28ucHJlZml4PWkrKG8ucHJlZml4fHxcIlwiKX1lbHNle28ub3V0cHV0PWF9cmV0dXJuIHBpY29tYXRjaC5jb21waWxlUmUobyx0LHIsbil9O3BpY29tYXRjaC50b1JlZ2V4PShlLHQpPT57dHJ5e2NvbnN0IHI9dHx8e307cmV0dXJuIG5ldyBSZWdFeHAoZSxyLmZsYWdzfHwoci5ub2Nhc2U/XCJpXCI6XCJcIikpfWNhdGNoKGUpe2lmKHQmJnQuZGVidWc9PT10cnVlKXRocm93IGU7cmV0dXJuLyReL319O3BpY29tYXRjaC5jb25zdGFudHM9aTtlLmV4cG9ydHM9cGljb21hdGNofSw3MDA6KGUsdCxyKT0+e2NvbnN0IG49cig1MTMpO2NvbnN0e0NIQVJfQVNURVJJU0s6dSxDSEFSX0FUOnMsQ0hBUl9CQUNLV0FSRF9TTEFTSDpvLENIQVJfQ09NTUE6aSxDSEFSX0RPVDphLENIQVJfRVhDTEFNQVRJT05fTUFSSzpsLENIQVJfRk9SV0FSRF9TTEFTSDpjLENIQVJfTEVGVF9DVVJMWV9CUkFDRTpwLENIQVJfTEVGVF9QQVJFTlRIRVNFUzpmLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDpBLENIQVJfUExVUzpSLENIQVJfUVVFU1RJT05fTUFSSzpfLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6aCxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOmcsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDpFfT1yKDM1Nik7Y29uc3QgaXNQYXRoU2VwYXJhdG9yPWU9PmU9PT1jfHxlPT09bztjb25zdCBkZXB0aD1lPT57aWYoZS5pc1ByZWZpeCE9PXRydWUpe2UuZGVwdGg9ZS5pc0dsb2JzdGFyP0luZmluaXR5OjF9fTtjb25zdCBzY2FuPShlLHQpPT57Y29uc3Qgcj10fHx7fTtjb25zdCBDPWUubGVuZ3RoLTE7Y29uc3QgeT1yLnBhcnRzPT09dHJ1ZXx8ci5zY2FuVG9FbmQ9PT10cnVlO2NvbnN0IGQ9W107Y29uc3QgeD1bXTtjb25zdCBiPVtdO2xldCBTPWU7bGV0IEg9LTE7bGV0IHY9MDtsZXQgJD0wO2xldCBtPWZhbHNlO2xldCBUPWZhbHNlO2xldCBMPWZhbHNlO2xldCBPPWZhbHNlO2xldCB3PWZhbHNlO2xldCBOPWZhbHNlO2xldCBrPWZhbHNlO2xldCBJPWZhbHNlO2xldCBNPWZhbHNlO2xldCBQPTA7bGV0IEI7bGV0IEc7bGV0IEQ9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2NvbnN0IGVvcz0oKT0+SD49Qztjb25zdCBwZWVrPSgpPT5TLmNoYXJDb2RlQXQoSCsxKTtjb25zdCBhZHZhbmNlPSgpPT57Qj1HO3JldHVybiBTLmNoYXJDb2RlQXQoKytIKX07d2hpbGUoSDxDKXtHPWFkdmFuY2UoKTtsZXQgZTtpZihHPT09byl7az1ELmJhY2tzbGFzaGVzPXRydWU7Rz1hZHZhbmNlKCk7aWYoRz09PXApe049dHJ1ZX1jb250aW51ZX1pZihOPT09dHJ1ZXx8Rz09PXApe1ArKzt3aGlsZShlb3MoKSE9PXRydWUmJihHPWFkdmFuY2UoKSkpe2lmKEc9PT1vKXtrPUQuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYoRz09PXApe1ArKztjb250aW51ZX1pZihOIT09dHJ1ZSYmRz09PWEmJihHPWFkdmFuY2UoKSk9PT1hKXttPUQuaXNCcmFjZT10cnVlO0w9RC5pc0dsb2I9dHJ1ZTtNPXRydWU7aWYoeT09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKE4hPT10cnVlJiZHPT09aSl7bT1ELmlzQnJhY2U9dHJ1ZTtMPUQuaXNHbG9iPXRydWU7TT10cnVlO2lmKHk9PT10cnVlKXtjb250aW51ZX1icmVha31pZihHPT09aCl7UC0tO2lmKFA9PT0wKXtOPWZhbHNlO209RC5pc0JyYWNlPXRydWU7TT10cnVlO2JyZWFrfX19aWYoeT09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKEc9PT1jKXtkLnB1c2goSCk7eC5wdXNoKEQpO0Q9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2lmKE09PT10cnVlKWNvbnRpbnVlO2lmKEI9PT1hJiZIPT09disxKXt2Kz0yO2NvbnRpbnVlfSQ9SCsxO2NvbnRpbnVlfWlmKHIubm9leHQhPT10cnVlKXtjb25zdCBlPUc9PT1SfHxHPT09c3x8Rz09PXV8fEc9PT1ffHxHPT09bDtpZihlPT09dHJ1ZSYmcGVlaygpPT09Zil7TD1ELmlzR2xvYj10cnVlO089RC5pc0V4dGdsb2I9dHJ1ZTtNPXRydWU7aWYoeT09PXRydWUpe3doaWxlKGVvcygpIT09dHJ1ZSYmKEc9YWR2YW5jZSgpKSl7aWYoRz09PW8pe2s9RC5iYWNrc2xhc2hlcz10cnVlO0c9YWR2YW5jZSgpO2NvbnRpbnVlfWlmKEc9PT1nKXtMPUQuaXNHbG9iPXRydWU7TT10cnVlO2JyZWFrfX1jb250aW51ZX1icmVha319aWYoRz09PXUpe2lmKEI9PT11KXc9RC5pc0dsb2JzdGFyPXRydWU7TD1ELmlzR2xvYj10cnVlO009dHJ1ZTtpZih5PT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoRz09PV8pe0w9RC5pc0dsb2I9dHJ1ZTtNPXRydWU7aWYoeT09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKEc9PT1BKXt3aGlsZShlb3MoKSE9PXRydWUmJihlPWFkdmFuY2UoKSkpe2lmKGU9PT1vKXtrPUQuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYoZT09PUUpe1Q9RC5pc0JyYWNrZXQ9dHJ1ZTtMPUQuaXNHbG9iPXRydWU7TT10cnVlO2JyZWFrfX1pZih5PT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoci5ub25lZ2F0ZSE9PXRydWUmJkc9PT1sJiZIPT09dil7ST1ELm5lZ2F0ZWQ9dHJ1ZTt2Kys7Y29udGludWV9aWYoci5ub3BhcmVuIT09dHJ1ZSYmRz09PWYpe0w9RC5pc0dsb2I9dHJ1ZTtpZih5PT09dHJ1ZSl7d2hpbGUoZW9zKCkhPT10cnVlJiYoRz1hZHZhbmNlKCkpKXtpZihHPT09Zil7az1ELmJhY2tzbGFzaGVzPXRydWU7Rz1hZHZhbmNlKCk7Y29udGludWV9aWYoRz09PWcpe009dHJ1ZTticmVha319Y29udGludWV9YnJlYWt9aWYoTD09PXRydWUpe009dHJ1ZTtpZih5PT09dHJ1ZSl7Y29udGludWV9YnJlYWt9fWlmKHIubm9leHQ9PT10cnVlKXtPPWZhbHNlO0w9ZmFsc2V9bGV0IFU9UztsZXQgSz1cIlwiO2xldCBGPVwiXCI7aWYodj4wKXtLPVMuc2xpY2UoMCx2KTtTPVMuc2xpY2Uodik7JC09dn1pZihVJiZMPT09dHJ1ZSYmJD4wKXtVPVMuc2xpY2UoMCwkKTtGPVMuc2xpY2UoJCl9ZWxzZSBpZihMPT09dHJ1ZSl7VT1cIlwiO0Y9U31lbHNle1U9U31pZihVJiZVIT09XCJcIiYmVSE9PVwiL1wiJiZVIT09Uyl7aWYoaXNQYXRoU2VwYXJhdG9yKFUuY2hhckNvZGVBdChVLmxlbmd0aC0xKSkpe1U9VS5zbGljZSgwLC0xKX19aWYoci51bmVzY2FwZT09PXRydWUpe2lmKEYpRj1uLnJlbW92ZUJhY2tzbGFzaGVzKEYpO2lmKFUmJms9PT10cnVlKXtVPW4ucmVtb3ZlQmFja3NsYXNoZXMoVSl9fWNvbnN0IFE9e3ByZWZpeDpLLGlucHV0OmUsc3RhcnQ6dixiYXNlOlUsZ2xvYjpGLGlzQnJhY2U6bSxpc0JyYWNrZXQ6VCxpc0dsb2I6TCxpc0V4dGdsb2I6Tyxpc0dsb2JzdGFyOncsbmVnYXRlZDpJfTtpZihyLnRva2Vucz09PXRydWUpe1EubWF4RGVwdGg9MDtpZighaXNQYXRoU2VwYXJhdG9yKEcpKXt4LnB1c2goRCl9US50b2tlbnM9eH1pZihyLnBhcnRzPT09dHJ1ZXx8ci50b2tlbnM9PT10cnVlKXtsZXQgdDtmb3IobGV0IG49MDtuPGQubGVuZ3RoO24rKyl7Y29uc3QgdT10P3QrMTp2O2NvbnN0IHM9ZFtuXTtjb25zdCBvPWUuc2xpY2UodSxzKTtpZihyLnRva2Vucyl7aWYobj09PTAmJnYhPT0wKXt4W25dLmlzUHJlZml4PXRydWU7eFtuXS52YWx1ZT1LfWVsc2V7eFtuXS52YWx1ZT1vfWRlcHRoKHhbbl0pO1EubWF4RGVwdGgrPXhbbl0uZGVwdGh9aWYobiE9PTB8fG8hPT1cIlwiKXtiLnB1c2gobyl9dD1zfWlmKHQmJnQrMTxlLmxlbmd0aCl7Y29uc3Qgbj1lLnNsaWNlKHQrMSk7Yi5wdXNoKG4pO2lmKHIudG9rZW5zKXt4W3gubGVuZ3RoLTFdLnZhbHVlPW47ZGVwdGgoeFt4Lmxlbmd0aC0xXSk7US5tYXhEZXB0aCs9eFt4Lmxlbmd0aC0xXS5kZXB0aH19US5zbGFzaGVzPWQ7US5wYXJ0cz1ifXJldHVybiBRfTtlLmV4cG9ydHM9c2Nhbn0sNTEzOihlLHQscik9Pntjb25zdCBuPXIoMTcpO2NvbnN0IHU9cHJvY2Vzcy5wbGF0Zm9ybT09PVwid2luMzJcIjtjb25zdHtSRUdFWF9CQUNLU0xBU0g6cyxSRUdFWF9SRU1PVkVfQkFDS1NMQVNIOm8sUkVHRVhfU1BFQ0lBTF9DSEFSUzppLFJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMOmF9PXIoMzU2KTt0LmlzT2JqZWN0PWU9PmUhPT1udWxsJiZ0eXBlb2YgZT09PVwib2JqZWN0XCImJiFBcnJheS5pc0FycmF5KGUpO3QuaGFzUmVnZXhDaGFycz1lPT5pLnRlc3QoZSk7dC5pc1JlZ2V4Q2hhcj1lPT5lLmxlbmd0aD09PTEmJnQuaGFzUmVnZXhDaGFycyhlKTt0LmVzY2FwZVJlZ2V4PWU9PmUucmVwbGFjZShhLFwiXFxcXCQxXCIpO3QudG9Qb3NpeFNsYXNoZXM9ZT0+ZS5yZXBsYWNlKHMsXCIvXCIpO3QucmVtb3ZlQmFja3NsYXNoZXM9ZT0+ZS5yZXBsYWNlKG8sKGU9PmU9PT1cIlxcXFxcIj9cIlwiOmUpKTt0LnN1cHBvcnRzTG9va2JlaGluZHM9KCk9Pntjb25zdCBlPXByb2Nlc3MudmVyc2lvbi5zbGljZSgxKS5zcGxpdChcIi5cIikubWFwKE51bWJlcik7aWYoZS5sZW5ndGg9PT0zJiZlWzBdPj05fHxlWzBdPT09OCYmZVsxXT49MTApe3JldHVybiB0cnVlfXJldHVybiBmYWxzZX07dC5pc1dpbmRvd3M9ZT0+e2lmKGUmJnR5cGVvZiBlLndpbmRvd3M9PT1cImJvb2xlYW5cIil7cmV0dXJuIGUud2luZG93c31yZXR1cm4gdT09PXRydWV8fG4uc2VwPT09XCJcXFxcXCJ9O3QuZXNjYXBlTGFzdD0oZSxyLG4pPT57Y29uc3QgdT1lLmxhc3RJbmRleE9mKHIsbik7aWYodT09PS0xKXJldHVybiBlO2lmKGVbdS0xXT09PVwiXFxcXFwiKXJldHVybiB0LmVzY2FwZUxhc3QoZSxyLHUtMSk7cmV0dXJuYCR7ZS5zbGljZSgwLHUpfVxcXFwke2Uuc2xpY2UodSl9YH07dC5yZW1vdmVQcmVmaXg9KGUsdD17fSk9PntsZXQgcj1lO2lmKHIuc3RhcnRzV2l0aChcIi4vXCIpKXtyPXIuc2xpY2UoMik7dC5wcmVmaXg9XCIuL1wifXJldHVybiByfTt0LndyYXBPdXRwdXQ9KGUsdD17fSxyPXt9KT0+e2NvbnN0IG49ci5jb250YWlucz9cIlwiOlwiXlwiO2NvbnN0IHU9ci5jb250YWlucz9cIlwiOlwiJFwiO2xldCBzPWAke259KD86JHtlfSkke3V9YDtpZih0Lm5lZ2F0ZWQ9PT10cnVlKXtzPWAoPzpeKD8hJHtzfSkuKiQpYH1yZXR1cm4gc319LDQ5MjooZSx0LHIpPT57XG4vKiFcbiAqIHRvLXJlZ2V4LXJhbmdlIDxodHRwczovL2dpdGh1Yi5jb20vbWljcm9tYXRjaC90by1yZWdleC1yYW5nZT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmNvbnN0IG49cigzNTcpO2NvbnN0IHRvUmVnZXhSYW5nZT0oZSx0LHIpPT57aWYobihlKT09PWZhbHNlKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwidG9SZWdleFJhbmdlOiBleHBlY3RlZCB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYSBudW1iZXJcIil9aWYodD09PXZvaWQgMHx8ZT09PXQpe3JldHVybiBTdHJpbmcoZSl9aWYobih0KT09PWZhbHNlKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwidG9SZWdleFJhbmdlOiBleHBlY3RlZCB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgbnVtYmVyLlwiKX1sZXQgdT17cmVsYXhaZXJvczp0cnVlLC4uLnJ9O2lmKHR5cGVvZiB1LnN0cmljdFplcm9zPT09XCJib29sZWFuXCIpe3UucmVsYXhaZXJvcz11LnN0cmljdFplcm9zPT09ZmFsc2V9bGV0IHM9U3RyaW5nKHUucmVsYXhaZXJvcyk7bGV0IG89U3RyaW5nKHUuc2hvcnRoYW5kKTtsZXQgaT1TdHJpbmcodS5jYXB0dXJlKTtsZXQgYT1TdHJpbmcodS53cmFwKTtsZXQgbD1lK1wiOlwiK3QrXCI9XCIrcytvK2krYTtpZih0b1JlZ2V4UmFuZ2UuY2FjaGUuaGFzT3duUHJvcGVydHkobCkpe3JldHVybiB0b1JlZ2V4UmFuZ2UuY2FjaGVbbF0ucmVzdWx0fWxldCBjPU1hdGgubWluKGUsdCk7bGV0IHA9TWF0aC5tYXgoZSx0KTtpZihNYXRoLmFicyhjLXApPT09MSl7bGV0IHI9ZStcInxcIit0O2lmKHUuY2FwdHVyZSl7cmV0dXJuYCgke3J9KWB9aWYodS53cmFwPT09ZmFsc2Upe3JldHVybiByfXJldHVybmAoPzoke3J9KWB9bGV0IGY9aGFzUGFkZGluZyhlKXx8aGFzUGFkZGluZyh0KTtsZXQgQT17bWluOmUsbWF4OnQsYTpjLGI6cH07bGV0IFI9W107bGV0IF89W107aWYoZil7QS5pc1BhZGRlZD1mO0EubWF4TGVuPVN0cmluZyhBLm1heCkubGVuZ3RofWlmKGM8MCl7bGV0IGU9cDwwP01hdGguYWJzKHApOjE7Xz1zcGxpdFRvUGF0dGVybnMoZSxNYXRoLmFicyhjKSxBLHUpO2M9QS5hPTB9aWYocD49MCl7Uj1zcGxpdFRvUGF0dGVybnMoYyxwLEEsdSl9QS5uZWdhdGl2ZXM9XztBLnBvc2l0aXZlcz1SO0EucmVzdWx0PWNvbGxhdGVQYXR0ZXJucyhfLFIsdSk7aWYodS5jYXB0dXJlPT09dHJ1ZSl7QS5yZXN1bHQ9YCgke0EucmVzdWx0fSlgfWVsc2UgaWYodS53cmFwIT09ZmFsc2UmJlIubGVuZ3RoK18ubGVuZ3RoPjEpe0EucmVzdWx0PWAoPzoke0EucmVzdWx0fSlgfXRvUmVnZXhSYW5nZS5jYWNoZVtsXT1BO3JldHVybiBBLnJlc3VsdH07ZnVuY3Rpb24gY29sbGF0ZVBhdHRlcm5zKGUsdCxyKXtsZXQgbj1maWx0ZXJQYXR0ZXJucyhlLHQsXCItXCIsZmFsc2Uscil8fFtdO2xldCB1PWZpbHRlclBhdHRlcm5zKHQsZSxcIlwiLGZhbHNlLHIpfHxbXTtsZXQgcz1maWx0ZXJQYXR0ZXJucyhlLHQsXCItP1wiLHRydWUscil8fFtdO2xldCBvPW4uY29uY2F0KHMpLmNvbmNhdCh1KTtyZXR1cm4gby5qb2luKFwifFwiKX1mdW5jdGlvbiBzcGxpdFRvUmFuZ2VzKGUsdCl7bGV0IHI9MTtsZXQgbj0xO2xldCB1PWNvdW50TmluZXMoZSxyKTtsZXQgcz1uZXcgU2V0KFt0XSk7d2hpbGUoZTw9dSYmdTw9dCl7cy5hZGQodSk7cis9MTt1PWNvdW50TmluZXMoZSxyKX11PWNvdW50WmVyb3ModCsxLG4pLTE7d2hpbGUoZTx1JiZ1PD10KXtzLmFkZCh1KTtuKz0xO3U9Y291bnRaZXJvcyh0KzEsbiktMX1zPVsuLi5zXTtzLnNvcnQoY29tcGFyZSk7cmV0dXJuIHN9ZnVuY3Rpb24gcmFuZ2VUb1BhdHRlcm4oZSx0LHIpe2lmKGU9PT10KXtyZXR1cm57cGF0dGVybjplLGNvdW50OltdLGRpZ2l0czowfX1sZXQgbj16aXAoZSx0KTtsZXQgdT1uLmxlbmd0aDtsZXQgcz1cIlwiO2xldCBvPTA7Zm9yKGxldCBlPTA7ZTx1O2UrKyl7bGV0W3QsdV09bltlXTtpZih0PT09dSl7cys9dH1lbHNlIGlmKHQhPT1cIjBcInx8dSE9PVwiOVwiKXtzKz10b0NoYXJhY3RlckNsYXNzKHQsdSxyKX1lbHNle28rK319aWYobyl7cys9ci5zaG9ydGhhbmQ9PT10cnVlP1wiXFxcXGRcIjpcIlswLTldXCJ9cmV0dXJue3BhdHRlcm46cyxjb3VudDpbb10sZGlnaXRzOnV9fWZ1bmN0aW9uIHNwbGl0VG9QYXR0ZXJucyhlLHQscixuKXtsZXQgdT1zcGxpdFRvUmFuZ2VzKGUsdCk7bGV0IHM9W107bGV0IG89ZTtsZXQgaTtmb3IobGV0IGU9MDtlPHUubGVuZ3RoO2UrKyl7bGV0IHQ9dVtlXTtsZXQgYT1yYW5nZVRvUGF0dGVybihTdHJpbmcobyksU3RyaW5nKHQpLG4pO2xldCBsPVwiXCI7aWYoIXIuaXNQYWRkZWQmJmkmJmkucGF0dGVybj09PWEucGF0dGVybil7aWYoaS5jb3VudC5sZW5ndGg+MSl7aS5jb3VudC5wb3AoKX1pLmNvdW50LnB1c2goYS5jb3VudFswXSk7aS5zdHJpbmc9aS5wYXR0ZXJuK3RvUXVhbnRpZmllcihpLmNvdW50KTtvPXQrMTtjb250aW51ZX1pZihyLmlzUGFkZGVkKXtsPXBhZFplcm9zKHQscixuKX1hLnN0cmluZz1sK2EucGF0dGVybit0b1F1YW50aWZpZXIoYS5jb3VudCk7cy5wdXNoKGEpO289dCsxO2k9YX1yZXR1cm4gc31mdW5jdGlvbiBmaWx0ZXJQYXR0ZXJucyhlLHQscixuLHUpe2xldCBzPVtdO2ZvcihsZXQgdSBvZiBlKXtsZXR7c3RyaW5nOmV9PXU7aWYoIW4mJiFjb250YWlucyh0LFwic3RyaW5nXCIsZSkpe3MucHVzaChyK2UpfWlmKG4mJmNvbnRhaW5zKHQsXCJzdHJpbmdcIixlKSl7cy5wdXNoKHIrZSl9fXJldHVybiBzfWZ1bmN0aW9uIHppcChlLHQpe2xldCByPVtdO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXIucHVzaChbZVtuXSx0W25dXSk7cmV0dXJuIHJ9ZnVuY3Rpb24gY29tcGFyZShlLHQpe3JldHVybiBlPnQ/MTp0PmU/LTE6MH1mdW5jdGlvbiBjb250YWlucyhlLHQscil7cmV0dXJuIGUuc29tZSgoZT0+ZVt0XT09PXIpKX1mdW5jdGlvbiBjb3VudE5pbmVzKGUsdCl7cmV0dXJuIE51bWJlcihTdHJpbmcoZSkuc2xpY2UoMCwtdCkrXCI5XCIucmVwZWF0KHQpKX1mdW5jdGlvbiBjb3VudFplcm9zKGUsdCl7cmV0dXJuIGUtZSVNYXRoLnBvdygxMCx0KX1mdW5jdGlvbiB0b1F1YW50aWZpZXIoZSl7bGV0W3Q9MCxyPVwiXCJdPWU7aWYocnx8dD4xKXtyZXR1cm5geyR7dCsocj9cIixcIityOlwiXCIpfX1gfXJldHVyblwiXCJ9ZnVuY3Rpb24gdG9DaGFyYWN0ZXJDbGFzcyhlLHQscil7cmV0dXJuYFske2V9JHt0LWU9PT0xP1wiXCI6XCItXCJ9JHt0fV1gfWZ1bmN0aW9uIGhhc1BhZGRpbmcoZSl7cmV0dXJuL14tPygwKylcXGQvLnRlc3QoZSl9ZnVuY3Rpb24gcGFkWmVyb3MoZSx0LHIpe2lmKCF0LmlzUGFkZGVkKXtyZXR1cm4gZX1sZXQgbj1NYXRoLmFicyh0Lm1heExlbi1TdHJpbmcoZSkubGVuZ3RoKTtsZXQgdT1yLnJlbGF4WmVyb3MhPT1mYWxzZTtzd2l0Y2gobil7Y2FzZSAwOnJldHVyblwiXCI7Y2FzZSAxOnJldHVybiB1P1wiMD9cIjpcIjBcIjtjYXNlIDI6cmV0dXJuIHU/XCIwezAsMn1cIjpcIjAwXCI7ZGVmYXVsdDp7cmV0dXJuIHU/YDB7MCwke259fWA6YDB7JHtufX1gfX19dG9SZWdleFJhbmdlLmNhY2hlPXt9O3RvUmVnZXhSYW5nZS5jbGVhckNhY2hlPSgpPT50b1JlZ2V4UmFuZ2UuY2FjaGU9e307ZS5leHBvcnRzPXRvUmVnZXhSYW5nZX0sMTc6ZT0+e2UuZXhwb3J0cz1yZXF1aXJlKFwicGF0aFwiKX0sODM3OmU9PntlLmV4cG9ydHM9cmVxdWlyZShcInV0aWxcIil9fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgdT10W3JdPXtleHBvcnRzOnt9fTt2YXIgcz10cnVlO3RyeXtlW3JdKHUsdS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO3M9ZmFsc2V9ZmluYWxseXtpZihzKWRlbGV0ZSB0W3JdfXJldHVybiB1LmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oOTcxKTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/micromatch/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/path-browserify/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/path-browserify/index.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){\"use strict\";var e={114:function(e){function assertPath(e){if(typeof e!==\"string\"){throw new TypeError(\"Path must be a string. Received \"+JSON.stringify(e))}}function normalizeStringPosix(e,r){var t=\"\";var i=0;var n=-1;var a=0;var f;for(var l=0;l<=e.length;++l){if(l<e.length)f=e.charCodeAt(l);else if(f===47)break;else f=47;if(f===47){if(n===l-1||a===1){}else if(n!==l-1&&a===2){if(t.length<2||i!==2||t.charCodeAt(t.length-1)!==46||t.charCodeAt(t.length-2)!==46){if(t.length>2){var s=t.lastIndexOf(\"/\");if(s!==t.length-1){if(s===-1){t=\"\";i=0}else{t=t.slice(0,s);i=t.length-1-t.lastIndexOf(\"/\")}n=l;a=0;continue}}else if(t.length===2||t.length===1){t=\"\";i=0;n=l;a=0;continue}}if(r){if(t.length>0)t+=\"/..\";else t=\"..\";i=2}}else{if(t.length>0)t+=\"/\"+e.slice(n+1,l);else t=e.slice(n+1,l);i=l-n-1}n=l;a=0}else if(f===46&&a!==-1){++a}else{a=-1}}return t}function _format(e,r){var t=r.dir||r.root;var i=r.base||(r.name||\"\")+(r.ext||\"\");if(!t){return i}if(t===r.root){return t+i}return t+e+i}var r={resolve:function resolve(){var e=\"\";var r=false;var t;for(var i=arguments.length-1;i>=-1&&!r;i--){var n;if(i>=0)n=arguments[i];else{if(t===undefined)t=\"\";n=t}assertPath(n);if(n.length===0){continue}e=n+\"/\"+e;r=n.charCodeAt(0)===47}e=normalizeStringPosix(e,!r);if(r){if(e.length>0)return\"/\"+e;else return\"/\"}else if(e.length>0){return e}else{return\".\"}},normalize:function normalize(e){assertPath(e);if(e.length===0)return\".\";var r=e.charCodeAt(0)===47;var t=e.charCodeAt(e.length-1)===47;e=normalizeStringPosix(e,!r);if(e.length===0&&!r)e=\".\";if(e.length>0&&t)e+=\"/\";if(r)return\"/\"+e;return e},isAbsolute:function isAbsolute(e){assertPath(e);return e.length>0&&e.charCodeAt(0)===47},join:function join(){if(arguments.length===0)return\".\";var e;for(var t=0;t<arguments.length;++t){var i=arguments[t];assertPath(i);if(i.length>0){if(e===undefined)e=i;else e+=\"/\"+i}}if(e===undefined)return\".\";return r.normalize(e)},relative:function relative(e,t){assertPath(e);assertPath(t);if(e===t)return\"\";e=r.resolve(e);t=r.resolve(t);if(e===t)return\"\";var i=1;for(;i<e.length;++i){if(e.charCodeAt(i)!==47)break}var n=e.length;var a=n-i;var f=1;for(;f<t.length;++f){if(t.charCodeAt(f)!==47)break}var l=t.length;var s=l-f;var o=a<s?a:s;var u=-1;var h=0;for(;h<=o;++h){if(h===o){if(s>o){if(t.charCodeAt(f+h)===47){return t.slice(f+h+1)}else if(h===0){return t.slice(f+h)}}else if(a>o){if(e.charCodeAt(i+h)===47){u=h}else if(h===0){u=0}}break}var c=e.charCodeAt(i+h);var v=t.charCodeAt(f+h);if(c!==v)break;else if(c===47)u=h}var g=\"\";for(h=i+u+1;h<=n;++h){if(h===n||e.charCodeAt(h)===47){if(g.length===0)g+=\"..\";else g+=\"/..\"}}if(g.length>0)return g+t.slice(f+u);else{f+=u;if(t.charCodeAt(f)===47)++f;return t.slice(f)}},_makeLong:function _makeLong(e){return e},dirname:function dirname(e){assertPath(e);if(e.length===0)return\".\";var r=e.charCodeAt(0);var t=r===47;var i=-1;var n=true;for(var a=e.length-1;a>=1;--a){r=e.charCodeAt(a);if(r===47){if(!n){i=a;break}}else{n=false}}if(i===-1)return t?\"/\":\".\";if(t&&i===1)return\"//\";return e.slice(0,i)},basename:function basename(e,r){if(r!==undefined&&typeof r!==\"string\")throw new TypeError('\"ext\" argument must be a string');assertPath(e);var t=0;var i=-1;var n=true;var a;if(r!==undefined&&r.length>0&&r.length<=e.length){if(r.length===e.length&&r===e)return\"\";var f=r.length-1;var l=-1;for(a=e.length-1;a>=0;--a){var s=e.charCodeAt(a);if(s===47){if(!n){t=a+1;break}}else{if(l===-1){n=false;l=a+1}if(f>=0){if(s===r.charCodeAt(f)){if(--f===-1){i=a}}else{f=-1;i=l}}}}if(t===i)i=l;else if(i===-1)i=e.length;return e.slice(t,i)}else{for(a=e.length-1;a>=0;--a){if(e.charCodeAt(a)===47){if(!n){t=a+1;break}}else if(i===-1){n=false;i=a+1}}if(i===-1)return\"\";return e.slice(t,i)}},extname:function extname(e){assertPath(e);var r=-1;var t=0;var i=-1;var n=true;var a=0;for(var f=e.length-1;f>=0;--f){var l=e.charCodeAt(f);if(l===47){if(!n){t=f+1;break}continue}if(i===-1){n=false;i=f+1}if(l===46){if(r===-1)r=f;else if(a!==1)a=1}else if(r!==-1){a=-1}}if(r===-1||i===-1||a===0||a===1&&r===i-1&&r===t+1){return\"\"}return e.slice(r,i)},format:function format(e){if(e===null||typeof e!==\"object\"){throw new TypeError('The \"pathObject\" argument must be of type Object. Received type '+typeof e)}return _format(\"/\",e)},parse:function parse(e){assertPath(e);var r={root:\"\",dir:\"\",base:\"\",ext:\"\",name:\"\"};if(e.length===0)return r;var t=e.charCodeAt(0);var i=t===47;var n;if(i){r.root=\"/\";n=1}else{n=0}var a=-1;var f=0;var l=-1;var s=true;var o=e.length-1;var u=0;for(;o>=n;--o){t=e.charCodeAt(o);if(t===47){if(!s){f=o+1;break}continue}if(l===-1){s=false;l=o+1}if(t===46){if(a===-1)a=o;else if(u!==1)u=1}else if(a!==-1){u=-1}}if(a===-1||l===-1||u===0||u===1&&a===l-1&&a===f+1){if(l!==-1){if(f===0&&i)r.base=r.name=e.slice(1,l);else r.base=r.name=e.slice(f,l)}}else{if(f===0&&i){r.name=e.slice(1,a);r.base=e.slice(1,l)}else{r.name=e.slice(f,a);r.base=e.slice(f,l)}r.ext=e.slice(a,l)}if(f>0)r.dir=e.slice(0,f-1);else if(i)r.dir=\"/\";return r},sep:\"/\",delimiter:\":\",win32:null,posix:null};r.posix=r;e.exports=r}};var r={};function __nccwpck_require__(t){var i=r[t];if(i!==undefined){return i.exports}var n=r[t]={exports:{}};var a=true;try{e[t](n,n.exports,__nccwpck_require__);a=false}finally{if(a)delete r[t]}return n.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(114);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsWUFBWSxhQUFhLE9BQU8sZ0JBQWdCLHVCQUF1Qix3QkFBd0IsMkVBQTJFLG1DQUFtQyxTQUFTLFFBQVEsU0FBUyxRQUFRLE1BQU0sWUFBWSxZQUFZLEtBQUssZ0NBQWdDLHFCQUFxQixVQUFVLFdBQVcsb0JBQW9CLHdCQUF3QixvRkFBb0YsZUFBZSx5QkFBeUIsbUJBQW1CLFdBQVcsS0FBSyxJQUFJLEtBQUssZUFBZSxnQ0FBZ0MsSUFBSSxJQUFJLFVBQVUsb0NBQW9DLEtBQUssSUFBSSxJQUFJLElBQUksVUFBVSxNQUFNLHVCQUF1QixZQUFZLEtBQUssS0FBSyxvQ0FBb0Msc0JBQXNCLFFBQVEsSUFBSSxJQUFJLHdCQUF3QixJQUFJLEtBQUssTUFBTSxTQUFTLHNCQUFzQixvQkFBb0IsdUNBQXVDLE9BQU8sU0FBUyxlQUFlLFdBQVcsYUFBYSxPQUFPLDJCQUEyQixTQUFTLFlBQVksTUFBTSw2QkFBNkIsVUFBVSxLQUFLLE1BQU0sdUJBQXVCLEtBQUssc0JBQXNCLElBQUksY0FBYyxpQkFBaUIsU0FBUyxVQUFVLHVCQUF1Qiw2QkFBNkIsTUFBTSwwQkFBMEIsZUFBZSxvQkFBb0IsU0FBUyxLQUFLLFdBQVcsaUNBQWlDLGNBQWMsMEJBQTBCLDJCQUEyQixvQ0FBb0MsNkJBQTZCLDBCQUEwQix3QkFBd0IsaUJBQWlCLFNBQVMsbUNBQW1DLGNBQWMsd0NBQXdDLHNCQUFzQixrQ0FBa0MsTUFBTSxZQUFZLG1CQUFtQixLQUFLLG1CQUFtQixjQUFjLGVBQWUscUJBQXFCLGVBQWUsMkJBQTJCLHNCQUFzQixpQ0FBaUMsY0FBYyxjQUFjLGtCQUFrQixlQUFlLGVBQWUsa0JBQWtCLFFBQVEsS0FBSyxXQUFXLEtBQUssOEJBQThCLGVBQWUsVUFBVSxRQUFRLEtBQUssV0FBVyxLQUFLLDhCQUE4QixlQUFlLFVBQVUsY0FBYyxTQUFTLFFBQVEsS0FBSyxLQUFLLEtBQUssVUFBVSxRQUFRLDJCQUEyQixzQkFBc0IsZUFBZSxxQkFBcUIsYUFBYSwyQkFBMkIsSUFBSSxlQUFlLEtBQUssTUFBTSx3QkFBd0Isd0JBQXdCLGVBQWUsbUJBQW1CLFNBQVMsWUFBWSxLQUFLLEtBQUssZ0NBQWdDLHdCQUF3QixlQUFlLG9DQUFvQyxLQUFLLEtBQUssNEJBQTRCLG1CQUFtQixpQ0FBaUMsU0FBUyw2QkFBNkIsY0FBYywwQkFBMEIsc0JBQXNCLGFBQWEsU0FBUyxXQUFXLHFCQUFxQixLQUFLLEtBQUssa0JBQWtCLFdBQVcsT0FBTyxJQUFJLE9BQU8sS0FBSyxTQUFTLDJCQUEyQix1QkFBdUIsb0JBQW9CLGlDQUFpQyw2RkFBNkYsY0FBYyxRQUFRLFNBQVMsV0FBVyxNQUFNLGtEQUFrRCx1Q0FBdUMsaUJBQWlCLFNBQVMsaUJBQWlCLEtBQUssS0FBSyxzQkFBc0IsV0FBVyxPQUFPLE1BQU0sT0FBTyxLQUFLLFdBQVcsUUFBUSxNQUFNLFNBQVMsd0JBQXdCLGFBQWEsS0FBSyxLQUFLLEtBQUssT0FBTyxhQUFhLDBCQUEwQixvQkFBb0IsS0FBSyxpQkFBaUIsS0FBSyxLQUFLLHlCQUF5QixPQUFPLE1BQU0sT0FBTyxnQkFBZ0IsUUFBUSxPQUFPLG1CQUFtQixxQkFBcUIsNkJBQTZCLGNBQWMsU0FBUyxRQUFRLFNBQVMsV0FBVyxRQUFRLHFCQUFxQixLQUFLLEtBQUssc0JBQXNCLFdBQVcsT0FBTyxNQUFNLE1BQU0sU0FBUyxXQUFXLFFBQVEsTUFBTSxXQUFXLGNBQWMsa0JBQWtCLGdCQUFnQixNQUFNLG1EQUFtRCxTQUFTLG9CQUFvQiwyQkFBMkIsa0NBQWtDLGlHQUFpRyxzQkFBc0IseUJBQXlCLGNBQWMsT0FBTyx1Q0FBdUMseUJBQXlCLHNCQUFzQixhQUFhLE1BQU0sTUFBTSxXQUFXLElBQUksS0FBSyxJQUFJLFNBQVMsUUFBUSxTQUFTLFdBQVcsaUJBQWlCLFFBQVEsS0FBSyxLQUFLLEtBQUssa0JBQWtCLFdBQVcsT0FBTyxNQUFNLE1BQU0sU0FBUyxXQUFXLFFBQVEsTUFBTSxXQUFXLGNBQWMsa0JBQWtCLGdCQUFnQixNQUFNLG1EQUFtRCxXQUFXLHVDQUF1QyxpQ0FBaUMsS0FBSyxhQUFhLG9CQUFvQixvQkFBb0IsS0FBSyxvQkFBb0Isb0JBQW9CLG1CQUFtQiw0QkFBNEIsb0JBQW9CLFNBQVMsOENBQThDLFVBQVUsY0FBYyxTQUFTLGdDQUFnQyxXQUFXLGtCQUFrQixpQkFBaUIsWUFBWSxZQUFZLFdBQVcsSUFBSSxzQ0FBc0MsUUFBUSxRQUFRLGlCQUFpQixpQkFBaUIsbUVBQW1FLFNBQVMsS0FBSywrQkFBK0IsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzPzNjZDEiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9ezExNDpmdW5jdGlvbihlKXtmdW5jdGlvbiBhc3NlcnRQYXRoKGUpe2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhdGggbXVzdCBiZSBhIHN0cmluZy4gUmVjZWl2ZWQgXCIrSlNPTi5zdHJpbmdpZnkoZSkpfX1mdW5jdGlvbiBub3JtYWxpemVTdHJpbmdQb3NpeChlLHIpe3ZhciB0PVwiXCI7dmFyIGk9MDt2YXIgbj0tMTt2YXIgYT0wO3ZhciBmO2Zvcih2YXIgbD0wO2w8PWUubGVuZ3RoOysrbCl7aWYobDxlLmxlbmd0aClmPWUuY2hhckNvZGVBdChsKTtlbHNlIGlmKGY9PT00NylicmVhaztlbHNlIGY9NDc7aWYoZj09PTQ3KXtpZihuPT09bC0xfHxhPT09MSl7fWVsc2UgaWYobiE9PWwtMSYmYT09PTIpe2lmKHQubGVuZ3RoPDJ8fGkhPT0yfHx0LmNoYXJDb2RlQXQodC5sZW5ndGgtMSkhPT00Nnx8dC5jaGFyQ29kZUF0KHQubGVuZ3RoLTIpIT09NDYpe2lmKHQubGVuZ3RoPjIpe3ZhciBzPXQubGFzdEluZGV4T2YoXCIvXCIpO2lmKHMhPT10Lmxlbmd0aC0xKXtpZihzPT09LTEpe3Q9XCJcIjtpPTB9ZWxzZXt0PXQuc2xpY2UoMCxzKTtpPXQubGVuZ3RoLTEtdC5sYXN0SW5kZXhPZihcIi9cIil9bj1sO2E9MDtjb250aW51ZX19ZWxzZSBpZih0Lmxlbmd0aD09PTJ8fHQubGVuZ3RoPT09MSl7dD1cIlwiO2k9MDtuPWw7YT0wO2NvbnRpbnVlfX1pZihyKXtpZih0Lmxlbmd0aD4wKXQrPVwiLy4uXCI7ZWxzZSB0PVwiLi5cIjtpPTJ9fWVsc2V7aWYodC5sZW5ndGg+MCl0Kz1cIi9cIitlLnNsaWNlKG4rMSxsKTtlbHNlIHQ9ZS5zbGljZShuKzEsbCk7aT1sLW4tMX1uPWw7YT0wfWVsc2UgaWYoZj09PTQ2JiZhIT09LTEpeysrYX1lbHNle2E9LTF9fXJldHVybiB0fWZ1bmN0aW9uIF9mb3JtYXQoZSxyKXt2YXIgdD1yLmRpcnx8ci5yb290O3ZhciBpPXIuYmFzZXx8KHIubmFtZXx8XCJcIikrKHIuZXh0fHxcIlwiKTtpZighdCl7cmV0dXJuIGl9aWYodD09PXIucm9vdCl7cmV0dXJuIHQraX1yZXR1cm4gdCtlK2l9dmFyIHI9e3Jlc29sdmU6ZnVuY3Rpb24gcmVzb2x2ZSgpe3ZhciBlPVwiXCI7dmFyIHI9ZmFsc2U7dmFyIHQ7Zm9yKHZhciBpPWFyZ3VtZW50cy5sZW5ndGgtMTtpPj0tMSYmIXI7aS0tKXt2YXIgbjtpZihpPj0wKW49YXJndW1lbnRzW2ldO2Vsc2V7aWYodD09PXVuZGVmaW5lZCl0PVwiXCI7bj10fWFzc2VydFBhdGgobik7aWYobi5sZW5ndGg9PT0wKXtjb250aW51ZX1lPW4rXCIvXCIrZTtyPW4uY2hhckNvZGVBdCgwKT09PTQ3fWU9bm9ybWFsaXplU3RyaW5nUG9zaXgoZSwhcik7aWYocil7aWYoZS5sZW5ndGg+MClyZXR1cm5cIi9cIitlO2Vsc2UgcmV0dXJuXCIvXCJ9ZWxzZSBpZihlLmxlbmd0aD4wKXtyZXR1cm4gZX1lbHNle3JldHVyblwiLlwifX0sbm9ybWFsaXplOmZ1bmN0aW9uIG5vcm1hbGl6ZShlKXthc3NlcnRQYXRoKGUpO2lmKGUubGVuZ3RoPT09MClyZXR1cm5cIi5cIjt2YXIgcj1lLmNoYXJDb2RlQXQoMCk9PT00Nzt2YXIgdD1lLmNoYXJDb2RlQXQoZS5sZW5ndGgtMSk9PT00NztlPW5vcm1hbGl6ZVN0cmluZ1Bvc2l4KGUsIXIpO2lmKGUubGVuZ3RoPT09MCYmIXIpZT1cIi5cIjtpZihlLmxlbmd0aD4wJiZ0KWUrPVwiL1wiO2lmKHIpcmV0dXJuXCIvXCIrZTtyZXR1cm4gZX0saXNBYnNvbHV0ZTpmdW5jdGlvbiBpc0Fic29sdXRlKGUpe2Fzc2VydFBhdGgoZSk7cmV0dXJuIGUubGVuZ3RoPjAmJmUuY2hhckNvZGVBdCgwKT09PTQ3fSxqb2luOmZ1bmN0aW9uIGpvaW4oKXtpZihhcmd1bWVudHMubGVuZ3RoPT09MClyZXR1cm5cIi5cIjt2YXIgZTtmb3IodmFyIHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7Kyt0KXt2YXIgaT1hcmd1bWVudHNbdF07YXNzZXJ0UGF0aChpKTtpZihpLmxlbmd0aD4wKXtpZihlPT09dW5kZWZpbmVkKWU9aTtlbHNlIGUrPVwiL1wiK2l9fWlmKGU9PT11bmRlZmluZWQpcmV0dXJuXCIuXCI7cmV0dXJuIHIubm9ybWFsaXplKGUpfSxyZWxhdGl2ZTpmdW5jdGlvbiByZWxhdGl2ZShlLHQpe2Fzc2VydFBhdGgoZSk7YXNzZXJ0UGF0aCh0KTtpZihlPT09dClyZXR1cm5cIlwiO2U9ci5yZXNvbHZlKGUpO3Q9ci5yZXNvbHZlKHQpO2lmKGU9PT10KXJldHVyblwiXCI7dmFyIGk9MTtmb3IoO2k8ZS5sZW5ndGg7KytpKXtpZihlLmNoYXJDb2RlQXQoaSkhPT00NylicmVha312YXIgbj1lLmxlbmd0aDt2YXIgYT1uLWk7dmFyIGY9MTtmb3IoO2Y8dC5sZW5ndGg7KytmKXtpZih0LmNoYXJDb2RlQXQoZikhPT00NylicmVha312YXIgbD10Lmxlbmd0aDt2YXIgcz1sLWY7dmFyIG89YTxzP2E6czt2YXIgdT0tMTt2YXIgaD0wO2Zvcig7aDw9bzsrK2gpe2lmKGg9PT1vKXtpZihzPm8pe2lmKHQuY2hhckNvZGVBdChmK2gpPT09NDcpe3JldHVybiB0LnNsaWNlKGYraCsxKX1lbHNlIGlmKGg9PT0wKXtyZXR1cm4gdC5zbGljZShmK2gpfX1lbHNlIGlmKGE+byl7aWYoZS5jaGFyQ29kZUF0KGkraCk9PT00Nyl7dT1ofWVsc2UgaWYoaD09PTApe3U9MH19YnJlYWt9dmFyIGM9ZS5jaGFyQ29kZUF0KGkraCk7dmFyIHY9dC5jaGFyQ29kZUF0KGYraCk7aWYoYyE9PXYpYnJlYWs7ZWxzZSBpZihjPT09NDcpdT1ofXZhciBnPVwiXCI7Zm9yKGg9aSt1KzE7aDw9bjsrK2gpe2lmKGg9PT1ufHxlLmNoYXJDb2RlQXQoaCk9PT00Nyl7aWYoZy5sZW5ndGg9PT0wKWcrPVwiLi5cIjtlbHNlIGcrPVwiLy4uXCJ9fWlmKGcubGVuZ3RoPjApcmV0dXJuIGcrdC5zbGljZShmK3UpO2Vsc2V7Zis9dTtpZih0LmNoYXJDb2RlQXQoZik9PT00NykrK2Y7cmV0dXJuIHQuc2xpY2UoZil9fSxfbWFrZUxvbmc6ZnVuY3Rpb24gX21ha2VMb25nKGUpe3JldHVybiBlfSxkaXJuYW1lOmZ1bmN0aW9uIGRpcm5hbWUoZSl7YXNzZXJ0UGF0aChlKTtpZihlLmxlbmd0aD09PTApcmV0dXJuXCIuXCI7dmFyIHI9ZS5jaGFyQ29kZUF0KDApO3ZhciB0PXI9PT00Nzt2YXIgaT0tMTt2YXIgbj10cnVlO2Zvcih2YXIgYT1lLmxlbmd0aC0xO2E+PTE7LS1hKXtyPWUuY2hhckNvZGVBdChhKTtpZihyPT09NDcpe2lmKCFuKXtpPWE7YnJlYWt9fWVsc2V7bj1mYWxzZX19aWYoaT09PS0xKXJldHVybiB0P1wiL1wiOlwiLlwiO2lmKHQmJmk9PT0xKXJldHVyblwiLy9cIjtyZXR1cm4gZS5zbGljZSgwLGkpfSxiYXNlbmFtZTpmdW5jdGlvbiBiYXNlbmFtZShlLHIpe2lmKHIhPT11bmRlZmluZWQmJnR5cGVvZiByIT09XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKCdcImV4dFwiIGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnKTthc3NlcnRQYXRoKGUpO3ZhciB0PTA7dmFyIGk9LTE7dmFyIG49dHJ1ZTt2YXIgYTtpZihyIT09dW5kZWZpbmVkJiZyLmxlbmd0aD4wJiZyLmxlbmd0aDw9ZS5sZW5ndGgpe2lmKHIubGVuZ3RoPT09ZS5sZW5ndGgmJnI9PT1lKXJldHVyblwiXCI7dmFyIGY9ci5sZW5ndGgtMTt2YXIgbD0tMTtmb3IoYT1lLmxlbmd0aC0xO2E+PTA7LS1hKXt2YXIgcz1lLmNoYXJDb2RlQXQoYSk7aWYocz09PTQ3KXtpZighbil7dD1hKzE7YnJlYWt9fWVsc2V7aWYobD09PS0xKXtuPWZhbHNlO2w9YSsxfWlmKGY+PTApe2lmKHM9PT1yLmNoYXJDb2RlQXQoZikpe2lmKC0tZj09PS0xKXtpPWF9fWVsc2V7Zj0tMTtpPWx9fX19aWYodD09PWkpaT1sO2Vsc2UgaWYoaT09PS0xKWk9ZS5sZW5ndGg7cmV0dXJuIGUuc2xpY2UodCxpKX1lbHNle2ZvcihhPWUubGVuZ3RoLTE7YT49MDstLWEpe2lmKGUuY2hhckNvZGVBdChhKT09PTQ3KXtpZighbil7dD1hKzE7YnJlYWt9fWVsc2UgaWYoaT09PS0xKXtuPWZhbHNlO2k9YSsxfX1pZihpPT09LTEpcmV0dXJuXCJcIjtyZXR1cm4gZS5zbGljZSh0LGkpfX0sZXh0bmFtZTpmdW5jdGlvbiBleHRuYW1lKGUpe2Fzc2VydFBhdGgoZSk7dmFyIHI9LTE7dmFyIHQ9MDt2YXIgaT0tMTt2YXIgbj10cnVlO3ZhciBhPTA7Zm9yKHZhciBmPWUubGVuZ3RoLTE7Zj49MDstLWYpe3ZhciBsPWUuY2hhckNvZGVBdChmKTtpZihsPT09NDcpe2lmKCFuKXt0PWYrMTticmVha31jb250aW51ZX1pZihpPT09LTEpe249ZmFsc2U7aT1mKzF9aWYobD09PTQ2KXtpZihyPT09LTEpcj1mO2Vsc2UgaWYoYSE9PTEpYT0xfWVsc2UgaWYociE9PS0xKXthPS0xfX1pZihyPT09LTF8fGk9PT0tMXx8YT09PTB8fGE9PT0xJiZyPT09aS0xJiZyPT09dCsxKXtyZXR1cm5cIlwifXJldHVybiBlLnNsaWNlKHIsaSl9LGZvcm1hdDpmdW5jdGlvbiBmb3JtYXQoZSl7aWYoZT09PW51bGx8fHR5cGVvZiBlIT09XCJvYmplY3RcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwicGF0aE9iamVjdFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyt0eXBlb2YgZSl9cmV0dXJuIF9mb3JtYXQoXCIvXCIsZSl9LHBhcnNlOmZ1bmN0aW9uIHBhcnNlKGUpe2Fzc2VydFBhdGgoZSk7dmFyIHI9e3Jvb3Q6XCJcIixkaXI6XCJcIixiYXNlOlwiXCIsZXh0OlwiXCIsbmFtZTpcIlwifTtpZihlLmxlbmd0aD09PTApcmV0dXJuIHI7dmFyIHQ9ZS5jaGFyQ29kZUF0KDApO3ZhciBpPXQ9PT00Nzt2YXIgbjtpZihpKXtyLnJvb3Q9XCIvXCI7bj0xfWVsc2V7bj0wfXZhciBhPS0xO3ZhciBmPTA7dmFyIGw9LTE7dmFyIHM9dHJ1ZTt2YXIgbz1lLmxlbmd0aC0xO3ZhciB1PTA7Zm9yKDtvPj1uOy0tbyl7dD1lLmNoYXJDb2RlQXQobyk7aWYodD09PTQ3KXtpZighcyl7Zj1vKzE7YnJlYWt9Y29udGludWV9aWYobD09PS0xKXtzPWZhbHNlO2w9bysxfWlmKHQ9PT00Nil7aWYoYT09PS0xKWE9bztlbHNlIGlmKHUhPT0xKXU9MX1lbHNlIGlmKGEhPT0tMSl7dT0tMX19aWYoYT09PS0xfHxsPT09LTF8fHU9PT0wfHx1PT09MSYmYT09PWwtMSYmYT09PWYrMSl7aWYobCE9PS0xKXtpZihmPT09MCYmaSlyLmJhc2U9ci5uYW1lPWUuc2xpY2UoMSxsKTtlbHNlIHIuYmFzZT1yLm5hbWU9ZS5zbGljZShmLGwpfX1lbHNle2lmKGY9PT0wJiZpKXtyLm5hbWU9ZS5zbGljZSgxLGEpO3IuYmFzZT1lLnNsaWNlKDEsbCl9ZWxzZXtyLm5hbWU9ZS5zbGljZShmLGEpO3IuYmFzZT1lLnNsaWNlKGYsbCl9ci5leHQ9ZS5zbGljZShhLGwpfWlmKGY+MClyLmRpcj1lLnNsaWNlKDAsZi0xKTtlbHNlIGlmKGkpci5kaXI9XCIvXCI7cmV0dXJuIHJ9LHNlcDpcIi9cIixkZWxpbWl0ZXI6XCI6XCIsd2luMzI6bnVsbCxwb3NpeDpudWxsfTtyLnBvc2l4PXI7ZS5leHBvcnRzPXJ9fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBpPXJbdF07aWYoaSE9PXVuZGVmaW5lZCl7cmV0dXJuIGkuZXhwb3J0c312YXIgbj1yW3RdPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW3RdKG4sbi5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW3RdfXJldHVybiBuLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oMTE0KTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/path-browserify/index.js\n"));

/***/ }),

/***/ "./node_modules/next/head.js":
/*!***********************************!*\
  !*** ./node_modules/next/head.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlIQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzPzg4NDkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3Qvc2hhcmVkL2xpYi9oZWFkJylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/head.js\n"));

/***/ }),

/***/ "./node_modules/next/image.js":
/*!************************************!*\
  !*** ./node_modules/next/image.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/client/image */ \"./node_modules/next/dist/client/image.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9pbWFnZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSwyR0FBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvaW1hZ2UuanM/MDUzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9jbGllbnQvaW1hZ2UnKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/image.js\n"));

/***/ }),

/***/ "./node_modules/next/link.js":
/*!***********************************!*\
  !*** ./node_modules/next/link.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/client/link */ \"./node_modules/next/dist/client/link.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLHlHQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzPzc1YjMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvY2xpZW50L2xpbmsnKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/link.js\n"));

/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar printWarning = function() {};\n\nif (true) {\n  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n  var loggedTypeFailures = {};\n  var has = __webpack_require__(/*! ./lib/has */ \"./node_modules/prop-types/lib/has.js\");\n\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) { /**/ }\n  };\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (true) {\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            var err = Error(\n              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +\n              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' +\n              'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'\n            );\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        if (error && !(error instanceof Error)) {\n          printWarning(\n            (componentName || 'React class') + ': type specification of ' +\n            location + ' `' + typeSpecName + '` is invalid; the type checker ' +\n            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +\n            'You may have forgotten to pass an argument to the type checker ' +\n            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +\n            'shape all require an argument).'\n          );\n        }\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          printWarning(\n            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')\n          );\n        }\n      }\n    }\n  }\n}\n\n/**\n * Resets warning cache when testing.\n *\n * @private\n */\ncheckPropTypes.resetWarningCache = function() {\n  if (true) {\n    loggedTypeFailures = {};\n  }\n}\n\nmodule.exports = checkPropTypes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEsSUFBSSxJQUFxQztBQUN6Qyw2QkFBNkIsbUJBQU8sQ0FBQyx5RkFBNEI7QUFDakU7QUFDQSxZQUFZLG1CQUFPLENBQUMsdURBQVc7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxZQUFZO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZHQUE2RztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanM/MjYyNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgdmFyIGhhcyA9IHJlcXVpcmUoJy4vbGliL2hhcycpO1xuXG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7IC8qKi8gfVxuICB9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcihcbiAgICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICtcbiAgICAgICAgICAgICAgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArXG4gICAgICAgICAgICAgICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICcgK1xuICAgICAgICAgICAgbG9jYXRpb24gKyAnIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAnICsgdHlwZW9mIGVycm9yICsgJy4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICtcbiAgICAgICAgICAgICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdGYWlsZWQgJyArIGxvY2F0aW9uICsgJyB0eXBlOiAnICsgZXJyb3IubWVzc2FnZSArIChzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVzZXRzIHdhcm5pbmcgY2FjaGUgd2hlbiB0ZXN0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/prop-types/checkPropTypes.js\n"));

/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactIs = __webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\");\nvar assign = __webpack_require__(/*! object-assign */ \"./node_modules/next/dist/build/polyfills/object-assign.js\");\n\nvar ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\nvar has = __webpack_require__(/*! ./lib/has */ \"./node_modules/prop-types/lib/has.js\");\nvar checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ \"./node_modules/prop-types/checkPropTypes.js\");\n\nvar printWarning = function() {};\n\nif (true) {\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\nfunction emptyFunctionThatReturnsNull() {\n  return null;\n}\n\nmodule.exports = function(isValidElement, throwOnDirectAccess) {\n  /* global Symbol */\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n  /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */\n  function getIteratorFn(maybeIterable) {\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */\n\n  var ANONYMOUS = '<<anonymous>>';\n\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n  var ReactPropTypes = {\n    array: createPrimitiveTypeChecker('array'),\n    bigint: createPrimitiveTypeChecker('bigint'),\n    bool: createPrimitiveTypeChecker('boolean'),\n    func: createPrimitiveTypeChecker('function'),\n    number: createPrimitiveTypeChecker('number'),\n    object: createPrimitiveTypeChecker('object'),\n    string: createPrimitiveTypeChecker('string'),\n    symbol: createPrimitiveTypeChecker('symbol'),\n\n    any: createAnyTypeChecker(),\n    arrayOf: createArrayOfTypeChecker,\n    element: createElementTypeChecker(),\n    elementType: createElementTypeTypeChecker(),\n    instanceOf: createInstanceTypeChecker,\n    node: createNodeChecker(),\n    objectOf: createObjectOfTypeChecker,\n    oneOf: createEnumTypeChecker,\n    oneOfType: createUnionTypeChecker,\n    shape: createShapeTypeChecker,\n    exact: createStrictShapeTypeChecker,\n  };\n\n  /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */\n  /*eslint-disable no-self-compare*/\n  function is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n      // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  }\n  /*eslint-enable no-self-compare*/\n\n  /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */\n  function PropTypeError(message, data) {\n    this.message = message;\n    this.data = data && typeof data === 'object' ? data: {};\n    this.stack = '';\n  }\n  // Make `instanceof Error` still work for returned errors.\n  PropTypeError.prototype = Error.prototype;\n\n  function createChainableTypeChecker(validate) {\n    if (true) {\n      var manualPropTypeCallCache = {};\n      var manualPropTypeWarningCount = 0;\n    }\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n      componentName = componentName || ANONYMOUS;\n      propFullName = propFullName || propName;\n\n      if (secret !== ReactPropTypesSecret) {\n        if (throwOnDirectAccess) {\n          // New behavior only for users of `prop-types` package\n          var err = new Error(\n            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n            'Use `PropTypes.checkPropTypes()` to call them. ' +\n            'Read more at http://fb.me/use-check-prop-types'\n          );\n          err.name = 'Invariant Violation';\n          throw err;\n        } else if ( true && typeof console !== 'undefined') {\n          // Old behavior for people using React.PropTypes\n          var cacheKey = componentName + ':' + propName;\n          if (\n            !manualPropTypeCallCache[cacheKey] &&\n            // Avoid spamming the console because they are often not actionable except for lib authors\n            manualPropTypeWarningCount < 3\n          ) {\n            printWarning(\n              'You are manually calling a React.PropTypes validation ' +\n              'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +\n              'and will throw in the standalone `prop-types` package. ' +\n              'You may be seeing this warning due to a third-party PropTypes ' +\n              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'\n            );\n            manualPropTypeCallCache[cacheKey] = true;\n            manualPropTypeWarningCount++;\n          }\n        }\n      }\n      if (props[propName] == null) {\n        if (isRequired) {\n          if (props[propName] === null) {\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n          }\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n        }\n        return null;\n      } else {\n        return validate(props, propName, componentName, location, propFullName);\n      }\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n\n    return chainedCheckType;\n  }\n\n  function createPrimitiveTypeChecker(expectedType) {\n    function validate(props, propName, componentName, location, propFullName, secret) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== expectedType) {\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\n        // check, but we can offer a more precise error message here rather than\n        // 'of type `object`'.\n        var preciseType = getPreciseType(propValue);\n\n        return new PropTypeError(\n          'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'),\n          {expectedType: expectedType}\n        );\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createAnyTypeChecker() {\n    return createChainableTypeChecker(emptyFunctionThatReturnsNull);\n  }\n\n  function createArrayOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n      }\n      var propValue = props[propName];\n      if (!Array.isArray(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n      }\n      for (var i = 0; i < propValue.length; i++) {\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!isValidElement(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!ReactIs.isValidElementType(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createInstanceTypeChecker(expectedClass) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!(props[propName] instanceof expectedClass)) {\n        var expectedClassName = expectedClass.name || ANONYMOUS;\n        var actualClassName = getClassName(props[propName]);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createEnumTypeChecker(expectedValues) {\n    if (!Array.isArray(expectedValues)) {\n      if (true) {\n        if (arguments.length > 1) {\n          printWarning(\n            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +\n            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'\n          );\n        } else {\n          printWarning('Invalid argument supplied to oneOf, expected an array.');\n        }\n      }\n      return emptyFunctionThatReturnsNull;\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      for (var i = 0; i < expectedValues.length; i++) {\n        if (is(propValue, expectedValues[i])) {\n          return null;\n        }\n      }\n\n      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {\n        var type = getPreciseType(value);\n        if (type === 'symbol') {\n          return String(value);\n        }\n        return value;\n      });\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createObjectOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n      }\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n      }\n      for (var key in propValue) {\n        if (has(propValue, key)) {\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n          if (error instanceof Error) {\n            return error;\n          }\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\n    if (!Array.isArray(arrayOfTypeCheckers)) {\n       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : 0;\n      return emptyFunctionThatReturnsNull;\n    }\n\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (typeof checker !== 'function') {\n        printWarning(\n          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\n          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'\n        );\n        return emptyFunctionThatReturnsNull;\n      }\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var expectedTypes = [];\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n        var checker = arrayOfTypeCheckers[i];\n        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);\n        if (checkerResult == null) {\n          return null;\n        }\n        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {\n          expectedTypes.push(checkerResult.data.expectedType);\n        }\n      }\n      var expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']': '';\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createNodeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!isNode(props[propName])) {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function invalidValidatorError(componentName, location, propFullName, key, type) {\n    return new PropTypeError(\n      (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +\n      'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'\n    );\n  }\n\n  function createShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      for (var key in shapeTypes) {\n        var checker = shapeTypes[key];\n        if (typeof checker !== 'function') {\n          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createStrictShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      // We need to check all keys in case some are required but missing from props.\n      var allKeys = assign({}, props[propName], shapeTypes);\n      for (var key in allKeys) {\n        var checker = shapeTypes[key];\n        if (has(shapeTypes, key) && typeof checker !== 'function') {\n          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n        }\n        if (!checker) {\n          return new PropTypeError(\n            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\n            '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\n            '\\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')\n          );\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function isNode(propValue) {\n    switch (typeof propValue) {\n      case 'number':\n      case 'string':\n      case 'undefined':\n        return true;\n      case 'boolean':\n        return !propValue;\n      case 'object':\n        if (Array.isArray(propValue)) {\n          return propValue.every(isNode);\n        }\n        if (propValue === null || isValidElement(propValue)) {\n          return true;\n        }\n\n        var iteratorFn = getIteratorFn(propValue);\n        if (iteratorFn) {\n          var iterator = iteratorFn.call(propValue);\n          var step;\n          if (iteratorFn !== propValue.entries) {\n            while (!(step = iterator.next()).done) {\n              if (!isNode(step.value)) {\n                return false;\n              }\n            }\n          } else {\n            // Iterator will provide entry [k,v] tuples rather than values.\n            while (!(step = iterator.next()).done) {\n              var entry = step.value;\n              if (entry) {\n                if (!isNode(entry[1])) {\n                  return false;\n                }\n              }\n            }\n          }\n        } else {\n          return false;\n        }\n\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === 'symbol') {\n      return true;\n    }\n\n    // falsy value can't be a Symbol\n    if (!propValue) {\n      return false;\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue['@@toStringTag'] === 'Symbol') {\n      return true;\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Equivalent of `typeof` but with special handling for array and regexp.\n  function getPropType(propValue) {\n    var propType = typeof propValue;\n    if (Array.isArray(propValue)) {\n      return 'array';\n    }\n    if (propValue instanceof RegExp) {\n      // Old webkits (at least until Android 4.0) return 'function' rather than\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n      // passes PropTypes.object.\n      return 'object';\n    }\n    if (isSymbol(propType, propValue)) {\n      return 'symbol';\n    }\n    return propType;\n  }\n\n  // This handles more types than `getPropType`. Only used for error messages.\n  // See `createPrimitiveTypeChecker`.\n  function getPreciseType(propValue) {\n    if (typeof propValue === 'undefined' || propValue === null) {\n      return '' + propValue;\n    }\n    var propType = getPropType(propValue);\n    if (propType === 'object') {\n      if (propValue instanceof Date) {\n        return 'date';\n      } else if (propValue instanceof RegExp) {\n        return 'regexp';\n      }\n    }\n    return propType;\n  }\n\n  // Returns a string that is postfixed to a warning about an invalid type.\n  // For example, \"undefined\" or \"of type array\"\n  function getPostfixForTypeWarning(value) {\n    var type = getPreciseType(value);\n    switch (type) {\n      case 'array':\n      case 'object':\n        return 'an ' + type;\n      case 'boolean':\n      case 'date':\n      case 'regexp':\n        return 'a ' + type;\n      default:\n        return type;\n    }\n  }\n\n  // Returns class name of the object, if any.\n  function getClassName(propValue) {\n    if (!propValue.constructor || !propValue.constructor.name) {\n      return ANONYMOUS;\n    }\n    return propValue.constructor.name;\n  }\n\n  ReactPropTypes.checkPropTypes = checkPropTypes;\n  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLGtEQUFVO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyxnRkFBZTs7QUFFcEMsMkJBQTJCLG1CQUFPLENBQUMseUZBQTRCO0FBQy9ELFVBQVUsbUJBQU8sQ0FBQyx1REFBVztBQUM3QixxQkFBcUIsbUJBQU8sQ0FBQyxxRUFBa0I7O0FBRS9DOztBQUVBLElBQUksSUFBcUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsOEJBQThCO0FBQzlCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsU0FBUyxLQUFxQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsSUFBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQyw0RkFBNEYsQ0FBTTtBQUM3STtBQUNBOztBQUVBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsZ0NBQWdDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpSEFBaUg7QUFDakg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzP2I3NmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9saWIvaGFzJyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBiaWdpbnQ6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdiaWdpbnQnKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBlbGVtZW50VHlwZTogY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSwgZGF0YSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5kYXRhID0gZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgPyBkYXRhOiB7fTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAnVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBwcm9wIG9uIGAnICsgY29tcG9uZW50TmFtZSArICdgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSxcbiAgICAgICAgICB7ZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGV9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghUmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQgdHlwZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50cyBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXksIGdvdCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLiAnICtcbiAgICAgICAgICAgICdBIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHdyaXRlIG9uZU9mKHgsIHksIHopIGluc3RlYWQgb2Ygb25lT2YoW3gsIHksIHpdKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcywgZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgU3RyaW5nKHByb3BWYWx1ZSkgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKGhhcyhwcm9wVmFsdWUsIGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICcgKyBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlcikgKyAnIGF0IGluZGV4ICcgKyBpICsgJy4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIHZhciBjaGVja2VyUmVzdWx0ID0gY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGNoZWNrZXJSZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGVja2VyUmVzdWx0LmRhdGEgJiYgaGFzKGNoZWNrZXJSZXN1bHQuZGF0YSwgJ2V4cGVjdGVkVHlwZScpKSB7XG4gICAgICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGNoZWNrZXJSZXN1bHQuZGF0YS5leHBlY3RlZFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZXhwZWN0ZWRUeXBlc01lc3NhZ2UgPSAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPiAwKSA/ICcsIGV4cGVjdGVkIG9uZSBvZiB0eXBlIFsnICsgZXhwZWN0ZWRUeXBlcy5qb2luKCcsICcpICsgJ10nOiAnJztcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AnICsgZXhwZWN0ZWRUeXBlc01lc3NhZ2UgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludmFsaWRWYWxpZGF0b3JFcnJvcihjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBrZXksIHR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHByb3BGdWxsTmFtZSArICcuJyArIGtleSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZSArICdgLidcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpbnZhbGlkVmFsaWRhdG9yRXJyb3IoY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwga2V5LCBnZXRQcmVjaXNlVHlwZShjaGVja2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb20gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoaGFzKHNoYXBlVHlwZXMsIGtleSkgJiYgdHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gaW52YWxpZFZhbGlkYXRvckVycm9yKGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIGtleSwgZ2V0UHJlY2lzZVR5cGUoY2hlY2tlcikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHNoYXBlVHlwZXMpLCBudWxsLCAnICAnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGZhbHN5IHZhbHVlIGNhbid0IGJlIGEgU3ltYm9sXG4gICAgaWYgKCFwcm9wVmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZSA9IGNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/prop-types/factoryWithTypeCheckers.js\n"));

/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (true) {\n  var ReactIs = __webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\");\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ \"./node_modules/prop-types/factoryWithTypeCheckers.js\")(ReactIs.isElement, throwOnDirectAccess);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxJQUFxQztBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxrREFBVTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsdUZBQTJCO0FBQ3RELEVBQUUsS0FBSyxFQUlOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzP2JkZTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShSZWFjdElzLmlzRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/prop-types/index.js\n"));

/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcz9lMDk4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/prop-types/lib/ReactPropTypesSecret.js\n"));

/***/ }),

/***/ "./node_modules/prop-types/lib/has.js":
/*!********************************************!*\
  !*** ./node_modules/prop-types/lib/has.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = Function.call.bind(Object.prototype.hasOwnProperty);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvaGFzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9oYXMuanM/ZTQ3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/prop-types/lib/has.js\n"));

/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/** @license React v16.13.1\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\nvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary\n// (unstable) APIs that have been removed. Can we remove the symbols?\n\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;\nvar REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\nvar REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;\nvar REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;\nvar REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\nvar REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;\nvar REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;\nvar REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;\nvar REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;\nvar REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;\n\nfunction isValidElementType(type) {\n  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);\n}\n\nfunction typeOf(object) {\n  if (typeof object === 'object' && object !== null) {\n    var $$typeof = object.$$typeof;\n\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        var type = object.type;\n\n        switch (type) {\n          case REACT_ASYNC_MODE_TYPE:\n          case REACT_CONCURRENT_MODE_TYPE:\n          case REACT_FRAGMENT_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_SUSPENSE_TYPE:\n            return type;\n\n          default:\n            var $$typeofType = type && type.$$typeof;\n\n            switch ($$typeofType) {\n              case REACT_CONTEXT_TYPE:\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_LAZY_TYPE:\n              case REACT_MEMO_TYPE:\n              case REACT_PROVIDER_TYPE:\n                return $$typeofType;\n\n              default:\n                return $$typeof;\n            }\n\n        }\n\n      case REACT_PORTAL_TYPE:\n        return $$typeof;\n    }\n  }\n\n  return undefined;\n} // AsyncMode is deprecated along with isAsyncMode\n\nvar AsyncMode = REACT_ASYNC_MODE_TYPE;\nvar ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\nvar ContextConsumer = REACT_CONTEXT_TYPE;\nvar ContextProvider = REACT_PROVIDER_TYPE;\nvar Element = REACT_ELEMENT_TYPE;\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Fragment = REACT_FRAGMENT_TYPE;\nvar Lazy = REACT_LAZY_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nvar Portal = REACT_PORTAL_TYPE;\nvar Profiler = REACT_PROFILER_TYPE;\nvar StrictMode = REACT_STRICT_MODE_TYPE;\nvar Suspense = REACT_SUSPENSE_TYPE;\nvar hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated\n\nfunction isAsyncMode(object) {\n  {\n    if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n\n      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');\n    }\n  }\n\n  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;\n}\nfunction isConcurrentMode(object) {\n  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;\n}\nfunction isContextConsumer(object) {\n  return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isContextProvider(object) {\n  return typeOf(object) === REACT_PROVIDER_TYPE;\n}\nfunction isElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nfunction isForwardRef(object) {\n  return typeOf(object) === REACT_FORWARD_REF_TYPE;\n}\nfunction isFragment(object) {\n  return typeOf(object) === REACT_FRAGMENT_TYPE;\n}\nfunction isLazy(object) {\n  return typeOf(object) === REACT_LAZY_TYPE;\n}\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n}\nfunction isPortal(object) {\n  return typeOf(object) === REACT_PORTAL_TYPE;\n}\nfunction isProfiler(object) {\n  return typeOf(object) === REACT_PROFILER_TYPE;\n}\nfunction isStrictMode(object) {\n  return typeOf(object) === REACT_STRICT_MODE_TYPE;\n}\nfunction isSuspense(object) {\n  return typeOf(object) === REACT_SUSPENSE_TYPE;\n}\n\nexports.AsyncMode = AsyncMode;\nexports.ConcurrentMode = ConcurrentMode;\nexports.ContextConsumer = ContextConsumer;\nexports.ContextProvider = ContextProvider;\nexports.Element = Element;\nexports.ForwardRef = ForwardRef;\nexports.Fragment = Fragment;\nexports.Lazy = Lazy;\nexports.Memo = Memo;\nexports.Portal = Portal;\nexports.Profiler = Profiler;\nexports.StrictMode = StrictMode;\nexports.Suspense = Suspense;\nexports.isAsyncMode = isAsyncMode;\nexports.isConcurrentMode = isConcurrentMode;\nexports.isContextConsumer = isContextConsumer;\nexports.isContextProvider = isContextProvider;\nexports.isElement = isElement;\nexports.isForwardRef = isForwardRef;\nexports.isFragment = isFragment;\nexports.isLazy = isLazy;\nexports.isMemo = isMemo;\nexports.isPortal = isPortal;\nexports.isProfiler = isProfiler;\nexports.isStrictMode = isStrictMode;\nexports.isSuspense = isSuspense;\nexports.isValidElementType = isValidElementType;\nexports.typeOf = typeOf;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7Ozs7QUFJYixJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakIsc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsZUFBZTtBQUNmLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsWUFBWTtBQUNaLFlBQVk7QUFDWixjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsbUJBQW1CO0FBQ25CLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLGlCQUFpQjtBQUNqQixvQkFBb0I7QUFDcEIsa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZCxjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGtCQUFrQjtBQUNsQixvQkFBb0I7QUFDcEIsa0JBQWtCO0FBQ2xCLDBCQUEwQjtBQUMxQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanM/NDk2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEzLjFcbiAqIHJlYWN0LWlzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpIDogMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTsgLy8gVE9ETzogV2UgZG9uJ3QgdXNlIEFzeW5jTW9kZSBvciBDb25jdXJyZW50TW9kZSBhbnltb3JlLiBUaGV5IHdlcmUgdGVtcG9yYXJ5XG4vLyAodW5zdGFibGUpIEFQSXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZC4gQ2FuIHdlIHJlbW92ZSB0aGUgc3ltYm9scz9cblxudmFyIFJFQUNUX0FTWU5DX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmFzeW5jX21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbmN1cnJlbnRfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpIDogMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKSA6IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJykgOiAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubGF6eScpIDogMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5ibG9jaycpIDogMHhlYWQ5O1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpIDogMHhlYWQ1O1xudmFyIFJFQUNUX1JFU1BPTkRFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucmVzcG9uZGVyJykgOiAweGVhZDY7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJykgOiAweGVhZDc7XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgLy8gTm90ZTogaXRzIHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIGlmIGl0J3MgYSBwb2x5ZmlsbC5cbiAgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1JFU1BPTkRFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1NDT1BFX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSk7XG59XG5cbmZ1bmN0aW9uIHR5cGVPZihvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIHZhciAkJHR5cGVvZiA9IG9iamVjdC4kJHR5cGVvZjtcblxuICAgIHN3aXRjaCAoJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICB2YXIgdHlwZSA9IG9iamVjdC50eXBlO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcblxuICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mVHlwZTtcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufSAvLyBBc3luY01vZGUgaXMgZGVwcmVjYXRlZCBhbG9uZyB3aXRoIGlzQXN5bmNNb2RlXG5cbnZhciBBc3luY01vZGUgPSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG52YXIgQ29uY3VycmVudE1vZGUgPSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbnZhciBDb250ZXh0Q29uc3VtZXIgPSBSRUFDVF9DT05URVhUX1RZUEU7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbnZhciBFbGVtZW50ID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xudmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xudmFyIEZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbnZhciBMYXp5ID0gUkVBQ1RfTEFaWV9UWVBFO1xudmFyIE1lbW8gPSBSRUFDVF9NRU1PX1RZUEU7XG52YXIgUG9ydGFsID0gUkVBQ1RfUE9SVEFMX1RZUEU7XG52YXIgUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xudmFyIFN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xudmFyIFN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbnZhciBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IGZhbHNlOyAvLyBBc3luY01vZGUgc2hvdWxkIGJlIGRlcHJlY2F0ZWRcblxuZnVuY3Rpb24gaXNBc3luY01vZGUob2JqZWN0KSB7XG4gIHtcbiAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IHRydWU7IC8vIFVzaW5nIGNvbnNvbGVbJ3dhcm4nXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG5cbiAgICAgIGNvbnNvbGVbJ3dhcm4nXSgnVGhlIFJlYWN0SXMuaXNBc3luY01vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTcrLiBVcGRhdGUgeW91ciBjb2RlIHRvIHVzZSAnICsgJ1JlYWN0SXMuaXNDb25jdXJyZW50TW9kZSgpIGluc3RlYWQuIEl0IGhhcyB0aGUgZXhhY3Qgc2FtZSBBUEkuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB8fCB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST1ZJREVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZvcndhcmRSZWYob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRnJhZ21lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTGF6eShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9MQVpZX1RZUEU7XG59XG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xufVxuZnVuY3Rpb24gaXNQb3J0YWwob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUE9SVEFMX1RZUEU7XG59XG5mdW5jdGlvbiBpc1Byb2ZpbGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N0cmljdE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2Uob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbn1cblxuZXhwb3J0cy5Bc3luY01vZGUgPSBBc3luY01vZGU7XG5leHBvcnRzLkNvbmN1cnJlbnRNb2RlID0gQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLkNvbnRleHRDb25zdW1lciA9IENvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuQ29udGV4dFByb3ZpZGVyID0gQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5FbGVtZW50ID0gRWxlbWVudDtcbmV4cG9ydHMuRm9yd2FyZFJlZiA9IEZvcndhcmRSZWY7XG5leHBvcnRzLkZyYWdtZW50ID0gRnJhZ21lbnQ7XG5leHBvcnRzLkxhenkgPSBMYXp5O1xuZXhwb3J0cy5NZW1vID0gTWVtbztcbmV4cG9ydHMuUG9ydGFsID0gUG9ydGFsO1xuZXhwb3J0cy5Qcm9maWxlciA9IFByb2ZpbGVyO1xuZXhwb3J0cy5TdHJpY3RNb2RlID0gU3RyaWN0TW9kZTtcbmV4cG9ydHMuU3VzcGVuc2UgPSBTdXNwZW5zZTtcbmV4cG9ydHMuaXNBc3luY01vZGUgPSBpc0FzeW5jTW9kZTtcbmV4cG9ydHMuaXNDb25jdXJyZW50TW9kZSA9IGlzQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLmlzQ29udGV4dENvbnN1bWVyID0gaXNDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLmlzQ29udGV4dFByb3ZpZGVyID0gaXNDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbmV4cG9ydHMuaXNGb3J3YXJkUmVmID0gaXNGb3J3YXJkUmVmO1xuZXhwb3J0cy5pc0ZyYWdtZW50ID0gaXNGcmFnbWVudDtcbmV4cG9ydHMuaXNMYXp5ID0gaXNMYXp5O1xuZXhwb3J0cy5pc01lbW8gPSBpc01lbW87XG5leHBvcnRzLmlzUG9ydGFsID0gaXNQb3J0YWw7XG5leHBvcnRzLmlzUHJvZmlsZXIgPSBpc1Byb2ZpbGVyO1xuZXhwb3J0cy5pc1N0cmljdE1vZGUgPSBpc1N0cmljdE1vZGU7XG5leHBvcnRzLmlzU3VzcGVuc2UgPSBpc1N1c3BlbnNlO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGU7XG5leHBvcnRzLnR5cGVPZiA9IHR5cGVPZjtcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-is/cjs/react-is.development.js\n"));

/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ \"./node_modules/react-is/cjs/react-is.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLGdJQUF5RDtBQUMzRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanM/YjMxMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-is/index.js\n"));

/***/ }),

/***/ "../../node_modules/inherits/inherits_browser.js":
/*!*******************************************************!*\
  !*** ../../node_modules/inherits/inherits_browser.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzPzkzMDYiXSwic291cmNlc0NvbnRlbnQiOlsiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/inherits/inherits_browser.js\n"));

/***/ }),

/***/ "../../node_modules/util/support/isBufferBrowser.js":
/*!**********************************************************!*\
  !*** ../../node_modules/util/support/isBufferBrowser.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcz81MWM3Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/util/support/isBufferBrowser.js\n"));

/***/ }),

/***/ "../../node_modules/util/util.js":
/*!***************************************!*\
  !*** ../../node_modules/util/util.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"../../node_modules/process/browser.js\");\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"../../node_modules/util/support/isBufferBrowser.js\");\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(/*! inherits */ \"../../node_modules/inherits/inherits_browser.js\");\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYSxPQUFPLG9CQUFvQixPQUFPO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0EsUUFBUSxTQUFTLE9BQU87QUFDeEI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7O0FBR2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxLQUFLOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTs7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QUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU8sMEJBQTBCO0FBQzdELDRCQUE0QixPQUFPLDJDQUEyQztBQUM5RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzPzAxZjUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgfHxcbiAgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgdmFyIGRlc2NyaXB0b3JzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXNjcmlwdG9yc1trZXlzW2ldXSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXlzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9O1xuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbnZhciBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/IFN5bWJvbCgndXRpbC5wcm9taXNpZnkuY3VzdG9tJykgOiB1bmRlZmluZWQ7XG5cbmV4cG9ydHMucHJvbWlzaWZ5ID0gZnVuY3Rpb24gcHJvbWlzaWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sICYmIG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF0pIHtcbiAgICB2YXIgZm4gPSBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInV0aWwucHJvbWlzaWZ5LmN1c3RvbVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICBmdW5jdGlvbiBmbigpIHtcbiAgICB2YXIgcHJvbWlzZVJlc29sdmUsIHByb21pc2VSZWplY3Q7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBwcm9taXNlUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICBwcm9taXNlUmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCB2YWx1ZSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlUmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZm4sIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhcbiAgICBmbixcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKVxuICApO1xufVxuXG5leHBvcnRzLnByb21pc2lmeS5jdXN0b20gPSBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xcblxuZnVuY3Rpb24gY2FsbGJhY2tpZnlPblJlamVjdGVkKHJlYXNvbiwgY2IpIHtcbiAgLy8gYCFyZWFzb25gIGd1YXJkIGluc3BpcmVkIGJ5IGJsdWViaXJkIChSZWY6IGh0dHBzOi8vZ29vLmdsL3Q1SVM2TSkuXG4gIC8vIEJlY2F1c2UgYG51bGxgIGlzIGEgc3BlY2lhbCBlcnJvciB2YWx1ZSBpbiBjYWxsYmFja3Mgd2hpY2ggbWVhbnMgXCJubyBlcnJvclxuICAvLyBvY2N1cnJlZFwiLCB3ZSBlcnJvci13cmFwIHNvIHRoZSBjYWxsYmFjayBjb25zdW1lciBjYW4gZGlzdGluZ3Vpc2ggYmV0d2VlblxuICAvLyBcInRoZSBwcm9taXNlIHJlamVjdGVkIHdpdGggbnVsbFwiIG9yIFwidGhlIHByb21pc2UgZnVsZmlsbGVkIHdpdGggdW5kZWZpbmVkXCIuXG4gIGlmICghcmVhc29uKSB7XG4gICAgdmFyIG5ld1JlYXNvbiA9IG5ldyBFcnJvcignUHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBhIGZhbHN5IHZhbHVlJyk7XG4gICAgbmV3UmVhc29uLnJlYXNvbiA9IHJlYXNvbjtcbiAgICByZWFzb24gPSBuZXdSZWFzb247XG4gIH1cbiAgcmV0dXJuIGNiKHJlYXNvbik7XG59XG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICB9XG5cbiAgLy8gV2UgRE8gTk9UIHJldHVybiB0aGUgcHJvbWlzZSBhcyBpdCBnaXZlcyB0aGUgdXNlciBhIGZhbHNlIHNlbnNlIHRoYXRcbiAgLy8gdGhlIHByb21pc2UgaXMgYWN0dWFsbHkgc29tZWhvdyByZWxhdGVkIHRvIHRoZSBjYWxsYmFjaydzIGV4ZWN1dGlvblxuICAvLyBhbmQgdGhhdCB0aGUgY2FsbGJhY2sgdGhyb3dpbmcgd2lsbCByZWplY3QgdGhlIHByb21pc2UuXG4gIGZ1bmN0aW9uIGNhbGxiYWNraWZpZWQoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIG1heWJlQ2IgPSBhcmdzLnBvcCgpO1xuICAgIGlmICh0eXBlb2YgbWF5YmVDYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxhc3QgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBtYXliZUNiLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICAvLyBJbiB0cnVlIG5vZGUgc3R5bGUgd2UgcHJvY2VzcyB0aGUgY2FsbGJhY2sgb24gYG5leHRUaWNrYCB3aXRoIGFsbCB0aGVcbiAgICAvLyBpbXBsaWNhdGlvbnMgKHN0YWNrLCBgdW5jYXVnaHRFeGNlcHRpb25gLCBgYXN5bmNfaG9va3NgKVxuICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAudGhlbihmdW5jdGlvbihyZXQpIHsgcHJvY2Vzcy5uZXh0VGljayhjYiwgbnVsbCwgcmV0KSB9LFxuICAgICAgICAgICAgZnVuY3Rpb24ocmVqKSB7IHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2tpZnlPblJlamVjdGVkLCByZWosIGNiKSB9KTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihjYWxsYmFja2lmaWVkLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY2FsbGJhY2tpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbCkpO1xuICByZXR1cm4gY2FsbGJhY2tpZmllZDtcbn1cbmV4cG9ydHMuY2FsbGJhY2tpZnkgPSBjYWxsYmFja2lmeTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/util/util.js\n"));

/***/ }),

/***/ "./src/components/Footer.js":
/*!**********************************!*\
  !*** ./src/components/Footer.js ***!
  \**********************************/
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Footer; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/link */ \"./node_modules/next/link.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\n\n\nfunction Footer() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"row footer bg-white text-dark\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"col-12 text-center mt-3\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                className: \"d-flex me-5 text-center justify-content-center\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_1__, {\n                            href: \"About\",\n                            className: \"btn text-danger selectable text-uppercase footerFont\",\n                            children: \"My Account\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Footer.js\",\n                            lineNumber: 10,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Footer.js\",\n                        lineNumber: 9,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_1__, {\n                            href: \"About\",\n                            className: \"btn text-danger selectable text-uppercase footerFont\",\n                            children: \"Contact\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Footer.js\",\n                            lineNumber: 15,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Footer.js\",\n                        lineNumber: 14,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_1__, {\n                            href: \"About\",\n                            className: \"btn text-danger selectable text-uppercase footerFont\",\n                            children: \"About\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Footer.js\",\n                            lineNumber: 20,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Footer.js\",\n                        lineNumber: 19,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Footer.js\",\n                lineNumber: 8,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Footer.js\",\n            lineNumber: 7,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Footer.js\",\n        lineNumber: 6,\n        columnNumber: 5\n    }, this);\n}\n_c = Footer;\nvar _c;\n$RefreshReg$(_c, \"Footer\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9Gb290ZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBNkI7QUFDSDtBQUVYLFNBQVNFO0lBQ3RCLHFCQUNFLDhEQUFDQztRQUFJQyxXQUFVO2tCQUNiLDRFQUFDRDtZQUFJQyxXQUFVO3NCQUNiLDRFQUFDQztnQkFBR0QsV0FBVTs7a0NBQ1osOERBQUNFO2tDQUNDLDRFQUFDTixzQ0FBSUE7NEJBQUNPLE1BQU07NEJBQVNILFdBQVU7c0NBQXVEOzs7Ozs7Ozs7OztrQ0FJeEYsOERBQUNFO2tDQUNDLDRFQUFDTixzQ0FBSUE7NEJBQUNPLE1BQU07NEJBQVNILFdBQVU7c0NBQXVEOzs7Ozs7Ozs7OztrQ0FJeEYsOERBQUNFO2tDQUNDLDRFQUFDTixzQ0FBSUE7NEJBQUNPLE1BQU07NEJBQVNILFdBQVU7c0NBQXVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFRbEc7S0F4QndCRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9Gb290ZXIuanM/OWRmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTGluayBmcm9tIFwibmV4dC9saW5rXCI7XHJcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZvb3RlcigpIHtcclxuICByZXR1cm4gKFxyXG4gICAgPGRpdiBjbGFzc05hbWU9XCJyb3cgZm9vdGVyIGJnLXdoaXRlIHRleHQtZGFya1wiPlxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC0xMiB0ZXh0LWNlbnRlciBtdC0zXCI+XHJcbiAgICAgICAgPHVsIGNsYXNzTmFtZT1cImQtZmxleCBtZS01IHRleHQtY2VudGVyIGp1c3RpZnktY29udGVudC1jZW50ZXJcIj5cclxuICAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgPExpbmsgaHJlZj17J0Fib3V0J30gY2xhc3NOYW1lPVwiYnRuIHRleHQtZGFuZ2VyIHNlbGVjdGFibGUgdGV4dC11cHBlcmNhc2UgZm9vdGVyRm9udFwiPlxyXG4gICAgICAgICAgICAgIE15IEFjY291bnRcclxuICAgICAgICAgICAgPC9MaW5rPlxyXG4gICAgICAgICAgPC9saT5cclxuICAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgPExpbmsgaHJlZj17J0Fib3V0J30gY2xhc3NOYW1lPVwiYnRuIHRleHQtZGFuZ2VyIHNlbGVjdGFibGUgdGV4dC11cHBlcmNhc2UgZm9vdGVyRm9udFwiPlxyXG4gICAgICAgICAgICAgIENvbnRhY3RcclxuICAgICAgICAgICAgPC9MaW5rPlxyXG4gICAgICAgICAgPC9saT5cclxuICAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgPExpbmsgaHJlZj17J0Fib3V0J30gY2xhc3NOYW1lPVwiYnRuIHRleHQtZGFuZ2VyIHNlbGVjdGFibGUgdGV4dC11cHBlcmNhc2UgZm9vdGVyRm9udFwiPlxyXG4gICAgICAgICAgICAgIEFib3V0XHJcbiAgICAgICAgICAgIDwvTGluaz5cclxuICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgPC91bD5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICApXHJcbn0iXSwibmFtZXMiOlsiTGluayIsIlJlYWN0IiwiRm9vdGVyIiwiZGl2IiwiY2xhc3NOYW1lIiwidWwiLCJsaSIsImhyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/Footer.js\n"));

/***/ }),

/***/ "./src/components/Layout.js":
/*!**********************************!*\
  !*** ./src/components/Layout.js ***!
  \**********************************/
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Layout; },\n/* harmony export */   \"siteTitle\": function() { return /* binding */ siteTitle; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ \"./node_modules/next/head.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/image */ \"./node_modules/next/image.js\");\n/* harmony import */ var _layout_module_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./layout.module.css */ \"./src/components/layout.module.css\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/link */ \"./node_modules/next/link.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var _Navbar__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Navbar */ \"./src/components/Navbar.js\");\n/* harmony import */ var _Footer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Footer */ \"./src/components/Footer.js\");\n\n\n\n\n\n\n\n\n\n\n// import { PropTypes } from 'mobx-react/dist/propTypes';\nvar name = \"MealMaster\";\nvar siteTitle = \"MealMaster\";\n// eslint-disable-next-line react/prop-types\nfunction Layout(param) {\n    var children = param.children, home = param.home;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"container-fluid p-0\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_head__WEBPACK_IMPORTED_MODULE_1__, {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        rel: \"icon\",\n                        href: \"/Images/hamburger.svg\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Layout.js\",\n                        lineNumber: 21,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                        name: \"description\",\n                        content: \"Learn how to build a personal website using Next.js\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Layout.js\",\n                        lineNumber: 22,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                        name: \"og:title\",\n                        content: siteTitle\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Layout.js\",\n                        lineNumber: 27,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                        name: \"twitter:card\",\n                        content: \"summary_large_image\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Layout.js\",\n                        lineNumber: 28,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Layout.js\",\n                lineNumber: 20,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Navbar__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {}, void 0, false, {\n                fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Layout.js\",\n                lineNumber: 30,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n                children: children\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Layout.js\",\n                lineNumber: 31,\n                columnNumber: 7\n            }, this),\n            !home && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: _layout_module_css__WEBPACK_IMPORTED_MODULE_7__.backToHome,\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_3__, {\n                    href: \"/\",\n                    children: \" Back to home\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Layout.js\",\n                    lineNumber: 34,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Layout.js\",\n                lineNumber: 33,\n                columnNumber: 9\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Footer__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {}, void 0, false, {\n                fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Layout.js\",\n                lineNumber: 37,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Layout.js\",\n        lineNumber: 19,\n        columnNumber: 5\n    }, this);\n}\n_c = Layout;\nLayout.propTypes = {\n    children: prop_types__WEBPACK_IMPORTED_MODULE_8__.array,\n    home: prop_types__WEBPACK_IMPORTED_MODULE_8__.bool\n};\nvar _c;\n$RefreshReg$(_c, \"Layout\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9MYXlvdXQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQTZCO0FBQ0U7QUFDVTtBQUNrQjtBQUM5QjtBQUNIO0FBQ1M7QUFDTDtBQUNBO0FBRTlCLHlEQUF5RDtBQUV6RCxJQUFNUyxPQUFPO0FBQ04sSUFBTUMsWUFBWSxhQUFhO0FBRXRDLDRDQUE0QztBQUM3QixTQUFTQyxPQUFPLEtBQWtCO1FBQWhCQyxXQUFGLE1BQUVBLFVBQVVDLE9BQVosTUFBWUE7SUFDekMscUJBQ0UsOERBQUNDO1FBQUlDLFdBQVU7OzBCQUNiLDhEQUFDZixzQ0FBSUE7O2tDQUNILDhEQUFDZ0I7d0JBQUtDLEtBQUk7d0JBQU9DLE1BQUs7Ozs7OztrQ0FDdEIsOERBQUNDO3dCQUNDVixNQUFLO3dCQUNMVyxTQUFROzs7Ozs7a0NBR1YsOERBQUNEO3dCQUFLVixNQUFLO3dCQUFXVyxTQUFTVjs7Ozs7O2tDQUMvQiw4REFBQ1M7d0JBQUtWLE1BQUs7d0JBQWVXLFNBQVE7Ozs7Ozs7Ozs7OzswQkFFcEMsOERBQUNiLCtDQUFNQTs7Ozs7MEJBQ1AsOERBQUNjOzBCQUFNVDs7Ozs7O1lBQ04sQ0FBQ0Msc0JBQ0EsOERBQUNDO2dCQUFJQyxXQUFXYiwwREFBaUJvQjswQkFDL0IsNEVBQUNsQixzQ0FBSUE7b0JBQUNjLE1BQUs7OEJBQUk7Ozs7Ozs7Ozs7OzBCQUduQiw4REFBQ1YsK0NBQU1BOzs7Ozs7Ozs7OztBQUdiO0tBdkJ3Qkc7QUF5QnhCQSxPQUFPWSxZQUFZO0lBQ2pCWCxVQUFVTiw2Q0FBZWtCO0lBQ3pCWCxNQUFNUCw0Q0FBY21CO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL0xheW91dC5qcz9mZTZiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBIZWFkIGZyb20gJ25leHQvaGVhZCc7XHJcbmltcG9ydCBJbWFnZSBmcm9tICduZXh0L2ltYWdlJztcclxuaW1wb3J0IHN0eWxlcyBmcm9tICcuL2xheW91dC5tb2R1bGUuY3NzJztcclxuaW1wb3J0IHV0aWxTdHlsZXMgZnJvbSAnLi4vYXNzZXRzL3N0eWxlcy91dGlscy5tb2R1bGUuY3NzJztcclxuaW1wb3J0IExpbmsgZnJvbSAnbmV4dC9saW5rJztcclxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IE5hdmJhciBmcm9tICcuL05hdmJhcic7XHJcbmltcG9ydCBGb290ZXIgZnJvbSAnLi9Gb290ZXInO1xyXG5cclxuLy8gaW1wb3J0IHsgUHJvcFR5cGVzIH0gZnJvbSAnbW9ieC1yZWFjdC9kaXN0L3Byb3BUeXBlcyc7XHJcblxyXG5jb25zdCBuYW1lID0gJ01lYWxNYXN0ZXInO1xyXG5leHBvcnQgY29uc3Qgc2l0ZVRpdGxlID0gJ01lYWxNYXN0ZXInO1xyXG5cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L3Byb3AtdHlwZXNcclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTGF5b3V0KHsgY2hpbGRyZW4sIGhvbWUgfSkge1xyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lci1mbHVpZCBwLTBcIj5cclxuICAgICAgPEhlYWQ+XHJcbiAgICAgICAgPGxpbmsgcmVsPVwiaWNvblwiIGhyZWY9XCIvSW1hZ2VzL2hhbWJ1cmdlci5zdmdcIiAvPlxyXG4gICAgICAgIDxtZXRhXHJcbiAgICAgICAgICBuYW1lPVwiZGVzY3JpcHRpb25cIlxyXG4gICAgICAgICAgY29udGVudD1cIkxlYXJuIGhvdyB0byBidWlsZCBhIHBlcnNvbmFsIHdlYnNpdGUgdXNpbmcgTmV4dC5qc1wiXHJcbiAgICAgICAgLz5cclxuICAgICAgICBcclxuICAgICAgICA8bWV0YSBuYW1lPVwib2c6dGl0bGVcIiBjb250ZW50PXtzaXRlVGl0bGV9IC8+XHJcbiAgICAgICAgPG1ldGEgbmFtZT1cInR3aXR0ZXI6Y2FyZFwiIGNvbnRlbnQ9XCJzdW1tYXJ5X2xhcmdlX2ltYWdlXCIgLz5cclxuICAgICAgPC9IZWFkPlxyXG4gICAgICA8TmF2YmFyIC8+XHJcbiAgICAgIDxtYWluPntjaGlsZHJlbn08L21haW4+XHJcbiAgICAgIHshaG9tZSAmJiAoXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5iYWNrVG9Ib21lfT5cclxuICAgICAgICAgIDxMaW5rIGhyZWY9XCIvXCI+4oaQIEJhY2sgdG8gaG9tZTwvTGluaz5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgKX1cclxuICAgICAgPEZvb3RlciAvPlxyXG4gICAgPC9kaXY+XHJcbiAgKVxyXG59XHJcblxyXG5MYXlvdXQucHJvcFR5cGVzID0ge1xyXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMuYXJyYXksXHJcbiAgaG9tZTogUHJvcFR5cGVzLmJvb2xcclxufSJdLCJuYW1lcyI6WyJIZWFkIiwiSW1hZ2UiLCJzdHlsZXMiLCJ1dGlsU3R5bGVzIiwiTGluayIsIlJlYWN0IiwiUHJvcFR5cGVzIiwiTmF2YmFyIiwiRm9vdGVyIiwibmFtZSIsInNpdGVUaXRsZSIsIkxheW91dCIsImNoaWxkcmVuIiwiaG9tZSIsImRpdiIsImNsYXNzTmFtZSIsImxpbmsiLCJyZWwiLCJocmVmIiwibWV0YSIsImNvbnRlbnQiLCJtYWluIiwiYmFja1RvSG9tZSIsInByb3BUeXBlcyIsImFycmF5IiwiYm9vbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/Layout.js\n"));

/***/ }),

/***/ "./src/components/Login.js":
/*!*********************************!*\
  !*** ./src/components/Login.js ***!
  \*********************************/
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var mobx_react_lite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mobx-react-lite */ \"./node_modules/mobx-react-lite/es/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\n\n\n// import { AppState } from \"../AppState.js\"\n// import { AuthService } from \"../services/AuthService.js\"\n// import Link from \"next/link\"\nfunction Login() {\n    // function login() {\n    //   AuthService.loginWithRedirect()\n    // }\n    // function logout() {\n    //   localStorage.removeItem('user-token')\n    //   AuthService.logout({})\n    // }\n    // const notAuthenticated = (\n    //   <button className=\"btn selectable text-success lighten-30 text-uppercase my-2 my-lg-0\" onClick={login}>Login</button>\n    // )\n    // const authenticated = (\n    //   <div className=\"my-2 my-lg-0\">\n    //     <img src={AppState.account?.picture} alt=\"account photo\" height=\"40\" className=\"rounded selectable no-select\" data-bs-toggle=\"dropdown\"\n    //       aria-expanded=\"false\" />\n    //     <div className=\"dropdown-menu dropdown-menu-lg-end dropdown-menu-start p-0\" aria-labelledby=\"authDropdown\">\n    //       <div className=\"list-group\">\n    //         <Link href={'Account'}>\n    //           <div className=\"list-group-item dropdown-item list-group-item-action\">\n    //             Manage Account\n    //           </div>\n    //         </Link>\n    //         <div className=\"list-group-item dropdown-item list-group-item-action text-danger selectable\" onClick={logout}>\n    //           <i className=\"mdi mdi-logout\"></i>\n    //           logout\n    //         </div>\n    //       </div>\n    //     </div>\n    //   </div>\n    // )\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n            className: \"navbar-text\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                    href: \"/api/auth/login\",\n                    children: \"Login\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Login.js\",\n                    lineNumber: 47,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                    href: \"/api/auth/logout\",\n                    children: \"Logout\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Login.js\",\n                    lineNumber: 48,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Login.js\",\n            lineNumber: 45,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Login.js\",\n        lineNumber: 44,\n        columnNumber: 5\n    }, this);\n}\n_c = Login;\n/* harmony default export */ __webpack_exports__[\"default\"] = (_c1 = (0,mobx_react_lite__WEBPACK_IMPORTED_MODULE_1__.observer)(Login));\nvar _c, _c1;\n$RefreshReg$(_c, \"Login\");\n$RefreshReg$(_c1, \"%default%\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9Mb2dpbi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwQztBQUNqQjtBQUN6Qiw0Q0FBNEM7QUFDNUMsMkRBQTJEO0FBQzNELCtCQUErQjtBQUUvQixTQUFTRTtJQUVQLHFCQUFxQjtJQUNyQixvQ0FBb0M7SUFDcEMsSUFBSTtJQUVKLHNCQUFzQjtJQUN0QiwwQ0FBMEM7SUFDMUMsMkJBQTJCO0lBQzNCLElBQUk7SUFFSiw2QkFBNkI7SUFDN0IsMEhBQTBIO0lBQzFILElBQUk7SUFFSiwwQkFBMEI7SUFDMUIsbUNBQW1DO0lBQ25DLDhJQUE4STtJQUM5SSxpQ0FBaUM7SUFFakMsa0hBQWtIO0lBQ2xILHFDQUFxQztJQUNyQyxrQ0FBa0M7SUFDbEMsbUZBQW1GO0lBQ25GLDZCQUE2QjtJQUM3QixtQkFBbUI7SUFDbkIsa0JBQWtCO0lBQ2xCLHlIQUF5SDtJQUN6SCwrQ0FBK0M7SUFDL0MsbUJBQW1CO0lBQ25CLGlCQUFpQjtJQUNqQixlQUFlO0lBQ2YsYUFBYTtJQUNiLFdBQVc7SUFDWCxJQUFJO0lBRUoscUJBQ0UsOERBQUNDO2tCQUNDLDRFQUFDQztZQUFLQyxXQUFVOzs4QkFFZCw4REFBQ0M7b0JBQUVDLE1BQUs7OEJBQWtCOzs7Ozs7OEJBQzFCLDhEQUFDRDtvQkFBRUMsTUFBSzs4QkFBbUI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSW5DO0tBN0NTTDtBQStDVCwrREFBZSxNQUFBRix5REFBUUEsQ0FBQ0UsTUFBTUEsRUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9Mb2dpbi5qcz8yOWJhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG9ic2VydmVyIH0gZnJvbSBcIm1vYngtcmVhY3QtbGl0ZVwiXHJcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIlxyXG4vLyBpbXBvcnQgeyBBcHBTdGF0ZSB9IGZyb20gXCIuLi9BcHBTdGF0ZS5qc1wiXHJcbi8vIGltcG9ydCB7IEF1dGhTZXJ2aWNlIH0gZnJvbSBcIi4uL3NlcnZpY2VzL0F1dGhTZXJ2aWNlLmpzXCJcclxuLy8gaW1wb3J0IExpbmsgZnJvbSBcIm5leHQvbGlua1wiXHJcblxyXG5mdW5jdGlvbiBMb2dpbigpIHtcclxuXHJcbiAgLy8gZnVuY3Rpb24gbG9naW4oKSB7XHJcbiAgLy8gICBBdXRoU2VydmljZS5sb2dpbldpdGhSZWRpcmVjdCgpXHJcbiAgLy8gfVxyXG5cclxuICAvLyBmdW5jdGlvbiBsb2dvdXQoKSB7XHJcbiAgLy8gICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgndXNlci10b2tlbicpXHJcbiAgLy8gICBBdXRoU2VydmljZS5sb2dvdXQoe30pXHJcbiAgLy8gfVxyXG5cclxuICAvLyBjb25zdCBub3RBdXRoZW50aWNhdGVkID0gKFxyXG4gIC8vICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJidG4gc2VsZWN0YWJsZSB0ZXh0LXN1Y2Nlc3MgbGlnaHRlbi0zMCB0ZXh0LXVwcGVyY2FzZSBteS0yIG15LWxnLTBcIiBvbkNsaWNrPXtsb2dpbn0+TG9naW48L2J1dHRvbj5cclxuICAvLyApXHJcblxyXG4gIC8vIGNvbnN0IGF1dGhlbnRpY2F0ZWQgPSAoXHJcbiAgLy8gICA8ZGl2IGNsYXNzTmFtZT1cIm15LTIgbXktbGctMFwiPlxyXG4gIC8vICAgICA8aW1nIHNyYz17QXBwU3RhdGUuYWNjb3VudD8ucGljdHVyZX0gYWx0PVwiYWNjb3VudCBwaG90b1wiIGhlaWdodD1cIjQwXCIgY2xhc3NOYW1lPVwicm91bmRlZCBzZWxlY3RhYmxlIG5vLXNlbGVjdFwiIGRhdGEtYnMtdG9nZ2xlPVwiZHJvcGRvd25cIlxyXG4gIC8vICAgICAgIGFyaWEtZXhwYW5kZWQ9XCJmYWxzZVwiIC8+XHJcblxyXG4gIC8vICAgICA8ZGl2IGNsYXNzTmFtZT1cImRyb3Bkb3duLW1lbnUgZHJvcGRvd24tbWVudS1sZy1lbmQgZHJvcGRvd24tbWVudS1zdGFydCBwLTBcIiBhcmlhLWxhYmVsbGVkYnk9XCJhdXRoRHJvcGRvd25cIj5cclxuICAvLyAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImxpc3QtZ3JvdXBcIj5cclxuICAvLyAgICAgICAgIDxMaW5rIGhyZWY9eydBY2NvdW50J30+XHJcbiAgLy8gICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibGlzdC1ncm91cC1pdGVtIGRyb3Bkb3duLWl0ZW0gbGlzdC1ncm91cC1pdGVtLWFjdGlvblwiPlxyXG4gIC8vICAgICAgICAgICAgIE1hbmFnZSBBY2NvdW50XHJcbiAgLy8gICAgICAgICAgIDwvZGl2PlxyXG4gIC8vICAgICAgICAgPC9MaW5rPlxyXG4gIC8vICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJsaXN0LWdyb3VwLWl0ZW0gZHJvcGRvd24taXRlbSBsaXN0LWdyb3VwLWl0ZW0tYWN0aW9uIHRleHQtZGFuZ2VyIHNlbGVjdGFibGVcIiBvbkNsaWNrPXtsb2dvdXR9PlxyXG4gIC8vICAgICAgICAgICA8aSBjbGFzc05hbWU9XCJtZGkgbWRpLWxvZ291dFwiPjwvaT5cclxuICAvLyAgICAgICAgICAgbG9nb3V0XHJcbiAgLy8gICAgICAgICA8L2Rpdj5cclxuICAvLyAgICAgICA8L2Rpdj5cclxuICAvLyAgICAgPC9kaXY+XHJcbiAgLy8gICA8L2Rpdj5cclxuICAvLyApXHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2PlxyXG4gICAgICA8c3BhbiBjbGFzc05hbWU9XCJuYXZiYXItdGV4dFwiPlxyXG4gICAgICAgIHsvKiB7IUFwcFN0YXRlLmFjY291bnQ/LmlkID8gbm90QXV0aGVudGljYXRlZCA6IGF1dGhlbnRpY2F0ZWR9ICovfVxyXG4gICAgICAgIDxhIGhyZWY9XCIvYXBpL2F1dGgvbG9naW5cIj5Mb2dpbjwvYT5cclxuICAgICAgICA8YSBocmVmPVwiL2FwaS9hdXRoL2xvZ291dFwiPkxvZ291dDwvYT5cclxuICAgICAgPC9zcGFuPlxyXG4gICAgPC9kaXY+XHJcbiAgKVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBvYnNlcnZlcihMb2dpbikiXSwibmFtZXMiOlsib2JzZXJ2ZXIiLCJSZWFjdCIsIkxvZ2luIiwiZGl2Iiwic3BhbiIsImNsYXNzTmFtZSIsImEiLCJocmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/Login.js\n"));

/***/ }),

/***/ "./src/components/Navbar.js":
/*!**********************************!*\
  !*** ./src/components/Navbar.js ***!
  \**********************************/
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Navbar; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/image */ \"./node_modules/next/image.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/link */ \"./node_modules/next/link.js\");\n/* harmony import */ var _Login_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Login.js */ \"./src/components/Login.js\");\n\n\n\n\n\nfunction Navbar() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"nav\", {\n        className: \"navbar navbar-expand-lg navbar-light bg-light shadow px-3\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_3__, {\n                className: \"navbar-brand d-flex\",\n                href: \"\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"d-flex\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_2__, {\n                            priority: true,\n                            src: \"/Images/hamburger.svg\",\n                            className: \"logo-icon rounded\",\n                            height: 40,\n                            width: 40,\n                            alt: \"\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Navbar.js\",\n                            lineNumber: 11,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                            className: \"text-danger ms-2 me-3 mb-0\",\n                            children: \"MealMaster\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Navbar.js\",\n                            lineNumber: 19,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Navbar.js\",\n                    lineNumber: 10,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Navbar.js\",\n                lineNumber: 9,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                className: \"navbar-toggler\",\n                type: \"button\",\n                \"data-bs-toggle\": \"collapse\",\n                \"data-bs-target\": \"#navbarText\",\n                \"aria-controls\": \"navbarText\",\n                \"aria-expanded\": \"false\",\n                \"aria-label\": \"Toggle navigation\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                    className: \"navbar-toggler-icon\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Navbar.js\",\n                    lineNumber: 31,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Navbar.js\",\n                lineNumber: 22,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"collapse navbar-collapse d-flex justify-content-end\",\n                id: \"navbarText\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                        className: \"navbar-nav me-5\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_3__, {\n                                    href: \"About\",\n                                    className: \"btn text-danger selectable text-uppercase\",\n                                    children: \"My Meal Plan\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Navbar.js\",\n                                    lineNumber: 36,\n                                    columnNumber: 13\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Navbar.js\",\n                                lineNumber: 35,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_3__, {\n                                    href: \"About\",\n                                    className: \"btn text-danger selectable text-uppercase\",\n                                    children: \"My Shopping List\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Navbar.js\",\n                                    lineNumber: 41,\n                                    columnNumber: 13\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Navbar.js\",\n                                lineNumber: 40,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_3__, {\n                                    href: \"About\",\n                                    className: \"btn text-danger selectable text-uppercase\",\n                                    children: \"Find Recipes\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Navbar.js\",\n                                    lineNumber: 46,\n                                    columnNumber: 13\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Navbar.js\",\n                                lineNumber: 45,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_3__, {\n                                    href: \"About\",\n                                    className: \"btn text-danger selectable text-uppercase\",\n                                    children: \"About\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Navbar.js\",\n                                    lineNumber: 51,\n                                    columnNumber: 13\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Navbar.js\",\n                                lineNumber: 50,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Navbar.js\",\n                        lineNumber: 34,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Login_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {}, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Navbar.js\",\n                        lineNumber: 56,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Navbar.js\",\n                lineNumber: 33,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\components\\\\Navbar.js\",\n        lineNumber: 8,\n        columnNumber: 5\n    }, this);\n}\n_c = Navbar;\nvar _c;\n$RefreshReg$(_c, \"Navbar\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9OYXZiYXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUEwQjtBQUNLO0FBQ0Y7QUFDRTtBQUVoQixTQUFTSTtJQUN0QixxQkFDRSw4REFBQ0M7UUFBSUMsV0FBVTs7MEJBQ2IsOERBQUNKLHNDQUFJQTtnQkFBQ0ksV0FBVTtnQkFBc0JDLE1BQU07MEJBQzFDLDRFQUFDQztvQkFBSUYsV0FBVTs7c0NBQ2IsOERBQUNMLHVDQUFLQTs0QkFDSlEsUUFBUTs0QkFDUkMsS0FBSTs0QkFDSkosV0FBVTs0QkFDVkssUUFBUTs0QkFDUkMsT0FBTzs0QkFDUEMsS0FBSTs7Ozs7O3NDQUVOLDhEQUFDQzs0QkFBR1IsV0FBVTtzQ0FBNkI7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQUcvQyw4REFBQ1M7Z0JBQ0NULFdBQVU7Z0JBQ1ZVLE1BQUs7Z0JBQ0xDLGtCQUFlO2dCQUNmQyxrQkFBZTtnQkFDZkMsaUJBQWM7Z0JBQ2RDLGlCQUFjO2dCQUNkQyxjQUFXOzBCQUVYLDRFQUFDQztvQkFBS2hCLFdBQVU7Ozs7Ozs7Ozs7OzBCQUVsQiw4REFBQ0U7Z0JBQUlGLFdBQVU7Z0JBQXNEaUIsSUFBRzs7a0NBQ3RFLDhEQUFDQzt3QkFBR2xCLFdBQVU7OzBDQUNaLDhEQUFDbUI7MENBQ0MsNEVBQUN2QixzQ0FBSUE7b0NBQUNLLE1BQU07b0NBQVNELFdBQVU7OENBQTRDOzs7Ozs7Ozs7OzswQ0FJN0UsOERBQUNtQjswQ0FDQyw0RUFBQ3ZCLHNDQUFJQTtvQ0FBQ0ssTUFBTTtvQ0FBU0QsV0FBVTs4Q0FBNEM7Ozs7Ozs7Ozs7OzBDQUk3RSw4REFBQ21COzBDQUNDLDRFQUFDdkIsc0NBQUlBO29DQUFDSyxNQUFNO29DQUFTRCxXQUFVOzhDQUE0Qzs7Ozs7Ozs7Ozs7MENBSTdFLDhEQUFDbUI7MENBQ0MsNEVBQUN2QixzQ0FBSUE7b0NBQUNLLE1BQU07b0NBQVNELFdBQVU7OENBQTRDOzs7Ozs7Ozs7Ozs7Ozs7OztrQ0FLL0UsOERBQUNILGlEQUFLQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJZDtLQXREd0JDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL05hdmJhci5qcz8zZDBlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IEltYWdlIGZyb20gJ25leHQvaW1hZ2UnO1xyXG5pbXBvcnQgTGluayBmcm9tIFwibmV4dC9saW5rXCI7XHJcbmltcG9ydCBMb2dpbiBmcm9tIFwiLi9Mb2dpbi5qc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTmF2YmFyKCkge1xyXG4gIHJldHVybiAoXHJcbiAgICA8bmF2IGNsYXNzTmFtZT1cIm5hdmJhciBuYXZiYXItZXhwYW5kLWxnIG5hdmJhci1saWdodCBiZy1saWdodCBzaGFkb3cgcHgtM1wiPlxyXG4gICAgICA8TGluayBjbGFzc05hbWU9XCJuYXZiYXItYnJhbmQgZC1mbGV4XCIgaHJlZj17Jyd9PlxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZC1mbGV4XCI+XHJcbiAgICAgICAgICA8SW1hZ2VcclxuICAgICAgICAgICAgcHJpb3JpdHlcclxuICAgICAgICAgICAgc3JjPVwiL0ltYWdlcy9oYW1idXJnZXIuc3ZnXCJcclxuICAgICAgICAgICAgY2xhc3NOYW1lPVwibG9nby1pY29uIHJvdW5kZWRcIlxyXG4gICAgICAgICAgICBoZWlnaHQ9ezQwfVxyXG4gICAgICAgICAgICB3aWR0aD17NDB9XHJcbiAgICAgICAgICAgIGFsdD1cIlwiXHJcbiAgICAgICAgICAvPlxyXG4gICAgICAgICAgPGgxIGNsYXNzTmFtZT1cInRleHQtZGFuZ2VyIG1zLTIgbWUtMyBtYi0wXCI+TWVhbE1hc3RlcjwvaDE+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvTGluaz5cclxuICAgICAgPGJ1dHRvblxyXG4gICAgICAgIGNsYXNzTmFtZT1cIm5hdmJhci10b2dnbGVyXCJcclxuICAgICAgICB0eXBlPVwiYnV0dG9uXCJcclxuICAgICAgICBkYXRhLWJzLXRvZ2dsZT1cImNvbGxhcHNlXCJcclxuICAgICAgICBkYXRhLWJzLXRhcmdldD1cIiNuYXZiYXJUZXh0XCJcclxuICAgICAgICBhcmlhLWNvbnRyb2xzPVwibmF2YmFyVGV4dFwiXHJcbiAgICAgICAgYXJpYS1leHBhbmRlZD1cImZhbHNlXCJcclxuICAgICAgICBhcmlhLWxhYmVsPVwiVG9nZ2xlIG5hdmlnYXRpb25cIlxyXG4gICAgICA+XHJcbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwibmF2YmFyLXRvZ2dsZXItaWNvblwiPjwvc3Bhbj5cclxuICAgICAgPC9idXR0b24+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sbGFwc2UgbmF2YmFyLWNvbGxhcHNlIGQtZmxleCBqdXN0aWZ5LWNvbnRlbnQtZW5kXCIgaWQ9XCJuYXZiYXJUZXh0XCI+XHJcbiAgICAgICAgPHVsIGNsYXNzTmFtZT1cIm5hdmJhci1uYXYgbWUtNVwiPlxyXG4gICAgICAgICAgPGxpPlxyXG4gICAgICAgICAgICA8TGluayBocmVmPXsnQWJvdXQnfSBjbGFzc05hbWU9XCJidG4gdGV4dC1kYW5nZXIgc2VsZWN0YWJsZSB0ZXh0LXVwcGVyY2FzZVwiPlxyXG4gICAgICAgICAgICAgIE15IE1lYWwgUGxhblxyXG4gICAgICAgICAgICA8L0xpbms+XHJcbiAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgPGxpPlxyXG4gICAgICAgICAgICA8TGluayBocmVmPXsnQWJvdXQnfSBjbGFzc05hbWU9XCJidG4gdGV4dC1kYW5nZXIgc2VsZWN0YWJsZSB0ZXh0LXVwcGVyY2FzZVwiPlxyXG4gICAgICAgICAgICAgIE15IFNob3BwaW5nIExpc3RcclxuICAgICAgICAgICAgPC9MaW5rPlxyXG4gICAgICAgICAgPC9saT5cclxuICAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgPExpbmsgaHJlZj17J0Fib3V0J30gY2xhc3NOYW1lPVwiYnRuIHRleHQtZGFuZ2VyIHNlbGVjdGFibGUgdGV4dC11cHBlcmNhc2VcIj5cclxuICAgICAgICAgICAgICBGaW5kIFJlY2lwZXNcclxuICAgICAgICAgICAgPC9MaW5rPlxyXG4gICAgICAgICAgPC9saT5cclxuICAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgPExpbmsgaHJlZj17J0Fib3V0J30gY2xhc3NOYW1lPVwiYnRuIHRleHQtZGFuZ2VyIHNlbGVjdGFibGUgdGV4dC11cHBlcmNhc2VcIj5cclxuICAgICAgICAgICAgICBBYm91dFxyXG4gICAgICAgICAgICA8L0xpbms+XHJcbiAgICAgICAgICA8L2xpPlxyXG4gICAgICAgIDwvdWw+XHJcbiAgICAgICAgPExvZ2luIC8+XHJcbiAgICAgIDwvZGl2ID5cclxuICAgIDwvbmF2ID5cclxuICApXHJcbn0iXSwibmFtZXMiOlsiUmVhY3QiLCJJbWFnZSIsIkxpbmsiLCJMb2dpbiIsIk5hdmJhciIsIm5hdiIsImNsYXNzTmFtZSIsImhyZWYiLCJkaXYiLCJwcmlvcml0eSIsInNyYyIsImhlaWdodCIsIndpZHRoIiwiYWx0IiwiaDEiLCJidXR0b24iLCJ0eXBlIiwiZGF0YS1icy10b2dnbGUiLCJkYXRhLWJzLXRhcmdldCIsImFyaWEtY29udHJvbHMiLCJhcmlhLWV4cGFuZGVkIiwiYXJpYS1sYWJlbCIsInNwYW4iLCJpZCIsInVsIiwibGkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/Navbar.js\n"));

/***/ }),

/***/ "./src/pages/index.js":
/*!****************************!*\
  !*** ./src/pages/index.js ***!
  \****************************/
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ \"./node_modules/next/head.js\");\n/* harmony import */ var _components_Layout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/Layout */ \"./src/components/Layout.js\");\n/* harmony import */ var _assets_styles_utils_module_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../assets/styles/utils.module.css */ \"./src/assets/styles/utils.module.css\");\n/* harmony import */ var _assets_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../assets/styles/Home.module.css */ \"./src/assets/styles/Home.module.css\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/image */ \"./node_modules/next/image.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/link */ \"./node_modules/next/link.js\");\n\n\n\n\n\n\n\n\nfunction Home() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Layout__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n        home: true,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_head__WEBPACK_IMPORTED_MODULE_1__, {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                    children: _components_Layout__WEBPACK_IMPORTED_MODULE_2__.siteTitle\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\pages\\\\index.js\",\n                    lineNumber: 14,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\pages\\\\index.js\",\n                lineNumber: 13,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                className: _assets_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_6__.masthead,\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                    className: \"ms-5 p-3 text-light w-50\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                            children: \"Plan\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\pages\\\\index.js\",\n                            lineNumber: 18,\n                            columnNumber: 11\n                        }, this),\n                        \" Your Meals\",\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\pages\\\\index.js\",\n                            lineNumber: 18,\n                            columnNumber: 43\n                        }, this),\n                        \" \",\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                            children: \"Shop\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\pages\\\\index.js\",\n                            lineNumber: 18,\n                            columnNumber: 50\n                        }, this),\n                        \" with an easy-made shopping list\",\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\pages\\\\index.js\",\n                            lineNumber: 18,\n                            columnNumber: 103\n                        }, this),\n                        \" \",\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                            children: \"Cook\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\pages\\\\index.js\",\n                            lineNumber: 18,\n                            columnNumber: 110\n                        }, this),\n                        \" a new favorite recipe\"\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\pages\\\\index.js\",\n                    lineNumber: 17,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\pages\\\\index.js\",\n                lineNumber: 16,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                className: \"\".concat(_assets_styles_utils_module_css__WEBPACK_IMPORTED_MODULE_7__.headingMd, \" \").concat(_assets_styles_utils_module_css__WEBPACK_IMPORTED_MODULE_7__.padding1px, \" \").concat(_assets_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_6__.homeSection1),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"ms-4 p-4 pb-1 text-dark w-50\",\n                        children: \"Let's be honest, we all hate meal planning.\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\pages\\\\index.js\",\n                        lineNumber: 22,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"ms-5 p-3\",\n                        children: \"Lorem, ipsum dolor sit amet consectetur adipisicing elit. Harum natus omnis incidunt iure voluptatum facere eius cupiditate repudiandae nisi repellat accusamus autem, dolor laudantium voluptate dolorem voluptatem fuga? Harum, nihil. Veniam doloremque quia eum non distinctio in animi dolore nemo quisquam et, ad nihil dolorum minima sint rerum, accusantium vitae excepturi aspernatur consequuntur a molestiae tenetur commodi. Laboriosam, distinctio perferendis.\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\pages\\\\index.js\",\n                        lineNumber: 25,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\pages\\\\index.js\",\n                lineNumber: 21,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                className: \"\".concat(_assets_styles_utils_module_css__WEBPACK_IMPORTED_MODULE_7__.headingMd, \" \").concat(_assets_styles_utils_module_css__WEBPACK_IMPORTED_MODULE_7__.padding1px, \" \").concat(_assets_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_6__.homeSection2),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"ms-4 p-4 pb-1 text-dark w-50\",\n                        children: \"Keep losing your list? We can help with that.\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\pages\\\\index.js\",\n                        lineNumber: 30,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"ms-5 p-3\",\n                        children: \"Shopping list\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\pages\\\\index.js\",\n                        lineNumber: 33,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\pages\\\\index.js\",\n                lineNumber: 29,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                className: \"\".concat(_assets_styles_utils_module_css__WEBPACK_IMPORTED_MODULE_7__.headingMd, \" \").concat(_assets_styles_utils_module_css__WEBPACK_IMPORTED_MODULE_7__.padding1px, \" \").concat(_assets_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_6__.homeSection3, \" mb-5\"),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"ms-4 p-4 pb-1 text-dark w-50\",\n                        children: 'You don\\'t have to have \"chef\" on your resume to make our recipes.'\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\pages\\\\index.js\",\n                        lineNumber: 36,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"recipeShowcase d-flex justify-content-evenly\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_4__, {\n                                priority: true,\n                                src: \"/Images/steak.jpg\",\n                                className: \"rounded\",\n                                height: 244,\n                                width: 244,\n                                alt: \"\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\pages\\\\index.js\",\n                                lineNumber: 40,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_4__, {\n                                priority: true,\n                                src: \"/Images/pizza.jpg\",\n                                className: \"rounded\",\n                                height: 244,\n                                width: 244,\n                                alt: \"\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\pages\\\\index.js\",\n                                lineNumber: 48,\n                                columnNumber: 9\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_4__, {\n                                priority: true,\n                                src: \"/Images/fried-rice.jpg\",\n                                className: \"rounded\",\n                                height: 244,\n                                width: 244,\n                                alt: \"\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\pages\\\\index.js\",\n                                lineNumber: 56,\n                                columnNumber: 9\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_4__, {\n                                priority: true,\n                                src: \"/Images/hamburger.jpg\",\n                                className: \"rounded\",\n                                height: 244,\n                                width: 244,\n                                alt: \"\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\pages\\\\index.js\",\n                                lineNumber: 64,\n                                columnNumber: 9\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\pages\\\\index.js\",\n                        lineNumber: 39,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\pages\\\\index.js\",\n                lineNumber: 35,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\smith\\\\source\\\\codeworks\\\\react\\\\meal-master-fullstack\\\\meal-master-fullstack.client\\\\src\\\\pages\\\\index.js\",\n        lineNumber: 12,\n        columnNumber: 5\n    }, this);\n}\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFnZXMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUE2QjtBQUM0QjtBQUNFO0FBQ0Y7QUFDL0I7QUFDSztBQUNGO0FBR2QsU0FBU1E7SUFDdEIscUJBQ0UsOERBQUNQLDBEQUFNQTtRQUFDUSxJQUFJOzswQkFDViw4REFBQ1Qsc0NBQUlBOzBCQUNILDRFQUFDVTs4QkFBT1IseURBQVNBOzs7Ozs7Ozs7OzswQkFFbkIsOERBQUNTO2dCQUFRQyxXQUFXUixvRUFBbUJTOzBCQUNyQyw0RUFBQ0M7b0JBQUdGLFdBQVU7O3NDQUNaLDhEQUFDRztzQ0FBTzs7Ozs7O3dCQUFhO3NDQUFXLDhEQUFDQzs7Ozs7d0JBQUs7c0NBQUMsOERBQUNEO3NDQUFPOzs7Ozs7d0JBQWE7c0NBQWdDLDhEQUFDQzs7Ozs7d0JBQUs7c0NBQUMsOERBQUNEO3NDQUFPOzs7Ozs7d0JBQWE7Ozs7Ozs7Ozs7OzswQkFHNUgsOERBQUNKO2dCQUFRQyxXQUFXLEdBQTJCVCxPQUF4QkEsc0VBQW9CYyxFQUFDLEtBQTRCYixPQUF6QkQsdUVBQXFCZSxFQUFDLEtBQTJCLE9BQXhCZCx3RUFBdUJlOztrQ0FDN0YsOERBQUNMO3dCQUFHRixXQUFVO2tDQUErQjs7Ozs7O2tDQUc3Qyw4REFBQ1E7d0JBQUVSLFdBQVU7a0NBQVc7Ozs7Ozs7Ozs7OzswQkFJMUIsOERBQUNEO2dCQUFRQyxXQUFXLEdBQTJCVCxPQUF4QkEsc0VBQW9CYyxFQUFDLEtBQTRCYixPQUF6QkQsdUVBQXFCZSxFQUFDLEtBQTJCLE9BQXhCZCx3RUFBdUJpQjs7a0NBQzdGLDhEQUFDUDt3QkFBR0YsV0FBVTtrQ0FBK0I7Ozs7OztrQ0FHN0MsOERBQUNRO3dCQUFFUixXQUFVO2tDQUFXOzs7Ozs7Ozs7Ozs7MEJBRTFCLDhEQUFDRDtnQkFBUUMsV0FBVyxHQUEyQlQsT0FBeEJBLHNFQUFvQmMsRUFBQyxLQUE0QmIsT0FBekJELHVFQUFxQmUsRUFBQyxLQUEyQixPQUF4QmQsd0VBQXVCa0IsRUFBQzs7a0NBQzlGLDhEQUFDUjt3QkFBR0YsV0FBVTtrQ0FBK0I7Ozs7OztrQ0FHN0MsOERBQUNXO3dCQUFJWCxXQUFVOzswQ0FDYiw4REFBQ04sdUNBQUtBO2dDQUNBa0IsUUFBUTtnQ0FDUkMsS0FBSTtnQ0FDSmIsV0FBVTtnQ0FDVmMsUUFBUTtnQ0FDUkMsT0FBTztnQ0FDUEMsS0FBSTs7Ozs7OzBDQUVaLDhEQUFDdEIsdUNBQUtBO2dDQUNBa0IsUUFBUTtnQ0FDUkMsS0FBSTtnQ0FDSmIsV0FBVTtnQ0FDVmMsUUFBUTtnQ0FDUkMsT0FBTztnQ0FDUEMsS0FBSTs7Ozs7OzBDQUVWLDhEQUFDdEIsdUNBQUtBO2dDQUNBa0IsUUFBUTtnQ0FDUkMsS0FBSTtnQ0FDSmIsV0FBVTtnQ0FDVmMsUUFBUTtnQ0FDUkMsT0FBTztnQ0FDUEMsS0FBSTs7Ozs7OzBDQUVWLDhEQUFDdEIsdUNBQUtBO2dDQUNBa0IsUUFBUTtnQ0FDUkMsS0FBSTtnQ0FDSmIsV0FBVTtnQ0FDVmMsUUFBUTtnQ0FDUkMsT0FBTztnQ0FDUEMsS0FBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMFFsQjtLQXRVd0JwQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvcGFnZXMvaW5kZXguanM/NDA4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSGVhZCBmcm9tICduZXh0L2hlYWQnO1xyXG5pbXBvcnQgTGF5b3V0LCB7IHNpdGVUaXRsZSB9IGZyb20gJy4uL2NvbXBvbmVudHMvTGF5b3V0JztcclxuaW1wb3J0IHV0aWxTdHlsZXMgZnJvbSAnLi4vYXNzZXRzL3N0eWxlcy91dGlscy5tb2R1bGUuY3NzJztcclxuaW1wb3J0IGhvbWVTdHlsZXMgZnJvbSAnLi4vYXNzZXRzL3N0eWxlcy9Ib21lLm1vZHVsZS5jc3MnXHJcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBJbWFnZSBmcm9tICduZXh0L2ltYWdlJztcclxuaW1wb3J0IExpbmsgZnJvbSAnbmV4dC9saW5rJztcclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBIb21lKCkge1xyXG4gIHJldHVybiAoXHJcbiAgICA8TGF5b3V0IGhvbWU+XHJcbiAgICAgIDxIZWFkPlxyXG4gICAgICAgIDx0aXRsZT57c2l0ZVRpdGxlfTwvdGl0bGU+XHJcbiAgICAgIDwvSGVhZD5cclxuICAgICAgPHNlY3Rpb24gY2xhc3NOYW1lPXtob21lU3R5bGVzLm1hc3RoZWFkfT5cclxuICAgICAgICA8aDIgY2xhc3NOYW1lPSdtcy01IHAtMyB0ZXh0LWxpZ2h0IHctNTAnPlxyXG4gICAgICAgICAgPHN0cm9uZz5QbGFuPC9zdHJvbmc+IFlvdXIgTWVhbHM8YnIgLz4gPHN0cm9uZz5TaG9wPC9zdHJvbmc+IHdpdGggYW4gZWFzeS1tYWRlIHNob3BwaW5nIGxpc3Q8YnIgLz4gPHN0cm9uZz5Db29rPC9zdHJvbmc+IGEgbmV3IGZhdm9yaXRlIHJlY2lwZVxyXG4gICAgICAgIDwvaDI+XHJcbiAgICAgIDwvc2VjdGlvbj5cclxuICAgICAgPHNlY3Rpb24gY2xhc3NOYW1lPXtgJHt1dGlsU3R5bGVzLmhlYWRpbmdNZH0gJHt1dGlsU3R5bGVzLnBhZGRpbmcxcHh9ICR7aG9tZVN0eWxlcy5ob21lU2VjdGlvbjF9YH0+XHJcbiAgICAgICAgPGgyIGNsYXNzTmFtZT0nbXMtNCBwLTQgcGItMSB0ZXh0LWRhcmsgdy01MCc+XHJcbiAgICAgICAgICBMZXQmYXBvcztzIGJlIGhvbmVzdCwgd2UgYWxsIGhhdGUgbWVhbCBwbGFubmluZy5cclxuICAgICAgICA8L2gyPlxyXG4gICAgICAgIDxwIGNsYXNzTmFtZT0nbXMtNSBwLTMnPkxvcmVtLCBpcHN1bSBkb2xvciBzaXQgYW1ldCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBIYXJ1bSBuYXR1cyBvbW5pcyBpbmNpZHVudCBpdXJlIHZvbHVwdGF0dW0gZmFjZXJlIGVpdXMgY3VwaWRpdGF0ZSByZXB1ZGlhbmRhZSBuaXNpIHJlcGVsbGF0IGFjY3VzYW11cyBhdXRlbSwgZG9sb3IgbGF1ZGFudGl1bSB2b2x1cHRhdGUgZG9sb3JlbSB2b2x1cHRhdGVtIGZ1Z2E/IEhhcnVtLCBuaWhpbC5cclxuICAgICAgICAgIFZlbmlhbSBkb2xvcmVtcXVlIHF1aWEgZXVtIG5vbiBkaXN0aW5jdGlvIGluIGFuaW1pIGRvbG9yZSBuZW1vIHF1aXNxdWFtIGV0LCBhZCBuaWhpbCBkb2xvcnVtIG1pbmltYSBzaW50IHJlcnVtLCBhY2N1c2FudGl1bSB2aXRhZSBleGNlcHR1cmkgYXNwZXJuYXR1ciBjb25zZXF1dW50dXIgYSBtb2xlc3RpYWUgdGVuZXR1ciBjb21tb2RpLiBMYWJvcmlvc2FtLCBkaXN0aW5jdGlvIHBlcmZlcmVuZGlzLlxyXG4gICAgICAgIDwvcD5cclxuICAgICAgPC9zZWN0aW9uPlxyXG4gICAgICA8c2VjdGlvbiBjbGFzc05hbWU9e2Ake3V0aWxTdHlsZXMuaGVhZGluZ01kfSAke3V0aWxTdHlsZXMucGFkZGluZzFweH0gJHtob21lU3R5bGVzLmhvbWVTZWN0aW9uMn1gfT5cclxuICAgICAgICA8aDIgY2xhc3NOYW1lPSdtcy00IHAtNCBwYi0xIHRleHQtZGFyayB3LTUwJz5cclxuICAgICAgICAgIEtlZXAgbG9zaW5nIHlvdXIgbGlzdD8gV2UgY2FuIGhlbHAgd2l0aCB0aGF0LlxyXG4gICAgICAgIDwvaDI+XHJcbiAgICAgICAgPHAgY2xhc3NOYW1lPSdtcy01IHAtMyc+U2hvcHBpbmcgbGlzdDwvcD5cclxuICAgICAgPC9zZWN0aW9uPlxyXG4gICAgICA8c2VjdGlvbiBjbGFzc05hbWU9e2Ake3V0aWxTdHlsZXMuaGVhZGluZ01kfSAke3V0aWxTdHlsZXMucGFkZGluZzFweH0gJHtob21lU3R5bGVzLmhvbWVTZWN0aW9uM30gbWItNWB9PlxyXG4gICAgICAgIDxoMiBjbGFzc05hbWU9J21zLTQgcC00IHBiLTEgdGV4dC1kYXJrIHctNTAnPlxyXG4gICAgICAgICAgWW91IGRvbiZhcG9zO3QgaGF2ZSB0byBoYXZlICZxdW90O2NoZWYmcXVvdDsgb24geW91ciByZXN1bWUgdG8gbWFrZSBvdXIgcmVjaXBlcy5cclxuICAgICAgICA8L2gyPlxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicmVjaXBlU2hvd2Nhc2UgZC1mbGV4IGp1c3RpZnktY29udGVudC1ldmVubHlcIj5cclxuICAgICAgICAgIDxJbWFnZVxyXG4gICAgICAgICAgICAgICAgcHJpb3JpdHlcclxuICAgICAgICAgICAgICAgIHNyYz1cIi9JbWFnZXMvc3RlYWsuanBnXCJcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInJvdW5kZWRcIlxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0PXsyNDR9XHJcbiAgICAgICAgICAgICAgICB3aWR0aD17MjQ0fVxyXG4gICAgICAgICAgICAgICAgYWx0PVwiXCJcclxuICAgICAgICAgICAgLz5cclxuICAgICAgICA8SW1hZ2VcclxuICAgICAgICAgICAgICBwcmlvcml0eVxyXG4gICAgICAgICAgICAgIHNyYz1cIi9JbWFnZXMvcGl6emEuanBnXCJcclxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJyb3VuZGVkXCJcclxuICAgICAgICAgICAgICBoZWlnaHQ9ezI0NH1cclxuICAgICAgICAgICAgICB3aWR0aD17MjQ0fVxyXG4gICAgICAgICAgICAgIGFsdD1cIlwiXHJcbiAgICAgICAgICAgIC8+XHJcbiAgICAgICAgPEltYWdlXHJcbiAgICAgICAgICAgICAgcHJpb3JpdHlcclxuICAgICAgICAgICAgICBzcmM9XCIvSW1hZ2VzL2ZyaWVkLXJpY2UuanBnXCJcclxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJyb3VuZGVkXCJcclxuICAgICAgICAgICAgICBoZWlnaHQ9ezI0NH1cclxuICAgICAgICAgICAgICB3aWR0aD17MjQ0fVxyXG4gICAgICAgICAgICAgIGFsdD1cIlwiXHJcbiAgICAgICAgICAvPlxyXG4gICAgICAgIDxJbWFnZVxyXG4gICAgICAgICAgICAgIHByaW9yaXR5XHJcbiAgICAgICAgICAgICAgc3JjPVwiL0ltYWdlcy9oYW1idXJnZXIuanBnXCJcclxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJyb3VuZGVkXCJcclxuICAgICAgICAgICAgICBoZWlnaHQ9ezI0NH1cclxuICAgICAgICAgICAgICB3aWR0aD17MjQ0fVxyXG4gICAgICAgICAgICAgIGFsdD1cIlwiXHJcbiAgICAgICAgICAgIC8+XHJcbiAgICAgICAgey8qIDxJbWFnZVxyXG4gICAgICAgICAgICAgIHByaW9yaXR5XHJcbiAgICAgICAgICAgICAgc3JjPVwiL0ltYWdlcy9mcmllZC1yaWNlLmpwZ1wiXHJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY29sLTEgcC0wXCJcclxuICAgICAgICAgICAgICBoZWlnaHQ9ezIwMH1cclxuICAgICAgICAgICAgICB3aWR0aD17MjAwfVxyXG4gICAgICAgICAgICAgIGFsdD1cIlwiXHJcbiAgICAgICAgICAvPlxyXG4gICAgICAgIDxJbWFnZVxyXG4gICAgICAgICAgICAgIHByaW9yaXR5XHJcbiAgICAgICAgICAgICAgc3JjPVwiL0ltYWdlcy9waXp6YS5qcGdcIlxyXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNvbC0xIHAtMFwiXHJcbiAgICAgICAgICAgICAgaGVpZ2h0PXsyMDB9XHJcbiAgICAgICAgICAgICAgd2lkdGg9ezIwMH1cclxuICAgICAgICAgICAgICBhbHQ9XCJcIlxyXG4gICAgICAgICAgLz5cclxuICAgICAgICAgIDxJbWFnZVxyXG4gICAgICAgICAgICAgIHByaW9yaXR5XHJcbiAgICAgICAgICAgICAgc3JjPVwiL0ltYWdlcy9zdGVhay5qcGdcIlxyXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNvbC0xIHAtMFwiXHJcbiAgICAgICAgICAgICAgaGVpZ2h0PXsyMDB9XHJcbiAgICAgICAgICAgICAgd2lkdGg9ezIwMH1cclxuICAgICAgICAgICAgICBhbHQ9XCJcIlxyXG4gICAgICAgICAgLz5cclxuICAgICAgICA8SW1hZ2VcclxuICAgICAgICAgICAgICBwcmlvcml0eVxyXG4gICAgICAgICAgICAgIHNyYz1cIi9JbWFnZXMvaGFtYnVyZ2VyLmpwZ1wiXHJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY29sLTEgcC0wXCJcclxuICAgICAgICAgICAgICBoZWlnaHQ9ezIwMH1cclxuICAgICAgICAgICAgICB3aWR0aD17MjAwfVxyXG4gICAgICAgICAgICAgIGFsdD1cIlwiXHJcbiAgICAgICAgICAvPlxyXG4gICAgICAgIDxJbWFnZVxyXG4gICAgICAgICAgICAgIHByaW9yaXR5XHJcbiAgICAgICAgICAgICAgc3JjPVwiL0ltYWdlcy9mcmllZC1yaWNlLmpwZ1wiXHJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY29sLTEgcC0wXCJcclxuICAgICAgICAgICAgICBoZWlnaHQ9ezIwMH1cclxuICAgICAgICAgICAgICB3aWR0aD17MjAwfVxyXG4gICAgICAgICAgICAgIGFsdD1cIlwiXHJcbiAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICA8SW1hZ2VcclxuICAgICAgICAgICAgICBwcmlvcml0eVxyXG4gICAgICAgICAgICAgIHNyYz1cIi9JbWFnZXMvc3RlYWsuanBnXCJcclxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjb2wtMSBwLTBcIlxyXG4gICAgICAgICAgICAgIGhlaWdodD17MjAwfVxyXG4gICAgICAgICAgICAgIHdpZHRoPXsyMDB9XHJcbiAgICAgICAgICAgICAgYWx0PVwiXCJcclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgPEltYWdlXHJcbiAgICAgICAgICAgICAgcHJpb3JpdHlcclxuICAgICAgICAgICAgICBzcmM9XCIvSW1hZ2VzL2hhbWJ1cmdlci5qcGdcIlxyXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNvbC0xIHAtMFwiXHJcbiAgICAgICAgICAgICAgaGVpZ2h0PXsyMDB9XHJcbiAgICAgICAgICAgICAgd2lkdGg9ezIwMH1cclxuICAgICAgICAgICAgICBhbHQ9XCJcIlxyXG4gICAgICAgICAgLz5cclxuICAgICAgICA8SW1hZ2VcclxuICAgICAgICAgICAgICBwcmlvcml0eVxyXG4gICAgICAgICAgICAgIHNyYz1cIi9JbWFnZXMvZnJpZWQtcmljZS5qcGdcIlxyXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNvbC0xIHAtMFwiXHJcbiAgICAgICAgICAgICAgaGVpZ2h0PXsyMDB9XHJcbiAgICAgICAgICAgICAgd2lkdGg9ezIwMH1cclxuICAgICAgICAgICAgICBhbHQ9XCJcIlxyXG4gICAgICAgICAgICAvPiAqL31cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIHsvKiA8ZGl2IGNsYXNzTmFtZT1cInJvdyByZWNpcGVTaG93Y2FzZSBkLWZsZXgganVzdGlmeS1jb250ZW50LWNlbnRlclwiPlxyXG4gICAgICAgICAgPEltYWdlXHJcbiAgICAgICAgICAgICAgICBwcmlvcml0eVxyXG4gICAgICAgICAgICAgICAgc3JjPVwiL0ltYWdlcy9zdGVhay5qcGdcIlxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY29sLTEgcC0wXCJcclxuICAgICAgICAgICAgICAgIGhlaWdodD17MjAwfVxyXG4gICAgICAgICAgICAgICAgd2lkdGg9ezIwMH1cclxuICAgICAgICAgICAgICAgIGFsdD1cIlwiXHJcbiAgICAgICAgICAgIC8+XHJcbiAgICAgICAgPEltYWdlXHJcbiAgICAgICAgICAgICAgcHJpb3JpdHlcclxuICAgICAgICAgICAgICBzcmM9XCIvSW1hZ2VzL3BpenphLmpwZ1wiXHJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY29sLTEgcC0wXCJcclxuICAgICAgICAgICAgICBoZWlnaHQ9ezIwMH1cclxuICAgICAgICAgICAgICB3aWR0aD17MjAwfVxyXG4gICAgICAgICAgICAgIGFsdD1cIlwiXHJcbiAgICAgICAgICAgIC8+XHJcbiAgICAgICAgPEltYWdlXHJcbiAgICAgICAgICAgICAgcHJpb3JpdHlcclxuICAgICAgICAgICAgICBzcmM9XCIvSW1hZ2VzL2ZyaWVkLXJpY2UuanBnXCJcclxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjb2wtMSBwLTBcIlxyXG4gICAgICAgICAgICAgIGhlaWdodD17MjAwfVxyXG4gICAgICAgICAgICAgIHdpZHRoPXsyMDB9XHJcbiAgICAgICAgICAgICAgYWx0PVwiXCJcclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgPEltYWdlXHJcbiAgICAgICAgICAgICAgcHJpb3JpdHlcclxuICAgICAgICAgICAgICBzcmM9XCIvSW1hZ2VzL3BpenphLmpwZ1wiXHJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY29sLTEgcC0wXCJcclxuICAgICAgICAgICAgICBoZWlnaHQ9ezIwMH1cclxuICAgICAgICAgICAgICB3aWR0aD17MjAwfVxyXG4gICAgICAgICAgICAgIGFsdD1cIlwiXHJcbiAgICAgICAgICAgIC8+XHJcbiAgICAgICAgPEltYWdlXHJcbiAgICAgICAgICAgICAgcHJpb3JpdHlcclxuICAgICAgICAgICAgICBzcmM9XCIvSW1hZ2VzL2ZyaWVkLXJpY2UuanBnXCJcclxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjb2wtMSBwLTBcIlxyXG4gICAgICAgICAgICAgIGhlaWdodD17MjAwfVxyXG4gICAgICAgICAgICAgIHdpZHRoPXsyMDB9XHJcbiAgICAgICAgICAgICAgYWx0PVwiXCJcclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgPEltYWdlXHJcbiAgICAgICAgICAgICAgcHJpb3JpdHlcclxuICAgICAgICAgICAgICBzcmM9XCIvSW1hZ2VzL3BpenphLmpwZ1wiXHJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY29sLTEgcC0wXCJcclxuICAgICAgICAgICAgICBoZWlnaHQ9ezIwMH1cclxuICAgICAgICAgICAgICB3aWR0aD17MjAwfVxyXG4gICAgICAgICAgICAgIGFsdD1cIlwiXHJcbiAgICAgICAgICAvPlxyXG4gICAgICAgICAgPEltYWdlXHJcbiAgICAgICAgICAgICAgcHJpb3JpdHlcclxuICAgICAgICAgICAgICBzcmM9XCIvSW1hZ2VzL3N0ZWFrLmpwZ1wiXHJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY29sLTEgcC0wXCJcclxuICAgICAgICAgICAgICBoZWlnaHQ9ezIwMH1cclxuICAgICAgICAgICAgICB3aWR0aD17MjAwfVxyXG4gICAgICAgICAgICAgIGFsdD1cIlwiXHJcbiAgICAgICAgICAvPlxyXG4gICAgICAgIDxJbWFnZVxyXG4gICAgICAgICAgICAgIHByaW9yaXR5XHJcbiAgICAgICAgICAgICAgc3JjPVwiL0ltYWdlcy9oYW1idXJnZXIuanBnXCJcclxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjb2wtMSBwLTBcIlxyXG4gICAgICAgICAgICAgIGhlaWdodD17MjAwfVxyXG4gICAgICAgICAgICAgIHdpZHRoPXsyMDB9XHJcbiAgICAgICAgICAgICAgYWx0PVwiXCJcclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgPEltYWdlXHJcbiAgICAgICAgICAgICAgcHJpb3JpdHlcclxuICAgICAgICAgICAgICBzcmM9XCIvSW1hZ2VzL2ZyaWVkLXJpY2UuanBnXCJcclxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjb2wtMSBwLTBcIlxyXG4gICAgICAgICAgICAgIGhlaWdodD17MjAwfVxyXG4gICAgICAgICAgICAgIHdpZHRoPXsyMDB9XHJcbiAgICAgICAgICAgICAgYWx0PVwiXCJcclxuICAgICAgICAgICAgLz5cclxuICAgICAgICAgIDxJbWFnZVxyXG4gICAgICAgICAgICAgIHByaW9yaXR5XHJcbiAgICAgICAgICAgICAgc3JjPVwiL0ltYWdlcy9zdGVhay5qcGdcIlxyXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNvbC0xIHAtMFwiXHJcbiAgICAgICAgICAgICAgaGVpZ2h0PXsyMDB9XHJcbiAgICAgICAgICAgICAgd2lkdGg9ezIwMH1cclxuICAgICAgICAgICAgICBhbHQ9XCJcIlxyXG4gICAgICAgICAgLz5cclxuICAgICAgICA8SW1hZ2VcclxuICAgICAgICAgICAgICBwcmlvcml0eVxyXG4gICAgICAgICAgICAgIHNyYz1cIi9JbWFnZXMvaGFtYnVyZ2VyLmpwZ1wiXHJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY29sLTEgcC0wXCJcclxuICAgICAgICAgICAgICBoZWlnaHQ9ezIwMH1cclxuICAgICAgICAgICAgICB3aWR0aD17MjAwfVxyXG4gICAgICAgICAgICAgIGFsdD1cIlwiXHJcbiAgICAgICAgICAvPlxyXG4gICAgICAgIDxJbWFnZVxyXG4gICAgICAgICAgICAgIHByaW9yaXR5XHJcbiAgICAgICAgICAgICAgc3JjPVwiL0ltYWdlcy9mcmllZC1yaWNlLmpwZ1wiXHJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY29sLTEgcC0wXCJcclxuICAgICAgICAgICAgICBoZWlnaHQ9ezIwMH1cclxuICAgICAgICAgICAgICB3aWR0aD17MjAwfVxyXG4gICAgICAgICAgICAgIGFsdD1cIlwiXHJcbiAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvdyByZWNpcGVTaG93Y2FzZSBkLWZsZXgganVzdGlmeS1jb250ZW50LWNlbnRlclwiPlxyXG4gICAgICAgICAgPEltYWdlXHJcbiAgICAgICAgICAgICAgICBwcmlvcml0eVxyXG4gICAgICAgICAgICAgICAgc3JjPVwiL0ltYWdlcy9zdGVhay5qcGdcIlxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY29sLTEgcC0wXCJcclxuICAgICAgICAgICAgICAgIGhlaWdodD17MjAwfVxyXG4gICAgICAgICAgICAgICAgd2lkdGg9ezIwMH1cclxuICAgICAgICAgICAgICAgIGFsdD1cIlwiXHJcbiAgICAgICAgICAgIC8+XHJcbiAgICAgICAgPEltYWdlXHJcbiAgICAgICAgICAgICAgcHJpb3JpdHlcclxuICAgICAgICAgICAgICBzcmM9XCIvSW1hZ2VzL3BpenphLmpwZ1wiXHJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY29sLTEgcC0wXCJcclxuICAgICAgICAgICAgICBoZWlnaHQ9ezIwMH1cclxuICAgICAgICAgICAgICB3aWR0aD17MjAwfVxyXG4gICAgICAgICAgICAgIGFsdD1cIlwiXHJcbiAgICAgICAgICAgIC8+XHJcbiAgICAgICAgPEltYWdlXHJcbiAgICAgICAgICAgICAgcHJpb3JpdHlcclxuICAgICAgICAgICAgICBzcmM9XCIvSW1hZ2VzL2ZyaWVkLXJpY2UuanBnXCJcclxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjb2wtMSBwLTBcIlxyXG4gICAgICAgICAgICAgIGhlaWdodD17MjAwfVxyXG4gICAgICAgICAgICAgIHdpZHRoPXsyMDB9XHJcbiAgICAgICAgICAgICAgYWx0PVwiXCJcclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgPEltYWdlXHJcbiAgICAgICAgICAgICAgcHJpb3JpdHlcclxuICAgICAgICAgICAgICBzcmM9XCIvSW1hZ2VzL3BpenphLmpwZ1wiXHJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY29sLTEgcC0wXCJcclxuICAgICAgICAgICAgICBoZWlnaHQ9ezIwMH1cclxuICAgICAgICAgICAgICB3aWR0aD17MjAwfVxyXG4gICAgICAgICAgICAgIGFsdD1cIlwiXHJcbiAgICAgICAgICAgIC8+XHJcbiAgICAgICAgPEltYWdlXHJcbiAgICAgICAgICAgICAgcHJpb3JpdHlcclxuICAgICAgICAgICAgICBzcmM9XCIvSW1hZ2VzL2ZyaWVkLXJpY2UuanBnXCJcclxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjb2wtMSBwLTBcIlxyXG4gICAgICAgICAgICAgIGhlaWdodD17MjAwfVxyXG4gICAgICAgICAgICAgIHdpZHRoPXsyMDB9XHJcbiAgICAgICAgICAgICAgYWx0PVwiXCJcclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgPEltYWdlXHJcbiAgICAgICAgICAgICAgcHJpb3JpdHlcclxuICAgICAgICAgICAgICBzcmM9XCIvSW1hZ2VzL3BpenphLmpwZ1wiXHJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY29sLTEgcC0wXCJcclxuICAgICAgICAgICAgICBoZWlnaHQ9ezIwMH1cclxuICAgICAgICAgICAgICB3aWR0aD17MjAwfVxyXG4gICAgICAgICAgICAgIGFsdD1cIlwiXHJcbiAgICAgICAgICAvPlxyXG4gICAgICAgICAgPEltYWdlXHJcbiAgICAgICAgICAgICAgcHJpb3JpdHlcclxuICAgICAgICAgICAgICBzcmM9XCIvSW1hZ2VzL3N0ZWFrLmpwZ1wiXHJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY29sLTEgcC0wXCJcclxuICAgICAgICAgICAgICBoZWlnaHQ9ezIwMH1cclxuICAgICAgICAgICAgICB3aWR0aD17MjAwfVxyXG4gICAgICAgICAgICAgIGFsdD1cIlwiXHJcbiAgICAgICAgICAvPlxyXG4gICAgICAgIDxJbWFnZVxyXG4gICAgICAgICAgICAgIHByaW9yaXR5XHJcbiAgICAgICAgICAgICAgc3JjPVwiL0ltYWdlcy9oYW1idXJnZXIuanBnXCJcclxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjb2wtMSBwLTBcIlxyXG4gICAgICAgICAgICAgIGhlaWdodD17MjAwfVxyXG4gICAgICAgICAgICAgIHdpZHRoPXsyMDB9XHJcbiAgICAgICAgICAgICAgYWx0PVwiXCJcclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgPEltYWdlXHJcbiAgICAgICAgICAgICAgcHJpb3JpdHlcclxuICAgICAgICAgICAgICBzcmM9XCIvSW1hZ2VzL2ZyaWVkLXJpY2UuanBnXCJcclxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjb2wtMSBwLTBcIlxyXG4gICAgICAgICAgICAgIGhlaWdodD17MjAwfVxyXG4gICAgICAgICAgICAgIHdpZHRoPXsyMDB9XHJcbiAgICAgICAgICAgICAgYWx0PVwiXCJcclxuICAgICAgICAgICAgLz5cclxuICAgICAgICAgIDxJbWFnZVxyXG4gICAgICAgICAgICAgIHByaW9yaXR5XHJcbiAgICAgICAgICAgICAgc3JjPVwiL0ltYWdlcy9zdGVhay5qcGdcIlxyXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNvbC0xIHAtMFwiXHJcbiAgICAgICAgICAgICAgaGVpZ2h0PXsyMDB9XHJcbiAgICAgICAgICAgICAgd2lkdGg9ezIwMH1cclxuICAgICAgICAgICAgICBhbHQ9XCJcIlxyXG4gICAgICAgICAgLz5cclxuICAgICAgICA8SW1hZ2VcclxuICAgICAgICAgICAgICBwcmlvcml0eVxyXG4gICAgICAgICAgICAgIHNyYz1cIi9JbWFnZXMvaGFtYnVyZ2VyLmpwZ1wiXHJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY29sLTEgcC0wXCJcclxuICAgICAgICAgICAgICBoZWlnaHQ9ezIwMH1cclxuICAgICAgICAgICAgICB3aWR0aD17MjAwfVxyXG4gICAgICAgICAgICAgIGFsdD1cIlwiXHJcbiAgICAgICAgICAvPlxyXG4gICAgICAgIDxJbWFnZVxyXG4gICAgICAgICAgICAgIHByaW9yaXR5XHJcbiAgICAgICAgICAgICAgc3JjPVwiL0ltYWdlcy9mcmllZC1yaWNlLmpwZ1wiXHJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY29sLTEgcC0wXCJcclxuICAgICAgICAgICAgICBoZWlnaHQ9ezIwMH1cclxuICAgICAgICAgICAgICB3aWR0aD17MjAwfVxyXG4gICAgICAgICAgICAgIGFsdD1cIlwiXHJcbiAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICA8L2Rpdj4gKi99XHJcbiAgICAgIDwvc2VjdGlvbj5cclxuICAgIDwvTGF5b3V0PlxyXG4gICk7XHJcbn0iXSwibmFtZXMiOlsiSGVhZCIsIkxheW91dCIsInNpdGVUaXRsZSIsInV0aWxTdHlsZXMiLCJob21lU3R5bGVzIiwiUmVhY3QiLCJJbWFnZSIsIkxpbmsiLCJIb21lIiwiaG9tZSIsInRpdGxlIiwic2VjdGlvbiIsImNsYXNzTmFtZSIsIm1hc3RoZWFkIiwiaDIiLCJzdHJvbmciLCJiciIsImhlYWRpbmdNZCIsInBhZGRpbmcxcHgiLCJob21lU2VjdGlvbjEiLCJwIiwiaG9tZVNlY3Rpb24yIiwiaG9tZVNlY3Rpb24zIiwiZGl2IiwicHJpb3JpdHkiLCJzcmMiLCJoZWlnaHQiLCJ3aWR0aCIsImFsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/pages/index.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5Csmith%5Csource%5Ccodeworks%5Creact%5Cmeal-master-fullstack%5Cmeal-master-fullstack.client%5Csrc%5Cpages%5Cindex.js&page=%2F!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);